!(function () {
  "use strict";
  var t,
    e,
    n,
    i,
    r,
    s = {},
    o = [],
    a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function l(t, e) {
    for (var n in e) t[n] = e[n];
    return t;
  }
  function h(t) {
    var e = t.parentNode;
    e && e.removeChild(t);
  }
  function u(e, n, i) {
    var r,
      s,
      o,
      a = {};
    for (o in n)
      "key" == o ? (r = n[o]) : "ref" == o ? (s = n[o]) : (a[o] = n[o]);
    if (
      (arguments.length > 2 &&
        (a.children = arguments.length > 3 ? t.call(arguments, 2) : i),
      "function" == typeof e && null != e.defaultProps)
    )
      for (o in e.defaultProps) void 0 === a[o] && (a[o] = e.defaultProps[o]);
    return c(e, a, r, s, null);
  }
  function c(t, i, r, s, o) {
    var a = {
      type: t,
      props: i,
      key: r,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++n : o,
    };
    return null == o && null != e.vnode && e.vnode(a), a;
  }
  function d(t) {
    return t.children;
  }
  function p(t, e) {
    (this.props = t), (this.context = e);
  }
  function f(t, e) {
    if (null == e) return t.__ ? f(t.__, t.__.__k.indexOf(t) + 1) : null;
    for (var n; e < t.__k.length; e++)
      if (null != (n = t.__k[e]) && null != n.__e) return n.__e;
    return "function" == typeof t.type ? f(t) : null;
  }
  function m(t) {
    var e, n;
    if (null != (t = t.__) && null != t.__c) {
      for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
        if (null != (n = t.__k[e]) && null != n.__e) {
          t.__e = t.__c.base = n.__e;
          break;
        }
      return m(t);
    }
  }
  function _(t) {
    ((!t.__d && (t.__d = !0) && i.push(t) && !g.__r++) ||
      r !== e.debounceRendering) &&
      ((r = e.debounceRendering) || setTimeout)(g);
  }
  function g() {
    for (var t; (g.__r = i.length); )
      (t = i.sort(function (t, e) {
        return t.__v.__b - e.__v.__b;
      })),
        (i = []),
        t.some(function (t) {
          var e, n, i, r, s, o;
          t.__d &&
            ((s = (r = (e = t).__v).__e),
            (o = e.__P) &&
              ((n = []),
              ((i = l({}, r)).__v = r.__v + 1),
              w(
                o,
                r,
                i,
                e.__n,
                void 0 !== o.ownerSVGElement,
                null != r.__h ? [s] : null,
                n,
                null == s ? f(r) : s,
                r.__h
              ),
              M(n, r),
              r.__e != s && m(r)));
        });
  }
  function v(t, e, n, i, r, a, l, h, u, p) {
    var m,
      _,
      g,
      v,
      b,
      T,
      E,
      S = (i && i.__k) || o,
      M = S.length;
    for (n.__k = [], m = 0; m < e.length; m++)
      if (
        null !=
        (v = n.__k[m] =
          null == (v = e[m]) || "boolean" == typeof v
            ? null
            : "string" == typeof v ||
              "number" == typeof v ||
              "bigint" == typeof v
            ? c(null, v, null, null, v)
            : Array.isArray(v)
            ? c(d, { children: v }, null, null, null)
            : v.__b > 0
            ? c(v.type, v.props, v.key, null, v.__v)
            : v)
      ) {
        if (
          ((v.__ = n),
          (v.__b = n.__b + 1),
          null === (g = S[m]) || (g && v.key == g.key && v.type === g.type))
        )
          S[m] = void 0;
        else
          for (_ = 0; _ < M; _++) {
            if ((g = S[_]) && v.key == g.key && v.type === g.type) {
              S[_] = void 0;
              break;
            }
            g = null;
          }
        w(t, v, (g = g || s), r, a, l, h, u, p),
          (b = v.__e),
          (_ = v.ref) &&
            g.ref != _ &&
            (E || (E = []),
            g.ref && E.push(g.ref, null, v),
            E.push(_, v.__c || b, v)),
          null != b
            ? (null == T && (T = b),
              "function" == typeof v.type && v.__k === g.__k
                ? (v.__d = u = y(v, u, t))
                : (u = x(t, v, g, S, b, u)),
              "function" == typeof n.type && (n.__d = u))
            : u && g.__e == u && u.parentNode != t && (u = f(g));
      }
    for (n.__e = T, m = M; m--; )
      null != S[m] &&
        ("function" == typeof n.type &&
          null != S[m].__e &&
          S[m].__e == n.__d &&
          (n.__d = f(i, m + 1)),
        R(S[m], S[m]));
    if (E) for (m = 0; m < E.length; m++) A(E[m], E[++m], E[++m]);
  }
  function y(t, e, n) {
    for (var i, r = t.__k, s = 0; r && s < r.length; s++)
      (i = r[s]) &&
        ((i.__ = t),
        (e =
          "function" == typeof i.type ? y(i, e, n) : x(n, i, i, r, i.__e, e)));
    return e;
  }
  function x(t, e, n, i, r, s) {
    var o, a, l;
    if (void 0 !== e.__d) (o = e.__d), (e.__d = void 0);
    else if (null == n || r != s || null == r.parentNode)
      t: if (null == s || s.parentNode !== t) t.appendChild(r), (o = null);
      else {
        for (a = s, l = 0; (a = a.nextSibling) && l < i.length; l += 2)
          if (a == r) break t;
        t.insertBefore(r, s), (o = s);
      }
    return void 0 !== o ? o : r.nextSibling;
  }
  function b(t, e, n) {
    "-" === e[0]
      ? t.setProperty(e, n)
      : (t[e] =
          null == n ? "" : "number" != typeof n || a.test(e) ? n : n + "px");
  }
  function T(t, e, n, i, r) {
    var s;
    t: if ("style" === e)
      if ("string" == typeof n) t.style.cssText = n;
      else {
        if (("string" == typeof i && (t.style.cssText = i = ""), i))
          for (e in i) (n && e in n) || b(t.style, e, "");
        if (n) for (e in n) (i && n[e] === i[e]) || b(t.style, e, n[e]);
      }
    else if ("o" === e[0] && "n" === e[1])
      (s = e !== (e = e.replace(/Capture$/, ""))),
        (e = e.toLowerCase() in t ? e.toLowerCase().slice(2) : e.slice(2)),
        t.l || (t.l = {}),
        (t.l[e + s] = n),
        n
          ? i || t.addEventListener(e, s ? S : E, s)
          : t.removeEventListener(e, s ? S : E, s);
    else if ("dangerouslySetInnerHTML" !== e) {
      if (r) e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (
        "href" !== e &&
        "list" !== e &&
        "form" !== e &&
        "tabIndex" !== e &&
        "download" !== e &&
        e in t
      )
        try {
          t[e] = null == n ? "" : n;
          break t;
        } catch (o) {}
      "function" == typeof n ||
        (null != n && (!1 !== n || ("a" === e[0] && "r" === e[1]))
          ? t.setAttribute(e, n)
          : t.removeAttribute(e));
    }
  }
  function E(t) {
    this.l[t.type + !1](e.event ? e.event(t) : t);
  }
  function S(t) {
    this.l[t.type + !0](e.event ? e.event(t) : t);
  }
  function w(n, i, r, o, a, u, c, m, _) {
    var g,
      y,
      x,
      b,
      E,
      S,
      w,
      M,
      A,
      R,
      I,
      P,
      O,
      N = i.type;
    if (void 0 !== i.constructor) return null;
    null != r.__h &&
      ((_ = r.__h), (m = i.__e = r.__e), (i.__h = null), (u = [m])),
      (g = e.__b) && g(i);
    try {
      t: if ("function" == typeof N) {
        if (
          ((M = i.props),
          (A = (g = N.contextType) && o[g.__c]),
          (R = g ? (A ? A.props.value : g.__) : o),
          r.__c
            ? (w = (y = i.__c = r.__c).__ = y.__E)
            : ("prototype" in N && N.prototype.render
                ? (i.__c = y = new N(M, R))
                : ((i.__c = y = new p(M, R)),
                  (y.constructor = N),
                  (y.render = C)),
              A && A.sub(y),
              (y.props = M),
              y.state || (y.state = {}),
              (y.context = R),
              (y.__n = o),
              (x = y.__d = !0),
              (y.__h = [])),
          null == y.__s && (y.__s = y.state),
          null != N.getDerivedStateFromProps &&
            (y.__s == y.state && (y.__s = l({}, y.__s)),
            l(y.__s, N.getDerivedStateFromProps(M, y.__s))),
          (b = y.props),
          (E = y.state),
          x)
        )
          null == N.getDerivedStateFromProps &&
            null != y.componentWillMount &&
            y.componentWillMount(),
            null != y.componentDidMount && y.__h.push(y.componentDidMount);
        else {
          if (
            (null == N.getDerivedStateFromProps &&
              M !== b &&
              null != y.componentWillReceiveProps &&
              y.componentWillReceiveProps(M, R),
            (!y.__e &&
              null != y.shouldComponentUpdate &&
              !1 === y.shouldComponentUpdate(M, y.__s, R)) ||
              i.__v === r.__v)
          ) {
            (y.props = M),
              (y.state = y.__s),
              i.__v !== r.__v && (y.__d = !1),
              (y.__v = i),
              (i.__e = r.__e),
              (i.__k = r.__k),
              i.__k.forEach(function (t) {
                t && (t.__ = i);
              }),
              y.__h.length && c.push(y);
            break t;
          }
          null != y.componentWillUpdate && y.componentWillUpdate(M, y.__s, R),
            null != y.componentDidUpdate &&
              y.__h.push(function () {
                y.componentDidUpdate(b, E, S);
              });
        }
        if (
          ((y.context = R),
          (y.props = M),
          (y.__v = i),
          (y.__P = n),
          (I = e.__r),
          (P = 0),
          "prototype" in N && N.prototype.render)
        )
          (y.state = y.__s),
            (y.__d = !1),
            I && I(i),
            (g = y.render(y.props, y.state, y.context));
        else
          do {
            (y.__d = !1),
              I && I(i),
              (g = y.render(y.props, y.state, y.context)),
              (y.state = y.__s);
          } while (y.__d && ++P < 25);
        (y.state = y.__s),
          null != y.getChildContext && (o = l(l({}, o), y.getChildContext())),
          x ||
            null == y.getSnapshotBeforeUpdate ||
            (S = y.getSnapshotBeforeUpdate(b, E)),
          (O =
            null != g && g.type === d && null == g.key ? g.props.children : g),
          v(n, Array.isArray(O) ? O : [O], i, r, o, a, u, c, m, _),
          (y.base = i.__e),
          (i.__h = null),
          y.__h.length && c.push(y),
          w && (y.__E = y.__ = null),
          (y.__e = !1);
      } else
        null == u && i.__v === r.__v
          ? ((i.__k = r.__k), (i.__e = r.__e))
          : (i.__e = (function (e, n, i, r, o, a, l, u) {
              var c,
                d,
                p,
                m = i.props,
                _ = n.props,
                g = n.type,
                y = 0;
              if (("svg" === g && (o = !0), null != a))
                for (; y < a.length; y++)
                  if (
                    (c = a[y]) &&
                    "setAttribute" in c == !!g &&
                    (g ? c.localName === g : 3 === c.nodeType)
                  ) {
                    (e = c), (a[y] = null);
                    break;
                  }
              if (null == e) {
                if (null === g) return document.createTextNode(_);
                (e = o
                  ? document.createElementNS("http://www.w3.org/2000/svg", g)
                  : document.createElement(g, _.is && _)),
                  (a = null),
                  (u = !1);
              }
              if (null === g) m === _ || (u && e.data === _) || (e.data = _);
              else {
                if (
                  ((a = a && t.call(e.childNodes)),
                  (d = (m = i.props || s).dangerouslySetInnerHTML),
                  (p = _.dangerouslySetInnerHTML),
                  !u)
                ) {
                  if (null != a)
                    for (m = {}, y = 0; y < e.attributes.length; y++)
                      m[e.attributes[y].name] = e.attributes[y].value;
                  (p || d) &&
                    ((p &&
                      ((d && p.__html == d.__html) ||
                        p.__html === e.innerHTML)) ||
                      (e.innerHTML = (p && p.__html) || ""));
                }
                if (
                  ((function (t, e, n, i, r) {
                    var s;
                    for (s in n)
                      "children" === s ||
                        "key" === s ||
                        s in e ||
                        T(t, s, null, n[s], i);
                    for (s in e)
                      (r && "function" != typeof e[s]) ||
                        "children" === s ||
                        "key" === s ||
                        "value" === s ||
                        "checked" === s ||
                        n[s] === e[s] ||
                        T(t, s, e[s], n[s], i);
                  })(e, _, m, o, u),
                  p)
                )
                  n.__k = [];
                else if (
                  ((y = n.props.children),
                  v(
                    e,
                    Array.isArray(y) ? y : [y],
                    n,
                    i,
                    r,
                    o && "foreignObject" !== g,
                    a,
                    l,
                    a ? a[0] : i.__k && f(i, 0),
                    u
                  ),
                  null != a)
                )
                  for (y = a.length; y--; ) null != a[y] && h(a[y]);
                u ||
                  ("value" in _ &&
                    void 0 !== (y = _.value) &&
                    (y !== e.value ||
                      ("progress" === g && !y) ||
                      ("option" === g && y !== m.value)) &&
                    T(e, "value", y, m.value, !1),
                  "checked" in _ &&
                    void 0 !== (y = _.checked) &&
                    y !== e.checked &&
                    T(e, "checked", y, m.checked, !1));
              }
              return e;
            })(r.__e, i, r, o, a, u, c, _));
      (g = e.diffed) && g(i);
    } catch (D) {
      (i.__v = null),
        (_ || null != u) &&
          ((i.__e = m), (i.__h = !!_), (u[u.indexOf(m)] = null)),
        e.__e(D, i, r);
    }
  }
  function M(t, n) {
    e.__c && e.__c(n, t),
      t.some(function (n) {
        try {
          (t = n.__h),
            (n.__h = []),
            t.some(function (t) {
              t.call(n);
            });
        } catch (i) {
          e.__e(i, n.__v);
        }
      });
  }
  function A(t, n, i) {
    try {
      "function" == typeof t ? t(n) : (t.current = n);
    } catch (r) {
      e.__e(r, i);
    }
  }
  function R(t, n, i) {
    var r, s;
    if (
      (e.unmount && e.unmount(t),
      (r = t.ref) && ((r.current && r.current !== t.__e) || A(r, null, n)),
      null != (r = t.__c))
    ) {
      if (r.componentWillUnmount)
        try {
          r.componentWillUnmount();
        } catch (o) {
          e.__e(o, n);
        }
      r.base = r.__P = null;
    }
    if ((r = t.__k))
      for (s = 0; s < r.length; s++)
        r[s] && R(r[s], n, "function" != typeof t.type);
    i || null == t.__e || h(t.__e), (t.__e = t.__d = void 0);
  }
  function C(t, e, n) {
    return this.constructor(t, n);
  }
  function I(n, i, r) {
    var o, a, l;
    e.__ && e.__(n, i),
      (a = (o = "function" == typeof r) ? null : (r && r.__k) || i.__k),
      (l = []),
      w(
        i,
        (n = ((!o && r) || i).__k = u(d, null, [n])),
        a || s,
        s,
        void 0 !== i.ownerSVGElement,
        !o && r ? [r] : a ? null : i.firstChild ? t.call(i.childNodes) : null,
        l,
        !o && r ? r : a ? a.__e : i.firstChild,
        o
      ),
      M(l, n);
  }
  function P(t, e) {
    I(t, e, P);
  }
  function O(e, n, i) {
    var r,
      s,
      o,
      a = l({}, e.props);
    for (o in n)
      "key" == o ? (r = n[o]) : "ref" == o ? (s = n[o]) : (a[o] = n[o]);
    return (
      arguments.length > 2 &&
        (a.children = arguments.length > 3 ? t.call(arguments, 2) : i),
      c(e.type, a, r || e.key, s || e.ref, null)
    );
  }
  function N() {
    return (N =
      Object.assign ||
      function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          for (var i in n)
            Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
        }
        return t;
      }).apply(this, arguments);
  }
  function D(t) {
    return (
      (this.getChildContext = function () {
        return t.context;
      }),
      O(
        t.children,
        (function (t, e) {
          if (null == t) return {};
          var n,
            i,
            r = {},
            s = Object.keys(t);
          for (i = 0; i < s.length; i++)
            e.indexOf((n = s[i])) >= 0 || (r[n] = t[n]);
          return r;
        })(t, ["context", "children"])
      )
    );
  }
  function L() {
    var t = new CustomEvent("_preact", {
      detail: {},
      bubbles: !0,
      cancelable: !0,
    });
    this.dispatchEvent(t),
      (this._vdom = u(
        D,
        N({}, this._props, { context: t.detail.context }),
        (function t(e, n) {
          if (3 === e.nodeType) return e.data;
          if (1 !== e.nodeType) return null;
          var i = [],
            r = {},
            s = 0,
            o = e.attributes,
            a = e.childNodes;
          for (s = o.length; s--; )
            "slot" !== o[s].name &&
              ((r[o[s].name] = o[s].value), (r[F(o[s].name)] = o[s].value));
          for (s = a.length; s--; ) {
            var l = t(a[s], null),
              h = a[s].slot;
            h ? (r[h] = u(k, { name: h }, l)) : (i[s] = l);
          }
          var c = n ? u(k, null, i) : i;
          return u(n || e.nodeName.toLowerCase(), r, c);
        })(this, this._vdomComponent)
      )),
      (this.hasAttribute("hydrate") ? P : I)(this._vdom, this._root);
  }
  function F(t) {
    return t.replace(/-(\w)/g, function (t, e) {
      return e ? e.toUpperCase() : "";
    });
  }
  function U(t, e, n) {
    if (this._vdom) {
      var i = {};
      (i[t] = n = null == n ? void 0 : n),
        (i[F(t)] = n),
        (this._vdom = O(this._vdom, i)),
        I(this._vdom, this._root);
    }
  }
  function B() {
    I((this._vdom = null), this._root);
  }
  function k(t, e) {
    var n = this;
    return u(
      "slot",
      N({}, t, {
        ref: function (t) {
          t
            ? ((n.ref = t),
              n._listener ||
                ((n._listener = function (t) {
                  t.stopPropagation(), (t.detail.context = e);
                }),
                t.addEventListener("_preact", n._listener)))
            : n.ref.removeEventListener("_preact", n._listener);
        },
      })
    );
  }
  function G(t, e, n, i) {
    function r() {
      var e = Reflect.construct(HTMLElement, [], r);
      return (
        (e._vdomComponent = t),
        (e._root = i && i.shadow ? e.attachShadow({ mode: "open" }) : e),
        e
      );
    }
    return (
      ((r.prototype = Object.create(HTMLElement.prototype)).constructor = r),
      (r.prototype.connectedCallback = L),
      (r.prototype.attributeChangedCallback = U),
      (r.prototype.disconnectedCallback = B),
      (n = n || t.observedAttributes || Object.keys(t.propTypes || {})),
      (r.observedAttributes = n),
      n.forEach(function (t) {
        Object.defineProperty(r.prototype, t, {
          get: function () {
            return this._vdom.props[t];
          },
          set: function (e) {
            this._vdom
              ? this.attributeChangedCallback(t, null, e)
              : (this._props || (this._props = {}),
                (this._props[t] = e),
                this.connectedCallback());
            var n = typeof e;
            (null != e &&
              "string" !== n &&
              "boolean" !== n &&
              "number" !== n) ||
              this.setAttribute(t, e);
          },
        });
      }),
      customElements.define(e || t.tagName || t.displayName || t.name, r)
    );
  }
  (t = o.slice),
    (e = {
      __e: function (t, e, n, i) {
        for (var r, s, o; (e = e.__); )
          if ((r = e.__c) && !r.__)
            try {
              if (
                ((s = r.constructor) &&
                  null != s.getDerivedStateFromError &&
                  (r.setState(s.getDerivedStateFromError(t)), (o = r.__d)),
                null != r.componentDidCatch &&
                  (r.componentDidCatch(t, i || {}), (o = r.__d)),
                o)
              )
                return (r.__E = r);
            } catch (a) {
              t = a;
            }
        throw t;
      },
    }),
    (n = 0),
    (p.prototype.setState = function (t, e) {
      var n;
      (n =
        null != this.__s && this.__s !== this.state
          ? this.__s
          : (this.__s = l({}, this.state))),
        "function" == typeof t && (t = t(l({}, n), this.props)),
        t && l(n, t),
        null != t && this.__v && (e && this.__h.push(e), _(this));
    }),
    (p.prototype.forceUpdate = function (t) {
      this.__v && ((this.__e = !0), t && this.__h.push(t), _(this));
    }),
    (p.prototype.render = d),
    (i = []),
    (g.__r = 0);
  var H,
    z,
    V,
    X,
    W = 0,
    j = [],
    Y = [],
    q = e.__b,
    K = e.__r,
    Z = e.diffed,
    J = e.__c,
    $ = e.unmount;
  function Q(t, n) {
    e.__h && e.__h(z, t, W || n), (W = 0);
    var i = z.__H || (z.__H = { __: [], __h: [] });
    return t >= i.__.length && i.__.push({ __V: Y }), i.__[t];
  }
  function tt(t) {
    return (
      (W = 1),
      (function (t, e, n) {
        var i = Q(H++, 2);
        if (
          ((i.t = t),
          !i.__c &&
            ((i.__ = [
              n ? n(e) : lt(void 0, e),
              function (t) {
                var e = i.__N ? i.__N[0] : i.__[0],
                  n = i.t(e, t);
                e !== n && ((i.__N = [n, i.__[1]]), i.__c.setState({}));
              },
            ]),
            (i.__c = z),
            !i.__c.u))
        ) {
          i.__c.__H.u = !0;
          var r = i.__c.shouldComponentUpdate;
          i.__c.shouldComponentUpdate = function (t, e, n) {
            if (!i.__c.__H) return !0;
            var s = i.__c.__H.__.filter(function (t) {
              return t.__c;
            });
            return (
              (s.every(function (t) {
                return !t.__N;
              }) ||
                !s.every(function (t) {
                  if (!t.__N) return !0;
                  var e = t.__[0];
                  return (t.__ = t.__N), (t.__N = void 0), e === t.__[0];
                })) &&
              (!r || r(t, e, n))
            );
          };
        }
        return i.__N || i.__;
      })(lt, t)
    );
  }
  function et(t, n) {
    var i = Q(H++, 3);
    !e.__s && at(i.__H, n) && ((i.__ = t), (i.i = n), z.__H.__h.push(i));
  }
  function nt(t) {
    return (
      (W = 5),
      (function (t, e) {
        var n = Q(H++, 7);
        return at(n.__H, e)
          ? ((n.__V = t()), (n.i = e), (n.__h = t), n.__V)
          : n.__;
      })(function () {
        return { current: t };
      }, [])
    );
  }
  function it() {
    for (var t; (t = j.shift()); )
      if (t.__P && t.__H)
        try {
          t.__H.__h.forEach(st), t.__H.__h.forEach(ot), (t.__H.__h = []);
        } catch (n) {
          (t.__H.__h = []), e.__e(n, t.__v);
        }
  }
  (e.__b = function (t) {
    (z = null), q && q(t);
  }),
    (e.__r = function (t) {
      K && K(t), (H = 0);
      var e = (z = t.__c).__H;
      e &&
        (V === z
          ? ((e.__h = []),
            (z.__h = []),
            e.__.forEach(function (t) {
              t.__N && (t.__ = t.__N), (t.__V = Y), (t.__N = t.i = void 0);
            }))
          : (e.__h.forEach(st), e.__h.forEach(ot), (e.__h = []))),
        (V = z);
    }),
    (e.diffed = function (t) {
      Z && Z(t);
      var n = t.__c;
      n &&
        n.__H &&
        (n.__H.__h.length &&
          ((1 !== j.push(n) && X === e.requestAnimationFrame) ||
            (
              (X = e.requestAnimationFrame) ||
              function (t) {
                var e,
                  n = function () {
                    clearTimeout(i),
                      rt && cancelAnimationFrame(e),
                      setTimeout(t);
                  },
                  i = setTimeout(n, 100);
                rt && (e = requestAnimationFrame(n));
              }
            )(it)),
        n.__H.__.forEach(function (t) {
          t.i && (t.__H = t.i),
            t.__V !== Y && (t.__ = t.__V),
            (t.i = void 0),
            (t.__V = Y);
        })),
        (V = z = null);
    }),
    (e.__c = function (t, n) {
      n.some(function (t) {
        try {
          t.__h.forEach(st),
            (t.__h = t.__h.filter(function (t) {
              return !t.__ || ot(t);
            }));
        } catch (i) {
          n.some(function (t) {
            t.__h && (t.__h = []);
          }),
            (n = []),
            e.__e(i, t.__v);
        }
      }),
        J && J(t, n);
    }),
    (e.unmount = function (t) {
      $ && $(t);
      var n,
        i = t.__c;
      i &&
        i.__H &&
        (i.__H.__.forEach(function (t) {
          try {
            st(t);
          } catch (e) {
            n = e;
          }
        }),
        n && e.__e(n, i.__v));
    });
  var rt = "function" == typeof requestAnimationFrame;
  function st(t) {
    var e = z,
      n = t.__c;
    "function" == typeof n && ((t.__c = void 0), n()), (z = e);
  }
  function ot(t) {
    var e = z;
    (t.__c = t.__()), (z = e);
  }
  function at(t, e) {
    return (
      !t ||
      t.length !== e.length ||
      e.some(function (e, n) {
        return e !== t[n];
      })
    );
  }
  function lt(t, e) {
    return "function" == typeof e ? e(t) : e;
  }
  const ht = () => {
    let t = "";
    return (
      (t = "https://designer-threads-wc.netlify.app"),
      "https://designer-threads-wc.netlify.app"
    );
  };
  function ut(t, e, n = function () {}, i = function () {}, r = {}) {
    let s = nt(!1);
    et(
      () => (
        new IntersectionObserver((t, r) => {
          const o = t[0];
          if (!s.current && o.isIntersecting) e(), (s.current = !0);
          else if (o.isIntersecting) n();
          else {
            if (!s.current) return;
            i();
          }
        }, r).observe(t.current),
        () => {}
      ),
      [t.current]
    );
  }
  const ct = !1,
    dt = "${JSCORE_VERSION}",
    pt = function (t, e) {
      if (!t) throw ft(e);
    },
    ft = function (t) {
      return new Error(
        "Firebase Database (" + dt + ") INTERNAL ASSERT FAILED: " + t
      );
    },
    mt = function (t) {
      const e = [];
      let n = 0;
      for (let i = 0; i < t.length; i++) {
        let r = t.charCodeAt(i);
        r < 128
          ? (e[n++] = r)
          : r < 2048
          ? ((e[n++] = (r >> 6) | 192), (e[n++] = (63 & r) | 128))
          : 55296 == (64512 & r) &&
            i + 1 < t.length &&
            56320 == (64512 & t.charCodeAt(i + 1))
          ? ((r = 65536 + ((1023 & r) << 10) + (1023 & t.charCodeAt(++i))),
            (e[n++] = (r >> 18) | 240),
            (e[n++] = ((r >> 12) & 63) | 128),
            (e[n++] = ((r >> 6) & 63) | 128),
            (e[n++] = (63 & r) | 128))
          : ((e[n++] = (r >> 12) | 224),
            (e[n++] = ((r >> 6) & 63) | 128),
            (e[n++] = (63 & r) | 128));
      }
      return e;
    },
    _t = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE:
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: "function" == typeof atob,
      encodeByteArray(t, e) {
        if (!Array.isArray(t))
          throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
          i = [];
        for (let r = 0; r < t.length; r += 3) {
          const e = t[r],
            s = r + 1 < t.length,
            o = s ? t[r + 1] : 0,
            a = r + 2 < t.length,
            l = a ? t[r + 2] : 0,
            h = e >> 2,
            u = ((3 & e) << 4) | (o >> 4);
          let c = ((15 & o) << 2) | (l >> 6),
            d = 63 & l;
          a || ((d = 64), s || (c = 64)), i.push(n[h], n[u], n[c], n[d]);
        }
        return i.join("");
      },
      encodeString(t, e) {
        return this.HAS_NATIVE_SUPPORT && !e
          ? btoa(t)
          : this.encodeByteArray(mt(t), e);
      },
      decodeString(t, e) {
        return this.HAS_NATIVE_SUPPORT && !e
          ? atob(t)
          : (function (t) {
              const e = [];
              let n = 0,
                i = 0;
              for (; n < t.length; ) {
                const r = t[n++];
                if (r < 128) e[i++] = String.fromCharCode(r);
                else if (r > 191 && r < 224) {
                  const s = t[n++];
                  e[i++] = String.fromCharCode(((31 & r) << 6) | (63 & s));
                } else if (r > 239 && r < 365) {
                  const s =
                    (((7 & r) << 18) |
                      ((63 & t[n++]) << 12) |
                      ((63 & t[n++]) << 6) |
                      (63 & t[n++])) -
                    65536;
                  (e[i++] = String.fromCharCode(55296 + (s >> 10))),
                    (e[i++] = String.fromCharCode(56320 + (1023 & s)));
                } else {
                  const s = t[n++],
                    o = t[n++];
                  e[i++] = String.fromCharCode(
                    ((15 & r) << 12) | ((63 & s) << 6) | (63 & o)
                  );
                }
              }
              return e.join("");
            })(this.decodeStringToByteArray(t, e));
      },
      decodeStringToByteArray(t, e) {
        this.init_();
        const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
          i = [];
        for (let r = 0; r < t.length; ) {
          const e = n[t.charAt(r++)],
            s = r < t.length ? n[t.charAt(r)] : 0;
          ++r;
          const o = r < t.length ? n[t.charAt(r)] : 64;
          ++r;
          const a = r < t.length ? n[t.charAt(r)] : 64;
          if ((++r, null == e || null == s || null == o || null == a))
            throw Error();
          const l = (e << 2) | (s >> 4);
          if ((i.push(l), 64 !== o)) {
            const t = ((s << 4) & 240) | (o >> 2);
            if ((i.push(t), 64 !== a)) {
              const t = ((o << 6) & 192) | a;
              i.push(t);
            }
          }
        }
        return i;
      },
      init_() {
        if (!this.byteToCharMap_) {
          (this.byteToCharMap_ = {}),
            (this.charToByteMap_ = {}),
            (this.byteToCharMapWebSafe_ = {}),
            (this.charToByteMapWebSafe_ = {});
          for (let t = 0; t < this.ENCODED_VALS.length; t++)
            (this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t)),
              (this.charToByteMap_[this.byteToCharMap_[t]] = t),
              (this.byteToCharMapWebSafe_[t] =
                this.ENCODED_VALS_WEBSAFE.charAt(t)),
              (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t),
              t >= this.ENCODED_VALS_BASE.length &&
                ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t),
                (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t));
        }
      },
    },
    gt = function (t) {
      const e = mt(t);
      return _t.encodeByteArray(e, !0);
    },
    vt = function (t) {
      return gt(t).replace(/\./g, "");
    },
    yt = function (t) {
      try {
        return _t.decodeString(t, !0);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
  function xt(t) {
    return bt(void 0, t);
  }
  function bt(t, e) {
    if (!(e instanceof Object)) return e;
    switch (e.constructor) {
      case Date:
        return new Date(e.getTime());
      case Object:
        void 0 === t && (t = {});
        break;
      case Array:
        t = [];
        break;
      default:
        return e;
    }
    for (const n in e)
      e.hasOwnProperty(n) && "__proto__" !== n && (t[n] = bt(t[n], e[n]));
    return t;
  }
  class Tt {
    constructor() {
      (this.reject = () => {}),
        (this.resolve = () => {}),
        (this.promise = new Promise((t, e) => {
          (this.resolve = t), (this.reject = e);
        }));
    }
    wrapCallback(t) {
      return (e, n) => {
        e ? this.reject(e) : this.resolve(n),
          "function" == typeof t &&
            (this.promise.catch(() => {}), 1 === t.length ? t(e) : t(e, n));
      };
    }
  }
  function Et() {
    return (
      "undefined" != typeof window &&
      !!(window.cordova || window.phonegap || window.PhoneGap) &&
      /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(
        "undefined" != typeof navigator &&
          "string" == typeof navigator.userAgent
          ? navigator.userAgent
          : ""
      )
    );
  }
  function St() {
    return !0 === ct;
  }
  function wt() {
    return "object" == typeof indexedDB;
  }
  function Mt() {
    return new Promise((t, e) => {
      try {
        let n = !0;
        const i = "validate-browser-context-for-indexeddb-analytics-module",
          r = self.indexedDB.open(i);
        (r.onsuccess = () => {
          r.result.close(), n || self.indexedDB.deleteDatabase(i), t(!0);
        }),
          (r.onupgradeneeded = () => {
            n = !1;
          }),
          (r.onerror = () => {
            var t;
            e(
              (null === (t = r.error) || void 0 === t ? void 0 : t.message) ||
                ""
            );
          });
      } catch (n) {
        e(n);
      }
    });
  }
  class At extends Error {
    constructor(t, e, n) {
      super(e),
        (this.code = t),
        (this.customData = n),
        (this.name = "FirebaseError"),
        Object.setPrototypeOf(this, At.prototype),
        Error.captureStackTrace &&
          Error.captureStackTrace(this, Rt.prototype.create);
    }
  }
  class Rt {
    constructor(t, e, n) {
      (this.service = t), (this.serviceName = e), (this.errors = n);
    }
    create(t, ...e) {
      const n = e[0] || {},
        i = `${this.service}/${t}`,
        r = this.errors[t],
        s = r
          ? (function (t, e) {
              return t.replace(Ct, (t, n) => {
                const i = e[n];
                return null != i ? String(i) : `<${n}?>`;
              });
            })(r, n)
          : "Error",
        o = `${this.serviceName}: ${s} (${i}).`;
      return new At(i, o, n);
    }
  }
  const Ct = /\{\$([^}]+)}/g;
  function It(t) {
    return JSON.parse(t);
  }
  function Pt(t) {
    return JSON.stringify(t);
  }
  const Ot = function (t) {
    let e = {},
      n = {},
      i = {},
      r = "";
    try {
      const s = t.split(".");
      (e = It(yt(s[0]) || "")),
        (n = It(yt(s[1]) || "")),
        (r = s[2]),
        (i = n.d || {}),
        delete n.d;
    } catch (s) {}
    return { header: e, claims: n, data: i, signature: r };
  };
  function Nt(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  function Dt(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e) ? t[e] : void 0;
  }
  function Lt(t) {
    for (const e in t)
      if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
    return !0;
  }
  function Ft(t, e, n) {
    const i = {};
    for (const r in t)
      Object.prototype.hasOwnProperty.call(t, r) &&
        (i[r] = e.call(n, t[r], r, t));
    return i;
  }
  function Ut(t, e) {
    if (t === e) return !0;
    const n = Object.keys(t),
      i = Object.keys(e);
    for (const r of n) {
      if (!i.includes(r)) return !1;
      const n = t[r],
        s = e[r];
      if (Bt(n) && Bt(s)) {
        if (!Ut(n, s)) return !1;
      } else if (n !== s) return !1;
    }
    for (const r of i) if (!n.includes(r)) return !1;
    return !0;
  }
  function Bt(t) {
    return null !== t && "object" == typeof t;
  }
  class kt {
    constructor() {
      (this.chain_ = []),
        (this.buf_ = []),
        (this.W_ = []),
        (this.pad_ = []),
        (this.inbuf_ = 0),
        (this.total_ = 0),
        (this.blockSize = 64),
        (this.pad_[0] = 128);
      for (let t = 1; t < this.blockSize; ++t) this.pad_[t] = 0;
      this.reset();
    }
    reset() {
      (this.chain_[0] = 1732584193),
        (this.chain_[1] = 4023233417),
        (this.chain_[2] = 2562383102),
        (this.chain_[3] = 271733878),
        (this.chain_[4] = 3285377520),
        (this.inbuf_ = 0),
        (this.total_ = 0);
    }
    compress_(t, e) {
      e || (e = 0);
      const n = this.W_;
      if ("string" == typeof t)
        for (let u = 0; u < 16; u++)
          (n[u] =
            (t.charCodeAt(e) << 24) |
            (t.charCodeAt(e + 1) << 16) |
            (t.charCodeAt(e + 2) << 8) |
            t.charCodeAt(e + 3)),
            (e += 4);
      else
        for (let u = 0; u < 16; u++)
          (n[u] = (t[e] << 24) | (t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]),
            (e += 4);
      for (let u = 16; u < 80; u++) {
        const t = n[u - 3] ^ n[u - 8] ^ n[u - 14] ^ n[u - 16];
        n[u] = 4294967295 & ((t << 1) | (t >>> 31));
      }
      let i,
        r,
        s = this.chain_[0],
        o = this.chain_[1],
        a = this.chain_[2],
        l = this.chain_[3],
        h = this.chain_[4];
      for (let u = 0; u < 80; u++) {
        u < 40
          ? u < 20
            ? ((i = l ^ (o & (a ^ l))), (r = 1518500249))
            : ((i = o ^ a ^ l), (r = 1859775393))
          : u < 60
          ? ((i = (o & a) | (l & (o | a))), (r = 2400959708))
          : ((i = o ^ a ^ l), (r = 3395469782));
        const t = (((s << 5) | (s >>> 27)) + i + h + r + n[u]) & 4294967295;
        (h = l),
          (l = a),
          (a = 4294967295 & ((o << 30) | (o >>> 2))),
          (o = s),
          (s = t);
      }
      (this.chain_[0] = (this.chain_[0] + s) & 4294967295),
        (this.chain_[1] = (this.chain_[1] + o) & 4294967295),
        (this.chain_[2] = (this.chain_[2] + a) & 4294967295),
        (this.chain_[3] = (this.chain_[3] + l) & 4294967295),
        (this.chain_[4] = (this.chain_[4] + h) & 4294967295);
    }
    update(t, e) {
      if (null == t) return;
      void 0 === e && (e = t.length);
      const n = e - this.blockSize;
      let i = 0;
      const r = this.buf_;
      let s = this.inbuf_;
      for (; i < e; ) {
        if (0 === s)
          for (; i <= n; ) this.compress_(t, i), (i += this.blockSize);
        if ("string" == typeof t) {
          for (; i < e; )
            if (((r[s] = t.charCodeAt(i)), ++s, ++i, s === this.blockSize)) {
              this.compress_(r), (s = 0);
              break;
            }
        } else
          for (; i < e; )
            if (((r[s] = t[i]), ++s, ++i, s === this.blockSize)) {
              this.compress_(r), (s = 0);
              break;
            }
      }
      (this.inbuf_ = s), (this.total_ += e);
    }
    digest() {
      const t = [];
      let e = 8 * this.total_;
      this.inbuf_ < 56
        ? this.update(this.pad_, 56 - this.inbuf_)
        : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
      for (let i = this.blockSize - 1; i >= 56; i--)
        (this.buf_[i] = 255 & e), (e /= 256);
      this.compress_(this.buf_);
      let n = 0;
      for (let i = 0; i < 5; i++)
        for (let e = 24; e >= 0; e -= 8)
          (t[n] = (this.chain_[i] >> e) & 255), ++n;
      return t;
    }
  }
  function Gt(t, e) {
    return `${t} failed: ${e} argument `;
  }
  const Ht = function (t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) {
      const i = t.charCodeAt(n);
      i < 128
        ? e++
        : i < 2048
        ? (e += 2)
        : i >= 55296 && i <= 56319
        ? ((e += 4), n++)
        : (e += 3);
    }
    return e;
  };
  function zt(t, e = 1e3, n = 2) {
    const i = e * Math.pow(n, t),
      r = Math.round(0.5 * i * (Math.random() - 0.5) * 2);
    return Math.min(144e5, i + r);
  }
  function Vt(t) {
    return t && t._delegate ? t._delegate : t;
  }
  class Xt {
    constructor(t, e, n) {
      (this.name = t),
        (this.instanceFactory = e),
        (this.type = n),
        (this.multipleInstances = !1),
        (this.serviceProps = {}),
        (this.instantiationMode = "LAZY"),
        (this.onInstanceCreated = null);
    }
    setInstantiationMode(t) {
      return (this.instantiationMode = t), this;
    }
    setMultipleInstances(t) {
      return (this.multipleInstances = t), this;
    }
    setServiceProps(t) {
      return (this.serviceProps = t), this;
    }
    setInstanceCreatedCallback(t) {
      return (this.onInstanceCreated = t), this;
    }
  }
  const Wt = "[DEFAULT]";
  class jt {
    constructor(t, e) {
      (this.name = t),
        (this.container = e),
        (this.component = null),
        (this.instances = new Map()),
        (this.instancesDeferred = new Map()),
        (this.instancesOptions = new Map()),
        (this.onInitCallbacks = new Map());
    }
    get(t) {
      const e = this.normalizeInstanceIdentifier(t);
      if (!this.instancesDeferred.has(e)) {
        const t = new Tt();
        if (
          (this.instancesDeferred.set(e, t),
          this.isInitialized(e) || this.shouldAutoInitialize())
        )
          try {
            const n = this.getOrInitializeService({ instanceIdentifier: e });
            n && t.resolve(n);
          } catch (n) {}
      }
      return this.instancesDeferred.get(e).promise;
    }
    getImmediate(t) {
      var e;
      const n = this.normalizeInstanceIdentifier(
          null == t ? void 0 : t.identifier
        ),
        i = null !== (e = null == t ? void 0 : t.optional) && void 0 !== e && e;
      if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
        if (i) return null;
        throw Error(`Service ${this.name} is not available`);
      }
      try {
        return this.getOrInitializeService({ instanceIdentifier: n });
      } catch (r) {
        if (i) return null;
        throw r;
      }
    }
    getComponent() {
      return this.component;
    }
    setComponent(t) {
      if (t.name !== this.name)
        throw Error(
          `Mismatching Component ${t.name} for Provider ${this.name}.`
        );
      if (this.component)
        throw Error(`Component for ${this.name} has already been provided`);
      if (((this.component = t), this.shouldAutoInitialize())) {
        if (
          (function (t) {
            return "EAGER" === t.instantiationMode;
          })(t)
        )
          try {
            this.getOrInitializeService({ instanceIdentifier: Wt });
          } catch (e) {}
        for (const [t, n] of this.instancesDeferred.entries()) {
          const i = this.normalizeInstanceIdentifier(t);
          try {
            const t = this.getOrInitializeService({ instanceIdentifier: i });
            n.resolve(t);
          } catch (e) {}
        }
      }
    }
    clearInstance(t = "[DEFAULT]") {
      this.instancesDeferred.delete(t),
        this.instancesOptions.delete(t),
        this.instances.delete(t);
    }
    async delete() {
      const t = Array.from(this.instances.values());
      await Promise.all([
        ...t.filter((t) => "INTERNAL" in t).map((t) => t.INTERNAL.delete()),
        ...t.filter((t) => "_delete" in t).map((t) => t._delete()),
      ]);
    }
    isComponentSet() {
      return null != this.component;
    }
    isInitialized(t = "[DEFAULT]") {
      return this.instances.has(t);
    }
    getOptions(t = "[DEFAULT]") {
      return this.instancesOptions.get(t) || {};
    }
    initialize(t = {}) {
      const { options: e = {} } = t,
        n = this.normalizeInstanceIdentifier(t.instanceIdentifier);
      if (this.isInitialized(n))
        throw Error(`${this.name}(${n}) has already been initialized`);
      if (!this.isComponentSet())
        throw Error(`Component ${this.name} has not been registered yet`);
      const i = this.getOrInitializeService({
        instanceIdentifier: n,
        options: e,
      });
      for (const [r, s] of this.instancesDeferred.entries()) {
        n === this.normalizeInstanceIdentifier(r) && s.resolve(i);
      }
      return i;
    }
    onInit(t, e) {
      var n;
      const i = this.normalizeInstanceIdentifier(e),
        r =
          null !== (n = this.onInitCallbacks.get(i)) && void 0 !== n
            ? n
            : new Set();
      r.add(t), this.onInitCallbacks.set(i, r);
      const s = this.instances.get(i);
      return (
        s && t(s, i),
        () => {
          r.delete(t);
        }
      );
    }
    invokeOnInitCallbacks(t, e) {
      const n = this.onInitCallbacks.get(e);
      if (n)
        for (const r of n)
          try {
            r(t, e);
          } catch (i) {}
    }
    getOrInitializeService({ instanceIdentifier: t, options: e = {} }) {
      let n = this.instances.get(t);
      if (
        !n &&
        this.component &&
        ((n = this.component.instanceFactory(this.container, {
          instanceIdentifier: ((i = t), i === Wt ? void 0 : i),
          options: e,
        })),
        this.instances.set(t, n),
        this.instancesOptions.set(t, e),
        this.invokeOnInitCallbacks(n, t),
        this.component.onInstanceCreated)
      )
        try {
          this.component.onInstanceCreated(this.container, t, n);
        } catch (r) {}
      var i;
      return n || null;
    }
    normalizeInstanceIdentifier(t = "[DEFAULT]") {
      return this.component ? (this.component.multipleInstances ? t : Wt) : t;
    }
    shouldAutoInitialize() {
      return (
        !!this.component && "EXPLICIT" !== this.component.instantiationMode
      );
    }
  }
  class Yt {
    constructor(t) {
      (this.name = t), (this.providers = new Map());
    }
    addComponent(t) {
      const e = this.getProvider(t.name);
      if (e.isComponentSet())
        throw new Error(
          `Component ${t.name} has already been registered with ${this.name}`
        );
      e.setComponent(t);
    }
    addOrOverwriteComponent(t) {
      this.getProvider(t.name).isComponentSet() &&
        this.providers.delete(t.name),
        this.addComponent(t);
    }
    getProvider(t) {
      if (this.providers.has(t)) return this.providers.get(t);
      const e = new jt(t, this);
      return this.providers.set(t, e), e;
    }
    getProviders() {
      return Array.from(this.providers.values());
    }
  }
  var qt, Kt;
  ((Kt = qt || (qt = {}))[(Kt.DEBUG = 0)] = "DEBUG"),
    (Kt[(Kt.VERBOSE = 1)] = "VERBOSE"),
    (Kt[(Kt.INFO = 2)] = "INFO"),
    (Kt[(Kt.WARN = 3)] = "WARN"),
    (Kt[(Kt.ERROR = 4)] = "ERROR"),
    (Kt[(Kt.SILENT = 5)] = "SILENT");
  const Zt = {
      debug: qt.DEBUG,
      verbose: qt.VERBOSE,
      info: qt.INFO,
      warn: qt.WARN,
      error: qt.ERROR,
      silent: qt.SILENT,
    },
    Jt = qt.INFO,
    $t = {
      [qt.DEBUG]: "log",
      [qt.VERBOSE]: "log",
      [qt.INFO]: "info",
      [qt.WARN]: "warn",
      [qt.ERROR]: "error",
    },
    Qt = (t, e, ...n) => {
      if (e < t.logLevel) return;
      const i = new Date().toISOString(),
        r = $t[e];
      if (!r)
        throw new Error(
          `Attempted to log a message with an invalid logType (value: ${e})`
        );
      console[r](`[${i}]  ${t.name}:`, ...n);
    };
  class te {
    constructor(t) {
      (this.name = t),
        (this._logLevel = Jt),
        (this._logHandler = Qt),
        (this._userLogHandler = null);
    }
    get logLevel() {
      return this._logLevel;
    }
    set logLevel(t) {
      if (!(t in qt))
        throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
      this._logLevel = t;
    }
    setLogLevel(t) {
      this._logLevel = "string" == typeof t ? Zt[t] : t;
    }
    get logHandler() {
      return this._logHandler;
    }
    set logHandler(t) {
      if ("function" != typeof t)
        throw new TypeError(
          "Value assigned to `logHandler` must be a function"
        );
      this._logHandler = t;
    }
    get userLogHandler() {
      return this._userLogHandler;
    }
    set userLogHandler(t) {
      this._userLogHandler = t;
    }
    debug(...t) {
      this._userLogHandler && this._userLogHandler(this, qt.DEBUG, ...t),
        this._logHandler(this, qt.DEBUG, ...t);
    }
    log(...t) {
      this._userLogHandler && this._userLogHandler(this, qt.VERBOSE, ...t),
        this._logHandler(this, qt.VERBOSE, ...t);
    }
    info(...t) {
      this._userLogHandler && this._userLogHandler(this, qt.INFO, ...t),
        this._logHandler(this, qt.INFO, ...t);
    }
    warn(...t) {
      this._userLogHandler && this._userLogHandler(this, qt.WARN, ...t),
        this._logHandler(this, qt.WARN, ...t);
    }
    error(...t) {
      this._userLogHandler && this._userLogHandler(this, qt.ERROR, ...t),
        this._logHandler(this, qt.ERROR, ...t);
    }
  }
  let ee, ne;
  const ie = new WeakMap(),
    re = new WeakMap(),
    se = new WeakMap(),
    oe = new WeakMap(),
    ae = new WeakMap();
  let le = {
    get(t, e, n) {
      if (t instanceof IDBTransaction) {
        if ("done" === e) return re.get(t);
        if ("objectStoreNames" === e) return t.objectStoreNames || se.get(t);
        if ("store" === e)
          return n.objectStoreNames[1]
            ? void 0
            : n.objectStore(n.objectStoreNames[0]);
      }
      return ce(t[e]);
    },
    set: (t, e, n) => ((t[e] = n), !0),
    has: (t, e) =>
      (t instanceof IDBTransaction && ("done" === e || "store" === e)) ||
      e in t,
  };
  function he(t) {
    return t !== IDBDatabase.prototype.transaction ||
      "objectStoreNames" in IDBTransaction.prototype
      ? (
          ne ||
          (ne = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
          ])
        ).includes(t)
        ? function (...e) {
            return t.apply(de(this), e), ce(ie.get(this));
          }
        : function (...e) {
            return ce(t.apply(de(this), e));
          }
      : function (e, ...n) {
          const i = t.call(de(this), e, ...n);
          return se.set(i, e.sort ? e.sort() : [e]), ce(i);
        };
  }
  function ue(t) {
    return "function" == typeof t
      ? he(t)
      : (t instanceof IDBTransaction &&
          (function (t) {
            if (re.has(t)) return;
            const e = new Promise((e, n) => {
              const i = () => {
                  t.removeEventListener("complete", r),
                    t.removeEventListener("error", s),
                    t.removeEventListener("abort", s);
                },
                r = () => {
                  e(), i();
                },
                s = () => {
                  n(t.error || new DOMException("AbortError", "AbortError")),
                    i();
                };
              t.addEventListener("complete", r),
                t.addEventListener("error", s),
                t.addEventListener("abort", s);
            });
            re.set(t, e);
          })(t),
        (e = t),
        (
          ee ||
          (ee = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
          ])
        ).some((t) => e instanceof t)
          ? new Proxy(t, le)
          : t);
    var e;
  }
  function ce(t) {
    if (t instanceof IDBRequest)
      return (function (t) {
        const e = new Promise((e, n) => {
          const i = () => {
              t.removeEventListener("success", r),
                t.removeEventListener("error", s);
            },
            r = () => {
              e(ce(t.result)), i();
            },
            s = () => {
              n(t.error), i();
            };
          t.addEventListener("success", r), t.addEventListener("error", s);
        });
        return (
          e
            .then((e) => {
              e instanceof IDBCursor && ie.set(e, t);
            })
            .catch(() => {}),
          ae.set(e, t),
          e
        );
      })(t);
    if (oe.has(t)) return oe.get(t);
    const e = ue(t);
    return e !== t && (oe.set(t, e), ae.set(e, t)), e;
  }
  const de = (t) => ae.get(t);
  function pe(
    t,
    e,
    { blocked: n, upgrade: i, blocking: r, terminated: s } = {}
  ) {
    const o = indexedDB.open(t, e),
      a = ce(o);
    return (
      i &&
        o.addEventListener("upgradeneeded", (t) => {
          i(ce(o.result), t.oldVersion, t.newVersion, ce(o.transaction));
        }),
      n && o.addEventListener("blocked", () => n()),
      a
        .then((t) => {
          s && t.addEventListener("close", () => s()),
            r && t.addEventListener("versionchange", () => r());
        })
        .catch(() => {}),
      a
    );
  }
  const fe = ["get", "getKey", "getAll", "getAllKeys", "count"],
    me = ["put", "add", "delete", "clear"],
    _e = new Map();
  function ge(t, e) {
    if (!(t instanceof IDBDatabase) || e in t || "string" != typeof e) return;
    if (_e.get(e)) return _e.get(e);
    const n = e.replace(/FromIndex$/, ""),
      i = e !== n,
      r = me.includes(n);
    if (
      !(n in (i ? IDBIndex : IDBObjectStore).prototype) ||
      (!r && !fe.includes(n))
    )
      return;
    const s = async function (t, ...e) {
      const s = this.transaction(t, r ? "readwrite" : "readonly");
      let o = s.store;
      return (
        i && (o = o.index(e.shift())),
        (await Promise.all([o[n](...e), r && s.done]))[0]
      );
    };
    return _e.set(e, s), s;
  }
  le = ((t) => ({
    ...t,
    get: (e, n, i) => ge(e, n) || t.get(e, n, i),
    has: (e, n) => !!ge(e, n) || t.has(e, n),
  }))(le);
  class ve {
    constructor(t) {
      this.container = t;
    }
    getPlatformInfoString() {
      return this.container
        .getProviders()
        .map((t) => {
          if (
            (function (t) {
              const e = t.getComponent();
              return "VERSION" === (null == e ? void 0 : e.type);
            })(t)
          ) {
            const e = t.getImmediate();
            return `${e.library}/${e.version}`;
          }
          return null;
        })
        .filter((t) => t)
        .join(" ");
    }
  }
  const ye = "@firebase/app",
    xe = "0.7.30",
    be = new te("@firebase/app"),
    Te = "[DEFAULT]",
    Ee = {
      [ye]: "fire-core",
      "@firebase/app-compat": "fire-core-compat",
      "@firebase/analytics": "fire-analytics",
      "@firebase/analytics-compat": "fire-analytics-compat",
      "@firebase/app-check": "fire-app-check",
      "@firebase/app-check-compat": "fire-app-check-compat",
      "@firebase/auth": "fire-auth",
      "@firebase/auth-compat": "fire-auth-compat",
      "@firebase/database": "fire-rtdb",
      "@firebase/database-compat": "fire-rtdb-compat",
      "@firebase/functions": "fire-fn",
      "@firebase/functions-compat": "fire-fn-compat",
      "@firebase/installations": "fire-iid",
      "@firebase/installations-compat": "fire-iid-compat",
      "@firebase/messaging": "fire-fcm",
      "@firebase/messaging-compat": "fire-fcm-compat",
      "@firebase/performance": "fire-perf",
      "@firebase/performance-compat": "fire-perf-compat",
      "@firebase/remote-config": "fire-rc",
      "@firebase/remote-config-compat": "fire-rc-compat",
      "@firebase/storage": "fire-gcs",
      "@firebase/storage-compat": "fire-gcs-compat",
      "@firebase/firestore": "fire-fst",
      "@firebase/firestore-compat": "fire-fst-compat",
      "fire-js": "fire-js",
      firebase: "fire-js-all",
    },
    Se = new Map(),
    we = new Map();
  function Me(t, e) {
    try {
      t.container.addComponent(e);
    } catch (n) {
      be.debug(
        `Component ${e.name} failed to register with FirebaseApp ${t.name}`,
        n
      );
    }
  }
  function Ae(t) {
    const e = t.name;
    if (we.has(e))
      return (
        be.debug(`There were multiple attempts to register component ${e}.`), !1
      );
    we.set(e, t);
    for (const n of Se.values()) Me(n, t);
    return !0;
  }
  function Re(t, e) {
    const n = t.container
      .getProvider("heartbeat")
      .getImmediate({ optional: !0 });
    return n && n.triggerHeartbeat(), t.container.getProvider(e);
  }
  const Ce = new Rt("app", "Firebase", {
    "no-app":
      "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
    "bad-app-name": "Illegal App name: '{$appName}",
    "duplicate-app":
      "Firebase App named '{$appName}' already exists with different options or config",
    "app-deleted": "Firebase App named '{$appName}' already deleted",
    "invalid-app-argument":
      "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    "invalid-log-argument":
      "First argument to `onLog` must be null or a function.",
    "idb-open":
      "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-get":
      "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-set":
      "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-delete":
      "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  });
  class Ie {
    constructor(t, e, n) {
      (this._isDeleted = !1),
        (this._options = Object.assign({}, t)),
        (this._config = Object.assign({}, e)),
        (this._name = e.name),
        (this._automaticDataCollectionEnabled =
          e.automaticDataCollectionEnabled),
        (this._container = n),
        this.container.addComponent(new Xt("app", () => this, "PUBLIC"));
    }
    get automaticDataCollectionEnabled() {
      return this.checkDestroyed(), this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(t) {
      this.checkDestroyed(), (this._automaticDataCollectionEnabled = t);
    }
    get name() {
      return this.checkDestroyed(), this._name;
    }
    get options() {
      return this.checkDestroyed(), this._options;
    }
    get config() {
      return this.checkDestroyed(), this._config;
    }
    get container() {
      return this._container;
    }
    get isDeleted() {
      return this._isDeleted;
    }
    set isDeleted(t) {
      this._isDeleted = t;
    }
    checkDestroyed() {
      if (this.isDeleted)
        throw Ce.create("app-deleted", { appName: this._name });
    }
  }
  function Pe(t, e = {}) {
    if ("object" != typeof e) {
      e = { name: e };
    }
    const n = Object.assign(
        { name: Te, automaticDataCollectionEnabled: !1 },
        e
      ),
      i = n.name;
    if ("string" != typeof i || !i)
      throw Ce.create("bad-app-name", { appName: String(i) });
    const r = Se.get(i);
    if (r) {
      if (Ut(t, r.options) && Ut(n, r.config)) return r;
      throw Ce.create("duplicate-app", { appName: i });
    }
    const s = new Yt(i);
    for (const a of we.values()) s.addComponent(a);
    const o = new Ie(t, n, s);
    return Se.set(i, o), o;
  }
  function Oe(t, e, n) {
    var i;
    let r = null !== (i = Ee[t]) && void 0 !== i ? i : t;
    n && (r += `-${n}`);
    const s = r.match(/\s|\//),
      o = e.match(/\s|\//);
    if (s || o) {
      const t = [`Unable to register library "${r}" with version "${e}":`];
      return (
        s &&
          t.push(
            `library name "${r}" contains illegal characters (whitespace or "/")`
          ),
        s && o && t.push("and"),
        o &&
          t.push(
            `version name "${e}" contains illegal characters (whitespace or "/")`
          ),
        void be.warn(t.join(" "))
      );
    }
    Ae(new Xt(`${r}-version`, () => ({ library: r, version: e }), "VERSION"));
  }
  const Ne = "firebase-heartbeat-store";
  let De = null;
  function Le() {
    return (
      De ||
        (De = pe("firebase-heartbeat-database", 1, {
          upgrade: (t, e) => {
            if (0 === e) t.createObjectStore(Ne);
          },
        }).catch((t) => {
          throw Ce.create("idb-open", { originalErrorMessage: t.message });
        })),
      De
    );
  }
  async function Fe(t, e) {
    var n;
    try {
      const n = (await Le()).transaction(Ne, "readwrite"),
        i = n.objectStore(Ne);
      return await i.put(e, Ue(t)), n.done;
    } catch (i) {
      if (i instanceof At) be.warn(i.message);
      else {
        const t = Ce.create("idb-set", {
          originalErrorMessage:
            null === (n = i) || void 0 === n ? void 0 : n.message,
        });
        be.warn(t.message);
      }
    }
  }
  function Ue(t) {
    return `${t.name}!${t.options.appId}`;
  }
  class Be {
    constructor(t) {
      (this.container = t), (this._heartbeatsCache = null);
      const e = this.container.getProvider("app").getImmediate();
      (this._storage = new Ge(e)),
        (this._heartbeatsCachePromise = this._storage
          .read()
          .then((t) => ((this._heartbeatsCache = t), t)));
    }
    async triggerHeartbeat() {
      const t = this.container
          .getProvider("platform-logger")
          .getImmediate()
          .getPlatformInfoString(),
        e = ke();
      if (
        (null === this._heartbeatsCache &&
          (this._heartbeatsCache = await this._heartbeatsCachePromise),
        this._heartbeatsCache.lastSentHeartbeatDate !== e &&
          !this._heartbeatsCache.heartbeats.some((t) => t.date === e))
      )
        return (
          this._heartbeatsCache.heartbeats.push({ date: e, agent: t }),
          (this._heartbeatsCache.heartbeats =
            this._heartbeatsCache.heartbeats.filter((t) => {
              const e = new Date(t.date).valueOf();
              return Date.now() - e <= 2592e6;
            })),
          this._storage.overwrite(this._heartbeatsCache)
        );
    }
    async getHeartbeatsHeader() {
      if (
        (null === this._heartbeatsCache && (await this._heartbeatsCachePromise),
        null === this._heartbeatsCache ||
          0 === this._heartbeatsCache.heartbeats.length)
      )
        return "";
      const t = ke(),
        { heartbeatsToSend: e, unsentEntries: n } = (function (t, e = 1024) {
          const n = [];
          let i = t.slice();
          for (const r of t) {
            const t = n.find((t) => t.agent === r.agent);
            if (t) {
              if ((t.dates.push(r.date), He(n) > e)) {
                t.dates.pop();
                break;
              }
            } else if (
              (n.push({ agent: r.agent, dates: [r.date] }), He(n) > e)
            ) {
              n.pop();
              break;
            }
            i = i.slice(1);
          }
          return { heartbeatsToSend: n, unsentEntries: i };
        })(this._heartbeatsCache.heartbeats),
        i = vt(JSON.stringify({ version: 2, heartbeats: e }));
      return (
        (this._heartbeatsCache.lastSentHeartbeatDate = t),
        n.length > 0
          ? ((this._heartbeatsCache.heartbeats = n),
            await this._storage.overwrite(this._heartbeatsCache))
          : ((this._heartbeatsCache.heartbeats = []),
            this._storage.overwrite(this._heartbeatsCache)),
        i
      );
    }
  }
  function ke() {
    return new Date().toISOString().substring(0, 10);
  }
  class Ge {
    constructor(t) {
      (this.app = t),
        (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
    }
    async runIndexedDBEnvironmentCheck() {
      return (
        !!wt() &&
        Mt()
          .then(() => !0)
          .catch(() => !1)
      );
    }
    async read() {
      if (await this._canUseIndexedDBPromise) {
        return (
          (await (async function (t) {
            var e;
            try {
              return (await Le()).transaction(Ne).objectStore(Ne).get(Ue(t));
            } catch (n) {
              if (n instanceof At) be.warn(n.message);
              else {
                const t = Ce.create("idb-get", {
                  originalErrorMessage:
                    null === (e = n) || void 0 === e ? void 0 : e.message,
                });
                be.warn(t.message);
              }
            }
          })(this.app)) || { heartbeats: [] }
        );
      }
      return { heartbeats: [] };
    }
    async overwrite(t) {
      var e;
      if (await this._canUseIndexedDBPromise) {
        const n = await this.read();
        return Fe(this.app, {
          lastSentHeartbeatDate:
            null !== (e = t.lastSentHeartbeatDate) && void 0 !== e
              ? e
              : n.lastSentHeartbeatDate,
          heartbeats: t.heartbeats,
        });
      }
    }
    async add(t) {
      var e;
      if (await this._canUseIndexedDBPromise) {
        const n = await this.read();
        return Fe(this.app, {
          lastSentHeartbeatDate:
            null !== (e = t.lastSentHeartbeatDate) && void 0 !== e
              ? e
              : n.lastSentHeartbeatDate,
          heartbeats: [...n.heartbeats, ...t.heartbeats],
        });
      }
    }
  }
  function He(t) {
    return vt(JSON.stringify({ version: 2, heartbeats: t })).length;
  }
  var ze;
  (ze = ""),
    Ae(new Xt("platform-logger", (t) => new ve(t), "PRIVATE")),
    Ae(new Xt("heartbeat", (t) => new Be(t), "PRIVATE")),
    Oe(ye, xe, ze),
    Oe(ye, xe, "esm2017"),
    Oe("fire-js", "");
  Oe("firebase", "9.9.2", "app");
  const Ve = "@firebase/database",
    Xe = "0.13.4";
  let We = "";
  class je {
    constructor(t) {
      (this.domStorage_ = t), (this.prefix_ = "firebase:");
    }
    set(t, e) {
      null == e
        ? this.domStorage_.removeItem(this.prefixedName_(t))
        : this.domStorage_.setItem(this.prefixedName_(t), Pt(e));
    }
    get(t) {
      const e = this.domStorage_.getItem(this.prefixedName_(t));
      return null == e ? null : It(e);
    }
    remove(t) {
      this.domStorage_.removeItem(this.prefixedName_(t));
    }
    prefixedName_(t) {
      return this.prefix_ + t;
    }
    toString() {
      return this.domStorage_.toString();
    }
  }
  class Ye {
    constructor() {
      (this.cache_ = {}), (this.isInMemoryStorage = !0);
    }
    set(t, e) {
      null == e ? delete this.cache_[t] : (this.cache_[t] = e);
    }
    get(t) {
      return Nt(this.cache_, t) ? this.cache_[t] : null;
    }
    remove(t) {
      delete this.cache_[t];
    }
  }
  const qe = function (t) {
      try {
        if ("undefined" != typeof window && void 0 !== window[t]) {
          const e = window[t];
          return (
            e.setItem("firebase:sentinel", "cache"),
            e.removeItem("firebase:sentinel"),
            new je(e)
          );
        }
      } catch (e) {}
      return new Ye();
    },
    Ke = qe("localStorage"),
    Ze = qe("sessionStorage"),
    Je = new te("@firebase/database"),
    $e = (function () {
      let t = 1;
      return function () {
        return t++;
      };
    })(),
    Qe = function (t) {
      const e = (function (t) {
          const e = [];
          let n = 0;
          for (let i = 0; i < t.length; i++) {
            let r = t.charCodeAt(i);
            if (r >= 55296 && r <= 56319) {
              const e = r - 55296;
              i++,
                pt(i < t.length, "Surrogate pair missing trail surrogate."),
                (r = 65536 + (e << 10) + (t.charCodeAt(i) - 56320));
            }
            r < 128
              ? (e[n++] = r)
              : r < 2048
              ? ((e[n++] = (r >> 6) | 192), (e[n++] = (63 & r) | 128))
              : r < 65536
              ? ((e[n++] = (r >> 12) | 224),
                (e[n++] = ((r >> 6) & 63) | 128),
                (e[n++] = (63 & r) | 128))
              : ((e[n++] = (r >> 18) | 240),
                (e[n++] = ((r >> 12) & 63) | 128),
                (e[n++] = ((r >> 6) & 63) | 128),
                (e[n++] = (63 & r) | 128));
          }
          return e;
        })(t),
        n = new kt();
      n.update(e);
      const i = n.digest();
      return _t.encodeByteArray(i);
    },
    tn = function (...t) {
      let e = "";
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        Array.isArray(i) ||
        (i && "object" == typeof i && "number" == typeof i.length)
          ? (e += tn.apply(null, i))
          : (e += "object" == typeof i ? Pt(i) : i),
          (e += " ");
      }
      return e;
    };
  let en = null,
    nn = !0;
  const rn = function (...t) {
      var e, n;
      if (
        (!0 === nn &&
          ((nn = !1),
          null === en &&
            !0 === Ze.get("logging_enabled") &&
            ((e = !0),
            pt(
              !n || !0 === e || !1 === e,
              "Can't turn on custom loggers persistently."
            ),
            !0 === e
              ? ((Je.logLevel = qt.VERBOSE),
                (en = Je.log.bind(Je)),
                n && Ze.set("logging_enabled", !0))
              : "function" == typeof e
              ? (en = e)
              : ((en = null), Ze.remove("logging_enabled")))),
        en)
      ) {
        const e = tn.apply(null, t);
        en(e);
      }
    },
    sn = function (t) {
      return function (...e) {
        rn(t, ...e);
      };
    },
    on = function (...t) {
      const e = "FIREBASE INTERNAL ERROR: " + tn(...t);
      Je.error(e);
    },
    an = function (...t) {
      const e = `FIREBASE FATAL ERROR: ${tn(...t)}`;
      throw (Je.error(e), new Error(e));
    },
    ln = function (...t) {
      const e = "FIREBASE WARNING: " + tn(...t);
      Je.warn(e);
    },
    hn = function (t) {
      return (
        "number" == typeof t &&
        (t != t ||
          t === Number.POSITIVE_INFINITY ||
          t === Number.NEGATIVE_INFINITY)
      );
    },
    un = "[MIN_NAME]",
    cn = "[MAX_NAME]",
    dn = function (t, e) {
      if (t === e) return 0;
      if (t === un || e === cn) return -1;
      if (e === un || t === cn) return 1;
      {
        const n = xn(t),
          i = xn(e);
        return null !== n
          ? null !== i
            ? n - i == 0
              ? t.length - e.length
              : n - i
            : -1
          : null !== i
          ? 1
          : t < e
          ? -1
          : 1;
      }
    },
    pn = function (t, e) {
      return t === e ? 0 : t < e ? -1 : 1;
    },
    fn = function (t, e) {
      if (e && t in e) return e[t];
      throw new Error("Missing required key (" + t + ") in object: " + Pt(e));
    },
    mn = function (t) {
      if ("object" != typeof t || null === t) return Pt(t);
      const e = [];
      for (const i in t) e.push(i);
      e.sort();
      let n = "{";
      for (let i = 0; i < e.length; i++)
        0 !== i && (n += ","), (n += Pt(e[i])), (n += ":"), (n += mn(t[e[i]]));
      return (n += "}"), n;
    },
    _n = function (t, e) {
      const n = t.length;
      if (n <= e) return [t];
      const i = [];
      for (let r = 0; r < n; r += e)
        r + e > n ? i.push(t.substring(r, n)) : i.push(t.substring(r, r + e));
      return i;
    };
  function gn(t, e) {
    for (const n in t) t.hasOwnProperty(n) && e(n, t[n]);
  }
  const vn = function (t) {
    pt(!hn(t), "Invalid JSON number");
    const e = 1023;
    let n, i, r, s, o;
    0 === t
      ? ((i = 0), (r = 0), (n = 1 / t == -1 / 0 ? 1 : 0))
      : ((n = t < 0),
        (t = Math.abs(t)) >= Math.pow(2, -1022)
          ? ((s = Math.min(Math.floor(Math.log(t) / Math.LN2), e)),
            (i = s + e),
            (r = Math.round(t * Math.pow(2, 52 - s) - Math.pow(2, 52))))
          : ((i = 0), (r = Math.round(t / Math.pow(2, -1074)))));
    const a = [];
    for (o = 52; o; o -= 1) a.push(r % 2 ? 1 : 0), (r = Math.floor(r / 2));
    for (o = 11; o; o -= 1) a.push(i % 2 ? 1 : 0), (i = Math.floor(i / 2));
    a.push(n ? 1 : 0), a.reverse();
    const l = a.join("");
    let h = "";
    for (o = 0; o < 64; o += 8) {
      let t = parseInt(l.substr(o, 8), 2).toString(16);
      1 === t.length && (t = "0" + t), (h += t);
    }
    return h.toLowerCase();
  };
  const yn = new RegExp("^-?(0*)\\d{1,10}$"),
    xn = function (t) {
      if (yn.test(t)) {
        const e = Number(t);
        if (e >= -2147483648 && e <= 2147483647) return e;
      }
      return null;
    },
    bn = function (t) {
      try {
        t();
      } catch (e) {
        setTimeout(() => {
          const t = e.stack || "";
          throw (ln("Exception was thrown by user callback.", t), e);
        }, Math.floor(0));
      }
    },
    Tn = function (t, e) {
      const n = setTimeout(t, e);
      return "object" == typeof n && n.unref && n.unref(), n;
    };
  class En {
    constructor(t, e) {
      (this.appName_ = t),
        (this.appCheckProvider = e),
        (this.appCheck = null == e ? void 0 : e.getImmediate({ optional: !0 })),
        this.appCheck || null == e || e.get().then((t) => (this.appCheck = t));
    }
    getToken(t) {
      return this.appCheck
        ? this.appCheck.getToken(t)
        : new Promise((e, n) => {
            setTimeout(() => {
              this.appCheck ? this.getToken(t).then(e, n) : e(null);
            }, 0);
          });
    }
    addTokenChangeListener(t) {
      var e;
      null === (e = this.appCheckProvider) ||
        void 0 === e ||
        e.get().then((e) => e.addTokenListener(t));
    }
    notifyForInvalidToken() {
      ln(
        `Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`
      );
    }
  }
  class Sn {
    constructor(t, e, n) {
      (this.appName_ = t),
        (this.firebaseOptions_ = e),
        (this.authProvider_ = n),
        (this.auth_ = null),
        (this.auth_ = n.getImmediate({ optional: !0 })),
        this.auth_ || n.onInit((t) => (this.auth_ = t));
    }
    getToken(t) {
      return this.auth_
        ? this.auth_
            .getToken(t)
            .catch((t) =>
              t && "auth/token-not-initialized" === t.code
                ? (rn(
                    "Got auth/token-not-initialized error.  Treating as null token."
                  ),
                  null)
                : Promise.reject(t)
            )
        : new Promise((e, n) => {
            setTimeout(() => {
              this.auth_ ? this.getToken(t).then(e, n) : e(null);
            }, 0);
          });
    }
    addTokenChangeListener(t) {
      this.auth_
        ? this.auth_.addAuthTokenListener(t)
        : this.authProvider_.get().then((e) => e.addAuthTokenListener(t));
    }
    removeTokenChangeListener(t) {
      this.authProvider_.get().then((e) => e.removeAuthTokenListener(t));
    }
    notifyForInvalidToken() {
      let t =
        'Provided authentication credentials for the app named "' +
        this.appName_ +
        '" are invalid. This usually indicates your app was not initialized correctly. ';
      "credential" in this.firebaseOptions_
        ? (t +=
            'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
        : "serviceAccount" in this.firebaseOptions_
        ? (t +=
            'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
        : (t +=
            'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.'),
        ln(t);
    }
  }
  class wn {
    constructor(t) {
      this.accessToken = t;
    }
    getToken(t) {
      return Promise.resolve({ accessToken: this.accessToken });
    }
    addTokenChangeListener(t) {
      t(this.accessToken);
    }
    removeTokenChangeListener(t) {}
    notifyForInvalidToken() {}
  }
  wn.OWNER = "owner";
  const Mn =
      /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
    An = "websocket",
    Rn = "long_polling";
  class Cn {
    constructor(t, e, n, i, r = !1, s = "", o = !1) {
      (this.secure = e),
        (this.namespace = n),
        (this.webSocketOnly = i),
        (this.nodeAdmin = r),
        (this.persistenceKey = s),
        (this.includeNamespaceInQueryParams = o),
        (this._host = t.toLowerCase()),
        (this._domain = this._host.substr(this._host.indexOf(".") + 1)),
        (this.internalHost = Ke.get("host:" + t) || this._host);
    }
    isCacheableHost() {
      return "s-" === this.internalHost.substr(0, 2);
    }
    isCustomHost() {
      return (
        "firebaseio.com" !== this._domain &&
        "firebaseio-demo.com" !== this._domain
      );
    }
    get host() {
      return this._host;
    }
    set host(t) {
      t !== this.internalHost &&
        ((this.internalHost = t),
        this.isCacheableHost() &&
          Ke.set("host:" + this._host, this.internalHost));
    }
    toString() {
      let t = this.toURLString();
      return this.persistenceKey && (t += "<" + this.persistenceKey + ">"), t;
    }
    toURLString() {
      const t = this.secure ? "https://" : "http://",
        e = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
      return `${t}${this.host}/${e}`;
    }
  }
  function In(t, e, n) {
    let i;
    if (
      (pt("string" == typeof e, "typeof type must == string"),
      pt("object" == typeof n, "typeof params must == object"),
      e === An)
    )
      i = (t.secure ? "wss://" : "ws://") + t.internalHost + "/.ws?";
    else {
      if (e !== Rn) throw new Error("Unknown connection type: " + e);
      i = (t.secure ? "https://" : "http://") + t.internalHost + "/.lp?";
    }
    (function (t) {
      return (
        t.host !== t.internalHost ||
        t.isCustomHost() ||
        t.includeNamespaceInQueryParams
      );
    })(t) && (n.ns = t.namespace);
    const r = [];
    return (
      gn(n, (t, e) => {
        r.push(t + "=" + e);
      }),
      i + r.join("&")
    );
  }
  class Pn {
    constructor() {
      this.counters_ = {};
    }
    incrementCounter(t, e = 1) {
      Nt(this.counters_, t) || (this.counters_[t] = 0),
        (this.counters_[t] += e);
    }
    get() {
      return xt(this.counters_);
    }
  }
  const On = {},
    Nn = {};
  function Dn(t) {
    const e = t.toString();
    return On[e] || (On[e] = new Pn()), On[e];
  }
  class Ln {
    constructor(t) {
      (this.onMessage_ = t),
        (this.pendingResponses = []),
        (this.currentResponseNum = 0),
        (this.closeAfterResponse = -1),
        (this.onClose = null);
    }
    closeAfter(t, e) {
      (this.closeAfterResponse = t),
        (this.onClose = e),
        this.closeAfterResponse < this.currentResponseNum &&
          (this.onClose(), (this.onClose = null));
    }
    handleResponse(t, e) {
      for (
        this.pendingResponses[t] = e;
        this.pendingResponses[this.currentResponseNum];

      ) {
        const t = this.pendingResponses[this.currentResponseNum];
        delete this.pendingResponses[this.currentResponseNum];
        for (let e = 0; e < t.length; ++e)
          t[e] &&
            bn(() => {
              this.onMessage_(t[e]);
            });
        if (this.currentResponseNum === this.closeAfterResponse) {
          this.onClose && (this.onClose(), (this.onClose = null));
          break;
        }
        this.currentResponseNum++;
      }
    }
  }
  const Fn = "start";
  class Un {
    constructor(t, e, n, i, r, s, o) {
      (this.connId = t),
        (this.repoInfo = e),
        (this.applicationId = n),
        (this.appCheckToken = i),
        (this.authToken = r),
        (this.transportSessionId = s),
        (this.lastSessionId = o),
        (this.bytesSent = 0),
        (this.bytesReceived = 0),
        (this.everConnected_ = !1),
        (this.log_ = sn(t)),
        (this.stats_ = Dn(e)),
        (this.urlFn = (t) => (
          this.appCheckToken && (t.ac = this.appCheckToken), In(e, Rn, t)
        ));
    }
    open(t, e) {
      (this.curSegmentNum = 0),
        (this.onDisconnect_ = e),
        (this.myPacketOrderer = new Ln(t)),
        (this.isClosed_ = !1),
        (this.connectTimeoutTimer_ = setTimeout(() => {
          this.log_("Timed out trying to connect."),
            this.onClosed_(),
            (this.connectTimeoutTimer_ = null);
        }, Math.floor(3e4))),
        (function (t) {
          if ("complete" === document.readyState) t();
          else {
            let e = !1;
            const n = function () {
              document.body
                ? e || ((e = !0), t())
                : setTimeout(n, Math.floor(10));
            };
            document.addEventListener
              ? (document.addEventListener("DOMContentLoaded", n, !1),
                window.addEventListener("load", n, !1))
              : document.attachEvent &&
                (document.attachEvent("onreadystatechange", () => {
                  "complete" === document.readyState && n();
                }),
                window.attachEvent("onload", n));
          }
        })(() => {
          if (this.isClosed_) return;
          this.scriptTagHolder = new Bn(
            (...t) => {
              const [e, n, i, r, s] = t;
              if ((this.incrementIncomingBytes_(t), this.scriptTagHolder))
                if (
                  (this.connectTimeoutTimer_ &&
                    (clearTimeout(this.connectTimeoutTimer_),
                    (this.connectTimeoutTimer_ = null)),
                  (this.everConnected_ = !0),
                  e === Fn)
                )
                  (this.id = n), (this.password = i);
                else {
                  if ("close" !== e)
                    throw new Error("Unrecognized command received: " + e);
                  n
                    ? ((this.scriptTagHolder.sendNewPolls = !1),
                      this.myPacketOrderer.closeAfter(n, () => {
                        this.onClosed_();
                      }))
                    : this.onClosed_();
                }
            },
            (...t) => {
              const [e, n] = t;
              this.incrementIncomingBytes_(t),
                this.myPacketOrderer.handleResponse(e, n);
            },
            () => {
              this.onClosed_();
            },
            this.urlFn
          );
          const t = { start: "t" };
          (t.ser = Math.floor(1e8 * Math.random())),
            this.scriptTagHolder.uniqueCallbackIdentifier &&
              (t.cb = this.scriptTagHolder.uniqueCallbackIdentifier),
            (t.v = "5"),
            this.transportSessionId && (t.s = this.transportSessionId),
            this.lastSessionId && (t.ls = this.lastSessionId),
            this.applicationId && (t.p = this.applicationId),
            this.appCheckToken && (t.ac = this.appCheckToken),
            "undefined" != typeof location &&
              location.hostname &&
              Mn.test(location.hostname) &&
              (t.r = "f");
          const e = this.urlFn(t);
          this.log_("Connecting via long-poll to " + e),
            this.scriptTagHolder.addTag(e, () => {});
        });
    }
    start() {
      this.scriptTagHolder.startLongPoll(this.id, this.password),
        this.addDisconnectPingFrame(this.id, this.password);
    }
    static forceAllow() {
      Un.forceAllow_ = !0;
    }
    static forceDisallow() {
      Un.forceDisallow_ = !0;
    }
    static isAvailable() {
      return (
        !!Un.forceAllow_ ||
        !(
          Un.forceDisallow_ ||
          "undefined" == typeof document ||
          null == document.createElement ||
          ("object" == typeof window &&
            window.chrome &&
            window.chrome.extension &&
            !/^chrome/.test(window.location.href)) ||
          ("object" == typeof Windows && "object" == typeof Windows.UI)
        )
      );
    }
    markConnectionHealthy() {}
    shutdown_() {
      (this.isClosed_ = !0),
        this.scriptTagHolder &&
          (this.scriptTagHolder.close(), (this.scriptTagHolder = null)),
        this.myDisconnFrame &&
          (document.body.removeChild(this.myDisconnFrame),
          (this.myDisconnFrame = null)),
        this.connectTimeoutTimer_ &&
          (clearTimeout(this.connectTimeoutTimer_),
          (this.connectTimeoutTimer_ = null));
    }
    onClosed_() {
      this.isClosed_ ||
        (this.log_("Longpoll is closing itself"),
        this.shutdown_(),
        this.onDisconnect_ &&
          (this.onDisconnect_(this.everConnected_),
          (this.onDisconnect_ = null)));
    }
    close() {
      this.isClosed_ ||
        (this.log_("Longpoll is being closed."), this.shutdown_());
    }
    send(t) {
      const e = Pt(t);
      (this.bytesSent += e.length),
        this.stats_.incrementCounter("bytes_sent", e.length);
      const n = gt(e),
        i = _n(n, 1840);
      for (let r = 0; r < i.length; r++)
        this.scriptTagHolder.enqueueSegment(this.curSegmentNum, i.length, i[r]),
          this.curSegmentNum++;
    }
    addDisconnectPingFrame(t, e) {
      this.myDisconnFrame = document.createElement("iframe");
      const n = { dframe: "t" };
      (n.id = t),
        (n.pw = e),
        (this.myDisconnFrame.src = this.urlFn(n)),
        (this.myDisconnFrame.style.display = "none"),
        document.body.appendChild(this.myDisconnFrame);
    }
    incrementIncomingBytes_(t) {
      const e = Pt(t).length;
      (this.bytesReceived += e),
        this.stats_.incrementCounter("bytes_received", e);
    }
  }
  class Bn {
    constructor(t, e, n, i) {
      (this.onDisconnect = n),
        (this.urlFn = i),
        (this.outstandingRequests = new Set()),
        (this.pendingSegs = []),
        (this.currentSerial = Math.floor(1e8 * Math.random())),
        (this.sendNewPolls = !0);
      {
        (this.uniqueCallbackIdentifier = $e()),
          (window["pLPCommand" + this.uniqueCallbackIdentifier] = t),
          (window["pRTLPCB" + this.uniqueCallbackIdentifier] = e),
          (this.myIFrame = Bn.createIFrame_());
        let n = "";
        if (
          this.myIFrame.src &&
          "javascript:" === this.myIFrame.src.substr(0, "javascript:".length)
        ) {
          n = '<script>document.domain="' + document.domain + '";</script>';
        }
        const i = "<html><body>" + n + "</body></html>";
        try {
          this.myIFrame.doc.open(),
            this.myIFrame.doc.write(i),
            this.myIFrame.doc.close();
        } catch (r) {
          rn("frame writing exception"), r.stack && rn(r.stack), rn(r);
        }
      }
    }
    static createIFrame_() {
      const t = document.createElement("iframe");
      if (((t.style.display = "none"), !document.body))
        throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
      document.body.appendChild(t);
      try {
        t.contentWindow.document || rn("No IE domain setting required");
      } catch (e) {
        const n = document.domain;
        t.src =
          "javascript:void((function(){document.open();document.domain='" +
          n +
          "';document.close();})())";
      }
      return (
        t.contentDocument
          ? (t.doc = t.contentDocument)
          : t.contentWindow
          ? (t.doc = t.contentWindow.document)
          : t.document && (t.doc = t.document),
        t
      );
    }
    close() {
      (this.alive = !1),
        this.myIFrame &&
          ((this.myIFrame.doc.body.innerHTML = ""),
          setTimeout(() => {
            null !== this.myIFrame &&
              (document.body.removeChild(this.myIFrame),
              (this.myIFrame = null));
          }, Math.floor(0)));
      const t = this.onDisconnect;
      t && ((this.onDisconnect = null), t());
    }
    startLongPoll(t, e) {
      for (this.myID = t, this.myPW = e, this.alive = !0; this.newRequest_(); );
    }
    newRequest_() {
      if (
        this.alive &&
        this.sendNewPolls &&
        this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)
      ) {
        this.currentSerial++;
        const t = {};
        (t.id = this.myID), (t.pw = this.myPW), (t.ser = this.currentSerial);
        let e = this.urlFn(t),
          n = "",
          i = 0;
        for (; this.pendingSegs.length > 0; ) {
          if (!(this.pendingSegs[0].d.length + 30 + n.length <= 1870)) break;
          {
            const t = this.pendingSegs.shift();
            (n =
              n +
              "&seg" +
              i +
              "=" +
              t.seg +
              "&ts" +
              i +
              "=" +
              t.ts +
              "&d" +
              i +
              "=" +
              t.d),
              i++;
          }
        }
        return (e += n), this.addLongPollTag_(e, this.currentSerial), !0;
      }
      return !1;
    }
    enqueueSegment(t, e, n) {
      this.pendingSegs.push({ seg: t, ts: e, d: n }),
        this.alive && this.newRequest_();
    }
    addLongPollTag_(t, e) {
      this.outstandingRequests.add(e);
      const n = () => {
          this.outstandingRequests.delete(e), this.newRequest_();
        },
        i = setTimeout(n, Math.floor(25e3));
      this.addTag(t, () => {
        clearTimeout(i), n();
      });
    }
    addTag(t, e) {
      setTimeout(() => {
        try {
          if (!this.sendNewPolls) return;
          const n = this.myIFrame.doc.createElement("script");
          (n.type = "text/javascript"),
            (n.async = !0),
            (n.src = t),
            (n.onload = n.onreadystatechange =
              function () {
                const t = n.readyState;
                (t && "loaded" !== t && "complete" !== t) ||
                  ((n.onload = n.onreadystatechange = null),
                  n.parentNode && n.parentNode.removeChild(n),
                  e());
              }),
            (n.onerror = () => {
              rn("Long-poll script failed to load: " + t),
                (this.sendNewPolls = !1),
                this.close();
            }),
            this.myIFrame.doc.body.appendChild(n);
        } catch (n) {}
      }, Math.floor(1));
    }
  }
  let kn = null;
  "undefined" != typeof MozWebSocket
    ? (kn = MozWebSocket)
    : "undefined" != typeof WebSocket && (kn = WebSocket);
  class Gn {
    constructor(t, e, n, i, r, s, o) {
      (this.connId = t),
        (this.applicationId = n),
        (this.appCheckToken = i),
        (this.authToken = r),
        (this.keepaliveTimer = null),
        (this.frames = null),
        (this.totalFrames = 0),
        (this.bytesSent = 0),
        (this.bytesReceived = 0),
        (this.log_ = sn(this.connId)),
        (this.stats_ = Dn(e)),
        (this.connURL = Gn.connectionURL_(e, s, o, i, n)),
        (this.nodeAdmin = e.nodeAdmin);
    }
    static connectionURL_(t, e, n, i, r) {
      const s = { v: "5" };
      return (
        "undefined" != typeof location &&
          location.hostname &&
          Mn.test(location.hostname) &&
          (s.r = "f"),
        e && (s.s = e),
        n && (s.ls = n),
        i && (s.ac = i),
        r && (s.p = r),
        In(t, An, s)
      );
    }
    open(t, e) {
      (this.onDisconnect = e),
        (this.onMessage = t),
        this.log_("Websocket connecting to " + this.connURL),
        (this.everConnected_ = !1),
        Ke.set("previous_websocket_failure", !0);
      try {
        let t;
        St(), (this.mySock = new kn(this.connURL, [], t));
      } catch (n) {
        this.log_("Error instantiating WebSocket.");
        const t = n.message || n.data;
        return t && this.log_(t), void this.onClosed_();
      }
      (this.mySock.onopen = () => {
        this.log_("Websocket connected."), (this.everConnected_ = !0);
      }),
        (this.mySock.onclose = () => {
          this.log_("Websocket connection was disconnected."),
            (this.mySock = null),
            this.onClosed_();
        }),
        (this.mySock.onmessage = (t) => {
          this.handleIncomingFrame(t);
        }),
        (this.mySock.onerror = (t) => {
          this.log_("WebSocket error.  Closing connection.");
          const e = t.message || t.data;
          e && this.log_(e), this.onClosed_();
        });
    }
    start() {}
    static forceDisallow() {
      Gn.forceDisallow_ = !0;
    }
    static isAvailable() {
      let t = !1;
      if ("undefined" != typeof navigator && navigator.userAgent) {
        const e = /Android ([0-9]{0,}\.[0-9]{0,})/,
          n = navigator.userAgent.match(e);
        n && n.length > 1 && parseFloat(n[1]) < 4.4 && (t = !0);
      }
      return !t && null !== kn && !Gn.forceDisallow_;
    }
    static previouslyFailed() {
      return (
        Ke.isInMemoryStorage || !0 === Ke.get("previous_websocket_failure")
      );
    }
    markConnectionHealthy() {
      Ke.remove("previous_websocket_failure");
    }
    appendFrame_(t) {
      if ((this.frames.push(t), this.frames.length === this.totalFrames)) {
        const t = this.frames.join("");
        this.frames = null;
        const e = It(t);
        this.onMessage(e);
      }
    }
    handleNewFrameCount_(t) {
      (this.totalFrames = t), (this.frames = []);
    }
    extractFrameCount_(t) {
      if (
        (pt(null === this.frames, "We already have a frame buffer"),
        t.length <= 6)
      ) {
        const e = Number(t);
        if (!isNaN(e)) return this.handleNewFrameCount_(e), null;
      }
      return this.handleNewFrameCount_(1), t;
    }
    handleIncomingFrame(t) {
      if (null === this.mySock) return;
      const e = t.data;
      if (
        ((this.bytesReceived += e.length),
        this.stats_.incrementCounter("bytes_received", e.length),
        this.resetKeepAlive(),
        null !== this.frames)
      )
        this.appendFrame_(e);
      else {
        const t = this.extractFrameCount_(e);
        null !== t && this.appendFrame_(t);
      }
    }
    send(t) {
      this.resetKeepAlive();
      const e = Pt(t);
      (this.bytesSent += e.length),
        this.stats_.incrementCounter("bytes_sent", e.length);
      const n = _n(e, 16384);
      n.length > 1 && this.sendString_(String(n.length));
      for (let i = 0; i < n.length; i++) this.sendString_(n[i]);
    }
    shutdown_() {
      (this.isClosed_ = !0),
        this.keepaliveTimer &&
          (clearInterval(this.keepaliveTimer), (this.keepaliveTimer = null)),
        this.mySock && (this.mySock.close(), (this.mySock = null));
    }
    onClosed_() {
      this.isClosed_ ||
        (this.log_("WebSocket is closing itself"),
        this.shutdown_(),
        this.onDisconnect &&
          (this.onDisconnect(this.everConnected_), (this.onDisconnect = null)));
    }
    close() {
      this.isClosed_ ||
        (this.log_("WebSocket is being closed"), this.shutdown_());
    }
    resetKeepAlive() {
      clearInterval(this.keepaliveTimer),
        (this.keepaliveTimer = setInterval(() => {
          this.mySock && this.sendString_("0"), this.resetKeepAlive();
        }, Math.floor(45e3)));
    }
    sendString_(t) {
      try {
        this.mySock.send(t);
      } catch (e) {
        this.log_(
          "Exception thrown from WebSocket.send():",
          e.message || e.data,
          "Closing connection."
        ),
          setTimeout(this.onClosed_.bind(this), 0);
      }
    }
  }
  (Gn.responsesRequiredToBeHealthy = 2), (Gn.healthyTimeout = 3e4);
  class Hn {
    constructor(t) {
      this.initTransports_(t);
    }
    static get ALL_TRANSPORTS() {
      return [Un, Gn];
    }
    static get IS_TRANSPORT_INITIALIZED() {
      return this.globalTransportInitialized_;
    }
    initTransports_(t) {
      const e = Gn && Gn.isAvailable();
      let n = e && !Gn.previouslyFailed();
      if (
        (t.webSocketOnly &&
          (e ||
            ln(
              "wss:// URL used, but browser isn't known to support websockets.  Trying anyway."
            ),
          (n = !0)),
        n)
      )
        this.transports_ = [Gn];
      else {
        const t = (this.transports_ = []);
        for (const e of Hn.ALL_TRANSPORTS) e && e.isAvailable() && t.push(e);
        Hn.globalTransportInitialized_ = !0;
      }
    }
    initialTransport() {
      if (this.transports_.length > 0) return this.transports_[0];
      throw new Error("No transports available");
    }
    upgradeTransport() {
      return this.transports_.length > 1 ? this.transports_[1] : null;
    }
  }
  Hn.globalTransportInitialized_ = !1;
  class zn {
    constructor(t, e, n, i, r, s, o, a, l, h) {
      (this.id = t),
        (this.repoInfo_ = e),
        (this.applicationId_ = n),
        (this.appCheckToken_ = i),
        (this.authToken_ = r),
        (this.onMessage_ = s),
        (this.onReady_ = o),
        (this.onDisconnect_ = a),
        (this.onKill_ = l),
        (this.lastSessionId = h),
        (this.connectionCount = 0),
        (this.pendingDataMessages = []),
        (this.state_ = 0),
        (this.log_ = sn("c:" + this.id + ":")),
        (this.transportManager_ = new Hn(e)),
        this.log_("Connection created"),
        this.start_();
    }
    start_() {
      const t = this.transportManager_.initialTransport();
      (this.conn_ = new t(
        this.nextTransportId_(),
        this.repoInfo_,
        this.applicationId_,
        this.appCheckToken_,
        this.authToken_,
        null,
        this.lastSessionId
      )),
        (this.primaryResponsesRequired_ = t.responsesRequiredToBeHealthy || 0);
      const e = this.connReceiver_(this.conn_),
        n = this.disconnReceiver_(this.conn_);
      (this.tx_ = this.conn_),
        (this.rx_ = this.conn_),
        (this.secondaryConn_ = null),
        (this.isHealthy_ = !1),
        setTimeout(() => {
          this.conn_ && this.conn_.open(e, n);
        }, Math.floor(0));
      const i = t.healthyTimeout || 0;
      i > 0 &&
        (this.healthyTimeout_ = Tn(() => {
          (this.healthyTimeout_ = null),
            this.isHealthy_ ||
              (this.conn_ && this.conn_.bytesReceived > 102400
                ? (this.log_(
                    "Connection exceeded healthy timeout but has received " +
                      this.conn_.bytesReceived +
                      " bytes.  Marking connection healthy."
                  ),
                  (this.isHealthy_ = !0),
                  this.conn_.markConnectionHealthy())
                : this.conn_ && this.conn_.bytesSent > 10240
                ? this.log_(
                    "Connection exceeded healthy timeout but has sent " +
                      this.conn_.bytesSent +
                      " bytes.  Leaving connection alive."
                  )
                : (this.log_("Closing unhealthy connection after timeout."),
                  this.close()));
        }, Math.floor(i)));
    }
    nextTransportId_() {
      return "c:" + this.id + ":" + this.connectionCount++;
    }
    disconnReceiver_(t) {
      return (e) => {
        t === this.conn_
          ? this.onConnectionLost_(e)
          : t === this.secondaryConn_
          ? (this.log_("Secondary connection lost."),
            this.onSecondaryConnectionLost_())
          : this.log_("closing an old connection");
      };
    }
    connReceiver_(t) {
      return (e) => {
        2 !== this.state_ &&
          (t === this.rx_
            ? this.onPrimaryMessageReceived_(e)
            : t === this.secondaryConn_
            ? this.onSecondaryMessageReceived_(e)
            : this.log_("message on old connection"));
      };
    }
    sendRequest(t) {
      const e = { t: "d", d: t };
      this.sendData_(e);
    }
    tryCleanupConnection() {
      this.tx_ === this.secondaryConn_ &&
        this.rx_ === this.secondaryConn_ &&
        (this.log_(
          "cleaning up and promoting a connection: " +
            this.secondaryConn_.connId
        ),
        (this.conn_ = this.secondaryConn_),
        (this.secondaryConn_ = null));
    }
    onSecondaryControl_(t) {
      if ("t" in t) {
        const e = t.t;
        "a" === e
          ? this.upgradeIfSecondaryHealthy_()
          : "r" === e
          ? (this.log_("Got a reset on secondary, closing it"),
            this.secondaryConn_.close(),
            (this.tx_ !== this.secondaryConn_ &&
              this.rx_ !== this.secondaryConn_) ||
              this.close())
          : "o" === e &&
            (this.log_("got pong on secondary."),
            this.secondaryResponsesRequired_--,
            this.upgradeIfSecondaryHealthy_());
      }
    }
    onSecondaryMessageReceived_(t) {
      const e = fn("t", t),
        n = fn("d", t);
      if ("c" === e) this.onSecondaryControl_(n);
      else {
        if ("d" !== e) throw new Error("Unknown protocol layer: " + e);
        this.pendingDataMessages.push(n);
      }
    }
    upgradeIfSecondaryHealthy_() {
      this.secondaryResponsesRequired_ <= 0
        ? (this.log_("Secondary connection is healthy."),
          (this.isHealthy_ = !0),
          this.secondaryConn_.markConnectionHealthy(),
          this.proceedWithUpgrade_())
        : (this.log_("sending ping on secondary."),
          this.secondaryConn_.send({ t: "c", d: { t: "p", d: {} } }));
    }
    proceedWithUpgrade_() {
      this.secondaryConn_.start(),
        this.log_("sending client ack on secondary"),
        this.secondaryConn_.send({ t: "c", d: { t: "a", d: {} } }),
        this.log_("Ending transmission on primary"),
        this.conn_.send({ t: "c", d: { t: "n", d: {} } }),
        (this.tx_ = this.secondaryConn_),
        this.tryCleanupConnection();
    }
    onPrimaryMessageReceived_(t) {
      const e = fn("t", t),
        n = fn("d", t);
      "c" === e ? this.onControl_(n) : "d" === e && this.onDataMessage_(n);
    }
    onDataMessage_(t) {
      this.onPrimaryResponse_(), this.onMessage_(t);
    }
    onPrimaryResponse_() {
      this.isHealthy_ ||
        (this.primaryResponsesRequired_--,
        this.primaryResponsesRequired_ <= 0 &&
          (this.log_("Primary connection is healthy."),
          (this.isHealthy_ = !0),
          this.conn_.markConnectionHealthy()));
    }
    onControl_(t) {
      const e = fn("t", t);
      if ("d" in t) {
        const n = t.d;
        if ("h" === e) this.onHandshake_(n);
        else if ("n" === e) {
          this.log_("recvd end transmission on primary"),
            (this.rx_ = this.secondaryConn_);
          for (let t = 0; t < this.pendingDataMessages.length; ++t)
            this.onDataMessage_(this.pendingDataMessages[t]);
          (this.pendingDataMessages = []), this.tryCleanupConnection();
        } else
          "s" === e
            ? this.onConnectionShutdown_(n)
            : "r" === e
            ? this.onReset_(n)
            : "e" === e
            ? on("Server Error: " + n)
            : "o" === e
            ? (this.log_("got pong on primary."),
              this.onPrimaryResponse_(),
              this.sendPingOnPrimaryIfNecessary_())
            : on("Unknown control packet command: " + e);
      }
    }
    onHandshake_(t) {
      const e = t.ts,
        n = t.v,
        i = t.h;
      (this.sessionId = t.s),
        (this.repoInfo_.host = i),
        0 === this.state_ &&
          (this.conn_.start(),
          this.onConnectionEstablished_(this.conn_, e),
          "5" !== n && ln("Protocol version mismatch detected"),
          this.tryStartUpgrade_());
    }
    tryStartUpgrade_() {
      const t = this.transportManager_.upgradeTransport();
      t && this.startUpgrade_(t);
    }
    startUpgrade_(t) {
      (this.secondaryConn_ = new t(
        this.nextTransportId_(),
        this.repoInfo_,
        this.applicationId_,
        this.appCheckToken_,
        this.authToken_,
        this.sessionId
      )),
        (this.secondaryResponsesRequired_ =
          t.responsesRequiredToBeHealthy || 0);
      const e = this.connReceiver_(this.secondaryConn_),
        n = this.disconnReceiver_(this.secondaryConn_);
      this.secondaryConn_.open(e, n),
        Tn(() => {
          this.secondaryConn_ &&
            (this.log_("Timed out trying to upgrade."),
            this.secondaryConn_.close());
        }, Math.floor(6e4));
    }
    onReset_(t) {
      this.log_("Reset packet received.  New host: " + t),
        (this.repoInfo_.host = t),
        1 === this.state_
          ? this.close()
          : (this.closeConnections_(), this.start_());
    }
    onConnectionEstablished_(t, e) {
      this.log_("Realtime connection established."),
        (this.conn_ = t),
        (this.state_ = 1),
        this.onReady_ &&
          (this.onReady_(e, this.sessionId), (this.onReady_ = null)),
        0 === this.primaryResponsesRequired_
          ? (this.log_("Primary connection is healthy."),
            (this.isHealthy_ = !0))
          : Tn(() => {
              this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(5e3));
    }
    sendPingOnPrimaryIfNecessary_() {
      this.isHealthy_ ||
        1 !== this.state_ ||
        (this.log_("sending ping on primary."),
        this.sendData_({ t: "c", d: { t: "p", d: {} } }));
    }
    onSecondaryConnectionLost_() {
      const t = this.secondaryConn_;
      (this.secondaryConn_ = null),
        (this.tx_ !== t && this.rx_ !== t) || this.close();
    }
    onConnectionLost_(t) {
      (this.conn_ = null),
        t || 0 !== this.state_
          ? 1 === this.state_ && this.log_("Realtime connection lost.")
          : (this.log_("Realtime connection failed."),
            this.repoInfo_.isCacheableHost() &&
              (Ke.remove("host:" + this.repoInfo_.host),
              (this.repoInfo_.internalHost = this.repoInfo_.host))),
        this.close();
    }
    onConnectionShutdown_(t) {
      this.log_("Connection shutdown command received. Shutting down..."),
        this.onKill_ && (this.onKill_(t), (this.onKill_ = null)),
        (this.onDisconnect_ = null),
        this.close();
    }
    sendData_(t) {
      if (1 !== this.state_) throw "Connection is not connected";
      this.tx_.send(t);
    }
    close() {
      2 !== this.state_ &&
        (this.log_("Closing realtime connection."),
        (this.state_ = 2),
        this.closeConnections_(),
        this.onDisconnect_ &&
          (this.onDisconnect_(), (this.onDisconnect_ = null)));
    }
    closeConnections_() {
      this.log_("Shutting down all connections"),
        this.conn_ && (this.conn_.close(), (this.conn_ = null)),
        this.secondaryConn_ &&
          (this.secondaryConn_.close(), (this.secondaryConn_ = null)),
        this.healthyTimeout_ &&
          (clearTimeout(this.healthyTimeout_), (this.healthyTimeout_ = null));
    }
  }
  class Vn {
    put(t, e, n, i) {}
    merge(t, e, n, i) {}
    refreshAuthToken(t) {}
    refreshAppCheckToken(t) {}
    onDisconnectPut(t, e, n) {}
    onDisconnectMerge(t, e, n) {}
    onDisconnectCancel(t, e) {}
    reportStats(t) {}
  }
  class Xn {
    constructor(t) {
      (this.allowedEvents_ = t),
        (this.listeners_ = {}),
        pt(Array.isArray(t) && t.length > 0, "Requires a non-empty array");
    }
    trigger(t, ...e) {
      if (Array.isArray(this.listeners_[t])) {
        const n = [...this.listeners_[t]];
        for (let t = 0; t < n.length; t++) n[t].callback.apply(n[t].context, e);
      }
    }
    on(t, e, n) {
      this.validateEventType_(t),
        (this.listeners_[t] = this.listeners_[t] || []),
        this.listeners_[t].push({ callback: e, context: n });
      const i = this.getInitialEvent(t);
      i && e.apply(n, i);
    }
    off(t, e, n) {
      this.validateEventType_(t);
      const i = this.listeners_[t] || [];
      for (let r = 0; r < i.length; r++)
        if (i[r].callback === e && (!n || n === i[r].context))
          return void i.splice(r, 1);
    }
    validateEventType_(t) {
      pt(
        this.allowedEvents_.find((e) => e === t),
        "Unknown event: " + t
      );
    }
  }
  class Wn extends Xn {
    constructor() {
      super(["online"]),
        (this.online_ = !0),
        "undefined" == typeof window ||
          void 0 === window.addEventListener ||
          Et() ||
          (window.addEventListener(
            "online",
            () => {
              this.online_ || ((this.online_ = !0), this.trigger("online", !0));
            },
            !1
          ),
          window.addEventListener(
            "offline",
            () => {
              this.online_ && ((this.online_ = !1), this.trigger("online", !1));
            },
            !1
          ));
    }
    static getInstance() {
      return new Wn();
    }
    getInitialEvent(t) {
      return pt("online" === t, "Unknown event type: " + t), [this.online_];
    }
    currentlyOnline() {
      return this.online_;
    }
  }
  class jn {
    constructor(t, e) {
      if (void 0 === e) {
        this.pieces_ = t.split("/");
        let e = 0;
        for (let t = 0; t < this.pieces_.length; t++)
          this.pieces_[t].length > 0 &&
            ((this.pieces_[e] = this.pieces_[t]), e++);
        (this.pieces_.length = e), (this.pieceNum_ = 0);
      } else (this.pieces_ = t), (this.pieceNum_ = e);
    }
    toString() {
      let t = "";
      for (let e = this.pieceNum_; e < this.pieces_.length; e++)
        "" !== this.pieces_[e] && (t += "/" + this.pieces_[e]);
      return t || "/";
    }
  }
  function Yn() {
    return new jn("");
  }
  function qn(t) {
    return t.pieceNum_ >= t.pieces_.length ? null : t.pieces_[t.pieceNum_];
  }
  function Kn(t) {
    return t.pieces_.length - t.pieceNum_;
  }
  function Zn(t) {
    let e = t.pieceNum_;
    return e < t.pieces_.length && e++, new jn(t.pieces_, e);
  }
  function Jn(t) {
    return t.pieceNum_ < t.pieces_.length
      ? t.pieces_[t.pieces_.length - 1]
      : null;
  }
  function $n(t, e = 0) {
    return t.pieces_.slice(t.pieceNum_ + e);
  }
  function Qn(t) {
    if (t.pieceNum_ >= t.pieces_.length) return null;
    const e = [];
    for (let n = t.pieceNum_; n < t.pieces_.length - 1; n++)
      e.push(t.pieces_[n]);
    return new jn(e, 0);
  }
  function ti(t, e) {
    const n = [];
    for (let i = t.pieceNum_; i < t.pieces_.length; i++) n.push(t.pieces_[i]);
    if (e instanceof jn)
      for (let i = e.pieceNum_; i < e.pieces_.length; i++) n.push(e.pieces_[i]);
    else {
      const t = e.split("/");
      for (let e = 0; e < t.length; e++) t[e].length > 0 && n.push(t[e]);
    }
    return new jn(n, 0);
  }
  function ei(t) {
    return t.pieceNum_ >= t.pieces_.length;
  }
  function ni(t, e) {
    const n = qn(t),
      i = qn(e);
    if (null === n) return e;
    if (n === i) return ni(Zn(t), Zn(e));
    throw new Error(
      "INTERNAL ERROR: innerPath (" +
        e +
        ") is not within outerPath (" +
        t +
        ")"
    );
  }
  function ii(t, e) {
    const n = $n(t, 0),
      i = $n(e, 0);
    for (let r = 0; r < n.length && r < i.length; r++) {
      const t = dn(n[r], i[r]);
      if (0 !== t) return t;
    }
    return n.length === i.length ? 0 : n.length < i.length ? -1 : 1;
  }
  function ri(t, e) {
    if (Kn(t) !== Kn(e)) return !1;
    for (let n = t.pieceNum_, i = e.pieceNum_; n <= t.pieces_.length; n++, i++)
      if (t.pieces_[n] !== e.pieces_[i]) return !1;
    return !0;
  }
  function si(t, e) {
    let n = t.pieceNum_,
      i = e.pieceNum_;
    if (Kn(t) > Kn(e)) return !1;
    for (; n < t.pieces_.length; ) {
      if (t.pieces_[n] !== e.pieces_[i]) return !1;
      ++n, ++i;
    }
    return !0;
  }
  class oi {
    constructor(t, e) {
      (this.errorPrefix_ = e),
        (this.parts_ = $n(t, 0)),
        (this.byteLength_ = Math.max(1, this.parts_.length));
      for (let n = 0; n < this.parts_.length; n++)
        this.byteLength_ += Ht(this.parts_[n]);
      ai(this);
    }
  }
  function ai(t) {
    if (t.byteLength_ > 768)
      throw new Error(
        t.errorPrefix_ +
          "has a key path longer than 768 bytes (" +
          t.byteLength_ +
          ")."
      );
    if (t.parts_.length > 32)
      throw new Error(
        t.errorPrefix_ +
          "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " +
          li(t)
      );
  }
  function li(t) {
    return 0 === t.parts_.length
      ? ""
      : "in property '" + t.parts_.join(".") + "'";
  }
  class hi extends Xn {
    constructor() {
      let t, e;
      super(["visible"]),
        "undefined" != typeof document &&
          void 0 !== document.addEventListener &&
          (void 0 !== document.hidden
            ? ((e = "visibilitychange"), (t = "hidden"))
            : void 0 !== document.mozHidden
            ? ((e = "mozvisibilitychange"), (t = "mozHidden"))
            : void 0 !== document.msHidden
            ? ((e = "msvisibilitychange"), (t = "msHidden"))
            : void 0 !== document.webkitHidden &&
              ((e = "webkitvisibilitychange"), (t = "webkitHidden"))),
        (this.visible_ = !0),
        e &&
          document.addEventListener(
            e,
            () => {
              const e = !document[t];
              e !== this.visible_ &&
                ((this.visible_ = e), this.trigger("visible", e));
            },
            !1
          );
    }
    static getInstance() {
      return new hi();
    }
    getInitialEvent(t) {
      return pt("visible" === t, "Unknown event type: " + t), [this.visible_];
    }
  }
  const ui = 1e3;
  class ci extends Vn {
    constructor(t, e, n, i, r, s, o, a) {
      if (
        (super(),
        (this.repoInfo_ = t),
        (this.applicationId_ = e),
        (this.onDataUpdate_ = n),
        (this.onConnectStatus_ = i),
        (this.onServerInfoUpdate_ = r),
        (this.authTokenProvider_ = s),
        (this.appCheckTokenProvider_ = o),
        (this.authOverride_ = a),
        (this.id = ci.nextPersistentConnectionId_++),
        (this.log_ = sn("p:" + this.id + ":")),
        (this.interruptReasons_ = {}),
        (this.listens = new Map()),
        (this.outstandingPuts_ = []),
        (this.outstandingGets_ = []),
        (this.outstandingPutCount_ = 0),
        (this.outstandingGetCount_ = 0),
        (this.onDisconnectRequestQueue_ = []),
        (this.connected_ = !1),
        (this.reconnectDelay_ = ui),
        (this.maxReconnectDelay_ = 3e5),
        (this.securityDebugCallback_ = null),
        (this.lastSessionId = null),
        (this.establishConnectionTimer_ = null),
        (this.visible_ = !1),
        (this.requestCBHash_ = {}),
        (this.requestNumber_ = 0),
        (this.realtime_ = null),
        (this.authToken_ = null),
        (this.appCheckToken_ = null),
        (this.forceTokenRefresh_ = !1),
        (this.invalidAuthTokenCount_ = 0),
        (this.invalidAppCheckTokenCount_ = 0),
        (this.firstConnection_ = !0),
        (this.lastConnectionAttemptTime_ = null),
        (this.lastConnectionEstablishedTime_ = null),
        a && !St())
      )
        throw new Error(
          "Auth override specified in options, but not supported on non Node.js platforms"
        );
      hi.getInstance().on("visible", this.onVisible_, this),
        -1 === t.host.indexOf("fblocal") &&
          Wn.getInstance().on("online", this.onOnline_, this);
    }
    sendRequest(t, e, n) {
      const i = ++this.requestNumber_,
        r = { r: i, a: t, b: e };
      this.log_(Pt(r)),
        pt(
          this.connected_,
          "sendRequest call when we're not connected not allowed."
        ),
        this.realtime_.sendRequest(r),
        n && (this.requestCBHash_[i] = n);
    }
    get(t) {
      this.initConnection_();
      const e = new Tt(),
        n = {
          action: "g",
          request: { p: t._path.toString(), q: t._queryObject },
          onComplete: (t) => {
            const n = t.d;
            "ok" === t.s ? e.resolve(n) : e.reject(n);
          },
        };
      this.outstandingGets_.push(n), this.outstandingGetCount_++;
      const i = this.outstandingGets_.length - 1;
      return this.connected_ && this.sendGet_(i), e.promise;
    }
    listen(t, e, n, i) {
      this.initConnection_();
      const r = t._queryIdentifier,
        s = t._path.toString();
      this.log_("Listen called for " + s + " " + r),
        this.listens.has(s) || this.listens.set(s, new Map()),
        pt(
          t._queryParams.isDefault() || !t._queryParams.loadsAllData(),
          "listen() called for non-default but complete query"
        ),
        pt(
          !this.listens.get(s).has(r),
          "listen() called twice for same path/queryId."
        );
      const o = { onComplete: i, hashFn: e, query: t, tag: n };
      this.listens.get(s).set(r, o), this.connected_ && this.sendListen_(o);
    }
    sendGet_(t) {
      const e = this.outstandingGets_[t];
      this.sendRequest("g", e.request, (n) => {
        delete this.outstandingGets_[t],
          this.outstandingGetCount_--,
          0 === this.outstandingGetCount_ && (this.outstandingGets_ = []),
          e.onComplete && e.onComplete(n);
      });
    }
    sendListen_(t) {
      const e = t.query,
        n = e._path.toString(),
        i = e._queryIdentifier;
      this.log_("Listen on " + n + " for " + i);
      const r = { p: n };
      t.tag && ((r.q = e._queryObject), (r.t = t.tag)),
        (r.h = t.hashFn()),
        this.sendRequest("q", r, (r) => {
          const s = r.d,
            o = r.s;
          ci.warnOnListenWarnings_(s, e);
          (this.listens.get(n) && this.listens.get(n).get(i)) === t &&
            (this.log_("listen response", r),
            "ok" !== o && this.removeListen_(n, i),
            t.onComplete && t.onComplete(o, s));
        });
    }
    static warnOnListenWarnings_(t, e) {
      if (t && "object" == typeof t && Nt(t, "w")) {
        const n = Dt(t, "w");
        if (Array.isArray(n) && ~n.indexOf("no_index")) {
          const t =
              '".indexOn": "' + e._queryParams.getIndex().toString() + '"',
            n = e._path.toString();
          ln(
            `Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${t} at ${n} to your security rules for better performance.`
          );
        }
      }
    }
    refreshAuthToken(t) {
      (this.authToken_ = t),
        this.log_("Auth token refreshed"),
        this.authToken_
          ? this.tryAuth()
          : this.connected_ && this.sendRequest("unauth", {}, () => {}),
        this.reduceReconnectDelayIfAdminCredential_(t);
    }
    reduceReconnectDelayIfAdminCredential_(t) {
      ((t && 40 === t.length) ||
        (function (t) {
          const e = Ot(t).claims;
          return "object" == typeof e && !0 === e.admin;
        })(t)) &&
        (this.log_(
          "Admin auth credential detected.  Reducing max reconnect time."
        ),
        (this.maxReconnectDelay_ = 3e4));
    }
    refreshAppCheckToken(t) {
      (this.appCheckToken_ = t),
        this.log_("App check token refreshed"),
        this.appCheckToken_
          ? this.tryAppCheck()
          : this.connected_ && this.sendRequest("unappeck", {}, () => {});
    }
    tryAuth() {
      if (this.connected_ && this.authToken_) {
        const t = this.authToken_,
          e = (function (t) {
            const e = Ot(t).claims;
            return !!e && "object" == typeof e && e.hasOwnProperty("iat");
          })(t)
            ? "auth"
            : "gauth",
          n = { cred: t };
        null === this.authOverride_
          ? (n.noauth = !0)
          : "object" == typeof this.authOverride_ &&
            (n.authvar = this.authOverride_),
          this.sendRequest(e, n, (e) => {
            const n = e.s,
              i = e.d || "error";
            this.authToken_ === t &&
              ("ok" === n
                ? (this.invalidAuthTokenCount_ = 0)
                : this.onAuthRevoked_(n, i));
          });
      }
    }
    tryAppCheck() {
      this.connected_ &&
        this.appCheckToken_ &&
        this.sendRequest("appcheck", { token: this.appCheckToken_ }, (t) => {
          const e = t.s,
            n = t.d || "error";
          "ok" === e
            ? (this.invalidAppCheckTokenCount_ = 0)
            : this.onAppCheckRevoked_(e, n);
        });
    }
    unlisten(t, e) {
      const n = t._path.toString(),
        i = t._queryIdentifier;
      this.log_("Unlisten called for " + n + " " + i),
        pt(
          t._queryParams.isDefault() || !t._queryParams.loadsAllData(),
          "unlisten() called for non-default but complete query"
        );
      this.removeListen_(n, i) &&
        this.connected_ &&
        this.sendUnlisten_(n, i, t._queryObject, e);
    }
    sendUnlisten_(t, e, n, i) {
      this.log_("Unlisten on " + t + " for " + e);
      const r = { p: t };
      i && ((r.q = n), (r.t = i)), this.sendRequest("n", r);
    }
    onDisconnectPut(t, e, n) {
      this.initConnection_(),
        this.connected_
          ? this.sendOnDisconnect_("o", t, e, n)
          : this.onDisconnectRequestQueue_.push({
              pathString: t,
              action: "o",
              data: e,
              onComplete: n,
            });
    }
    onDisconnectMerge(t, e, n) {
      this.initConnection_(),
        this.connected_
          ? this.sendOnDisconnect_("om", t, e, n)
          : this.onDisconnectRequestQueue_.push({
              pathString: t,
              action: "om",
              data: e,
              onComplete: n,
            });
    }
    onDisconnectCancel(t, e) {
      this.initConnection_(),
        this.connected_
          ? this.sendOnDisconnect_("oc", t, null, e)
          : this.onDisconnectRequestQueue_.push({
              pathString: t,
              action: "oc",
              data: null,
              onComplete: e,
            });
    }
    sendOnDisconnect_(t, e, n, i) {
      const r = { p: e, d: n };
      this.log_("onDisconnect " + t, r),
        this.sendRequest(t, r, (t) => {
          i &&
            setTimeout(() => {
              i(t.s, t.d);
            }, Math.floor(0));
        });
    }
    put(t, e, n, i) {
      this.putInternal("p", t, e, n, i);
    }
    merge(t, e, n, i) {
      this.putInternal("m", t, e, n, i);
    }
    putInternal(t, e, n, i, r) {
      this.initConnection_();
      const s = { p: e, d: n };
      void 0 !== r && (s.h = r),
        this.outstandingPuts_.push({ action: t, request: s, onComplete: i }),
        this.outstandingPutCount_++;
      const o = this.outstandingPuts_.length - 1;
      this.connected_ ? this.sendPut_(o) : this.log_("Buffering put: " + e);
    }
    sendPut_(t) {
      const e = this.outstandingPuts_[t].action,
        n = this.outstandingPuts_[t].request,
        i = this.outstandingPuts_[t].onComplete;
      (this.outstandingPuts_[t].queued = this.connected_),
        this.sendRequest(e, n, (n) => {
          this.log_(e + " response", n),
            delete this.outstandingPuts_[t],
            this.outstandingPutCount_--,
            0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []),
            i && i(n.s, n.d);
        });
    }
    reportStats(t) {
      if (this.connected_) {
        const e = { c: t };
        this.log_("reportStats", e),
          this.sendRequest("s", e, (t) => {
            if ("ok" !== t.s) {
              const e = t.d;
              this.log_("reportStats", "Error sending stats: " + e);
            }
          });
      }
    }
    onDataMessage_(t) {
      if ("r" in t) {
        this.log_("from server: " + Pt(t));
        const e = t.r,
          n = this.requestCBHash_[e];
        n && (delete this.requestCBHash_[e], n(t.b));
      } else {
        if ("error" in t) throw "A server-side error has occurred: " + t.error;
        "a" in t && this.onDataPush_(t.a, t.b);
      }
    }
    onDataPush_(t, e) {
      this.log_("handleServerMessage", t, e),
        "d" === t
          ? this.onDataUpdate_(e.p, e.d, !1, e.t)
          : "m" === t
          ? this.onDataUpdate_(e.p, e.d, !0, e.t)
          : "c" === t
          ? this.onListenRevoked_(e.p, e.q)
          : "ac" === t
          ? this.onAuthRevoked_(e.s, e.d)
          : "apc" === t
          ? this.onAppCheckRevoked_(e.s, e.d)
          : "sd" === t
          ? this.onSecurityDebugPacket_(e)
          : on(
              "Unrecognized action received from server: " +
                Pt(t) +
                "\nAre you using the latest client?"
            );
    }
    onReady_(t, e) {
      this.log_("connection ready"),
        (this.connected_ = !0),
        (this.lastConnectionEstablishedTime_ = new Date().getTime()),
        this.handleTimestamp_(t),
        (this.lastSessionId = e),
        this.firstConnection_ && this.sendConnectStats_(),
        this.restoreState_(),
        (this.firstConnection_ = !1),
        this.onConnectStatus_(!0);
    }
    scheduleConnect_(t) {
      pt(
        !this.realtime_,
        "Scheduling a connect when we're already connected/ing?"
      ),
        this.establishConnectionTimer_ &&
          clearTimeout(this.establishConnectionTimer_),
        (this.establishConnectionTimer_ = setTimeout(() => {
          (this.establishConnectionTimer_ = null), this.establishConnection_();
        }, Math.floor(t)));
    }
    initConnection_() {
      !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0);
    }
    onVisible_(t) {
      t &&
        !this.visible_ &&
        this.reconnectDelay_ === this.maxReconnectDelay_ &&
        (this.log_("Window became visible.  Reducing delay."),
        (this.reconnectDelay_ = ui),
        this.realtime_ || this.scheduleConnect_(0)),
        (this.visible_ = t);
    }
    onOnline_(t) {
      t
        ? (this.log_("Browser went online."),
          (this.reconnectDelay_ = ui),
          this.realtime_ || this.scheduleConnect_(0))
        : (this.log_("Browser went offline.  Killing connection."),
          this.realtime_ && this.realtime_.close());
    }
    onRealtimeDisconnect_() {
      if (
        (this.log_("data client disconnected"),
        (this.connected_ = !1),
        (this.realtime_ = null),
        this.cancelSentTransactions_(),
        (this.requestCBHash_ = {}),
        this.shouldReconnect_())
      ) {
        if (this.visible_) {
          if (this.lastConnectionEstablishedTime_) {
            new Date().getTime() - this.lastConnectionEstablishedTime_ > 3e4 &&
              (this.reconnectDelay_ = ui),
              (this.lastConnectionEstablishedTime_ = null);
          }
        } else
          this.log_("Window isn't visible.  Delaying reconnect."),
            (this.reconnectDelay_ = this.maxReconnectDelay_),
            (this.lastConnectionAttemptTime_ = new Date().getTime());
        const t = new Date().getTime() - this.lastConnectionAttemptTime_;
        let e = Math.max(0, this.reconnectDelay_ - t);
        (e = Math.random() * e),
          this.log_("Trying to reconnect in " + e + "ms"),
          this.scheduleConnect_(e),
          (this.reconnectDelay_ = Math.min(
            this.maxReconnectDelay_,
            1.3 * this.reconnectDelay_
          ));
      }
      this.onConnectStatus_(!1);
    }
    async establishConnection_() {
      if (this.shouldReconnect_()) {
        this.log_("Making a connection attempt"),
          (this.lastConnectionAttemptTime_ = new Date().getTime()),
          (this.lastConnectionEstablishedTime_ = null);
        const e = this.onDataMessage_.bind(this),
          n = this.onReady_.bind(this),
          i = this.onRealtimeDisconnect_.bind(this),
          r = this.id + ":" + ci.nextConnectionId_++,
          s = this.lastSessionId;
        let o = !1,
          a = null;
        const l = function () {
            a ? a.close() : ((o = !0), i());
          },
          h = function (t) {
            pt(a, "sendRequest call when we're not connected not allowed."),
              a.sendRequest(t);
          };
        this.realtime_ = { close: l, sendRequest: h };
        const u = this.forceTokenRefresh_;
        this.forceTokenRefresh_ = !1;
        try {
          const [t, l] = await Promise.all([
            this.authTokenProvider_.getToken(u),
            this.appCheckTokenProvider_.getToken(u),
          ]);
          o
            ? rn("getToken() completed but was canceled")
            : (rn("getToken() completed. Creating connection."),
              (this.authToken_ = t && t.accessToken),
              (this.appCheckToken_ = l && l.token),
              (a = new zn(
                r,
                this.repoInfo_,
                this.applicationId_,
                this.appCheckToken_,
                this.authToken_,
                e,
                n,
                i,
                (t) => {
                  ln(t + " (" + this.repoInfo_.toString() + ")"),
                    this.interrupt("server_kill");
                },
                s
              )));
        } catch (t) {
          this.log_("Failed to get token: " + t),
            o || (this.repoInfo_.nodeAdmin && ln(t), l());
        }
      }
    }
    interrupt(t) {
      rn("Interrupting connection for reason: " + t),
        (this.interruptReasons_[t] = !0),
        this.realtime_
          ? this.realtime_.close()
          : (this.establishConnectionTimer_ &&
              (clearTimeout(this.establishConnectionTimer_),
              (this.establishConnectionTimer_ = null)),
            this.connected_ && this.onRealtimeDisconnect_());
    }
    resume(t) {
      rn("Resuming connection for reason: " + t),
        delete this.interruptReasons_[t],
        Lt(this.interruptReasons_) &&
          ((this.reconnectDelay_ = ui),
          this.realtime_ || this.scheduleConnect_(0));
    }
    handleTimestamp_(t) {
      const e = t - new Date().getTime();
      this.onServerInfoUpdate_({ serverTimeOffset: e });
    }
    cancelSentTransactions_() {
      for (let t = 0; t < this.outstandingPuts_.length; t++) {
        const e = this.outstandingPuts_[t];
        e &&
          "h" in e.request &&
          e.queued &&
          (e.onComplete && e.onComplete("disconnect"),
          delete this.outstandingPuts_[t],
          this.outstandingPutCount_--);
      }
      0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []);
    }
    onListenRevoked_(t, e) {
      let n;
      n = e ? e.map((t) => mn(t)).join("$") : "default";
      const i = this.removeListen_(t, n);
      i && i.onComplete && i.onComplete("permission_denied");
    }
    removeListen_(t, e) {
      const n = new jn(t).toString();
      let i;
      if (this.listens.has(n)) {
        const t = this.listens.get(n);
        (i = t.get(e)), t.delete(e), 0 === t.size && this.listens.delete(n);
      } else i = void 0;
      return i;
    }
    onAuthRevoked_(t, e) {
      rn("Auth token revoked: " + t + "/" + e),
        (this.authToken_ = null),
        (this.forceTokenRefresh_ = !0),
        this.realtime_.close(),
        ("invalid_token" !== t && "permission_denied" !== t) ||
          (this.invalidAuthTokenCount_++,
          this.invalidAuthTokenCount_ >= 3 &&
            ((this.reconnectDelay_ = 3e4),
            this.authTokenProvider_.notifyForInvalidToken()));
    }
    onAppCheckRevoked_(t, e) {
      rn("App check token revoked: " + t + "/" + e),
        (this.appCheckToken_ = null),
        (this.forceTokenRefresh_ = !0),
        ("invalid_token" !== t && "permission_denied" !== t) ||
          (this.invalidAppCheckTokenCount_++,
          this.invalidAppCheckTokenCount_ >= 3 &&
            this.appCheckTokenProvider_.notifyForInvalidToken());
    }
    onSecurityDebugPacket_(t) {
      this.securityDebugCallback_
        ? this.securityDebugCallback_(t)
        : "msg" in t &&
          console.log("FIREBASE: " + t.msg.replace("\n", "\nFIREBASE: "));
    }
    restoreState_() {
      this.tryAuth(), this.tryAppCheck();
      for (const t of this.listens.values())
        for (const e of t.values()) this.sendListen_(e);
      for (let t = 0; t < this.outstandingPuts_.length; t++)
        this.outstandingPuts_[t] && this.sendPut_(t);
      for (; this.onDisconnectRequestQueue_.length; ) {
        const t = this.onDisconnectRequestQueue_.shift();
        this.sendOnDisconnect_(t.action, t.pathString, t.data, t.onComplete);
      }
      for (let t = 0; t < this.outstandingGets_.length; t++)
        this.outstandingGets_[t] && this.sendGet_(t);
    }
    sendConnectStats_() {
      const t = {};
      (t["sdk.js." + We.replace(/\./g, "-")] = 1),
        Et()
          ? (t["framework.cordova"] = 1)
          : "object" == typeof navigator &&
            "ReactNative" === navigator.product &&
            (t["framework.reactnative"] = 1),
        this.reportStats(t);
    }
    shouldReconnect_() {
      const t = Wn.getInstance().currentlyOnline();
      return Lt(this.interruptReasons_) && t;
    }
  }
  (ci.nextPersistentConnectionId_ = 0), (ci.nextConnectionId_ = 0);
  class di {
    constructor(t, e) {
      (this.name = t), (this.node = e);
    }
    static Wrap(t, e) {
      return new di(t, e);
    }
  }
  class pi {
    getCompare() {
      return this.compare.bind(this);
    }
    indexedValueChanged(t, e) {
      const n = new di(un, t),
        i = new di(un, e);
      return 0 !== this.compare(n, i);
    }
    minPost() {
      return di.MIN;
    }
  }
  let fi;
  class mi extends pi {
    static get __EMPTY_NODE() {
      return fi;
    }
    static set __EMPTY_NODE(t) {
      fi = t;
    }
    compare(t, e) {
      return dn(t.name, e.name);
    }
    isDefinedOn(t) {
      throw ft("KeyIndex.isDefinedOn not expected to be called.");
    }
    indexedValueChanged(t, e) {
      return !1;
    }
    minPost() {
      return di.MIN;
    }
    maxPost() {
      return new di(cn, fi);
    }
    makePost(t, e) {
      return (
        pt(
          "string" == typeof t,
          "KeyIndex indexValue must always be a string."
        ),
        new di(t, fi)
      );
    }
    toString() {
      return ".key";
    }
  }
  const _i = new mi();
  class gi {
    constructor(t, e, n, i, r = null) {
      (this.isReverse_ = i),
        (this.resultGenerator_ = r),
        (this.nodeStack_ = []);
      let s = 1;
      for (; !t.isEmpty(); )
        if (((s = e ? n(t.key, e) : 1), i && (s *= -1), s < 0))
          t = this.isReverse_ ? t.left : t.right;
        else {
          if (0 === s) {
            this.nodeStack_.push(t);
            break;
          }
          this.nodeStack_.push(t), (t = this.isReverse_ ? t.right : t.left);
        }
    }
    getNext() {
      if (0 === this.nodeStack_.length) return null;
      let t,
        e = this.nodeStack_.pop();
      if (
        ((t = this.resultGenerator_
          ? this.resultGenerator_(e.key, e.value)
          : { key: e.key, value: e.value }),
        this.isReverse_)
      )
        for (e = e.left; !e.isEmpty(); ) this.nodeStack_.push(e), (e = e.right);
      else
        for (e = e.right; !e.isEmpty(); ) this.nodeStack_.push(e), (e = e.left);
      return t;
    }
    hasNext() {
      return this.nodeStack_.length > 0;
    }
    peek() {
      if (0 === this.nodeStack_.length) return null;
      const t = this.nodeStack_[this.nodeStack_.length - 1];
      return this.resultGenerator_
        ? this.resultGenerator_(t.key, t.value)
        : { key: t.key, value: t.value };
    }
  }
  class vi {
    constructor(t, e, n, i, r) {
      (this.key = t),
        (this.value = e),
        (this.color = null != n ? n : vi.RED),
        (this.left = null != i ? i : yi.EMPTY_NODE),
        (this.right = null != r ? r : yi.EMPTY_NODE);
    }
    copy(t, e, n, i, r) {
      return new vi(
        null != t ? t : this.key,
        null != e ? e : this.value,
        null != n ? n : this.color,
        null != i ? i : this.left,
        null != r ? r : this.right
      );
    }
    count() {
      return this.left.count() + 1 + this.right.count();
    }
    isEmpty() {
      return !1;
    }
    inorderTraversal(t) {
      return (
        this.left.inorderTraversal(t) ||
        !!t(this.key, this.value) ||
        this.right.inorderTraversal(t)
      );
    }
    reverseTraversal(t) {
      return (
        this.right.reverseTraversal(t) ||
        t(this.key, this.value) ||
        this.left.reverseTraversal(t)
      );
    }
    min_() {
      return this.left.isEmpty() ? this : this.left.min_();
    }
    minKey() {
      return this.min_().key;
    }
    maxKey() {
      return this.right.isEmpty() ? this.key : this.right.maxKey();
    }
    insert(t, e, n) {
      let i = this;
      const r = n(t, i.key);
      return (
        (i =
          r < 0
            ? i.copy(null, null, null, i.left.insert(t, e, n), null)
            : 0 === r
            ? i.copy(null, e, null, null, null)
            : i.copy(null, null, null, null, i.right.insert(t, e, n))),
        i.fixUp_()
      );
    }
    removeMin_() {
      if (this.left.isEmpty()) return yi.EMPTY_NODE;
      let t = this;
      return (
        t.left.isRed_() || t.left.left.isRed_() || (t = t.moveRedLeft_()),
        (t = t.copy(null, null, null, t.left.removeMin_(), null)),
        t.fixUp_()
      );
    }
    remove(t, e) {
      let n, i;
      if (((n = this), e(t, n.key) < 0))
        n.left.isEmpty() ||
          n.left.isRed_() ||
          n.left.left.isRed_() ||
          (n = n.moveRedLeft_()),
          (n = n.copy(null, null, null, n.left.remove(t, e), null));
      else {
        if (
          (n.left.isRed_() && (n = n.rotateRight_()),
          n.right.isEmpty() ||
            n.right.isRed_() ||
            n.right.left.isRed_() ||
            (n = n.moveRedRight_()),
          0 === e(t, n.key))
        ) {
          if (n.right.isEmpty()) return yi.EMPTY_NODE;
          (i = n.right.min_()),
            (n = n.copy(i.key, i.value, null, null, n.right.removeMin_()));
        }
        n = n.copy(null, null, null, null, n.right.remove(t, e));
      }
      return n.fixUp_();
    }
    isRed_() {
      return this.color;
    }
    fixUp_() {
      let t = this;
      return (
        t.right.isRed_() && !t.left.isRed_() && (t = t.rotateLeft_()),
        t.left.isRed_() && t.left.left.isRed_() && (t = t.rotateRight_()),
        t.left.isRed_() && t.right.isRed_() && (t = t.colorFlip_()),
        t
      );
    }
    moveRedLeft_() {
      let t = this.colorFlip_();
      return (
        t.right.left.isRed_() &&
          ((t = t.copy(null, null, null, null, t.right.rotateRight_())),
          (t = t.rotateLeft_()),
          (t = t.colorFlip_())),
        t
      );
    }
    moveRedRight_() {
      let t = this.colorFlip_();
      return (
        t.left.left.isRed_() && ((t = t.rotateRight_()), (t = t.colorFlip_())),
        t
      );
    }
    rotateLeft_() {
      const t = this.copy(null, null, vi.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, t, null);
    }
    rotateRight_() {
      const t = this.copy(null, null, vi.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, t);
    }
    colorFlip_() {
      const t = this.left.copy(null, null, !this.left.color, null, null),
        e = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, t, e);
    }
    checkMaxDepth_() {
      const t = this.check_();
      return Math.pow(2, t) <= this.count() + 1;
    }
    check_() {
      if (this.isRed_() && this.left.isRed_())
        throw new Error(
          "Red node has red child(" + this.key + "," + this.value + ")"
        );
      if (this.right.isRed_())
        throw new Error(
          "Right child of (" + this.key + "," + this.value + ") is red"
        );
      const t = this.left.check_();
      if (t !== this.right.check_()) throw new Error("Black depths differ");
      return t + (this.isRed_() ? 0 : 1);
    }
  }
  (vi.RED = !0), (vi.BLACK = !1);
  class yi {
    constructor(t, e = yi.EMPTY_NODE) {
      (this.comparator_ = t), (this.root_ = e);
    }
    insert(t, e) {
      return new yi(
        this.comparator_,
        this.root_
          .insert(t, e, this.comparator_)
          .copy(null, null, vi.BLACK, null, null)
      );
    }
    remove(t) {
      return new yi(
        this.comparator_,
        this.root_
          .remove(t, this.comparator_)
          .copy(null, null, vi.BLACK, null, null)
      );
    }
    get(t) {
      let e,
        n = this.root_;
      for (; !n.isEmpty(); ) {
        if (((e = this.comparator_(t, n.key)), 0 === e)) return n.value;
        e < 0 ? (n = n.left) : e > 0 && (n = n.right);
      }
      return null;
    }
    getPredecessorKey(t) {
      let e,
        n = this.root_,
        i = null;
      for (; !n.isEmpty(); ) {
        if (((e = this.comparator_(t, n.key)), 0 === e)) {
          if (n.left.isEmpty()) return i ? i.key : null;
          for (n = n.left; !n.right.isEmpty(); ) n = n.right;
          return n.key;
        }
        e < 0 ? (n = n.left) : e > 0 && ((i = n), (n = n.right));
      }
      throw new Error(
        "Attempted to find predecessor key for a nonexistent key.  What gives?"
      );
    }
    isEmpty() {
      return this.root_.isEmpty();
    }
    count() {
      return this.root_.count();
    }
    minKey() {
      return this.root_.minKey();
    }
    maxKey() {
      return this.root_.maxKey();
    }
    inorderTraversal(t) {
      return this.root_.inorderTraversal(t);
    }
    reverseTraversal(t) {
      return this.root_.reverseTraversal(t);
    }
    getIterator(t) {
      return new gi(this.root_, null, this.comparator_, !1, t);
    }
    getIteratorFrom(t, e) {
      return new gi(this.root_, t, this.comparator_, !1, e);
    }
    getReverseIteratorFrom(t, e) {
      return new gi(this.root_, t, this.comparator_, !0, e);
    }
    getReverseIterator(t) {
      return new gi(this.root_, null, this.comparator_, !0, t);
    }
  }
  function xi(t, e) {
    return dn(t.name, e.name);
  }
  function bi(t, e) {
    return dn(t, e);
  }
  let Ti;
  yi.EMPTY_NODE = new (class {
    copy(t, e, n, i, r) {
      return this;
    }
    insert(t, e, n) {
      return new vi(t, e, null);
    }
    remove(t, e) {
      return this;
    }
    count() {
      return 0;
    }
    isEmpty() {
      return !0;
    }
    inorderTraversal(t) {
      return !1;
    }
    reverseTraversal(t) {
      return !1;
    }
    minKey() {
      return null;
    }
    maxKey() {
      return null;
    }
    check_() {
      return 0;
    }
    isRed_() {
      return !1;
    }
  })();
  const Ei = function (t) {
      return "number" == typeof t ? "number:" + vn(t) : "string:" + t;
    },
    Si = function (t) {
      if (t.isLeafNode()) {
        const e = t.val();
        pt(
          "string" == typeof e ||
            "number" == typeof e ||
            ("object" == typeof e && Nt(e, ".sv")),
          "Priority must be a string or number."
        );
      } else pt(t === Ti || t.isEmpty(), "priority of unexpected type.");
      pt(
        t === Ti || t.getPriority().isEmpty(),
        "Priority nodes can't have a priority of their own."
      );
    };
  let wi, Mi, Ai;
  class Ri {
    constructor(t, e = Ri.__childrenNodeConstructor.EMPTY_NODE) {
      (this.value_ = t),
        (this.priorityNode_ = e),
        (this.lazyHash_ = null),
        pt(
          void 0 !== this.value_ && null !== this.value_,
          "LeafNode shouldn't be created with null/undefined value."
        ),
        Si(this.priorityNode_);
    }
    static set __childrenNodeConstructor(t) {
      wi = t;
    }
    static get __childrenNodeConstructor() {
      return wi;
    }
    isLeafNode() {
      return !0;
    }
    getPriority() {
      return this.priorityNode_;
    }
    updatePriority(t) {
      return new Ri(this.value_, t);
    }
    getImmediateChild(t) {
      return ".priority" === t
        ? this.priorityNode_
        : Ri.__childrenNodeConstructor.EMPTY_NODE;
    }
    getChild(t) {
      return ei(t)
        ? this
        : ".priority" === qn(t)
        ? this.priorityNode_
        : Ri.__childrenNodeConstructor.EMPTY_NODE;
    }
    hasChild() {
      return !1;
    }
    getPredecessorChildName(t, e) {
      return null;
    }
    updateImmediateChild(t, e) {
      return ".priority" === t
        ? this.updatePriority(e)
        : e.isEmpty() && ".priority" !== t
        ? this
        : Ri.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(
            t,
            e
          ).updatePriority(this.priorityNode_);
    }
    updateChild(t, e) {
      const n = qn(t);
      return null === n
        ? e
        : e.isEmpty() && ".priority" !== n
        ? this
        : (pt(
            ".priority" !== n || 1 === Kn(t),
            ".priority must be the last token in a path"
          ),
          this.updateImmediateChild(
            n,
            Ri.__childrenNodeConstructor.EMPTY_NODE.updateChild(Zn(t), e)
          ));
    }
    isEmpty() {
      return !1;
    }
    numChildren() {
      return 0;
    }
    forEachChild(t, e) {
      return !1;
    }
    val(t) {
      return t && !this.getPriority().isEmpty()
        ? { ".value": this.getValue(), ".priority": this.getPriority().val() }
        : this.getValue();
    }
    hash() {
      if (null === this.lazyHash_) {
        let t = "";
        this.priorityNode_.isEmpty() ||
          (t += "priority:" + Ei(this.priorityNode_.val()) + ":");
        const e = typeof this.value_;
        (t += e + ":"),
          (t += "number" === e ? vn(this.value_) : this.value_),
          (this.lazyHash_ = Qe(t));
      }
      return this.lazyHash_;
    }
    getValue() {
      return this.value_;
    }
    compareTo(t) {
      return t === Ri.__childrenNodeConstructor.EMPTY_NODE
        ? 1
        : t instanceof Ri.__childrenNodeConstructor
        ? -1
        : (pt(t.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(t));
    }
    compareToLeafNode_(t) {
      const e = typeof t.value_,
        n = typeof this.value_,
        i = Ri.VALUE_TYPE_ORDER.indexOf(e),
        r = Ri.VALUE_TYPE_ORDER.indexOf(n);
      return (
        pt(i >= 0, "Unknown leaf type: " + e),
        pt(r >= 0, "Unknown leaf type: " + n),
        i === r
          ? "object" === n
            ? 0
            : this.value_ < t.value_
            ? -1
            : this.value_ === t.value_
            ? 0
            : 1
          : r - i
      );
    }
    withIndex() {
      return this;
    }
    isIndexed() {
      return !0;
    }
    equals(t) {
      if (t === this) return !0;
      if (t.isLeafNode()) {
        const e = t;
        return (
          this.value_ === e.value_ && this.priorityNode_.equals(e.priorityNode_)
        );
      }
      return !1;
    }
  }
  Ri.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
  const Ci = new (class extends pi {
      compare(t, e) {
        const n = t.node.getPriority(),
          i = e.node.getPriority(),
          r = n.compareTo(i);
        return 0 === r ? dn(t.name, e.name) : r;
      }
      isDefinedOn(t) {
        return !t.getPriority().isEmpty();
      }
      indexedValueChanged(t, e) {
        return !t.getPriority().equals(e.getPriority());
      }
      minPost() {
        return di.MIN;
      }
      maxPost() {
        return new di(cn, new Ri("[PRIORITY-POST]", Ai));
      }
      makePost(t, e) {
        const n = Mi(t);
        return new di(e, new Ri("[PRIORITY-POST]", n));
      }
      toString() {
        return ".priority";
      }
    })(),
    Ii = Math.log(2);
  class Pi {
    constructor(t) {
      var e;
      (this.count = ((e = t + 1), parseInt(Math.log(e) / Ii, 10))),
        (this.current_ = this.count - 1);
      const n = ((i = this.count), parseInt(Array(i + 1).join("1"), 2));
      var i;
      this.bits_ = (t + 1) & n;
    }
    nextBitIsOne() {
      const t = !(this.bits_ & (1 << this.current_));
      return this.current_--, t;
    }
  }
  const Oi = function (t, e, n, i) {
    t.sort(e);
    const r = function (e, i) {
        const s = i - e;
        let o, a;
        if (0 === s) return null;
        if (1 === s)
          return (
            (o = t[e]),
            (a = n ? n(o) : o),
            new vi(a, o.node, vi.BLACK, null, null)
          );
        {
          const l = parseInt(s / 2, 10) + e,
            h = r(e, l),
            u = r(l + 1, i);
          return (
            (o = t[l]), (a = n ? n(o) : o), new vi(a, o.node, vi.BLACK, h, u)
          );
        }
      },
      s = (function (e) {
        let i = null,
          s = null,
          o = t.length;
        const a = function (e, i) {
            const s = o - e,
              a = o;
            o -= e;
            const h = r(s + 1, a),
              u = t[s],
              c = n ? n(u) : u;
            l(new vi(c, u.node, i, null, h));
          },
          l = function (t) {
            i ? ((i.left = t), (i = t)) : ((s = t), (i = t));
          };
        for (let t = 0; t < e.count; ++t) {
          const n = e.nextBitIsOne(),
            i = Math.pow(2, e.count - (t + 1));
          n ? a(i, vi.BLACK) : (a(i, vi.BLACK), a(i, vi.RED));
        }
        return s;
      })(new Pi(t.length));
    return new yi(i || e, s);
  };
  let Ni;
  const Di = {};
  class Li {
    constructor(t, e) {
      (this.indexes_ = t), (this.indexSet_ = e);
    }
    static get Default() {
      return (
        pt(Di && Ci, "ChildrenNode.ts has not been loaded"),
        (Ni = Ni || new Li({ ".priority": Di }, { ".priority": Ci })),
        Ni
      );
    }
    get(t) {
      const e = Dt(this.indexes_, t);
      if (!e) throw new Error("No index defined for " + t);
      return e instanceof yi ? e : null;
    }
    hasIndex(t) {
      return Nt(this.indexSet_, t.toString());
    }
    addIndex(t, e) {
      pt(
        t !== _i,
        "KeyIndex always exists and isn't meant to be added to the IndexMap."
      );
      const n = [];
      let i = !1;
      const r = e.getIterator(di.Wrap);
      let s,
        o = r.getNext();
      for (; o; )
        (i = i || t.isDefinedOn(o.node)), n.push(o), (o = r.getNext());
      s = i ? Oi(n, t.getCompare()) : Di;
      const a = t.toString(),
        l = Object.assign({}, this.indexSet_);
      l[a] = t;
      const h = Object.assign({}, this.indexes_);
      return (h[a] = s), new Li(h, l);
    }
    addToIndexes(t, e) {
      const n = Ft(this.indexes_, (n, i) => {
        const r = Dt(this.indexSet_, i);
        if ((pt(r, "Missing index implementation for " + i), n === Di)) {
          if (r.isDefinedOn(t.node)) {
            const n = [],
              i = e.getIterator(di.Wrap);
            let s = i.getNext();
            for (; s; ) s.name !== t.name && n.push(s), (s = i.getNext());
            return n.push(t), Oi(n, r.getCompare());
          }
          return Di;
        }
        {
          const i = e.get(t.name);
          let r = n;
          return i && (r = r.remove(new di(t.name, i))), r.insert(t, t.node);
        }
      });
      return new Li(n, this.indexSet_);
    }
    removeFromIndexes(t, e) {
      const n = Ft(this.indexes_, (n) => {
        if (n === Di) return n;
        {
          const i = e.get(t.name);
          return i ? n.remove(new di(t.name, i)) : n;
        }
      });
      return new Li(n, this.indexSet_);
    }
  }
  let Fi;
  class Ui {
    constructor(t, e, n) {
      (this.children_ = t),
        (this.priorityNode_ = e),
        (this.indexMap_ = n),
        (this.lazyHash_ = null),
        this.priorityNode_ && Si(this.priorityNode_),
        this.children_.isEmpty() &&
          pt(
            !this.priorityNode_ || this.priorityNode_.isEmpty(),
            "An empty node cannot have a priority"
          );
    }
    static get EMPTY_NODE() {
      return Fi || (Fi = new Ui(new yi(bi), null, Li.Default));
    }
    isLeafNode() {
      return !1;
    }
    getPriority() {
      return this.priorityNode_ || Fi;
    }
    updatePriority(t) {
      return this.children_.isEmpty()
        ? this
        : new Ui(this.children_, t, this.indexMap_);
    }
    getImmediateChild(t) {
      if (".priority" === t) return this.getPriority();
      {
        const e = this.children_.get(t);
        return null === e ? Fi : e;
      }
    }
    getChild(t) {
      const e = qn(t);
      return null === e ? this : this.getImmediateChild(e).getChild(Zn(t));
    }
    hasChild(t) {
      return null !== this.children_.get(t);
    }
    updateImmediateChild(t, e) {
      if (
        (pt(e, "We should always be passing snapshot nodes"), ".priority" === t)
      )
        return this.updatePriority(e);
      {
        const n = new di(t, e);
        let i, r;
        e.isEmpty()
          ? ((i = this.children_.remove(t)),
            (r = this.indexMap_.removeFromIndexes(n, this.children_)))
          : ((i = this.children_.insert(t, e)),
            (r = this.indexMap_.addToIndexes(n, this.children_)));
        const s = i.isEmpty() ? Fi : this.priorityNode_;
        return new Ui(i, s, r);
      }
    }
    updateChild(t, e) {
      const n = qn(t);
      if (null === n) return e;
      {
        pt(
          ".priority" !== qn(t) || 1 === Kn(t),
          ".priority must be the last token in a path"
        );
        const i = this.getImmediateChild(n).updateChild(Zn(t), e);
        return this.updateImmediateChild(n, i);
      }
    }
    isEmpty() {
      return this.children_.isEmpty();
    }
    numChildren() {
      return this.children_.count();
    }
    val(t) {
      if (this.isEmpty()) return null;
      const e = {};
      let n = 0,
        i = 0,
        r = !0;
      if (
        (this.forEachChild(Ci, (s, o) => {
          (e[s] = o.val(t)),
            n++,
            r && Ui.INTEGER_REGEXP_.test(s)
              ? (i = Math.max(i, Number(s)))
              : (r = !1);
        }),
        !t && r && i < 2 * n)
      ) {
        const t = [];
        for (const n in e) t[n] = e[n];
        return t;
      }
      return (
        t &&
          !this.getPriority().isEmpty() &&
          (e[".priority"] = this.getPriority().val()),
        e
      );
    }
    hash() {
      if (null === this.lazyHash_) {
        let t = "";
        this.getPriority().isEmpty() ||
          (t += "priority:" + Ei(this.getPriority().val()) + ":"),
          this.forEachChild(Ci, (e, n) => {
            const i = n.hash();
            "" !== i && (t += ":" + e + ":" + i);
          }),
          (this.lazyHash_ = "" === t ? "" : Qe(t));
      }
      return this.lazyHash_;
    }
    getPredecessorChildName(t, e, n) {
      const i = this.resolveIndex_(n);
      if (i) {
        const n = i.getPredecessorKey(new di(t, e));
        return n ? n.name : null;
      }
      return this.children_.getPredecessorKey(t);
    }
    getFirstChildName(t) {
      const e = this.resolveIndex_(t);
      if (e) {
        const t = e.minKey();
        return t && t.name;
      }
      return this.children_.minKey();
    }
    getFirstChild(t) {
      const e = this.getFirstChildName(t);
      return e ? new di(e, this.children_.get(e)) : null;
    }
    getLastChildName(t) {
      const e = this.resolveIndex_(t);
      if (e) {
        const t = e.maxKey();
        return t && t.name;
      }
      return this.children_.maxKey();
    }
    getLastChild(t) {
      const e = this.getLastChildName(t);
      return e ? new di(e, this.children_.get(e)) : null;
    }
    forEachChild(t, e) {
      const n = this.resolveIndex_(t);
      return n
        ? n.inorderTraversal((t) => e(t.name, t.node))
        : this.children_.inorderTraversal(e);
    }
    getIterator(t) {
      return this.getIteratorFrom(t.minPost(), t);
    }
    getIteratorFrom(t, e) {
      const n = this.resolveIndex_(e);
      if (n) return n.getIteratorFrom(t, (t) => t);
      {
        const n = this.children_.getIteratorFrom(t.name, di.Wrap);
        let i = n.peek();
        for (; null != i && e.compare(i, t) < 0; ) n.getNext(), (i = n.peek());
        return n;
      }
    }
    getReverseIterator(t) {
      return this.getReverseIteratorFrom(t.maxPost(), t);
    }
    getReverseIteratorFrom(t, e) {
      const n = this.resolveIndex_(e);
      if (n) return n.getReverseIteratorFrom(t, (t) => t);
      {
        const n = this.children_.getReverseIteratorFrom(t.name, di.Wrap);
        let i = n.peek();
        for (; null != i && e.compare(i, t) > 0; ) n.getNext(), (i = n.peek());
        return n;
      }
    }
    compareTo(t) {
      return this.isEmpty()
        ? t.isEmpty()
          ? 0
          : -1
        : t.isLeafNode() || t.isEmpty()
        ? 1
        : t === Bi
        ? -1
        : 0;
    }
    withIndex(t) {
      if (t === _i || this.indexMap_.hasIndex(t)) return this;
      {
        const e = this.indexMap_.addIndex(t, this.children_);
        return new Ui(this.children_, this.priorityNode_, e);
      }
    }
    isIndexed(t) {
      return t === _i || this.indexMap_.hasIndex(t);
    }
    equals(t) {
      if (t === this) return !0;
      if (t.isLeafNode()) return !1;
      {
        const e = t;
        if (this.getPriority().equals(e.getPriority())) {
          if (this.children_.count() === e.children_.count()) {
            const t = this.getIterator(Ci),
              n = e.getIterator(Ci);
            let i = t.getNext(),
              r = n.getNext();
            for (; i && r; ) {
              if (i.name !== r.name || !i.node.equals(r.node)) return !1;
              (i = t.getNext()), (r = n.getNext());
            }
            return null === i && null === r;
          }
          return !1;
        }
        return !1;
      }
    }
    resolveIndex_(t) {
      return t === _i ? null : this.indexMap_.get(t.toString());
    }
  }
  Ui.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
  const Bi = new (class extends Ui {
    constructor() {
      super(new yi(bi), Ui.EMPTY_NODE, Li.Default);
    }
    compareTo(t) {
      return t === this ? 0 : 1;
    }
    equals(t) {
      return t === this;
    }
    getPriority() {
      return this;
    }
    getImmediateChild(t) {
      return Ui.EMPTY_NODE;
    }
    isEmpty() {
      return !1;
    }
  })();
  Object.defineProperties(di, {
    MIN: { value: new di(un, Ui.EMPTY_NODE) },
    MAX: { value: new di(cn, Bi) },
  }),
    (mi.__EMPTY_NODE = Ui.EMPTY_NODE),
    (Ri.__childrenNodeConstructor = Ui),
    (Ti = Bi),
    (function (t) {
      Ai = t;
    })(Bi);
  function ki(t, e = null) {
    if (null === t) return Ui.EMPTY_NODE;
    if (
      ("object" == typeof t && ".priority" in t && (e = t[".priority"]),
      pt(
        null === e ||
          "string" == typeof e ||
          "number" == typeof e ||
          ("object" == typeof e && ".sv" in e),
        "Invalid priority type found: " + typeof e
      ),
      "object" == typeof t &&
        ".value" in t &&
        null !== t[".value"] &&
        (t = t[".value"]),
      "object" != typeof t || ".sv" in t)
    ) {
      return new Ri(t, ki(e));
    }
    if (t instanceof Array) {
      let n = Ui.EMPTY_NODE;
      return (
        gn(t, (e, i) => {
          if (Nt(t, e) && "." !== e.substring(0, 1)) {
            const t = ki(i);
            (!t.isLeafNode() && t.isEmpty()) ||
              (n = n.updateImmediateChild(e, t));
          }
        }),
        n.updatePriority(ki(e))
      );
    }
    {
      const n = [];
      let i = !1;
      if (
        (gn(t, (t, e) => {
          if ("." !== t.substring(0, 1)) {
            const r = ki(e);
            r.isEmpty() ||
              ((i = i || !r.getPriority().isEmpty()), n.push(new di(t, r)));
          }
        }),
        0 === n.length)
      )
        return Ui.EMPTY_NODE;
      const r = Oi(n, xi, (t) => t.name, bi);
      if (i) {
        const t = Oi(n, Ci.getCompare());
        return new Ui(
          r,
          ki(e),
          new Li({ ".priority": t }, { ".priority": Ci })
        );
      }
      return new Ui(r, ki(e), Li.Default);
    }
  }
  !(function (t) {
    Mi = t;
  })(ki);
  class Gi extends pi {
    constructor(t) {
      super(),
        (this.indexPath_ = t),
        pt(
          !ei(t) && ".priority" !== qn(t),
          "Can't create PathIndex with empty path or .priority key"
        );
    }
    extractChild(t) {
      return t.getChild(this.indexPath_);
    }
    isDefinedOn(t) {
      return !t.getChild(this.indexPath_).isEmpty();
    }
    compare(t, e) {
      const n = this.extractChild(t.node),
        i = this.extractChild(e.node),
        r = n.compareTo(i);
      return 0 === r ? dn(t.name, e.name) : r;
    }
    makePost(t, e) {
      const n = ki(t),
        i = Ui.EMPTY_NODE.updateChild(this.indexPath_, n);
      return new di(e, i);
    }
    maxPost() {
      const t = Ui.EMPTY_NODE.updateChild(this.indexPath_, Bi);
      return new di(cn, t);
    }
    toString() {
      return $n(this.indexPath_, 0).join("/");
    }
  }
  const Hi = new (class extends pi {
      compare(t, e) {
        const n = t.node.compareTo(e.node);
        return 0 === n ? dn(t.name, e.name) : n;
      }
      isDefinedOn(t) {
        return !0;
      }
      indexedValueChanged(t, e) {
        return !t.equals(e);
      }
      minPost() {
        return di.MIN;
      }
      maxPost() {
        return di.MAX;
      }
      makePost(t, e) {
        const n = ki(t);
        return new di(e, n);
      }
      toString() {
        return ".value";
      }
    })(),
    zi = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",
    Vi = (function () {
      let t = 0;
      const e = [];
      return function (n) {
        const i = n === t;
        let r;
        t = n;
        const s = new Array(8);
        for (r = 7; r >= 0; r--)
          (s[r] = zi.charAt(n % 64)), (n = Math.floor(n / 64));
        pt(0 === n, "Cannot push at time == 0");
        let o = s.join("");
        if (i) {
          for (r = 11; r >= 0 && 63 === e[r]; r--) e[r] = 0;
          e[r]++;
        } else for (r = 0; r < 12; r++) e[r] = Math.floor(64 * Math.random());
        for (r = 0; r < 12; r++) o += zi.charAt(e[r]);
        return pt(20 === o.length, "nextPushId: Length should be 20."), o;
      };
    })();
  function Xi(t) {
    return { type: "value", snapshotNode: t };
  }
  function Wi(t, e) {
    return { type: "child_added", snapshotNode: e, childName: t };
  }
  function ji(t, e) {
    return { type: "child_removed", snapshotNode: e, childName: t };
  }
  function Yi(t, e, n) {
    return { type: "child_changed", snapshotNode: e, childName: t, oldSnap: n };
  }
  class qi {
    constructor(t) {
      this.index_ = t;
    }
    updateChild(t, e, n, i, r, s) {
      pt(
        t.isIndexed(this.index_),
        "A node must be indexed if only a child is updated"
      );
      const o = t.getImmediateChild(e);
      return o.getChild(i).equals(n.getChild(i)) && o.isEmpty() === n.isEmpty()
        ? t
        : (null != s &&
            (n.isEmpty()
              ? t.hasChild(e)
                ? s.trackChildChange(ji(e, o))
                : pt(
                    t.isLeafNode(),
                    "A child remove without an old child only makes sense on a leaf node"
                  )
              : o.isEmpty()
              ? s.trackChildChange(Wi(e, n))
              : s.trackChildChange(Yi(e, n, o))),
          t.isLeafNode() && n.isEmpty()
            ? t
            : t.updateImmediateChild(e, n).withIndex(this.index_));
    }
    updateFullNode(t, e, n) {
      return (
        null != n &&
          (t.isLeafNode() ||
            t.forEachChild(Ci, (t, i) => {
              e.hasChild(t) || n.trackChildChange(ji(t, i));
            }),
          e.isLeafNode() ||
            e.forEachChild(Ci, (e, i) => {
              if (t.hasChild(e)) {
                const r = t.getImmediateChild(e);
                r.equals(i) || n.trackChildChange(Yi(e, i, r));
              } else n.trackChildChange(Wi(e, i));
            })),
        e.withIndex(this.index_)
      );
    }
    updatePriority(t, e) {
      return t.isEmpty() ? Ui.EMPTY_NODE : t.updatePriority(e);
    }
    filtersNodes() {
      return !1;
    }
    getIndexedFilter() {
      return this;
    }
    getIndex() {
      return this.index_;
    }
  }
  class Ki {
    constructor(t) {
      (this.indexedFilter_ = new qi(t.getIndex())),
        (this.index_ = t.getIndex()),
        (this.startPost_ = Ki.getStartPost_(t)),
        (this.endPost_ = Ki.getEndPost_(t));
    }
    getStartPost() {
      return this.startPost_;
    }
    getEndPost() {
      return this.endPost_;
    }
    matches(t) {
      return (
        this.index_.compare(this.getStartPost(), t) <= 0 &&
        this.index_.compare(t, this.getEndPost()) <= 0
      );
    }
    updateChild(t, e, n, i, r, s) {
      return (
        this.matches(new di(e, n)) || (n = Ui.EMPTY_NODE),
        this.indexedFilter_.updateChild(t, e, n, i, r, s)
      );
    }
    updateFullNode(t, e, n) {
      e.isLeafNode() && (e = Ui.EMPTY_NODE);
      let i = e.withIndex(this.index_);
      i = i.updatePriority(Ui.EMPTY_NODE);
      const r = this;
      return (
        e.forEachChild(Ci, (t, e) => {
          r.matches(new di(t, e)) ||
            (i = i.updateImmediateChild(t, Ui.EMPTY_NODE));
        }),
        this.indexedFilter_.updateFullNode(t, i, n)
      );
    }
    updatePriority(t, e) {
      return t;
    }
    filtersNodes() {
      return !0;
    }
    getIndexedFilter() {
      return this.indexedFilter_;
    }
    getIndex() {
      return this.index_;
    }
    static getStartPost_(t) {
      if (t.hasStart()) {
        const e = t.getIndexStartName();
        return t.getIndex().makePost(t.getIndexStartValue(), e);
      }
      return t.getIndex().minPost();
    }
    static getEndPost_(t) {
      if (t.hasEnd()) {
        const e = t.getIndexEndName();
        return t.getIndex().makePost(t.getIndexEndValue(), e);
      }
      return t.getIndex().maxPost();
    }
  }
  class Zi {
    constructor(t) {
      (this.rangedFilter_ = new Ki(t)),
        (this.index_ = t.getIndex()),
        (this.limit_ = t.getLimit()),
        (this.reverse_ = !t.isViewFromLeft());
    }
    updateChild(t, e, n, i, r, s) {
      return (
        this.rangedFilter_.matches(new di(e, n)) || (n = Ui.EMPTY_NODE),
        t.getImmediateChild(e).equals(n)
          ? t
          : t.numChildren() < this.limit_
          ? this.rangedFilter_.getIndexedFilter().updateChild(t, e, n, i, r, s)
          : this.fullLimitUpdateChild_(t, e, n, r, s)
      );
    }
    updateFullNode(t, e, n) {
      let i;
      if (e.isLeafNode() || e.isEmpty())
        i = Ui.EMPTY_NODE.withIndex(this.index_);
      else if (2 * this.limit_ < e.numChildren() && e.isIndexed(this.index_)) {
        let t;
        (i = Ui.EMPTY_NODE.withIndex(this.index_)),
          (t = this.reverse_
            ? e.getReverseIteratorFrom(
                this.rangedFilter_.getEndPost(),
                this.index_
              )
            : e.getIteratorFrom(
                this.rangedFilter_.getStartPost(),
                this.index_
              ));
        let n = 0;
        for (; t.hasNext() && n < this.limit_; ) {
          const e = t.getNext();
          let r;
          if (
            ((r = this.reverse_
              ? this.index_.compare(this.rangedFilter_.getStartPost(), e) <= 0
              : this.index_.compare(e, this.rangedFilter_.getEndPost()) <= 0),
            !r)
          )
            break;
          (i = i.updateImmediateChild(e.name, e.node)), n++;
        }
      } else {
        let t, n, r, s;
        if (
          ((i = e.withIndex(this.index_)),
          (i = i.updatePriority(Ui.EMPTY_NODE)),
          this.reverse_)
        ) {
          (s = i.getReverseIterator(this.index_)),
            (t = this.rangedFilter_.getEndPost()),
            (n = this.rangedFilter_.getStartPost());
          const e = this.index_.getCompare();
          r = (t, n) => e(n, t);
        } else
          (s = i.getIterator(this.index_)),
            (t = this.rangedFilter_.getStartPost()),
            (n = this.rangedFilter_.getEndPost()),
            (r = this.index_.getCompare());
        let o = 0,
          a = !1;
        for (; s.hasNext(); ) {
          const e = s.getNext();
          !a && r(t, e) <= 0 && (a = !0);
          a && o < this.limit_ && r(e, n) <= 0
            ? o++
            : (i = i.updateImmediateChild(e.name, Ui.EMPTY_NODE));
        }
      }
      return this.rangedFilter_.getIndexedFilter().updateFullNode(t, i, n);
    }
    updatePriority(t, e) {
      return t;
    }
    filtersNodes() {
      return !0;
    }
    getIndexedFilter() {
      return this.rangedFilter_.getIndexedFilter();
    }
    getIndex() {
      return this.index_;
    }
    fullLimitUpdateChild_(t, e, n, i, r) {
      let s;
      if (this.reverse_) {
        const t = this.index_.getCompare();
        s = (e, n) => t(n, e);
      } else s = this.index_.getCompare();
      const o = t;
      pt(o.numChildren() === this.limit_, "");
      const a = new di(e, n),
        l = this.reverse_
          ? o.getFirstChild(this.index_)
          : o.getLastChild(this.index_),
        h = this.rangedFilter_.matches(a);
      if (o.hasChild(e)) {
        const t = o.getImmediateChild(e);
        let u = i.getChildAfterChild(this.index_, l, this.reverse_);
        for (; null != u && (u.name === e || o.hasChild(u.name)); )
          u = i.getChildAfterChild(this.index_, u, this.reverse_);
        const c = null == u ? 1 : s(u, a);
        if (h && !n.isEmpty() && c >= 0)
          return (
            null != r && r.trackChildChange(Yi(e, n, t)),
            o.updateImmediateChild(e, n)
          );
        {
          null != r && r.trackChildChange(ji(e, t));
          const n = o.updateImmediateChild(e, Ui.EMPTY_NODE);
          return null != u && this.rangedFilter_.matches(u)
            ? (null != r && r.trackChildChange(Wi(u.name, u.node)),
              n.updateImmediateChild(u.name, u.node))
            : n;
        }
      }
      return n.isEmpty()
        ? t
        : h && s(l, a) >= 0
        ? (null != r &&
            (r.trackChildChange(ji(l.name, l.node)),
            r.trackChildChange(Wi(e, n))),
          o
            .updateImmediateChild(e, n)
            .updateImmediateChild(l.name, Ui.EMPTY_NODE))
        : t;
    }
  }
  class Ji {
    constructor() {
      (this.limitSet_ = !1),
        (this.startSet_ = !1),
        (this.startNameSet_ = !1),
        (this.startAfterSet_ = !1),
        (this.endSet_ = !1),
        (this.endNameSet_ = !1),
        (this.endBeforeSet_ = !1),
        (this.limit_ = 0),
        (this.viewFrom_ = ""),
        (this.indexStartValue_ = null),
        (this.indexStartName_ = ""),
        (this.indexEndValue_ = null),
        (this.indexEndName_ = ""),
        (this.index_ = Ci);
    }
    hasStart() {
      return this.startSet_;
    }
    hasStartAfter() {
      return this.startAfterSet_;
    }
    hasEndBefore() {
      return this.endBeforeSet_;
    }
    isViewFromLeft() {
      return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_;
    }
    getIndexStartValue() {
      return (
        pt(this.startSet_, "Only valid if start has been set"),
        this.indexStartValue_
      );
    }
    getIndexStartName() {
      return (
        pt(this.startSet_, "Only valid if start has been set"),
        this.startNameSet_ ? this.indexStartName_ : un
      );
    }
    hasEnd() {
      return this.endSet_;
    }
    getIndexEndValue() {
      return (
        pt(this.endSet_, "Only valid if end has been set"), this.indexEndValue_
      );
    }
    getIndexEndName() {
      return (
        pt(this.endSet_, "Only valid if end has been set"),
        this.endNameSet_ ? this.indexEndName_ : cn
      );
    }
    hasLimit() {
      return this.limitSet_;
    }
    hasAnchoredLimit() {
      return this.limitSet_ && "" !== this.viewFrom_;
    }
    getLimit() {
      return (
        pt(this.limitSet_, "Only valid if limit has been set"), this.limit_
      );
    }
    getIndex() {
      return this.index_;
    }
    loadsAllData() {
      return !(this.startSet_ || this.endSet_ || this.limitSet_);
    }
    isDefault() {
      return this.loadsAllData() && this.index_ === Ci;
    }
    copy() {
      const t = new Ji();
      return (
        (t.limitSet_ = this.limitSet_),
        (t.limit_ = this.limit_),
        (t.startSet_ = this.startSet_),
        (t.indexStartValue_ = this.indexStartValue_),
        (t.startNameSet_ = this.startNameSet_),
        (t.indexStartName_ = this.indexStartName_),
        (t.endSet_ = this.endSet_),
        (t.indexEndValue_ = this.indexEndValue_),
        (t.endNameSet_ = this.endNameSet_),
        (t.indexEndName_ = this.indexEndName_),
        (t.index_ = this.index_),
        (t.viewFrom_ = this.viewFrom_),
        t
      );
    }
  }
  function $i(t) {
    const e = {};
    if (t.isDefault()) return e;
    let n;
    return (
      t.index_ === Ci
        ? (n = "$priority")
        : t.index_ === Hi
        ? (n = "$value")
        : t.index_ === _i
        ? (n = "$key")
        : (pt(t.index_ instanceof Gi, "Unrecognized index type!"),
          (n = t.index_.toString())),
      (e.orderBy = Pt(n)),
      t.startSet_ &&
        ((e.startAt = Pt(t.indexStartValue_)),
        t.startNameSet_ && (e.startAt += "," + Pt(t.indexStartName_))),
      t.endSet_ &&
        ((e.endAt = Pt(t.indexEndValue_)),
        t.endNameSet_ && (e.endAt += "," + Pt(t.indexEndName_))),
      t.limitSet_ &&
        (t.isViewFromLeft()
          ? (e.limitToFirst = t.limit_)
          : (e.limitToLast = t.limit_)),
      e
    );
  }
  function Qi(t) {
    const e = {};
    if (
      (t.startSet_ &&
        ((e.sp = t.indexStartValue_),
        t.startNameSet_ && (e.sn = t.indexStartName_)),
      t.endSet_ &&
        ((e.ep = t.indexEndValue_), t.endNameSet_ && (e.en = t.indexEndName_)),
      t.limitSet_)
    ) {
      e.l = t.limit_;
      let n = t.viewFrom_;
      "" === n && (n = t.isViewFromLeft() ? "l" : "r"), (e.vf = n);
    }
    return t.index_ !== Ci && (e.i = t.index_.toString()), e;
  }
  class tr extends Vn {
    constructor(t, e, n, i) {
      super(),
        (this.repoInfo_ = t),
        (this.onDataUpdate_ = e),
        (this.authTokenProvider_ = n),
        (this.appCheckTokenProvider_ = i),
        (this.log_ = sn("p:rest:")),
        (this.listens_ = {});
    }
    reportStats(t) {
      throw new Error("Method not implemented.");
    }
    static getListenId_(t, e) {
      return void 0 !== e
        ? "tag$" + e
        : (pt(
            t._queryParams.isDefault(),
            "should have a tag if it's not a default query."
          ),
          t._path.toString());
    }
    listen(t, e, n, i) {
      const r = t._path.toString();
      this.log_("Listen called for " + r + " " + t._queryIdentifier);
      const s = tr.getListenId_(t, n),
        o = {};
      this.listens_[s] = o;
      const a = $i(t._queryParams);
      this.restRequest_(r + ".json", a, (t, e) => {
        let a = e;
        if (
          (404 === t && ((a = null), (t = null)),
          null === t && this.onDataUpdate_(r, a, !1, n),
          Dt(this.listens_, s) === o)
        ) {
          let e;
          (e = t
            ? 401 === t
              ? "permission_denied"
              : "rest_error:" + t
            : "ok"),
            i(e, null);
        }
      });
    }
    unlisten(t, e) {
      const n = tr.getListenId_(t, e);
      delete this.listens_[n];
    }
    get(t) {
      const e = $i(t._queryParams),
        n = t._path.toString(),
        i = new Tt();
      return (
        this.restRequest_(n + ".json", e, (t, e) => {
          let r = e;
          404 === t && ((r = null), (t = null)),
            null === t
              ? (this.onDataUpdate_(n, r, !1, null), i.resolve(r))
              : i.reject(new Error(r));
        }),
        i.promise
      );
    }
    refreshAuthToken(t) {}
    restRequest_(t, e = {}, n) {
      return (
        (e.format = "export"),
        Promise.all([
          this.authTokenProvider_.getToken(!1),
          this.appCheckTokenProvider_.getToken(!1),
        ]).then(([i, r]) => {
          i && i.accessToken && (e.auth = i.accessToken),
            r && r.token && (e.ac = r.token);
          const s =
            (this.repoInfo_.secure ? "https://" : "http://") +
            this.repoInfo_.host +
            t +
            "?ns=" +
            this.repoInfo_.namespace +
            (function (t) {
              const e = [];
              for (const [n, i] of Object.entries(t))
                Array.isArray(i)
                  ? i.forEach((t) => {
                      e.push(
                        encodeURIComponent(n) + "=" + encodeURIComponent(t)
                      );
                    })
                  : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
              return e.length ? "&" + e.join("&") : "";
            })(e);
          this.log_("Sending REST request for " + s);
          const o = new XMLHttpRequest();
          (o.onreadystatechange = () => {
            if (n && 4 === o.readyState) {
              this.log_(
                "REST Response for " + s + " received. status:",
                o.status,
                "response:",
                o.responseText
              );
              let e = null;
              if (o.status >= 200 && o.status < 300) {
                try {
                  e = It(o.responseText);
                } catch (t) {
                  ln(
                    "Failed to parse JSON response for " +
                      s +
                      ": " +
                      o.responseText
                  );
                }
                n(null, e);
              } else
                401 !== o.status &&
                  404 !== o.status &&
                  ln(
                    "Got unsuccessful REST response for " +
                      s +
                      " Status: " +
                      o.status
                  ),
                  n(o.status);
              n = null;
            }
          }),
            o.open("GET", s, !0),
            o.send();
        })
      );
    }
  }
  class er {
    constructor() {
      this.rootNode_ = Ui.EMPTY_NODE;
    }
    getNode(t) {
      return this.rootNode_.getChild(t);
    }
    updateSnapshot(t, e) {
      this.rootNode_ = this.rootNode_.updateChild(t, e);
    }
  }
  function nr() {
    return { value: null, children: new Map() };
  }
  function ir(t, e, n) {
    if (ei(e)) (t.value = n), t.children.clear();
    else if (null !== t.value) t.value = t.value.updateChild(e, n);
    else {
      const i = qn(e);
      t.children.has(i) || t.children.set(i, nr());
      ir(t.children.get(i), (e = Zn(e)), n);
    }
  }
  function rr(t, e, n) {
    null !== t.value
      ? n(e, t.value)
      : (function (t, e) {
          t.children.forEach((t, n) => {
            e(n, t);
          });
        })(t, (t, i) => {
          rr(i, new jn(e.toString() + "/" + t), n);
        });
  }
  class sr {
    constructor(t) {
      (this.collection_ = t), (this.last_ = null);
    }
    get() {
      const t = this.collection_.get(),
        e = Object.assign({}, t);
      return (
        this.last_ &&
          gn(this.last_, (t, n) => {
            e[t] = e[t] - n;
          }),
        (this.last_ = t),
        e
      );
    }
  }
  class or {
    constructor(t, e) {
      (this.server_ = e),
        (this.statsToReport_ = {}),
        (this.statsListener_ = new sr(t));
      const n = 1e4 + 2e4 * Math.random();
      Tn(this.reportStats_.bind(this), Math.floor(n));
    }
    reportStats_() {
      const t = this.statsListener_.get(),
        e = {};
      let n = !1;
      gn(t, (t, i) => {
        i > 0 && Nt(this.statsToReport_, t) && ((e[t] = i), (n = !0));
      }),
        n && this.server_.reportStats(e),
        Tn(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5));
    }
  }
  var ar, lr;
  function hr(t) {
    return { fromUser: !1, fromServer: !0, queryId: t, tagged: !0 };
  }
  ((lr = ar || (ar = {}))[(lr.OVERWRITE = 0)] = "OVERWRITE"),
    (lr[(lr.MERGE = 1)] = "MERGE"),
    (lr[(lr.ACK_USER_WRITE = 2)] = "ACK_USER_WRITE"),
    (lr[(lr.LISTEN_COMPLETE = 3)] = "LISTEN_COMPLETE");
  class ur {
    constructor(t, e, n) {
      (this.path = t),
        (this.affectedTree = e),
        (this.revert = n),
        (this.type = ar.ACK_USER_WRITE),
        (this.source = {
          fromUser: !0,
          fromServer: !1,
          queryId: null,
          tagged: !1,
        });
    }
    operationForChild(t) {
      if (ei(this.path)) {
        if (null != this.affectedTree.value)
          return (
            pt(
              this.affectedTree.children.isEmpty(),
              "affectedTree should not have overlapping affected paths."
            ),
            this
          );
        {
          const e = this.affectedTree.subtree(new jn(t));
          return new ur(Yn(), e, this.revert);
        }
      }
      return (
        pt(
          qn(this.path) === t,
          "operationForChild called for unrelated child."
        ),
        new ur(Zn(this.path), this.affectedTree, this.revert)
      );
    }
  }
  class cr {
    constructor(t, e) {
      (this.source = t), (this.path = e), (this.type = ar.LISTEN_COMPLETE);
    }
    operationForChild(t) {
      return ei(this.path)
        ? new cr(this.source, Yn())
        : new cr(this.source, Zn(this.path));
    }
  }
  class dr {
    constructor(t, e, n) {
      (this.source = t),
        (this.path = e),
        (this.snap = n),
        (this.type = ar.OVERWRITE);
    }
    operationForChild(t) {
      return ei(this.path)
        ? new dr(this.source, Yn(), this.snap.getImmediateChild(t))
        : new dr(this.source, Zn(this.path), this.snap);
    }
  }
  class pr {
    constructor(t, e, n) {
      (this.source = t),
        (this.path = e),
        (this.children = n),
        (this.type = ar.MERGE);
    }
    operationForChild(t) {
      if (ei(this.path)) {
        const e = this.children.subtree(new jn(t));
        return e.isEmpty()
          ? null
          : e.value
          ? new dr(this.source, Yn(), e.value)
          : new pr(this.source, Yn(), e);
      }
      return (
        pt(
          qn(this.path) === t,
          "Can't get a merge for a child not on the path of the operation"
        ),
        new pr(this.source, Zn(this.path), this.children)
      );
    }
    toString() {
      return (
        "Operation(" +
        this.path +
        ": " +
        this.source.toString() +
        " merge: " +
        this.children.toString() +
        ")"
      );
    }
  }
  class fr {
    constructor(t, e, n) {
      (this.node_ = t), (this.fullyInitialized_ = e), (this.filtered_ = n);
    }
    isFullyInitialized() {
      return this.fullyInitialized_;
    }
    isFiltered() {
      return this.filtered_;
    }
    isCompleteForPath(t) {
      if (ei(t)) return this.isFullyInitialized() && !this.filtered_;
      const e = qn(t);
      return this.isCompleteForChild(e);
    }
    isCompleteForChild(t) {
      return (
        (this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(t)
      );
    }
    getNode() {
      return this.node_;
    }
  }
  class mr {
    constructor(t) {
      (this.query_ = t), (this.index_ = this.query_._queryParams.getIndex());
    }
  }
  function _r(t, e, n, i, r, s) {
    const o = i.filter((t) => t.type === n);
    o.sort((e, n) =>
      (function (t, e, n) {
        if (null == e.childName || null == n.childName)
          throw ft("Should only compare child_ events.");
        const i = new di(e.childName, e.snapshotNode),
          r = new di(n.childName, n.snapshotNode);
        return t.index_.compare(i, r);
      })(t, e, n)
    ),
      o.forEach((n) => {
        const i = (function (t, e, n) {
          return (
            "value" === e.type ||
              "child_removed" === e.type ||
              (e.prevName = n.getPredecessorChildName(
                e.childName,
                e.snapshotNode,
                t.index_
              )),
            e
          );
        })(t, n, s);
        r.forEach((r) => {
          r.respondsTo(n.type) && e.push(r.createEvent(i, t.query_));
        });
      });
  }
  function gr(t, e) {
    return { eventCache: t, serverCache: e };
  }
  function vr(t, e, n, i) {
    return gr(new fr(e, n, i), t.serverCache);
  }
  function yr(t, e, n, i) {
    return gr(t.eventCache, new fr(e, n, i));
  }
  function xr(t) {
    return t.eventCache.isFullyInitialized() ? t.eventCache.getNode() : null;
  }
  function br(t) {
    return t.serverCache.isFullyInitialized() ? t.serverCache.getNode() : null;
  }
  let Tr;
  class Er {
    constructor(t, e = (() => (Tr || (Tr = new yi(pn)), Tr))()) {
      (this.value = t), (this.children = e);
    }
    static fromObject(t) {
      let e = new Er(null);
      return (
        gn(t, (t, n) => {
          e = e.set(new jn(t), n);
        }),
        e
      );
    }
    isEmpty() {
      return null === this.value && this.children.isEmpty();
    }
    findRootMostMatchingPathAndValue(t, e) {
      if (null != this.value && e(this.value))
        return { path: Yn(), value: this.value };
      if (ei(t)) return null;
      {
        const n = qn(t),
          i = this.children.get(n);
        if (null !== i) {
          const r = i.findRootMostMatchingPathAndValue(Zn(t), e);
          if (null != r) {
            return { path: ti(new jn(n), r.path), value: r.value };
          }
          return null;
        }
        return null;
      }
    }
    findRootMostValueAndPath(t) {
      return this.findRootMostMatchingPathAndValue(t, () => !0);
    }
    subtree(t) {
      if (ei(t)) return this;
      {
        const e = qn(t),
          n = this.children.get(e);
        return null !== n ? n.subtree(Zn(t)) : new Er(null);
      }
    }
    set(t, e) {
      if (ei(t)) return new Er(e, this.children);
      {
        const n = qn(t),
          i = (this.children.get(n) || new Er(null)).set(Zn(t), e),
          r = this.children.insert(n, i);
        return new Er(this.value, r);
      }
    }
    remove(t) {
      if (ei(t))
        return this.children.isEmpty()
          ? new Er(null)
          : new Er(null, this.children);
      {
        const e = qn(t),
          n = this.children.get(e);
        if (n) {
          const i = n.remove(Zn(t));
          let r;
          return (
            (r = i.isEmpty()
              ? this.children.remove(e)
              : this.children.insert(e, i)),
            null === this.value && r.isEmpty()
              ? new Er(null)
              : new Er(this.value, r)
          );
        }
        return this;
      }
    }
    get(t) {
      if (ei(t)) return this.value;
      {
        const e = qn(t),
          n = this.children.get(e);
        return n ? n.get(Zn(t)) : null;
      }
    }
    setTree(t, e) {
      if (ei(t)) return e;
      {
        const n = qn(t),
          i = (this.children.get(n) || new Er(null)).setTree(Zn(t), e);
        let r;
        return (
          (r = i.isEmpty()
            ? this.children.remove(n)
            : this.children.insert(n, i)),
          new Er(this.value, r)
        );
      }
    }
    fold(t) {
      return this.fold_(Yn(), t);
    }
    fold_(t, e) {
      const n = {};
      return (
        this.children.inorderTraversal((i, r) => {
          n[i] = r.fold_(ti(t, i), e);
        }),
        e(t, this.value, n)
      );
    }
    findOnPath(t, e) {
      return this.findOnPath_(t, Yn(), e);
    }
    findOnPath_(t, e, n) {
      const i = !!this.value && n(e, this.value);
      if (i) return i;
      if (ei(t)) return null;
      {
        const i = qn(t),
          r = this.children.get(i);
        return r ? r.findOnPath_(Zn(t), ti(e, i), n) : null;
      }
    }
    foreachOnPath(t, e) {
      return this.foreachOnPath_(t, Yn(), e);
    }
    foreachOnPath_(t, e, n) {
      if (ei(t)) return this;
      {
        this.value && n(e, this.value);
        const i = qn(t),
          r = this.children.get(i);
        return r ? r.foreachOnPath_(Zn(t), ti(e, i), n) : new Er(null);
      }
    }
    foreach(t) {
      this.foreach_(Yn(), t);
    }
    foreach_(t, e) {
      this.children.inorderTraversal((n, i) => {
        i.foreach_(ti(t, n), e);
      }),
        this.value && e(t, this.value);
    }
    foreachChild(t) {
      this.children.inorderTraversal((e, n) => {
        n.value && t(e, n.value);
      });
    }
  }
  class Sr {
    constructor(t) {
      this.writeTree_ = t;
    }
    static empty() {
      return new Sr(new Er(null));
    }
  }
  function wr(t, e, n) {
    if (ei(e)) return new Sr(new Er(n));
    {
      const i = t.writeTree_.findRootMostValueAndPath(e);
      if (null != i) {
        const r = i.path;
        let s = i.value;
        const o = ni(r, e);
        return (s = s.updateChild(o, n)), new Sr(t.writeTree_.set(r, s));
      }
      {
        const i = new Er(n),
          r = t.writeTree_.setTree(e, i);
        return new Sr(r);
      }
    }
  }
  function Mr(t, e, n) {
    let i = t;
    return (
      gn(n, (t, n) => {
        i = wr(i, ti(e, t), n);
      }),
      i
    );
  }
  function Ar(t, e) {
    if (ei(e)) return Sr.empty();
    {
      const n = t.writeTree_.setTree(e, new Er(null));
      return new Sr(n);
    }
  }
  function Rr(t, e) {
    return null != Cr(t, e);
  }
  function Cr(t, e) {
    const n = t.writeTree_.findRootMostValueAndPath(e);
    return null != n ? t.writeTree_.get(n.path).getChild(ni(n.path, e)) : null;
  }
  function Ir(t) {
    const e = [],
      n = t.writeTree_.value;
    return (
      null != n
        ? n.isLeafNode() ||
          n.forEachChild(Ci, (t, n) => {
            e.push(new di(t, n));
          })
        : t.writeTree_.children.inorderTraversal((t, n) => {
            null != n.value && e.push(new di(t, n.value));
          }),
      e
    );
  }
  function Pr(t, e) {
    if (ei(e)) return t;
    {
      const n = Cr(t, e);
      return new Sr(null != n ? new Er(n) : t.writeTree_.subtree(e));
    }
  }
  function Or(t) {
    return t.writeTree_.isEmpty();
  }
  function Nr(t, e) {
    return Dr(Yn(), t.writeTree_, e);
  }
  function Dr(t, e, n) {
    if (null != e.value) return n.updateChild(t, e.value);
    {
      let i = null;
      return (
        e.children.inorderTraversal((e, r) => {
          ".priority" === e
            ? (pt(
                null !== r.value,
                "Priority writes must always be leaf nodes"
              ),
              (i = r.value))
            : (n = Dr(ti(t, e), r, n));
        }),
        n.getChild(t).isEmpty() ||
          null === i ||
          (n = n.updateChild(ti(t, ".priority"), i)),
        n
      );
    }
  }
  function Lr(t, e) {
    return qr(e, t);
  }
  function Fr(t, e) {
    const n = t.allWrites.findIndex((t) => t.writeId === e);
    pt(n >= 0, "removeWrite called with nonexistent writeId.");
    const i = t.allWrites[n];
    t.allWrites.splice(n, 1);
    let r = i.visible,
      s = !1,
      o = t.allWrites.length - 1;
    for (; r && o >= 0; ) {
      const e = t.allWrites[o];
      e.visible &&
        (o >= n && Ur(e, i.path) ? (r = !1) : si(i.path, e.path) && (s = !0)),
        o--;
    }
    if (r) {
      if (s)
        return (
          (function (t) {
            (t.visibleWrites = kr(t.allWrites, Br, Yn())),
              t.allWrites.length > 0
                ? (t.lastWriteId = t.allWrites[t.allWrites.length - 1].writeId)
                : (t.lastWriteId = -1);
          })(t),
          !0
        );
      if (i.snap) t.visibleWrites = Ar(t.visibleWrites, i.path);
      else {
        gn(i.children, (e) => {
          t.visibleWrites = Ar(t.visibleWrites, ti(i.path, e));
        });
      }
      return !0;
    }
    return !1;
  }
  function Ur(t, e) {
    if (t.snap) return si(t.path, e);
    for (const n in t.children)
      if (t.children.hasOwnProperty(n) && si(ti(t.path, n), e)) return !0;
    return !1;
  }
  function Br(t) {
    return t.visible;
  }
  function kr(t, e, n) {
    let i = Sr.empty();
    for (let r = 0; r < t.length; ++r) {
      const s = t[r];
      if (e(s)) {
        const t = s.path;
        let e;
        if (s.snap)
          si(n, t)
            ? ((e = ni(n, t)), (i = wr(i, e, s.snap)))
            : si(t, n) &&
              ((e = ni(t, n)), (i = wr(i, Yn(), s.snap.getChild(e))));
        else {
          if (!s.children)
            throw ft("WriteRecord should have .snap or .children");
          if (si(n, t)) (e = ni(n, t)), (i = Mr(i, e, s.children));
          else if (si(t, n))
            if (((e = ni(t, n)), ei(e))) i = Mr(i, Yn(), s.children);
            else {
              const t = Dt(s.children, qn(e));
              if (t) {
                const n = t.getChild(Zn(e));
                i = wr(i, Yn(), n);
              }
            }
        }
      }
    }
    return i;
  }
  function Gr(t, e, n, i, r) {
    if (i || r) {
      const s = Pr(t.visibleWrites, e);
      if (!r && Or(s)) return n;
      if (r || null != n || Rr(s, Yn())) {
        const s = function (t) {
          return (
            (t.visible || r) &&
            (!i || !~i.indexOf(t.writeId)) &&
            (si(t.path, e) || si(e, t.path))
          );
        };
        return Nr(kr(t.allWrites, s, e), n || Ui.EMPTY_NODE);
      }
      return null;
    }
    {
      const i = Cr(t.visibleWrites, e);
      if (null != i) return i;
      {
        const i = Pr(t.visibleWrites, e);
        if (Or(i)) return n;
        if (null != n || Rr(i, Yn())) {
          return Nr(i, n || Ui.EMPTY_NODE);
        }
        return null;
      }
    }
  }
  function Hr(t, e, n, i) {
    return Gr(t.writeTree, t.treePath, e, n, i);
  }
  function zr(t, e) {
    return (function (t, e, n) {
      let i = Ui.EMPTY_NODE;
      const r = Cr(t.visibleWrites, e);
      if (r)
        return (
          r.isLeafNode() ||
            r.forEachChild(Ci, (t, e) => {
              i = i.updateImmediateChild(t, e);
            }),
          i
        );
      if (n) {
        const r = Pr(t.visibleWrites, e);
        return (
          n.forEachChild(Ci, (t, e) => {
            const n = Nr(Pr(r, new jn(t)), e);
            i = i.updateImmediateChild(t, n);
          }),
          Ir(r).forEach((t) => {
            i = i.updateImmediateChild(t.name, t.node);
          }),
          i
        );
      }
      return (
        Ir(Pr(t.visibleWrites, e)).forEach((t) => {
          i = i.updateImmediateChild(t.name, t.node);
        }),
        i
      );
    })(t.writeTree, t.treePath, e);
  }
  function Vr(t, e, n, i) {
    return (function (t, e, n, i, r) {
      pt(i || r, "Either existingEventSnap or existingServerSnap must exist");
      const s = ti(e, n);
      if (Rr(t.visibleWrites, s)) return null;
      {
        const e = Pr(t.visibleWrites, s);
        return Or(e) ? r.getChild(n) : Nr(e, r.getChild(n));
      }
    })(t.writeTree, t.treePath, e, n, i);
  }
  function Xr(t, e) {
    return (function (t, e) {
      return Cr(t.visibleWrites, e);
    })(t.writeTree, ti(t.treePath, e));
  }
  function Wr(t, e, n, i, r, s) {
    return (function (t, e, n, i, r, s, o) {
      let a;
      const l = Pr(t.visibleWrites, e),
        h = Cr(l, Yn());
      if (null != h) a = h;
      else {
        if (null == n) return [];
        a = Nr(l, n);
      }
      if (((a = a.withIndex(o)), a.isEmpty() || a.isLeafNode())) return [];
      {
        const t = [],
          e = o.getCompare(),
          n = s ? a.getReverseIteratorFrom(i, o) : a.getIteratorFrom(i, o);
        let l = n.getNext();
        for (; l && t.length < r; )
          0 !== e(l, i) && t.push(l), (l = n.getNext());
        return t;
      }
    })(t.writeTree, t.treePath, e, n, i, r, s);
  }
  function jr(t, e, n) {
    return (function (t, e, n, i) {
      const r = ti(e, n),
        s = Cr(t.visibleWrites, r);
      if (null != s) return s;
      if (i.isCompleteForChild(n))
        return Nr(Pr(t.visibleWrites, r), i.getNode().getImmediateChild(n));
      return null;
    })(t.writeTree, t.treePath, e, n);
  }
  function Yr(t, e) {
    return qr(ti(t.treePath, e), t.writeTree);
  }
  function qr(t, e) {
    return { treePath: t, writeTree: e };
  }
  class Kr {
    constructor() {
      this.changeMap = new Map();
    }
    trackChildChange(t) {
      const e = t.type,
        n = t.childName;
      pt(
        "child_added" === e || "child_changed" === e || "child_removed" === e,
        "Only child changes supported for tracking"
      ),
        pt(
          ".priority" !== n,
          "Only non-priority child changes can be tracked."
        );
      const i = this.changeMap.get(n);
      if (i) {
        const r = i.type;
        if ("child_added" === e && "child_removed" === r)
          this.changeMap.set(n, Yi(n, t.snapshotNode, i.snapshotNode));
        else if ("child_removed" === e && "child_added" === r)
          this.changeMap.delete(n);
        else if ("child_removed" === e && "child_changed" === r)
          this.changeMap.set(n, ji(n, i.oldSnap));
        else if ("child_changed" === e && "child_added" === r)
          this.changeMap.set(n, Wi(n, t.snapshotNode));
        else {
          if ("child_changed" !== e || "child_changed" !== r)
            throw ft(
              "Illegal combination of changes: " + t + " occurred after " + i
            );
          this.changeMap.set(n, Yi(n, t.snapshotNode, i.oldSnap));
        }
      } else this.changeMap.set(n, t);
    }
    getChanges() {
      return Array.from(this.changeMap.values());
    }
  }
  const Zr = new (class {
    getCompleteChild(t) {
      return null;
    }
    getChildAfterChild(t, e, n) {
      return null;
    }
  })();
  class Jr {
    constructor(t, e, n = null) {
      (this.writes_ = t),
        (this.viewCache_ = e),
        (this.optCompleteServerCache_ = n);
    }
    getCompleteChild(t) {
      const e = this.viewCache_.eventCache;
      if (e.isCompleteForChild(t)) return e.getNode().getImmediateChild(t);
      {
        const e =
          null != this.optCompleteServerCache_
            ? new fr(this.optCompleteServerCache_, !0, !1)
            : this.viewCache_.serverCache;
        return jr(this.writes_, t, e);
      }
    }
    getChildAfterChild(t, e, n) {
      const i =
          null != this.optCompleteServerCache_
            ? this.optCompleteServerCache_
            : br(this.viewCache_),
        r = Wr(this.writes_, i, e, 1, n, t);
      return 0 === r.length ? null : r[0];
    }
  }
  function $r(t, e, n, i, r) {
    const s = new Kr();
    let o, a;
    if (n.type === ar.OVERWRITE) {
      const l = n;
      l.source.fromUser
        ? (o = es(t, e, l.path, l.snap, i, r, s))
        : (pt(l.source.fromServer, "Unknown source."),
          (a = l.source.tagged || (e.serverCache.isFiltered() && !ei(l.path))),
          (o = ts(t, e, l.path, l.snap, i, r, a, s)));
    } else if (n.type === ar.MERGE) {
      const l = n;
      l.source.fromUser
        ? (o = (function (t, e, n, i, r, s, o) {
            let a = e;
            return (
              i.foreach((i, l) => {
                const h = ti(n, i);
                ns(e, qn(h)) && (a = es(t, a, h, l, r, s, o));
              }),
              i.foreach((i, l) => {
                const h = ti(n, i);
                ns(e, qn(h)) || (a = es(t, a, h, l, r, s, o));
              }),
              a
            );
          })(t, e, l.path, l.children, i, r, s))
        : (pt(l.source.fromServer, "Unknown source."),
          (a = l.source.tagged || e.serverCache.isFiltered()),
          (o = rs(t, e, l.path, l.children, i, r, a, s)));
    } else if (n.type === ar.ACK_USER_WRITE) {
      const a = n;
      o = a.revert
        ? (function (t, e, n, i, r, s) {
            let o;
            if (null != Xr(i, n)) return e;
            {
              const a = new Jr(i, e, r),
                l = e.eventCache.getNode();
              let h;
              if (ei(n) || ".priority" === qn(n)) {
                let n;
                if (e.serverCache.isFullyInitialized()) n = Hr(i, br(e));
                else {
                  const t = e.serverCache.getNode();
                  pt(
                    t instanceof Ui,
                    "serverChildren would be complete if leaf node"
                  ),
                    (n = zr(i, t));
                }
                h = t.filter.updateFullNode(l, n, s);
              } else {
                const r = qn(n);
                let u = jr(i, r, e.serverCache);
                null == u &&
                  e.serverCache.isCompleteForChild(r) &&
                  (u = l.getImmediateChild(r)),
                  (h =
                    null != u
                      ? t.filter.updateChild(l, r, u, Zn(n), a, s)
                      : e.eventCache.getNode().hasChild(r)
                      ? t.filter.updateChild(l, r, Ui.EMPTY_NODE, Zn(n), a, s)
                      : l),
                  h.isEmpty() &&
                    e.serverCache.isFullyInitialized() &&
                    ((o = Hr(i, br(e))),
                    o.isLeafNode() && (h = t.filter.updateFullNode(h, o, s)));
              }
              return (
                (o = e.serverCache.isFullyInitialized() || null != Xr(i, Yn())),
                vr(e, h, o, t.filter.filtersNodes())
              );
            }
          })(t, e, a.path, i, r, s)
        : (function (t, e, n, i, r, s, o) {
            if (null != Xr(r, n)) return e;
            const a = e.serverCache.isFiltered(),
              l = e.serverCache;
            if (null != i.value) {
              if ((ei(n) && l.isFullyInitialized()) || l.isCompleteForPath(n))
                return ts(t, e, n, l.getNode().getChild(n), r, s, a, o);
              if (ei(n)) {
                let i = new Er(null);
                return (
                  l.getNode().forEachChild(_i, (t, e) => {
                    i = i.set(new jn(t), e);
                  }),
                  rs(t, e, n, i, r, s, a, o)
                );
              }
              return e;
            }
            {
              let h = new Er(null);
              return (
                i.foreach((t, e) => {
                  const i = ti(n, t);
                  l.isCompleteForPath(i) &&
                    (h = h.set(t, l.getNode().getChild(i)));
                }),
                rs(t, e, n, h, r, s, a, o)
              );
            }
          })(t, e, a.path, a.affectedTree, i, r, s);
    } else {
      if (n.type !== ar.LISTEN_COMPLETE)
        throw ft("Unknown operation type: " + n.type);
      o = (function (t, e, n, i, r) {
        const s = e.serverCache,
          o = yr(
            e,
            s.getNode(),
            s.isFullyInitialized() || ei(n),
            s.isFiltered()
          );
        return Qr(t, o, n, i, Zr, r);
      })(t, e, n.path, i, s);
    }
    const l = s.getChanges();
    return (
      (function (t, e, n) {
        const i = e.eventCache;
        if (i.isFullyInitialized()) {
          const r = i.getNode().isLeafNode() || i.getNode().isEmpty(),
            s = xr(t);
          (n.length > 0 ||
            !t.eventCache.isFullyInitialized() ||
            (r && !i.getNode().equals(s)) ||
            !i.getNode().getPriority().equals(s.getPriority())) &&
            n.push(Xi(xr(e)));
        }
      })(e, o, l),
      { viewCache: o, changes: l }
    );
  }
  function Qr(t, e, n, i, r, s) {
    const o = e.eventCache;
    if (null != Xr(i, n)) return e;
    {
      let a, l;
      if (ei(n))
        if (
          (pt(
            e.serverCache.isFullyInitialized(),
            "If change path is empty, we must have complete server data"
          ),
          e.serverCache.isFiltered())
        ) {
          const n = br(e),
            r = zr(i, n instanceof Ui ? n : Ui.EMPTY_NODE);
          a = t.filter.updateFullNode(e.eventCache.getNode(), r, s);
        } else {
          const n = Hr(i, br(e));
          a = t.filter.updateFullNode(e.eventCache.getNode(), n, s);
        }
      else {
        const h = qn(n);
        if (".priority" === h) {
          pt(
            1 === Kn(n),
            "Can't have a priority with additional path components"
          );
          const r = o.getNode();
          l = e.serverCache.getNode();
          const s = Vr(i, n, r, l);
          a = null != s ? t.filter.updatePriority(r, s) : o.getNode();
        } else {
          const u = Zn(n);
          let c;
          if (o.isCompleteForChild(h)) {
            l = e.serverCache.getNode();
            const t = Vr(i, n, o.getNode(), l);
            c =
              null != t
                ? o.getNode().getImmediateChild(h).updateChild(u, t)
                : o.getNode().getImmediateChild(h);
          } else c = jr(i, h, e.serverCache);
          a =
            null != c
              ? t.filter.updateChild(o.getNode(), h, c, u, r, s)
              : o.getNode();
        }
      }
      return vr(e, a, o.isFullyInitialized() || ei(n), t.filter.filtersNodes());
    }
  }
  function ts(t, e, n, i, r, s, o, a) {
    const l = e.serverCache;
    let h;
    const u = o ? t.filter : t.filter.getIndexedFilter();
    if (ei(n)) h = u.updateFullNode(l.getNode(), i, null);
    else if (u.filtersNodes() && !l.isFiltered()) {
      const t = l.getNode().updateChild(n, i);
      h = u.updateFullNode(l.getNode(), t, null);
    } else {
      const t = qn(n);
      if (!l.isCompleteForPath(n) && Kn(n) > 1) return e;
      const r = Zn(n),
        s = l.getNode().getImmediateChild(t).updateChild(r, i);
      h =
        ".priority" === t
          ? u.updatePriority(l.getNode(), s)
          : u.updateChild(l.getNode(), t, s, r, Zr, null);
    }
    const c = yr(e, h, l.isFullyInitialized() || ei(n), u.filtersNodes());
    return Qr(t, c, n, r, new Jr(r, c, s), a);
  }
  function es(t, e, n, i, r, s, o) {
    const a = e.eventCache;
    let l, h;
    const u = new Jr(r, e, s);
    if (ei(n))
      (h = t.filter.updateFullNode(e.eventCache.getNode(), i, o)),
        (l = vr(e, h, !0, t.filter.filtersNodes()));
    else {
      const r = qn(n);
      if (".priority" === r)
        (h = t.filter.updatePriority(e.eventCache.getNode(), i)),
          (l = vr(e, h, a.isFullyInitialized(), a.isFiltered()));
      else {
        const s = Zn(n),
          h = a.getNode().getImmediateChild(r);
        let c;
        if (ei(s)) c = i;
        else {
          const t = u.getCompleteChild(r);
          c =
            null != t
              ? ".priority" === Jn(s) && t.getChild(Qn(s)).isEmpty()
                ? t
                : t.updateChild(s, i)
              : Ui.EMPTY_NODE;
        }
        if (h.equals(c)) l = e;
        else {
          l = vr(
            e,
            t.filter.updateChild(a.getNode(), r, c, s, u, o),
            a.isFullyInitialized(),
            t.filter.filtersNodes()
          );
        }
      }
    }
    return l;
  }
  function ns(t, e) {
    return t.eventCache.isCompleteForChild(e);
  }
  function is(t, e, n) {
    return (
      n.foreach((t, n) => {
        e = e.updateChild(t, n);
      }),
      e
    );
  }
  function rs(t, e, n, i, r, s, o, a) {
    if (
      e.serverCache.getNode().isEmpty() &&
      !e.serverCache.isFullyInitialized()
    )
      return e;
    let l,
      h = e;
    l = ei(n) ? i : new Er(null).setTree(n, i);
    const u = e.serverCache.getNode();
    return (
      l.children.inorderTraversal((n, i) => {
        if (u.hasChild(n)) {
          const l = is(0, e.serverCache.getNode().getImmediateChild(n), i);
          h = ts(t, h, new jn(n), l, r, s, o, a);
        }
      }),
      l.children.inorderTraversal((n, i) => {
        const l = !e.serverCache.isCompleteForChild(n) && void 0 === i.value;
        if (!u.hasChild(n) && !l) {
          const l = is(0, e.serverCache.getNode().getImmediateChild(n), i);
          h = ts(t, h, new jn(n), l, r, s, o, a);
        }
      }),
      h
    );
  }
  class ss {
    constructor(t, e) {
      (this.query_ = t), (this.eventRegistrations_ = []);
      const n = this.query_._queryParams,
        i = new qi(n.getIndex()),
        r = (s = n).loadsAllData()
          ? new qi(s.getIndex())
          : s.hasLimit()
          ? new Zi(s)
          : new Ki(s);
      var s;
      this.processor_ = (function (t) {
        return { filter: t };
      })(r);
      const o = e.serverCache,
        a = e.eventCache,
        l = i.updateFullNode(Ui.EMPTY_NODE, o.getNode(), null),
        h = r.updateFullNode(Ui.EMPTY_NODE, a.getNode(), null),
        u = new fr(l, o.isFullyInitialized(), i.filtersNodes()),
        c = new fr(h, a.isFullyInitialized(), r.filtersNodes());
      (this.viewCache_ = gr(c, u)),
        (this.eventGenerator_ = new mr(this.query_));
    }
    get query() {
      return this.query_;
    }
  }
  function os(t, e) {
    const n = br(t.viewCache_);
    return n &&
      (t.query._queryParams.loadsAllData() ||
        (!ei(e) && !n.getImmediateChild(qn(e)).isEmpty()))
      ? n.getChild(e)
      : null;
  }
  function as(t) {
    return 0 === t.eventRegistrations_.length;
  }
  function ls(t, e, n) {
    const i = [];
    if (n) {
      pt(null == e, "A cancel should cancel all event registrations.");
      const r = t.query._path;
      t.eventRegistrations_.forEach((t) => {
        const e = t.createCancelEvent(n, r);
        e && i.push(e);
      });
    }
    if (e) {
      let n = [];
      for (let i = 0; i < t.eventRegistrations_.length; ++i) {
        const r = t.eventRegistrations_[i];
        if (r.matches(e)) {
          if (e.hasAnyCallback()) {
            n = n.concat(t.eventRegistrations_.slice(i + 1));
            break;
          }
        } else n.push(r);
      }
      t.eventRegistrations_ = n;
    } else t.eventRegistrations_ = [];
    return i;
  }
  function hs(t, e, n, i) {
    e.type === ar.MERGE &&
      null !== e.source.queryId &&
      (pt(
        br(t.viewCache_),
        "We should always have a full cache before handling merges"
      ),
      pt(
        xr(t.viewCache_),
        "Missing event cache, even though we have a server cache"
      ));
    const r = t.viewCache_,
      s = $r(t.processor_, r, e, n, i);
    var o, a;
    return (
      (o = t.processor_),
      (a = s.viewCache),
      pt(
        a.eventCache.getNode().isIndexed(o.filter.getIndex()),
        "Event snap not indexed"
      ),
      pt(
        a.serverCache.getNode().isIndexed(o.filter.getIndex()),
        "Server snap not indexed"
      ),
      pt(
        s.viewCache.serverCache.isFullyInitialized() ||
          !r.serverCache.isFullyInitialized(),
        "Once a server snap is complete, it should never go back"
      ),
      (t.viewCache_ = s.viewCache),
      us(t, s.changes, s.viewCache.eventCache.getNode(), null)
    );
  }
  function us(t, e, n, i) {
    const r = i ? [i] : t.eventRegistrations_;
    return (function (t, e, n, i) {
      const r = [],
        s = [];
      return (
        e.forEach((e) => {
          var n;
          "child_changed" === e.type &&
            t.index_.indexedValueChanged(e.oldSnap, e.snapshotNode) &&
            s.push(
              ((n = e.childName),
              {
                type: "child_moved",
                snapshotNode: e.snapshotNode,
                childName: n,
              })
            );
        }),
        _r(t, r, "child_removed", e, i, n),
        _r(t, r, "child_added", e, i, n),
        _r(t, r, "child_moved", s, i, n),
        _r(t, r, "child_changed", e, i, n),
        _r(t, r, "value", e, i, n),
        r
      );
    })(t.eventGenerator_, e, n, r);
  }
  let cs, ds;
  class ps {
    constructor() {
      this.views = new Map();
    }
  }
  function fs(t, e, n, i) {
    const r = e.source.queryId;
    if (null !== r) {
      const s = t.views.get(r);
      return (
        pt(null != s, "SyncTree gave us an op for an invalid query."),
        hs(s, e, n, i)
      );
    }
    {
      let r = [];
      for (const s of t.views.values()) r = r.concat(hs(s, e, n, i));
      return r;
    }
  }
  function ms(t, e, n, i, r, s) {
    const o = (function (t, e, n, i, r) {
      const s = e._queryIdentifier,
        o = t.views.get(s);
      if (!o) {
        let t = Hr(n, r ? i : null),
          s = !1;
        t
          ? (s = !0)
          : i instanceof Ui
          ? ((t = zr(n, i)), (s = !1))
          : ((t = Ui.EMPTY_NODE), (s = !1));
        const o = gr(new fr(t, s, !1), new fr(i, r, !1));
        return new ss(e, o);
      }
      return o;
    })(t, e, i, r, s);
    return (
      t.views.has(e._queryIdentifier) || t.views.set(e._queryIdentifier, o),
      (function (t, e) {
        t.eventRegistrations_.push(e);
      })(o, n),
      (function (t, e) {
        const n = t.viewCache_.eventCache,
          i = [];
        n.getNode().isLeafNode() ||
          n.getNode().forEachChild(Ci, (t, e) => {
            i.push(Wi(t, e));
          });
        return (
          n.isFullyInitialized() && i.push(Xi(n.getNode())),
          us(t, i, n.getNode(), e)
        );
      })(o, n)
    );
  }
  function _s(t, e, n, i) {
    const r = e._queryIdentifier,
      s = [];
    let o = [];
    const a = bs(t);
    if ("default" === r)
      for (const [l, h] of t.views.entries())
        (o = o.concat(ls(h, n, i))),
          as(h) &&
            (t.views.delete(l),
            h.query._queryParams.loadsAllData() || s.push(h.query));
    else {
      const e = t.views.get(r);
      e &&
        ((o = o.concat(ls(e, n, i))),
        as(e) &&
          (t.views.delete(r),
          e.query._queryParams.loadsAllData() || s.push(e.query)));
    }
    return (
      a &&
        !bs(t) &&
        s.push(
          new (pt(cs, "Reference.ts has not been loaded"), cs)(e._repo, e._path)
        ),
      { removed: s, events: o }
    );
  }
  function gs(t) {
    const e = [];
    for (const n of t.views.values())
      n.query._queryParams.loadsAllData() || e.push(n);
    return e;
  }
  function vs(t, e) {
    let n = null;
    for (const i of t.views.values()) n = n || os(i, e);
    return n;
  }
  function ys(t, e) {
    if (e._queryParams.loadsAllData()) return Ts(t);
    {
      const n = e._queryIdentifier;
      return t.views.get(n);
    }
  }
  function xs(t, e) {
    return null != ys(t, e);
  }
  function bs(t) {
    return null != Ts(t);
  }
  function Ts(t) {
    for (const e of t.views.values())
      if (e.query._queryParams.loadsAllData()) return e;
    return null;
  }
  let Es = 1;
  class Ss {
    constructor(t) {
      (this.listenProvider_ = t),
        (this.syncPointTree_ = new Er(null)),
        (this.pendingWriteTree_ = {
          visibleWrites: Sr.empty(),
          allWrites: [],
          lastWriteId: -1,
        }),
        (this.tagToQueryMap = new Map()),
        (this.queryToTagMap = new Map());
    }
  }
  function ws(t, e, n, i, r) {
    return (
      (function (t, e, n, i, r) {
        pt(i > t.lastWriteId, "Stacking an older write on top of newer ones"),
          void 0 === r && (r = !0),
          t.allWrites.push({ path: e, snap: n, writeId: i, visible: r }),
          r && (t.visibleWrites = wr(t.visibleWrites, e, n)),
          (t.lastWriteId = i);
      })(t.pendingWriteTree_, e, n, i, r),
      r
        ? Ns(
            t,
            new dr(
              { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 },
              e,
              n
            )
          )
        : []
    );
  }
  function Ms(t, e, n, i) {
    !(function (t, e, n, i) {
      pt(i > t.lastWriteId, "Stacking an older merge on top of newer ones"),
        t.allWrites.push({ path: e, children: n, writeId: i, visible: !0 }),
        (t.visibleWrites = Mr(t.visibleWrites, e, n)),
        (t.lastWriteId = i);
    })(t.pendingWriteTree_, e, n, i);
    const r = Er.fromObject(n);
    return Ns(
      t,
      new pr({ fromUser: !0, fromServer: !1, queryId: null, tagged: !1 }, e, r)
    );
  }
  function As(t, e, n = !1) {
    const i = (function (t, e) {
      for (let n = 0; n < t.allWrites.length; n++) {
        const i = t.allWrites[n];
        if (i.writeId === e) return i;
      }
      return null;
    })(t.pendingWriteTree_, e);
    if (Fr(t.pendingWriteTree_, e)) {
      let e = new Er(null);
      return (
        null != i.snap
          ? (e = e.set(Yn(), !0))
          : gn(i.children, (t) => {
              e = e.set(new jn(t), !0);
            }),
        Ns(t, new ur(i.path, e, n))
      );
    }
    return [];
  }
  function Rs(t, e, n) {
    return Ns(
      t,
      new dr({ fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }, e, n)
    );
  }
  function Cs(t, e, n, i) {
    const r = e._path,
      s = t.syncPointTree_.get(r);
    let o = [];
    if (s && ("default" === e._queryIdentifier || xs(s, e))) {
      const a = _s(s, e, n, i);
      0 === s.views.size && (t.syncPointTree_ = t.syncPointTree_.remove(r));
      const l = a.removed;
      o = a.events;
      const h = -1 !== l.findIndex((t) => t._queryParams.loadsAllData()),
        u = t.syncPointTree_.findOnPath(r, (t, e) => bs(e));
      if (h && !u) {
        const e = t.syncPointTree_.subtree(r);
        if (!e.isEmpty()) {
          const n = (function (t) {
            return t.fold((t, e, n) => {
              if (e && bs(e)) {
                return [Ts(e)];
              }
              {
                let t = [];
                return (
                  e && (t = gs(e)),
                  gn(n, (e, n) => {
                    t = t.concat(n);
                  }),
                  t
                );
              }
            });
          })(e);
          for (let e = 0; e < n.length; ++e) {
            const i = n[e],
              r = i.query,
              s = Fs(t, i);
            t.listenProvider_.startListening(
              zs(r),
              Us(t, r),
              s.hashFn,
              s.onComplete
            );
          }
        }
      }
      if (!u && l.length > 0 && !i)
        if (h) {
          const n = null;
          t.listenProvider_.stopListening(zs(e), n);
        } else
          l.forEach((e) => {
            const n = t.queryToTagMap.get(Bs(e));
            t.listenProvider_.stopListening(zs(e), n);
          });
      !(function (t, e) {
        for (let n = 0; n < e.length; ++n) {
          const i = e[n];
          if (!i._queryParams.loadsAllData()) {
            const e = Bs(i),
              n = t.queryToTagMap.get(e);
            t.queryToTagMap.delete(e), t.tagToQueryMap.delete(n);
          }
        }
      })(t, l);
    }
    return o;
  }
  function Is(t, e) {
    const n = t._path;
    let i = null,
      r = !1;
    e.syncPointTree_.foreachOnPath(n, (t, e) => {
      const s = ni(t, n);
      (i = i || vs(e, s)), (r = r || bs(e));
    });
    let s,
      o = e.syncPointTree_.get(n);
    if (
      (o
        ? ((r = r || bs(o)), (i = i || vs(o, Yn())))
        : ((o = new ps()), (e.syncPointTree_ = e.syncPointTree_.set(n, o))),
      null != i)
    )
      s = !0;
    else {
      (s = !1), (i = Ui.EMPTY_NODE);
      e.syncPointTree_.subtree(n).foreachChild((t, e) => {
        const n = vs(e, Yn());
        n && (i = i.updateImmediateChild(t, n));
      });
    }
    const a = xs(o, t);
    if (!a && !t._queryParams.loadsAllData()) {
      const n = Bs(t);
      pt(!e.queryToTagMap.has(n), "View does not exist, but we have a tag");
      const i = Es++;
      e.queryToTagMap.set(n, i), e.tagToQueryMap.set(i, n);
    }
    return {
      syncPoint: o,
      writesCache: Lr(e.pendingWriteTree_, n),
      serverCache: i,
      serverCacheComplete: s,
      foundAncestorDefaultView: r,
      viewAlreadyExists: a,
    };
  }
  function Ps(t, e, n) {
    const {
      syncPoint: i,
      serverCache: r,
      writesCache: s,
      serverCacheComplete: o,
      viewAlreadyExists: a,
      foundAncestorDefaultView: l,
    } = Is(e, t);
    let h = ms(i, e, n, s, r, o);
    if (!a && !l) {
      const n = ys(i, e);
      h = h.concat(
        (function (t, e, n) {
          const i = e._path,
            r = Us(t, e),
            s = Fs(t, n),
            o = t.listenProvider_.startListening(
              zs(e),
              r,
              s.hashFn,
              s.onComplete
            ),
            a = t.syncPointTree_.subtree(i);
          if (r)
            pt(
              !bs(a.value),
              "If we're adding a query, it shouldn't be shadowed"
            );
          else {
            const e = a.fold((t, e, n) => {
              if (!ei(t) && e && bs(e)) return [Ts(e).query];
              {
                let t = [];
                return (
                  e && (t = t.concat(gs(e).map((t) => t.query))),
                  gn(n, (e, n) => {
                    t = t.concat(n);
                  }),
                  t
                );
              }
            });
            for (let n = 0; n < e.length; ++n) {
              const i = e[n];
              t.listenProvider_.stopListening(zs(i), Us(t, i));
            }
          }
          return o;
        })(t, e, n)
      );
    }
    return h;
  }
  function Os(t, e, n) {
    const i = t.pendingWriteTree_,
      r = t.syncPointTree_.findOnPath(e, (t, n) => {
        const i = vs(n, ni(t, e));
        if (i) return i;
      });
    return Gr(i, e, r, n, !0);
  }
  function Ns(t, e) {
    return Ds(e, t.syncPointTree_, null, Lr(t.pendingWriteTree_, Yn()));
  }
  function Ds(t, e, n, i) {
    if (ei(t.path)) return Ls(t, e, n, i);
    {
      const r = e.get(Yn());
      null == n && null != r && (n = vs(r, Yn()));
      let s = [];
      const o = qn(t.path),
        a = t.operationForChild(o),
        l = e.children.get(o);
      if (l && a) {
        const t = n ? n.getImmediateChild(o) : null,
          e = Yr(i, o);
        s = s.concat(Ds(a, l, t, e));
      }
      return r && (s = s.concat(fs(r, t, i, n))), s;
    }
  }
  function Ls(t, e, n, i) {
    const r = e.get(Yn());
    null == n && null != r && (n = vs(r, Yn()));
    let s = [];
    return (
      e.children.inorderTraversal((e, r) => {
        const o = n ? n.getImmediateChild(e) : null,
          a = Yr(i, e),
          l = t.operationForChild(e);
        l && (s = s.concat(Ls(l, r, o, a)));
      }),
      r && (s = s.concat(fs(r, t, i, n))),
      s
    );
  }
  function Fs(t, e) {
    const n = e.query,
      i = Us(t, n);
    return {
      hashFn: () => {
        const t =
          (function (t) {
            return t.viewCache_.serverCache.getNode();
          })(e) || Ui.EMPTY_NODE;
        return t.hash();
      },
      onComplete: (e) => {
        if ("ok" === e)
          return i
            ? (function (t, e, n) {
                const i = ks(t, n);
                if (i) {
                  const n = Gs(i),
                    r = n.path,
                    s = n.queryId,
                    o = ni(r, e);
                  return Hs(t, r, new cr(hr(s), o));
                }
                return [];
              })(t, n._path, i)
            : (function (t, e) {
                return Ns(
                  t,
                  new cr(
                    { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 },
                    e
                  )
                );
              })(t, n._path);
        {
          const i = (function (t, e) {
            let n = "Unknown Error";
            "too_big" === t
              ? (n =
                  "The data requested exceeds the maximum size that can be accessed with a single request.")
              : "permission_denied" === t
              ? (n =
                  "Client doesn't have permission to access the desired data.")
              : "unavailable" === t && (n = "The service is unavailable");
            const i = new Error(t + " at " + e._path.toString() + ": " + n);
            return (i.code = t.toUpperCase()), i;
          })(e, n);
          return Cs(t, n, null, i);
        }
      },
    };
  }
  function Us(t, e) {
    const n = Bs(e);
    return t.queryToTagMap.get(n);
  }
  function Bs(t) {
    return t._path.toString() + "$" + t._queryIdentifier;
  }
  function ks(t, e) {
    return t.tagToQueryMap.get(e);
  }
  function Gs(t) {
    const e = t.indexOf("$");
    return (
      pt(-1 !== e && e < t.length - 1, "Bad queryKey."),
      { queryId: t.substr(e + 1), path: new jn(t.substr(0, e)) }
    );
  }
  function Hs(t, e, n) {
    const i = t.syncPointTree_.get(e);
    pt(i, "Missing sync point for query tag that we're tracking");
    return fs(i, n, Lr(t.pendingWriteTree_, e), null);
  }
  function zs(t) {
    return t._queryParams.loadsAllData() && !t._queryParams.isDefault()
      ? new (pt(ds, "Reference.ts has not been loaded"), ds)(t._repo, t._path)
      : t;
  }
  class Vs {
    constructor(t) {
      this.node_ = t;
    }
    getImmediateChild(t) {
      const e = this.node_.getImmediateChild(t);
      return new Vs(e);
    }
    node() {
      return this.node_;
    }
  }
  class Xs {
    constructor(t, e) {
      (this.syncTree_ = t), (this.path_ = e);
    }
    getImmediateChild(t) {
      const e = ti(this.path_, t);
      return new Xs(this.syncTree_, e);
    }
    node() {
      return Os(this.syncTree_, this.path_);
    }
  }
  const Ws = function (t, e, n) {
      return t && "object" == typeof t
        ? (pt(".sv" in t, "Unexpected leaf node or priority contents"),
          "string" == typeof t[".sv"]
            ? js(t[".sv"], e, n)
            : "object" == typeof t[".sv"]
            ? Ys(t[".sv"], e)
            : void pt(
                !1,
                "Unexpected server value: " + JSON.stringify(t, null, 2)
              ))
        : t;
    },
    js = function (t, e, n) {
      if ("timestamp" === t) return n.timestamp;
      pt(!1, "Unexpected server value: " + t);
    },
    Ys = function (t, e, n) {
      t.hasOwnProperty("increment") ||
        pt(!1, "Unexpected server value: " + JSON.stringify(t, null, 2));
      const i = t.increment;
      "number" != typeof i && pt(!1, "Unexpected increment value: " + i);
      const r = e.node();
      if (
        (pt(null != r, "Expected ChildrenNode.EMPTY_NODE for nulls"),
        !r.isLeafNode())
      )
        return i;
      const s = r.getValue();
      return "number" != typeof s ? i : s + i;
    },
    qs = function (t, e, n, i) {
      return Zs(e, new Xs(n, t), i);
    },
    Ks = function (t, e, n) {
      return Zs(t, new Vs(e), n);
    };
  function Zs(t, e, n) {
    const i = t.getPriority().val(),
      r = Ws(i, e.getImmediateChild(".priority"), n);
    let s;
    if (t.isLeafNode()) {
      const i = t,
        s = Ws(i.getValue(), e, n);
      return s !== i.getValue() || r !== i.getPriority().val()
        ? new Ri(s, ki(r))
        : t;
    }
    {
      const i = t;
      return (
        (s = i),
        r !== i.getPriority().val() && (s = s.updatePriority(new Ri(r))),
        i.forEachChild(Ci, (t, i) => {
          const r = Zs(i, e.getImmediateChild(t), n);
          r !== i && (s = s.updateImmediateChild(t, r));
        }),
        s
      );
    }
  }
  class Js {
    constructor(t = "", e = null, n = { children: {}, childCount: 0 }) {
      (this.name = t), (this.parent = e), (this.node = n);
    }
  }
  function $s(t, e) {
    let n = e instanceof jn ? e : new jn(e),
      i = t,
      r = qn(n);
    for (; null !== r; ) {
      const t = Dt(i.node.children, r) || { children: {}, childCount: 0 };
      (i = new Js(r, i, t)), (n = Zn(n)), (r = qn(n));
    }
    return i;
  }
  function Qs(t) {
    return t.node.value;
  }
  function to(t, e) {
    (t.node.value = e), so(t);
  }
  function eo(t) {
    return t.node.childCount > 0;
  }
  function no(t, e) {
    gn(t.node.children, (n, i) => {
      e(new Js(n, t, i));
    });
  }
  function io(t, e, n, i) {
    n && !i && e(t),
      no(t, (t) => {
        io(t, e, !0, i);
      }),
      n && i && e(t);
  }
  function ro(t) {
    return new jn(null === t.parent ? t.name : ro(t.parent) + "/" + t.name);
  }
  function so(t) {
    null !== t.parent &&
      (function (t, e, n) {
        const i = (function (t) {
            return void 0 === Qs(t) && !eo(t);
          })(n),
          r = Nt(t.node.children, e);
        i && r
          ? (delete t.node.children[e], t.node.childCount--, so(t))
          : i ||
            r ||
            ((t.node.children[e] = n.node), t.node.childCount++, so(t));
      })(t.parent, t.name, t);
  }
  const oo = /[\[\].#$\/\u0000-\u001F\u007F]/,
    ao = /[\[\].#$\u0000-\u001F\u007F]/,
    lo = 10485760,
    ho = function (t) {
      return "string" == typeof t && 0 !== t.length && !oo.test(t);
    },
    uo = function (t) {
      return "string" == typeof t && 0 !== t.length && !ao.test(t);
    },
    co = function (t, e, n, i) {
      (i && void 0 === e) || po(Gt(t, "value"), e, n);
    },
    po = function (t, e, n) {
      const i = n instanceof jn ? new oi(n, t) : n;
      if (void 0 === e) throw new Error(t + "contains undefined " + li(i));
      if ("function" == typeof e)
        throw new Error(
          t +
            "contains a function " +
            li(i) +
            " with contents = " +
            e.toString()
        );
      if (hn(e)) throw new Error(t + "contains " + e.toString() + " " + li(i));
      if ("string" == typeof e && e.length > lo / 3 && Ht(e) > lo)
        throw new Error(
          t +
            "contains a string greater than " +
            "10485760 utf8 bytes " +
            li(i) +
            " ('" +
            e.substring(0, 50) +
            "...')"
        );
      if (e && "object" == typeof e) {
        let n = !1,
          r = !1;
        if (
          (gn(e, (e, s) => {
            if (".value" === e) n = !0;
            else if (".priority" !== e && ".sv" !== e && ((r = !0), !ho(e)))
              throw new Error(
                t +
                  " contains an invalid key (" +
                  e +
                  ") " +
                  li(i) +
                  '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
              );
            var o, a;
            (a = e),
              (o = i).parts_.length > 0 && (o.byteLength_ += 1),
              o.parts_.push(a),
              (o.byteLength_ += Ht(a)),
              ai(o),
              po(t, s, i),
              (function (t) {
                const e = t.parts_.pop();
                (t.byteLength_ -= Ht(e)),
                  t.parts_.length > 0 && (t.byteLength_ -= 1);
              })(i);
          }),
          n && r)
        )
          throw new Error(
            t +
              ' contains ".value" child ' +
              li(i) +
              " in addition to actual children."
          );
      }
    },
    fo = function (t, e, n, i) {
      if (i && void 0 === e) return;
      const r = Gt(t, "values");
      if (!e || "object" != typeof e || Array.isArray(e))
        throw new Error(
          r + " must be an object containing the children to replace."
        );
      const s = [];
      gn(e, (t, e) => {
        const i = new jn(t);
        if (
          (po(r, e, ti(n, i)),
          ".priority" === Jn(i) &&
            !(
              null === (o = e) ||
              "string" == typeof o ||
              ("number" == typeof o && !hn(o)) ||
              (o && "object" == typeof o && Nt(o, ".sv"))
            ))
        )
          throw new Error(
            r +
              "contains an invalid value for '" +
              i.toString() +
              "', which must be a valid Firebase priority (a string, finite number, server value, or null)."
          );
        var o;
        s.push(i);
      }),
        (function (t, e) {
          let n, i;
          for (n = 0; n < e.length; n++) {
            i = e[n];
            const r = $n(i);
            for (let e = 0; e < r.length; e++)
              if (".priority" === r[e] && e === r.length - 1);
              else if (!ho(r[e]))
                throw new Error(
                  t +
                    "contains an invalid key (" +
                    r[e] +
                    ") in path " +
                    i.toString() +
                    '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
                );
          }
          e.sort(ii);
          let r = null;
          for (n = 0; n < e.length; n++) {
            if (((i = e[n]), null !== r && si(r, i)))
              throw new Error(
                t +
                  "contains a path " +
                  r.toString() +
                  " that is ancestor of another path " +
                  i.toString()
              );
            r = i;
          }
        })(r, s);
    },
    mo = function (t, e, n, i) {
      if (!((i && void 0 === n) || uo(n)))
        throw new Error(
          Gt(t, e) +
            'was an invalid path = "' +
            n +
            '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"'
        );
    },
    _o = function (t, e) {
      if (".info" === qn(e))
        throw new Error(t + " failed = Can't modify data under /.info/");
    },
    go = function (t, e) {
      const n = e.path.toString();
      if (
        "string" != typeof e.repoInfo.host ||
        0 === e.repoInfo.host.length ||
        (!ho(e.repoInfo.namespace) &&
          "localhost" !== e.repoInfo.host.split(":")[0]) ||
        (0 !== n.length &&
          !(function (t) {
            return t && (t = t.replace(/^\/*\.info(\/|$)/, "/")), uo(t);
          })(n))
      )
        throw new Error(
          Gt(t, "url") +
            'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".'
        );
    };
  class vo {
    constructor() {
      (this.eventLists_ = []), (this.recursionDepth_ = 0);
    }
  }
  function yo(t, e) {
    let n = null;
    for (let i = 0; i < e.length; i++) {
      const r = e[i],
        s = r.getPath();
      null === n || ri(s, n.path) || (t.eventLists_.push(n), (n = null)),
        null === n && (n = { events: [], path: s }),
        n.events.push(r);
    }
    n && t.eventLists_.push(n);
  }
  function xo(t, e, n) {
    yo(t, n), To(t, (t) => ri(t, e));
  }
  function bo(t, e, n) {
    yo(t, n), To(t, (t) => si(t, e) || si(e, t));
  }
  function To(t, e) {
    t.recursionDepth_++;
    let n = !0;
    for (let i = 0; i < t.eventLists_.length; i++) {
      const r = t.eventLists_[i];
      if (r) {
        e(r.path)
          ? (Eo(t.eventLists_[i]), (t.eventLists_[i] = null))
          : (n = !1);
      }
    }
    n && (t.eventLists_ = []), t.recursionDepth_--;
  }
  function Eo(t) {
    for (let e = 0; e < t.events.length; e++) {
      const n = t.events[e];
      if (null !== n) {
        t.events[e] = null;
        const i = n.getEventRunner();
        en && rn("event: " + n.toString()), bn(i);
      }
    }
  }
  class So {
    constructor(t, e, n, i) {
      (this.repoInfo_ = t),
        (this.forceRestClient_ = e),
        (this.authTokenProvider_ = n),
        (this.appCheckProvider_ = i),
        (this.dataUpdateCount = 0),
        (this.statsListener_ = null),
        (this.eventQueue_ = new vo()),
        (this.nextWriteId_ = 1),
        (this.interceptServerDataCallback_ = null),
        (this.onDisconnect_ = nr()),
        (this.transactionQueueTree_ = new Js()),
        (this.persistentConnection_ = null),
        (this.key = this.repoInfo_.toURLString());
    }
    toString() {
      return (
        (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host
      );
    }
  }
  function wo(t, e, n) {
    if (
      ((t.stats_ = Dn(t.repoInfo_)),
      t.forceRestClient_ ||
        (
          ("object" == typeof window &&
            window.navigator &&
            window.navigator.userAgent) ||
          ""
        ).search(
          /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
        ) >= 0)
    )
      (t.server_ = new tr(
        t.repoInfo_,
        (e, n, i, r) => {
          Ro(t, e, n, i, r);
        },
        t.authTokenProvider_,
        t.appCheckProvider_
      )),
        setTimeout(() => Co(t, !0), 0);
    else {
      if (null != n) {
        if ("object" != typeof n)
          throw new Error(
            "Only objects are supported for option databaseAuthVariableOverride"
          );
        try {
          Pt(n);
        } catch (i) {
          throw new Error("Invalid authOverride provided: " + i);
        }
      }
      (t.persistentConnection_ = new ci(
        t.repoInfo_,
        e,
        (e, n, i, r) => {
          Ro(t, e, n, i, r);
        },
        (e) => {
          Co(t, e);
        },
        (e) => {
          !(function (t, e) {
            gn(e, (e, n) => {
              Io(t, e, n);
            });
          })(t, e);
        },
        t.authTokenProvider_,
        t.appCheckProvider_,
        n
      )),
        (t.server_ = t.persistentConnection_);
    }
    t.authTokenProvider_.addTokenChangeListener((e) => {
      t.server_.refreshAuthToken(e);
    }),
      t.appCheckProvider_.addTokenChangeListener((e) => {
        t.server_.refreshAppCheckToken(e.token);
      }),
      (t.statsReporter_ = (function (t, e) {
        const n = t.toString();
        return Nn[n] || (Nn[n] = e()), Nn[n];
      })(t.repoInfo_, () => new or(t.stats_, t.server_))),
      (t.infoData_ = new er()),
      (t.infoSyncTree_ = new Ss({
        startListening: (e, n, i, r) => {
          let s = [];
          const o = t.infoData_.getNode(e._path);
          return (
            o.isEmpty() ||
              ((s = Rs(t.infoSyncTree_, e._path, o)),
              setTimeout(() => {
                r("ok");
              }, 0)),
            s
          );
        },
        stopListening: () => {},
      })),
      Io(t, "connected", !1),
      (t.serverSyncTree_ = new Ss({
        startListening: (e, n, i, r) => (
          t.server_.listen(e, i, n, (n, i) => {
            const s = r(n, i);
            bo(t.eventQueue_, e._path, s);
          }),
          []
        ),
        stopListening: (e, n) => {
          t.server_.unlisten(e, n);
        },
      }));
  }
  function Mo(t) {
    const e = t.infoData_.getNode(new jn(".info/serverTimeOffset")).val() || 0;
    return new Date().getTime() + e;
  }
  function Ao(t) {
    return (
      ((e = (e = { timestamp: Mo(t) }) || {}).timestamp =
        e.timestamp || new Date().getTime()),
      e
    );
    var e;
  }
  function Ro(t, e, n, i, r) {
    t.dataUpdateCount++;
    const s = new jn(e);
    n = t.interceptServerDataCallback_
      ? t.interceptServerDataCallback_(e, n)
      : n;
    let o = [];
    if (r)
      if (i) {
        const e = Ft(n, (t) => ki(t));
        o = (function (t, e, n, i) {
          const r = ks(t, i);
          if (r) {
            const i = Gs(r),
              s = i.path,
              o = i.queryId,
              a = ni(s, e),
              l = Er.fromObject(n);
            return Hs(t, s, new pr(hr(o), a, l));
          }
          return [];
        })(t.serverSyncTree_, s, e, r);
      } else {
        const e = ki(n);
        o = (function (t, e, n, i) {
          const r = ks(t, i);
          if (null != r) {
            const i = Gs(r),
              s = i.path,
              o = i.queryId,
              a = ni(s, e);
            return Hs(t, s, new dr(hr(o), a, n));
          }
          return [];
        })(t.serverSyncTree_, s, e, r);
      }
    else if (i) {
      const e = Ft(n, (t) => ki(t));
      o = (function (t, e, n) {
        const i = Er.fromObject(n);
        return Ns(
          t,
          new pr(
            { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 },
            e,
            i
          )
        );
      })(t.serverSyncTree_, s, e);
    } else {
      const e = ki(n);
      o = Rs(t.serverSyncTree_, s, e);
    }
    let a = s;
    o.length > 0 && (a = Uo(t, s)), bo(t.eventQueue_, a, o);
  }
  function Co(t, e) {
    Io(t, "connected", e),
      !1 === e &&
        (function (t) {
          No(t, "onDisconnectEvents");
          const e = Ao(t),
            n = nr();
          rr(t.onDisconnect_, Yn(), (i, r) => {
            const s = qs(i, r, t.serverSyncTree_, e);
            ir(n, i, s);
          });
          let i = [];
          rr(n, Yn(), (e, n) => {
            i = i.concat(Rs(t.serverSyncTree_, e, n));
            const r = zo(t, e);
            Uo(t, r);
          }),
            (t.onDisconnect_ = nr()),
            bo(t.eventQueue_, Yn(), i);
        })(t);
  }
  function Io(t, e, n) {
    const i = new jn("/.info/" + e),
      r = ki(n);
    t.infoData_.updateSnapshot(i, r);
    const s = Rs(t.infoSyncTree_, i, r);
    bo(t.eventQueue_, i, s);
  }
  function Po(t) {
    return t.nextWriteId_++;
  }
  function Oo(t, e, n) {
    let i;
    (i =
      ".info" === qn(e._path)
        ? Cs(t.infoSyncTree_, e, n)
        : Cs(t.serverSyncTree_, e, n)),
      xo(t.eventQueue_, e._path, i);
  }
  function No(t, ...e) {
    let n = "";
    t.persistentConnection_ && (n = t.persistentConnection_.id + ":"),
      rn(n, ...e);
  }
  function Do(t, e, n, i) {
    e &&
      bn(() => {
        if ("ok" === n) e(null);
        else {
          const t = (n || "error").toUpperCase();
          let r = t;
          i && (r += ": " + i);
          const s = new Error(r);
          (s.code = t), e(s);
        }
      });
  }
  function Lo(t, e, n) {
    return Os(t.serverSyncTree_, e, n) || Ui.EMPTY_NODE;
  }
  function Fo(t, e = t.transactionQueueTree_) {
    if ((e || Ho(t, e), Qs(e))) {
      const n = ko(t, e);
      pt(n.length > 0, "Sending zero length transaction queue");
      n.every((t) => 0 === t.status) &&
        (function (t, e, n) {
          const i = n.map((t) => t.currentWriteId),
            r = Lo(t, e, i);
          let s = r;
          const o = r.hash();
          for (let h = 0; h < n.length; h++) {
            const t = n[h];
            pt(
              0 === t.status,
              "tryToSendTransactionQueue_: items in queue should all be run."
            ),
              (t.status = 1),
              t.retryCount++;
            const i = ni(e, t.path);
            s = s.updateChild(i, t.currentOutputSnapshotRaw);
          }
          const a = s.val(!0),
            l = e;
          t.server_.put(
            l.toString(),
            a,
            (i) => {
              No(t, "transaction put response", {
                path: l.toString(),
                status: i,
              });
              let r = [];
              if ("ok" === i) {
                const i = [];
                for (let e = 0; e < n.length; e++)
                  (n[e].status = 2),
                    (r = r.concat(As(t.serverSyncTree_, n[e].currentWriteId))),
                    n[e].onComplete &&
                      i.push(() =>
                        n[e].onComplete(
                          null,
                          !0,
                          n[e].currentOutputSnapshotResolved
                        )
                      ),
                    n[e].unwatcher();
                Ho(t, $s(t.transactionQueueTree_, e)),
                  Fo(t, t.transactionQueueTree_),
                  bo(t.eventQueue_, e, r);
                for (let t = 0; t < i.length; t++) bn(i[t]);
              } else {
                if ("datastale" === i)
                  for (let t = 0; t < n.length; t++)
                    3 === n[t].status ? (n[t].status = 4) : (n[t].status = 0);
                else {
                  ln("transaction at " + l.toString() + " failed: " + i);
                  for (let t = 0; t < n.length; t++)
                    (n[t].status = 4), (n[t].abortReason = i);
                }
                Uo(t, e);
              }
            },
            o
          );
        })(t, ro(e), n);
    } else
      eo(e) &&
        no(e, (e) => {
          Fo(t, e);
        });
  }
  function Uo(t, e) {
    const n = Bo(t, e),
      i = ro(n);
    return (
      (function (t, e, n) {
        if (0 === e.length) return;
        const i = [];
        let r = [];
        const s = e.filter((t) => 0 === t.status).map((t) => t.currentWriteId);
        for (let a = 0; a < e.length; a++) {
          const l = e[a],
            h = ni(n, l.path);
          let u,
            c = !1;
          if (
            (pt(
              null !== h,
              "rerunTransactionsUnderNode_: relativePath should not be null."
            ),
            4 === l.status)
          )
            (c = !0),
              (u = l.abortReason),
              (r = r.concat(As(t.serverSyncTree_, l.currentWriteId, !0)));
          else if (0 === l.status)
            if (l.retryCount >= 25)
              (c = !0),
                (u = "maxretry"),
                (r = r.concat(As(t.serverSyncTree_, l.currentWriteId, !0)));
            else {
              const n = Lo(t, l.path, s);
              l.currentInputSnapshot = n;
              const i = e[a].update(n.val());
              if (void 0 !== i) {
                po("transaction failed: Data returned ", i, l.path);
                let e = ki(i);
                ("object" == typeof i && null != i && Nt(i, ".priority")) ||
                  (e = e.updatePriority(n.getPriority()));
                const o = l.currentWriteId,
                  a = Ao(t),
                  h = Ks(e, n, a);
                (l.currentOutputSnapshotRaw = e),
                  (l.currentOutputSnapshotResolved = h),
                  (l.currentWriteId = Po(t)),
                  s.splice(s.indexOf(o), 1),
                  (r = r.concat(
                    ws(
                      t.serverSyncTree_,
                      l.path,
                      h,
                      l.currentWriteId,
                      l.applyLocally
                    )
                  )),
                  (r = r.concat(As(t.serverSyncTree_, o, !0)));
              } else
                (c = !0),
                  (u = "nodata"),
                  (r = r.concat(As(t.serverSyncTree_, l.currentWriteId, !0)));
            }
          bo(t.eventQueue_, n, r),
            (r = []),
            c &&
              ((e[a].status = 2),
              (o = e[a].unwatcher),
              setTimeout(o, Math.floor(0)),
              e[a].onComplete &&
                ("nodata" === u
                  ? i.push(() =>
                      e[a].onComplete(null, !1, e[a].currentInputSnapshot)
                    )
                  : i.push(() => e[a].onComplete(new Error(u), !1, null))));
        }
        var o;
        Ho(t, t.transactionQueueTree_);
        for (let a = 0; a < i.length; a++) bn(i[a]);
        Fo(t, t.transactionQueueTree_);
      })(t, ko(t, n), i),
      i
    );
  }
  function Bo(t, e) {
    let n,
      i = t.transactionQueueTree_;
    for (n = qn(e); null !== n && void 0 === Qs(i); )
      (i = $s(i, n)), (n = qn((e = Zn(e))));
    return i;
  }
  function ko(t, e) {
    const n = [];
    return Go(t, e, n), n.sort((t, e) => t.order - e.order), n;
  }
  function Go(t, e, n) {
    const i = Qs(e);
    if (i) for (let r = 0; r < i.length; r++) n.push(i[r]);
    no(e, (e) => {
      Go(t, e, n);
    });
  }
  function Ho(t, e) {
    const n = Qs(e);
    if (n) {
      let t = 0;
      for (let e = 0; e < n.length; e++)
        2 !== n[e].status && ((n[t] = n[e]), t++);
      (n.length = t), to(e, n.length > 0 ? n : void 0);
    }
    no(e, (e) => {
      Ho(t, e);
    });
  }
  function zo(t, e) {
    const n = ro(Bo(t, e)),
      i = $s(t.transactionQueueTree_, e);
    return (
      (function (t, e, n) {
        let i = n ? t : t.parent;
        for (; null !== i; ) {
          if (e(i)) return !0;
          i = i.parent;
        }
      })(i, (e) => {
        Vo(t, e);
      }),
      Vo(t, i),
      io(i, (e) => {
        Vo(t, e);
      }),
      n
    );
  }
  function Vo(t, e) {
    const n = Qs(e);
    if (n) {
      const i = [];
      let r = [],
        s = -1;
      for (let e = 0; e < n.length; e++)
        3 === n[e].status ||
          (1 === n[e].status
            ? (pt(
                s === e - 1,
                "All SENT items should be at beginning of queue."
              ),
              (s = e),
              (n[e].status = 3),
              (n[e].abortReason = "set"))
            : (pt(0 === n[e].status, "Unexpected transaction status in abort"),
              n[e].unwatcher(),
              (r = r.concat(As(t.serverSyncTree_, n[e].currentWriteId, !0))),
              n[e].onComplete &&
                i.push(
                  n[e].onComplete.bind(null, new Error("set"), !1, null)
                )));
      -1 === s ? to(e, void 0) : (n.length = s + 1),
        bo(t.eventQueue_, ro(e), r);
      for (let t = 0; t < i.length; t++) bn(i[t]);
    }
  }
  const Xo = function (t, e) {
      const n = Wo(t),
        i = n.namespace;
      "firebase.com" === n.domain &&
        an(
          n.host +
            " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"
        ),
        (i && "undefined" !== i) ||
          "localhost" === n.domain ||
          an(
            "Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"
          ),
        n.secure ||
          ("undefined" != typeof window &&
            window.location &&
            window.location.protocol &&
            -1 !== window.location.protocol.indexOf("https:") &&
            ln(
              "Insecure Firebase access from a secure page. Please use https in calls to new Firebase()."
            ));
      const r = "ws" === n.scheme || "wss" === n.scheme;
      return {
        repoInfo: new Cn(n.host, n.secure, i, r, e, "", i !== n.subdomain),
        path: new jn(n.pathString),
      };
    },
    Wo = function (t) {
      let e = "",
        n = "",
        i = "",
        r = "",
        s = "",
        o = !0,
        a = "https",
        l = 443;
      if ("string" == typeof t) {
        let h = t.indexOf("//");
        h >= 0 && ((a = t.substring(0, h - 1)), (t = t.substring(h + 2)));
        let u = t.indexOf("/");
        -1 === u && (u = t.length);
        let c = t.indexOf("?");
        -1 === c && (c = t.length),
          (e = t.substring(0, Math.min(u, c))),
          u < c &&
            (r = (function (t) {
              let e = "";
              const n = t.split("/");
              for (let r = 0; r < n.length; r++)
                if (n[r].length > 0) {
                  let t = n[r];
                  try {
                    t = decodeURIComponent(t.replace(/\+/g, " "));
                  } catch (i) {}
                  e += "/" + t;
                }
              return e;
            })(t.substring(u, c)));
        const d = (function (t) {
          const e = {};
          "?" === t.charAt(0) && (t = t.substring(1));
          for (const n of t.split("&")) {
            if (0 === n.length) continue;
            const i = n.split("=");
            2 === i.length
              ? (e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]))
              : ln(`Invalid query segment '${n}' in query '${t}'`);
          }
          return e;
        })(t.substring(Math.min(t.length, c)));
        (h = e.indexOf(":")),
          h >= 0
            ? ((o = "https" === a || "wss" === a),
              (l = parseInt(e.substring(h + 1), 10)))
            : (h = e.length);
        const p = e.slice(0, h);
        if ("localhost" === p.toLowerCase()) n = "localhost";
        else if (p.split(".").length <= 2) n = p;
        else {
          const t = e.indexOf(".");
          (i = e.substring(0, t).toLowerCase()),
            (n = e.substring(t + 1)),
            (s = i);
        }
        "ns" in d && (s = d.ns);
      }
      return {
        host: e,
        port: l,
        domain: n,
        subdomain: i,
        secure: o,
        scheme: a,
        pathString: r,
        namespace: s,
      };
    };
  class jo {
    constructor(t, e, n, i) {
      (this.eventType = t),
        (this.eventRegistration = e),
        (this.snapshot = n),
        (this.prevName = i);
    }
    getPath() {
      const t = this.snapshot.ref;
      return "value" === this.eventType ? t._path : t.parent._path;
    }
    getEventType() {
      return this.eventType;
    }
    getEventRunner() {
      return this.eventRegistration.getEventRunner(this);
    }
    toString() {
      return (
        this.getPath().toString() +
        ":" +
        this.eventType +
        ":" +
        Pt(this.snapshot.exportVal())
      );
    }
  }
  class Yo {
    constructor(t, e, n) {
      (this.eventRegistration = t), (this.error = e), (this.path = n);
    }
    getPath() {
      return this.path;
    }
    getEventType() {
      return "cancel";
    }
    getEventRunner() {
      return this.eventRegistration.getEventRunner(this);
    }
    toString() {
      return this.path.toString() + ":cancel";
    }
  }
  class qo {
    constructor(t, e) {
      (this.snapshotCallback = t), (this.cancelCallback = e);
    }
    onValue(t, e) {
      this.snapshotCallback.call(null, t, e);
    }
    onCancel(t) {
      return (
        pt(
          this.hasCancelCallback,
          "Raising a cancel event on a listener with no cancel callback"
        ),
        this.cancelCallback.call(null, t)
      );
    }
    get hasCancelCallback() {
      return !!this.cancelCallback;
    }
    matches(t) {
      return (
        this.snapshotCallback === t.snapshotCallback ||
        (void 0 !== this.snapshotCallback.userCallback &&
          this.snapshotCallback.userCallback ===
            t.snapshotCallback.userCallback &&
          this.snapshotCallback.context === t.snapshotCallback.context)
      );
    }
  }
  class Ko {
    constructor(t, e, n, i) {
      (this._repo = t),
        (this._path = e),
        (this._queryParams = n),
        (this._orderByCalled = i);
    }
    get key() {
      return ei(this._path) ? null : Jn(this._path);
    }
    get ref() {
      return new Zo(this._repo, this._path);
    }
    get _queryIdentifier() {
      const t = Qi(this._queryParams),
        e = mn(t);
      return "{}" === e ? "default" : e;
    }
    get _queryObject() {
      return Qi(this._queryParams);
    }
    isEqual(t) {
      if (!((t = Vt(t)) instanceof Ko)) return !1;
      const e = this._repo === t._repo,
        n = ri(this._path, t._path),
        i = this._queryIdentifier === t._queryIdentifier;
      return e && n && i;
    }
    toJSON() {
      return this.toString();
    }
    toString() {
      return (
        this._repo.toString() +
        (function (t) {
          let e = "";
          for (let n = t.pieceNum_; n < t.pieces_.length; n++)
            "" !== t.pieces_[n] &&
              (e += "/" + encodeURIComponent(String(t.pieces_[n])));
          return e || "/";
        })(this._path)
      );
    }
  }
  class Zo extends Ko {
    constructor(t, e) {
      super(t, e, new Ji(), !1);
    }
    get parent() {
      const t = Qn(this._path);
      return null === t ? null : new Zo(this._repo, t);
    }
    get root() {
      let t = this;
      for (; null !== t.parent; ) t = t.parent;
      return t;
    }
  }
  class Jo {
    constructor(t, e, n) {
      (this._node = t), (this.ref = e), (this._index = n);
    }
    get priority() {
      return this._node.getPriority().val();
    }
    get key() {
      return this.ref.key;
    }
    get size() {
      return this._node.numChildren();
    }
    child(t) {
      const e = new jn(t),
        n = Qo(this.ref, t);
      return new Jo(this._node.getChild(e), n, Ci);
    }
    exists() {
      return !this._node.isEmpty();
    }
    exportVal() {
      return this._node.val(!0);
    }
    forEach(t) {
      if (this._node.isLeafNode()) return !1;
      return !!this._node.forEachChild(this._index, (e, n) =>
        t(new Jo(n, Qo(this.ref, e), Ci))
      );
    }
    hasChild(t) {
      const e = new jn(t);
      return !this._node.getChild(e).isEmpty();
    }
    hasChildren() {
      return !this._node.isLeafNode() && !this._node.isEmpty();
    }
    toJSON() {
      return this.exportVal();
    }
    val() {
      return this._node.val();
    }
  }
  function $o(t, e) {
    return (
      (t = Vt(t))._checkNotDeleted("ref"),
      void 0 !== e ? Qo(t._root, e) : t._root
    );
  }
  function Qo(t, e) {
    var n, i, r, s;
    return (
      null === qn((t = Vt(t))._path)
        ? ((n = "child"),
          (i = "path"),
          (s = !1),
          (r = e) && (r = r.replace(/^\/*\.info(\/|$)/, "/")),
          mo(n, i, r, s))
        : mo("child", "path", e, !1),
      new Zo(t._repo, ti(t._path, e))
    );
  }
  function ta(t, e) {
    (t = Vt(t)), _o("set", t._path), co("set", e, t._path, !1);
    const n = new Tt();
    return (
      (function (t, e, n, i, r) {
        No(t, "set", { path: e.toString(), value: n, priority: i });
        const s = Ao(t),
          o = ki(n, i),
          a = Os(t.serverSyncTree_, e),
          l = Ks(o, a, s),
          h = Po(t),
          u = ws(t.serverSyncTree_, e, l, h, !0);
        yo(t.eventQueue_, u),
          t.server_.put(e.toString(), o.val(!0), (n, i) => {
            const s = "ok" === n;
            s || ln("set at " + e + " failed: " + n);
            const o = As(t.serverSyncTree_, h, !s);
            bo(t.eventQueue_, e, o), Do(0, r, n, i);
          });
        const c = zo(t, e);
        Uo(t, c), bo(t.eventQueue_, c, []);
      })(
        t._repo,
        t._path,
        e,
        null,
        n.wrapCallback(() => {})
      ),
      n.promise
    );
  }
  function ea(t, e) {
    fo("update", e, t._path, !1);
    const n = new Tt();
    return (
      (function (t, e, n, i) {
        No(t, "update", { path: e.toString(), value: n });
        let r = !0;
        const s = Ao(t),
          o = {};
        if (
          (gn(n, (n, i) => {
            (r = !1), (o[n] = qs(ti(e, n), ki(i), t.serverSyncTree_, s));
          }),
          r)
        )
          rn("update() called with empty data.  Don't do anything."),
            Do(0, i, "ok", void 0);
        else {
          const r = Po(t),
            s = Ms(t.serverSyncTree_, e, o, r);
          yo(t.eventQueue_, s),
            t.server_.merge(e.toString(), n, (n, s) => {
              const o = "ok" === n;
              o || ln("update at " + e + " failed: " + n);
              const a = As(t.serverSyncTree_, r, !o),
                l = a.length > 0 ? Uo(t, e) : e;
              bo(t.eventQueue_, l, a), Do(0, i, n, s);
            }),
            gn(n, (n) => {
              const i = zo(t, ti(e, n));
              Uo(t, i);
            }),
            bo(t.eventQueue_, e, []);
        }
      })(
        t._repo,
        t._path,
        e,
        n.wrapCallback(() => {})
      ),
      n.promise
    );
  }
  class na {
    constructor(t) {
      this.callbackContext = t;
    }
    respondsTo(t) {
      return "value" === t;
    }
    createEvent(t, e) {
      const n = e._queryParams.getIndex();
      return new jo(
        "value",
        this,
        new Jo(t.snapshotNode, new Zo(e._repo, e._path), n)
      );
    }
    getEventRunner(t) {
      return "cancel" === t.getEventType()
        ? () => this.callbackContext.onCancel(t.error)
        : () => this.callbackContext.onValue(t.snapshot, null);
    }
    createCancelEvent(t, e) {
      return this.callbackContext.hasCancelCallback ? new Yo(this, t, e) : null;
    }
    matches(t) {
      return (
        t instanceof na &&
        (!t.callbackContext ||
          !this.callbackContext ||
          t.callbackContext.matches(this.callbackContext))
      );
    }
    hasAnyCallback() {
      return null !== this.callbackContext;
    }
  }
  class ia {
    constructor(t, e) {
      (this.eventType = t), (this.callbackContext = e);
    }
    respondsTo(t) {
      let e = "children_added" === t ? "child_added" : t;
      return (
        (e = "children_removed" === e ? "child_removed" : e),
        this.eventType === e
      );
    }
    createCancelEvent(t, e) {
      return this.callbackContext.hasCancelCallback ? new Yo(this, t, e) : null;
    }
    createEvent(t, e) {
      pt(null != t.childName, "Child events should have a childName.");
      const n = Qo(new Zo(e._repo, e._path), t.childName),
        i = e._queryParams.getIndex();
      return new jo(t.type, this, new Jo(t.snapshotNode, n, i), t.prevName);
    }
    getEventRunner(t) {
      return "cancel" === t.getEventType()
        ? () => this.callbackContext.onCancel(t.error)
        : () => this.callbackContext.onValue(t.snapshot, t.prevName);
    }
    matches(t) {
      return (
        t instanceof ia &&
        this.eventType === t.eventType &&
        (!this.callbackContext ||
          !t.callbackContext ||
          this.callbackContext.matches(t.callbackContext))
      );
    }
    hasAnyCallback() {
      return !!this.callbackContext;
    }
  }
  function ra(t, e, n, i, r) {
    let s;
    if (
      ("object" == typeof i && ((s = void 0), (r = i)),
      "function" == typeof i && (s = i),
      r && r.onlyOnce)
    ) {
      const e = n,
        i = (n, i) => {
          Oo(t._repo, t, a), e(n, i);
        };
      (i.userCallback = n.userCallback), (i.context = n.context), (n = i);
    }
    const o = new qo(n, s || void 0),
      a = "value" === e ? new na(o) : new ia(e, o);
    return (
      (function (t, e, n) {
        let i;
        (i =
          ".info" === qn(e._path)
            ? Ps(t.infoSyncTree_, e, n)
            : Ps(t.serverSyncTree_, e, n)),
          xo(t.eventQueue_, e._path, i);
      })(t._repo, t, a),
      () => Oo(t._repo, t, a)
    );
  }
  function sa(t, e, n, i) {
    return ra(t, "value", e, n, i);
  }
  class oa {}
  class aa extends oa {
    constructor(t) {
      super(), (this._limit = t);
    }
    _apply(t) {
      if (t._queryParams.hasLimit())
        throw new Error(
          "limitToLast: Limit was already set (by another call to limitToFirst or limitToLast)."
        );
      return new Ko(
        t._repo,
        t._path,
        (function (t, e) {
          const n = t.copy();
          return (n.limitSet_ = !0), (n.limit_ = e), (n.viewFrom_ = "r"), n;
        })(t._queryParams, this._limit),
        t._orderByCalled
      );
    }
  }
  function la(t) {
    if ("number" != typeof t || Math.floor(t) !== t || t <= 0)
      throw new Error(
        "limitToLast: First argument must be a positive integer."
      );
    return new aa(t);
  }
  function ha(t, ...e) {
    let n = Vt(t);
    for (const i of e) n = i._apply(n);
    return n;
  }
  !(function (t) {
    pt(!cs, "__referenceConstructor has already been defined"), (cs = t);
  })(Zo),
    (function (t) {
      pt(!ds, "__referenceConstructor has already been defined"), (ds = t);
    })(Zo);
  const ua = {};
  function ca(t, e, n, i, r) {
    let s = i || t.options.databaseURL;
    void 0 === s &&
      (t.options.projectId ||
        an(
          "Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."
        ),
      rn("Using default host for project ", t.options.projectId),
      (s = `${t.options.projectId}-default-rtdb.firebaseio.com`));
    let o,
      a,
      l = Xo(s, r),
      h = l.repoInfo;
    "undefined" != typeof process &&
      process.env &&
      (a = process.env.FIREBASE_DATABASE_EMULATOR_HOST),
      a
        ? ((o = !0),
          (s = `http://${a}?ns=${h.namespace}`),
          (l = Xo(s, r)),
          (h = l.repoInfo))
        : (o = !l.repoInfo.secure);
    const u = r && o ? new wn(wn.OWNER) : new Sn(t.name, t.options, e);
    go("Invalid Firebase Database URL", l),
      ei(l.path) ||
        an(
          "Database URL must point to the root of a Firebase Database (not including a child path)."
        );
    const c = (function (t, e, n, i) {
      let r = ua[e.name];
      r || ((r = {}), (ua[e.name] = r));
      let s = r[t.toURLString()];
      s &&
        an(
          "Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."
        );
      return (s = new So(t, false, n, i)), (r[t.toURLString()] = s), s;
    })(h, t, u, new En(t.name, n));
    return new da(c, t);
  }
  class da {
    constructor(t, e) {
      (this._repoInternal = t),
        (this.app = e),
        (this.type = "database"),
        (this._instanceStarted = !1);
    }
    get _repo() {
      return (
        this._instanceStarted ||
          (wo(
            this._repoInternal,
            this.app.options.appId,
            this.app.options.databaseAuthVariableOverride
          ),
          (this._instanceStarted = !0)),
        this._repoInternal
      );
    }
    get _root() {
      return (
        this._rootInternal || (this._rootInternal = new Zo(this._repo, Yn())),
        this._rootInternal
      );
    }
    _delete() {
      return (
        null !== this._rootInternal &&
          (!(function (t, e) {
            const n = ua[e];
            (n && n[t.key] === t) ||
              an(`Database ${e}(${t.repoInfo_}) has already been deleted.`),
              (function (t) {
                t.persistentConnection_ &&
                  t.persistentConnection_.interrupt("repo_interrupt");
              })(t),
              delete n[t.key];
          })(this._repo, this.app.name),
          (this._repoInternal = null),
          (this._rootInternal = null)),
        Promise.resolve()
      );
    }
    _checkNotDeleted(t) {
      null === this._rootInternal &&
        an("Cannot call " + t + " on a deleted database.");
    }
  }
  function pa(
    t = (function (t = "[DEFAULT]") {
      const e = Se.get(t);
      if (!e) throw Ce.create("no-app", { appName: t });
      return e;
    })(),
    e
  ) {
    return Re(t, "database").getImmediate({ identifier: e });
  }
  function fa(t) {
    if (void 0 === t)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return t;
  }
  function ma(t, e) {
    (t.prototype = Object.create(e.prototype)),
      (t.prototype.constructor = t),
      (t.__proto__ = e);
  }
  (ci.prototype.simpleListen = function (t, e) {
    this.sendRequest("q", { p: t }, e);
  }),
    (ci.prototype.echo = function (t, e) {
      this.sendRequest("echo", { d: t }, e);
    }),
    (function (t) {
      (We = "9.9.2"),
        Ae(
          new Xt(
            "database",
            (t, { instanceIdentifier: e }) =>
              ca(
                t.getProvider("app").getImmediate(),
                t.getProvider("auth-internal"),
                t.getProvider("app-check-internal"),
                e
              ),
            "PUBLIC"
          ).setMultipleInstances(!0)
        ),
        Oe(Ve, Xe, t),
        Oe(Ve, Xe, "esm2017");
    })();
  var _a,
    ga,
    va,
    ya,
    xa,
    ba,
    Ta,
    Ea,
    Sa,
    wa,
    Ma,
    Aa,
    Ra,
    Ca,
    Ia,
    Pa,
    Oa,
    Na,
    Da,
    La,
    Fa,
    Ua,
    Ba,
    ka,
    Ga,
    Ha,
    za,
    Va,
    Xa = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: { lineHeight: "" },
    },
    Wa = { duration: 0.5, overwrite: !1, delay: 0 },
    ja = 1e8,
    Ya = 1e-8,
    qa = 2 * Math.PI,
    Ka = qa / 4,
    Za = 0,
    Ja = Math.sqrt,
    $a = Math.cos,
    Qa = Math.sin,
    tl = function (t) {
      return "string" == typeof t;
    },
    el = function (t) {
      return "function" == typeof t;
    },
    nl = function (t) {
      return "number" == typeof t;
    },
    il = function (t) {
      return void 0 === t;
    },
    rl = function (t) {
      return "object" == typeof t;
    },
    sl = function (t) {
      return !1 !== t;
    },
    ol = function () {
      return "undefined" != typeof window;
    },
    al = function (t) {
      return el(t) || tl(t);
    },
    ll =
      ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
      function () {},
    hl = Array.isArray,
    ul = /(?:-?\.?\d|\.)+/gi,
    cl = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    dl = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    pl = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    fl = /[+-]=-?[.\d]+/,
    ml = /[^,'"\[\]\s]+/gi,
    _l = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    gl = {},
    vl = {},
    yl = function (t) {
      return (vl = Wl(t, gl)) && Du;
    },
    xl = function (t, e) {
      return console.warn(
        "Invalid property",
        t,
        "set to",
        e,
        "Missing plugin? gsap.registerPlugin()"
      );
    },
    bl = function (t, e) {
      return !e && console.warn(t);
    },
    Tl = function (t, e) {
      return (t && (gl[t] = e) && vl && (vl[t] = e)) || gl;
    },
    El = function () {
      return 0;
    },
    Sl = {},
    wl = [],
    Ml = {},
    Al = {},
    Rl = {},
    Cl = 30,
    Il = [],
    Pl = "",
    Ol = function (t) {
      var e,
        n,
        i = t[0];
      if ((rl(i) || el(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
        for (n = Il.length; n-- && !Il[n].targetTest(i); );
        e = Il[n];
      }
      for (n = t.length; n--; )
        (t[n] && (t[n]._gsap || (t[n]._gsap = new iu(t[n], e)))) ||
          t.splice(n, 1);
      return t;
    },
    Nl = function (t) {
      return t._gsap || Ol(Th(t))[0]._gsap;
    },
    Dl = function (t, e, n) {
      return (n = t[e]) && el(n)
        ? t[e]()
        : (il(n) && t.getAttribute && t.getAttribute(e)) || n;
    },
    Ll = function (t, e) {
      return (t = t.split(",")).forEach(e) || t;
    },
    Fl = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    Ul = function (t) {
      return Math.round(1e7 * t) / 1e7 || 0;
    },
    Bl = function (t, e) {
      var n = e.charAt(0),
        i = parseFloat(e.substr(2));
      return (
        (t = parseFloat(t)),
        "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
      );
    },
    kl = function (t, e) {
      for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
      return i < n;
    },
    Gl = function () {
      var t,
        e,
        n = wl.length,
        i = wl.slice(0);
      for (Ml = {}, wl.length = 0, t = 0; t < n; t++)
        (e = i[t]) &&
          e._lazy &&
          (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
    },
    Hl = function (t, e, n, i) {
      wl.length && Gl(), t.render(e, n, i), wl.length && Gl();
    },
    zl = function (t) {
      var e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(ml).length < 2
        ? e
        : tl(t)
        ? t.trim()
        : t;
    },
    Vl = function (t) {
      return t;
    },
    Xl = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    Wl = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    jl = function t(e, n) {
      for (var i in n)
        "__proto__" !== i &&
          "constructor" !== i &&
          "prototype" !== i &&
          (e[i] = rl(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
      return e;
    },
    Yl = function (t, e) {
      var n,
        i = {};
      for (n in t) n in e || (i[n] = t[n]);
      return i;
    },
    ql = function (t) {
      var e,
        n = t.parent || ga,
        i = t.keyframes
          ? ((e = hl(t.keyframes)),
            function (t, n) {
              for (var i in n)
                i in t ||
                  ("duration" === i && e) ||
                  "ease" === i ||
                  (t[i] = n[i]);
            })
          : Xl;
      if (sl(t.inherit))
        for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
      return t;
    },
    Kl = function (t, e, n, i, r) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var s,
        o = t[i];
      if (r) for (s = e[r]; o && o[r] > s; ) o = o._prev;
      return (
        o
          ? ((e._next = o._next), (o._next = e))
          : ((e._next = t[n]), (t[n] = e)),
        e._next ? (e._next._prev = e) : (t[i] = e),
        (e._prev = o),
        (e.parent = e._dp = t),
        e
      );
    },
    Zl = function (t, e, n, i) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var r = e._prev,
        s = e._next;
      r ? (r._next = s) : t[n] === e && (t[n] = s),
        s ? (s._prev = r) : t[i] === e && (t[i] = r),
        (e._next = e._prev = e.parent = null);
    },
    Jl = function (t, e) {
      t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
        (t._act = 0);
    },
    $l = function (t, e) {
      if (t && (!e || e._end > t._dur || e._start < 0))
        for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
      return t;
    },
    Ql = function (t) {
      for (var e = t.parent; e && e.parent; )
        (e._dirty = 1), e.totalDuration(), (e = e.parent);
      return t;
    },
    th = function t(e) {
      return !e || (e._ts && t(e.parent));
    },
    eh = function (t) {
      return t._repeat ? nh(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
    },
    nh = function (t, e) {
      var n = Math.floor((t /= e));
      return t && n === t ? n - 1 : n;
    },
    ih = function (t, e) {
      return (
        (t - e._start) * e._ts +
        (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
      );
    },
    rh = function (t) {
      return (t._end = Ul(
        t._start + (t._tDur / Math.abs(t._ts || t._rts || Ya) || 0)
      ));
    },
    sh = function (t, e) {
      var n = t._dp;
      return (
        n &&
          n.smoothChildTiming &&
          t._ts &&
          ((t._start = Ul(
            n._time -
              (t._ts > 0
                ? e / t._ts
                : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
          )),
          rh(t),
          n._dirty || $l(n, t)),
        t
      );
    },
    oh = function (t, e) {
      var n;
      if (
        ((e._time || (e._initted && !e._dur)) &&
          ((n = ih(t.rawTime(), e)),
          (!e._dur || vh(0, e.totalDuration(), n) - e._tTime > Ya) &&
            e.render(n, !0)),
        $l(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
      ) {
        if (t._dur < t.duration())
          for (n = t; n._dp; )
            n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
        t._zTime = -1e-8;
      }
    },
    ah = function (t, e, n, i) {
      return (
        e.parent && Jl(e),
        (e._start = Ul(
          (nl(n) ? n : n || t !== ga ? mh(t, n, e) : t._time) + e._delay
        )),
        (e._end = Ul(
          e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
        )),
        Kl(t, e, "_first", "_last", t._sort ? "_start" : 0),
        ch(e) || (t._recent = e),
        i || oh(t, e),
        t
      );
    },
    lh = function (t, e) {
      return (
        (gl.ScrollTrigger || xl("scrollTrigger", e)) &&
        gl.ScrollTrigger.create(e, t)
      );
    },
    hh = function (t, e, n, i) {
      return (
        cu(t, e),
        t._initted
          ? !n &&
            t._pt &&
            ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
            Ta !== Xh.frame
            ? (wl.push(t), (t._lazy = [e, i]), 1)
            : void 0
          : 1
      );
    },
    uh = function t(e) {
      var n = e.parent;
      return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n));
    },
    ch = function (t) {
      var e = t.data;
      return "isFromStart" === e || "isStart" === e;
    },
    dh = function (t, e, n, i) {
      var r = t._repeat,
        s = Ul(e) || 0,
        o = t._tTime / t._tDur;
      return (
        o && !i && (t._time *= s / t._dur),
        (t._dur = s),
        (t._tDur = r ? (r < 0 ? 1e10 : Ul(s * (r + 1) + t._rDelay * r)) : s),
        o > 0 && !i ? sh(t, (t._tTime = t._tDur * o)) : t.parent && rh(t),
        n || $l(t.parent, t),
        t
      );
    },
    ph = function (t) {
      return t instanceof su ? $l(t) : dh(t, t._dur);
    },
    fh = { _start: 0, endTime: El, totalDuration: El },
    mh = function t(e, n, i) {
      var r,
        s,
        o,
        a = e.labels,
        l = e._recent || fh,
        h = e.duration() >= ja ? l.endTime(!1) : e._dur;
      return tl(n) && (isNaN(n) || n in a)
        ? ((s = n.charAt(0)),
          (o = "%" === n.substr(-1)),
          (r = n.indexOf("=")),
          "<" === s || ">" === s
            ? (r >= 0 && (n = n.replace(/=/, "")),
              ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                (parseFloat(n.substr(1)) || 0) *
                  (o ? (r < 0 ? l : i).totalDuration() / 100 : 1))
            : r < 0
            ? (n in a || (a[n] = h), a[n])
            : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
              o && i && (s = (s / 100) * (hl(i) ? i[0] : i).totalDuration()),
              r > 1 ? t(e, n.substr(0, r - 1), i) + s : h + s))
        : null == n
        ? h
        : +n;
    },
    _h = function (t, e, n) {
      var i,
        r,
        s = nl(e[1]),
        o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
        a = e[o];
      if ((s && (a.duration = e[1]), (a.parent = n), t)) {
        for (i = a, r = n; r && !("immediateRender" in i); )
          (i = r.vars.defaults || {}), (r = sl(r.vars.inherit) && r.parent);
        (a.immediateRender = sl(i.immediateRender)),
          t < 2 ? (a.runBackwards = 1) : (a.startAt = e[o - 1]);
      }
      return new _u(e[0], a, e[o + 1]);
    },
    gh = function (t, e) {
      return t || 0 === t ? e(t) : e;
    },
    vh = function (t, e, n) {
      return n < t ? t : n > e ? e : n;
    },
    yh = function (t, e) {
      return tl(t) && (e = _l.exec(t)) ? e[1] : "";
    },
    xh = [].slice,
    bh = function (t, e) {
      return (
        t &&
        rl(t) &&
        "length" in t &&
        ((!e && !t.length) || (t.length - 1 in t && rl(t[0]))) &&
        !t.nodeType &&
        t !== va
      );
    },
    Th = function (t, e, n) {
      return !tl(t) || n || (!ya && Wh())
        ? hl(t)
          ? (function (t, e, n) {
              return (
                void 0 === n && (n = []),
                t.forEach(function (t) {
                  var i;
                  return (tl(t) && !e) || bh(t, 1)
                    ? (i = n).push.apply(i, Th(t))
                    : n.push(t);
                }) || n
              );
            })(t, n)
          : bh(t)
          ? xh.call(t, 0)
          : t
          ? [t]
          : []
        : xh.call((e || xa).querySelectorAll(t), 0);
    },
    Eh = function (t) {
      return t.sort(function () {
        return 0.5 - Math.random();
      });
    },
    Sh = function (t) {
      if (el(t)) return t;
      var e = rl(t) ? t : { each: t },
        n = $h(e.ease),
        i = e.from || 0,
        r = parseFloat(e.base) || 0,
        s = {},
        o = i > 0 && i < 1,
        a = isNaN(i) || o,
        l = e.axis,
        h = i,
        u = i;
      return (
        tl(i)
          ? (h = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
          : !o && a && ((h = i[0]), (u = i[1])),
        function (t, o, c) {
          var d,
            p,
            f,
            m,
            _,
            g,
            v,
            y,
            x,
            b = (c || e).length,
            T = s[b];
          if (!T) {
            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, ja])[1])) {
              for (
                v = -1e8;
                v < (v = c[x++].getBoundingClientRect().left) && x < b;

              );
              x--;
            }
            for (
              T = s[b] = [],
                d = a ? Math.min(x, b) * h - 0.5 : i % x,
                p = x === ja ? 0 : a ? (b * u) / x - 0.5 : (i / x) | 0,
                v = 0,
                y = ja,
                g = 0;
              g < b;
              g++
            )
              (f = (g % x) - d),
                (m = p - ((g / x) | 0)),
                (T[g] = _ =
                  l ? Math.abs("y" === l ? m : f) : Ja(f * f + m * m)),
                _ > v && (v = _),
                _ < y && (y = _);
            "random" === i && Eh(T),
              (T.max = v - y),
              (T.min = y),
              (T.v = b =
                (parseFloat(e.amount) ||
                  parseFloat(e.each) *
                    (x > b
                      ? b - 1
                      : l
                      ? "y" === l
                        ? b / x
                        : x
                      : Math.max(x, b / x)) ||
                  0) * ("edges" === i ? -1 : 1)),
              (T.b = b < 0 ? r - b : r),
              (T.u = yh(e.amount || e.each) || 0),
              (n = n && b < 0 ? Zh(n) : n);
          }
          return (
            (b = (T[t] - T.min) / T.max || 0),
            Ul(T.b + (n ? n(b) : b) * T.v) + T.u
          );
        }
      );
    },
    wh = function (t) {
      var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
      return function (n) {
        var i = Math.round(parseFloat(n) / t) * t * e;
        return (i - (i % 1)) / e + (nl(n) ? 0 : yh(n));
      };
    },
    Mh = function (t, e) {
      var n,
        i,
        r = hl(t);
      return (
        !r &&
          rl(t) &&
          ((n = r = t.radius || ja),
          t.values
            ? ((t = Th(t.values)), (i = !nl(t[0])) && (n *= n))
            : (t = wh(t.increment))),
        gh(
          e,
          r
            ? el(t)
              ? function (e) {
                  return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                }
              : function (e) {
                  for (
                    var r,
                      s,
                      o = parseFloat(i ? e.x : e),
                      a = parseFloat(i ? e.y : 0),
                      l = ja,
                      h = 0,
                      u = t.length;
                    u--;

                  )
                    (r = i
                      ? (r = t[u].x - o) * r + (s = t[u].y - a) * s
                      : Math.abs(t[u] - o)) < l && ((l = r), (h = u));
                  return (
                    (h = !n || l <= n ? t[h] : e),
                    i || h === e || nl(e) ? h : h + yh(e)
                  );
                }
            : wh(t)
        )
      );
    },
    Ah = function (t, e, n, i) {
      return gh(hl(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
        return hl(t)
          ? t[~~(Math.random() * t.length)]
          : (n = n || 1e-5) &&
              (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                ) *
                  n *
                  i
              ) / i;
      });
    },
    Rh = function (t, e, n) {
      return gh(n, function (n) {
        return t[~~e(n)];
      });
    },
    Ch = function (t) {
      for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
        (i = t.indexOf(")", e)),
          (r = "[" === t.charAt(e + 7)),
          (n = t.substr(e + 7, i - e - 7).match(r ? ml : ul)),
          (o +=
            t.substr(s, e - s) +
            Ah(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
          (s = i + 1);
      return o + t.substr(s, t.length - s);
    },
    Ih = function (t, e, n, i, r) {
      var s = e - t,
        o = i - n;
      return gh(r, function (e) {
        return n + (((e - t) / s) * o || 0);
      });
    },
    Ph = function (t, e, n) {
      var i,
        r,
        s,
        o = t.labels,
        a = ja;
      for (i in o)
        (r = o[i] - e) < 0 == !!n &&
          r &&
          a > (r = Math.abs(r)) &&
          ((s = i), (a = r));
      return s;
    },
    Oh = function (t, e, n) {
      var i,
        r,
        s = t.vars,
        o = s[e];
      if (o)
        return (
          (i = s[e + "Params"]),
          (r = s.callbackScope || t),
          n && wl.length && Gl(),
          i ? o.apply(r, i) : o.call(r)
        );
    },
    Nh = function (t) {
      return (
        Jl(t),
        t.scrollTrigger && t.scrollTrigger.kill(!1),
        t.progress() < 1 && Oh(t, "onInterrupt"),
        t
      );
    },
    Dh = function (t) {
      var e = (t = (!t.name && t.default) || t).name,
        n = el(t),
        i =
          e && !n && t.init
            ? function () {
                this._props = [];
              }
            : t,
        r = {
          init: El,
          render: wu,
          add: hu,
          kill: Au,
          modifier: Mu,
          rawVars: 0,
        },
        s = { targetTest: 0, get: 0, getSetter: bu, aliases: {}, register: 0 };
      if ((Wh(), t !== i)) {
        if (Al[e]) return;
        Xl(i, Xl(Yl(t, r), s)),
          Wl(i.prototype, Wl(r, Yl(t, s))),
          (Al[(i.prop = e)] = i),
          t.targetTest && (Il.push(i), (Sl[e] = 1)),
          (e =
            ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) +
            "Plugin");
      }
      Tl(e, i), t.register && t.register(Du, i, Iu);
    },
    Lh = 255,
    Fh = {
      aqua: [0, Lh, Lh],
      lime: [0, Lh, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, Lh],
      navy: [0, 0, 128],
      white: [Lh, Lh, Lh],
      olive: [128, 128, 0],
      yellow: [Lh, Lh, 0],
      orange: [Lh, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [Lh, 0, 0],
      pink: [Lh, 192, 203],
      cyan: [0, Lh, Lh],
      transparent: [Lh, Lh, Lh, 0],
    },
    Uh = function (t, e, n) {
      return (
        ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
          ? e + (n - e) * t * 6
          : t < 0.5
          ? n
          : 3 * t < 2
          ? e + (n - e) * (2 / 3 - t) * 6
          : e) *
          Lh +
          0.5) |
        0
      );
    },
    Bh = function (t, e, n) {
      var i,
        r,
        s,
        o,
        a,
        l,
        h,
        u,
        c,
        d,
        p = t ? (nl(t) ? [t >> 16, (t >> 8) & Lh, t & Lh] : 0) : Fh.black;
      if (!p) {
        if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Fh[t]))
          p = Fh[t];
        else if ("#" === t.charAt(0)) {
          if (
            (t.length < 6 &&
              ((i = t.charAt(1)),
              (r = t.charAt(2)),
              (s = t.charAt(3)),
              (t =
                "#" +
                i +
                i +
                r +
                r +
                s +
                s +
                (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
            9 === t.length)
          )
            return [
              (p = parseInt(t.substr(1, 6), 16)) >> 16,
              (p >> 8) & Lh,
              p & Lh,
              parseInt(t.substr(7), 16) / 255,
            ];
          p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & Lh, t & Lh];
        } else if ("hsl" === t.substr(0, 3))
          if (((p = d = t.match(ul)), e)) {
            if (~t.indexOf("="))
              return (p = t.match(cl)), n && p.length < 4 && (p[3] = 1), p;
          } else
            (o = (+p[0] % 360) / 360),
              (a = +p[1] / 100),
              (i =
                2 * (l = +p[2] / 100) -
                (r = l <= 0.5 ? l * (a + 1) : l + a - l * a)),
              p.length > 3 && (p[3] *= 1),
              (p[0] = Uh(o + 1 / 3, i, r)),
              (p[1] = Uh(o, i, r)),
              (p[2] = Uh(o - 1 / 3, i, r));
        else p = t.match(ul) || Fh.transparent;
        p = p.map(Number);
      }
      return (
        e &&
          !d &&
          ((i = p[0] / Lh),
          (r = p[1] / Lh),
          (s = p[2] / Lh),
          (l = ((h = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
          h === u
            ? (o = a = 0)
            : ((c = h - u),
              (a = l > 0.5 ? c / (2 - h - u) : c / (h + u)),
              (o =
                h === i
                  ? (r - s) / c + (r < s ? 6 : 0)
                  : h === r
                  ? (s - i) / c + 2
                  : (i - r) / c + 4),
              (o *= 60)),
          (p[0] = ~~(o + 0.5)),
          (p[1] = ~~(100 * a + 0.5)),
          (p[2] = ~~(100 * l + 0.5))),
        n && p.length < 4 && (p[3] = 1),
        p
      );
    },
    kh = function (t) {
      var e = [],
        n = [],
        i = -1;
      return (
        t.split(Hh).forEach(function (t) {
          var r = t.match(dl) || [];
          e.push.apply(e, r), n.push((i += r.length + 1));
        }),
        (e.c = n),
        e
      );
    },
    Gh = function (t, e, n) {
      var i,
        r,
        s,
        o,
        a = "",
        l = (t + a).match(Hh),
        h = e ? "hsla(" : "rgba(",
        u = 0;
      if (!l) return t;
      if (
        ((l = l.map(function (t) {
          return (
            (t = Bh(t, e, 1)) &&
            h +
              (e
                ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                : t.join(",")) +
              ")"
          );
        })),
        n && ((s = kh(t)), (i = n.c).join(a) !== s.c.join(a)))
      )
        for (o = (r = t.replace(Hh, "1").split(dl)).length - 1; u < o; u++)
          a +=
            r[u] +
            (~i.indexOf(u)
              ? l.shift() || h + "0,0,0,0)"
              : (s.length ? s : l.length ? l : n).shift());
      if (!r)
        for (o = (r = t.split(Hh)).length - 1; u < o; u++) a += r[u] + l[u];
      return a + r[o];
    },
    Hh = (function () {
      var t,
        e =
          "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in Fh) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    })(),
    zh = /hsl[a]?\(/,
    Vh = function (t) {
      var e,
        n = t.join(" ");
      if (((Hh.lastIndex = 0), Hh.test(n)))
        return (
          (e = zh.test(n)),
          (t[1] = Gh(t[1], e)),
          (t[0] = Gh(t[0], e, kh(t[1]))),
          !0
        );
    },
    Xh =
      ((Pa = Date.now),
      (Oa = 500),
      (Na = 33),
      (Da = Pa()),
      (La = Da),
      (Ua = Fa = 1e3 / 240),
      (ka = function t(e) {
        var n,
          i,
          r,
          s,
          o = Pa() - La,
          a = !0 === e;
        if (
          (o > Oa && (Da += o - Na),
          ((n = (r = (La += o) - Da) - Ua) > 0 || a) &&
            ((s = ++Ra.frame),
            (Ca = r - 1e3 * Ra.time),
            (Ra.time = r /= 1e3),
            (Ua += n + (n >= Fa ? 4 : Fa - n)),
            (i = 1)),
          a || (wa = Ma(t)),
          i)
        )
          for (Ia = 0; Ia < Ba.length; Ia++) Ba[Ia](r, Ca, s, e);
      }),
      (Ra = {
        time: 0,
        frame: 0,
        tick: function () {
          ka(!0);
        },
        deltaRatio: function (t) {
          return Ca / (1e3 / (t || 60));
        },
        wake: function () {
          ba &&
            (!ya &&
              ol() &&
              ((va = ya = window),
              (xa = va.document || {}),
              (gl.gsap = Du),
              (va.gsapVersions || (va.gsapVersions = [])).push(Du.version),
              yl(vl || va.GreenSockGlobals || (!va.gsap && va) || {}),
              (Aa = va.requestAnimationFrame)),
            wa && Ra.sleep(),
            (Ma =
              Aa ||
              function (t) {
                return setTimeout(t, (Ua - 1e3 * Ra.time + 1) | 0);
              }),
            (Sa = 1),
            ka(2));
        },
        sleep: function () {
          (Aa ? va.cancelAnimationFrame : clearTimeout)(wa),
            (Sa = 0),
            (Ma = El);
        },
        lagSmoothing: function (t, e) {
          (Oa = t || 1e8), (Na = Math.min(e, Oa, 0));
        },
        fps: function (t) {
          (Fa = 1e3 / (t || 240)), (Ua = 1e3 * Ra.time + Fa);
        },
        add: function (t, e, n) {
          var i = e
            ? function (e, n, r, s) {
                t(e, n, r, s), Ra.remove(i);
              }
            : t;
          return Ra.remove(t), Ba[n ? "unshift" : "push"](i), Wh(), i;
        },
        remove: function (t, e) {
          ~(e = Ba.indexOf(t)) && Ba.splice(e, 1) && Ia >= e && Ia--;
        },
        _listeners: (Ba = []),
      }),
      Ra),
    Wh = function () {
      return !Sa && Xh.wake();
    },
    jh = {},
    Yh = /^[\d.\-M][\d.\-,\s]/,
    qh = /["']/g,
    Kh = function (t) {
      for (
        var e,
          n,
          i,
          r = {},
          s = t.substr(1, t.length - 3).split(":"),
          o = s[0],
          a = 1,
          l = s.length;
        a < l;
        a++
      )
        (n = s[a]),
          (e = a !== l - 1 ? n.lastIndexOf(",") : n.length),
          (i = n.substr(0, e)),
          (r[o] = isNaN(i) ? i.replace(qh, "").trim() : +i),
          (o = n.substr(e + 1).trim());
      return r;
    },
    Zh = function (t) {
      return function (e) {
        return 1 - t(1 - e);
      };
    },
    Jh = function t(e, n) {
      for (var i, r = e._first; r; )
        r instanceof su
          ? t(r, n)
          : !r.vars.yoyoEase ||
            (r._yoyo && r._repeat) ||
            r._yoyo === n ||
            (r.timeline
              ? t(r.timeline, n)
              : ((i = r._ease),
                (r._ease = r._yEase),
                (r._yEase = i),
                (r._yoyo = n))),
          (r = r._next);
    },
    $h = function (t, e) {
      return (
        (t &&
          (el(t)
            ? t
            : jh[t] ||
              (function (t) {
                var e,
                  n,
                  i,
                  r,
                  s = (t + "").split("("),
                  o = jh[s[0]];
                return o && s.length > 1 && o.config
                  ? o.config.apply(
                      null,
                      ~t.indexOf("{")
                        ? [Kh(s[1])]
                        : ((e = t),
                          (n = e.indexOf("(") + 1),
                          (i = e.indexOf(")")),
                          (r = e.indexOf("(", n)),
                          e.substring(
                            n,
                            ~r && r < i ? e.indexOf(")", i + 1) : i
                          ))
                            .split(",")
                            .map(zl)
                    )
                  : jh._CE && Yh.test(t)
                  ? jh._CE("", t)
                  : o;
              })(t))) ||
        e
      );
    },
    Qh = function (t, e, n, i) {
      void 0 === n &&
        (n = function (t) {
          return 1 - e(1 - t);
        }),
        void 0 === i &&
          (i = function (t) {
            return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
          });
      var r,
        s = { easeIn: e, easeOut: n, easeInOut: i };
      return (
        Ll(t, function (t) {
          for (var e in ((jh[t] = gl[t] = s),
          (jh[(r = t.toLowerCase())] = n),
          s))
            jh[
              r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
            ] = jh[t + "." + e] = s[e];
        }),
        s
      );
    },
    tu = function (t) {
      return function (e) {
        return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
      };
    },
    eu = function t(e, n, i) {
      var r = n >= 1 ? n : 1,
        s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
        o = (s / qa) * (Math.asin(1 / r) || 0),
        a = function (t) {
          return 1 === t ? 1 : r * Math.pow(2, -10 * t) * Qa((t - o) * s) + 1;
        },
        l =
          "out" === e
            ? a
            : "in" === e
            ? function (t) {
                return 1 - a(1 - t);
              }
            : tu(a);
      return (
        (s = qa / s),
        (l.config = function (n, i) {
          return t(e, n, i);
        }),
        l
      );
    },
    nu = function t(e, n) {
      void 0 === n && (n = 1.70158);
      var i = function (t) {
          return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
        },
        r =
          "out" === e
            ? i
            : "in" === e
            ? function (t) {
                return 1 - i(1 - t);
              }
            : tu(i);
      return (
        (r.config = function (n) {
          return t(e, n);
        }),
        r
      );
    };
  Ll("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
    var n = e < 5 ? e + 1 : e;
    Qh(
      t + ",Power" + (n - 1),
      e
        ? function (t) {
            return Math.pow(t, n);
          }
        : function (t) {
            return t;
          },
      function (t) {
        return 1 - Math.pow(1 - t, n);
      },
      function (t) {
        return t < 0.5
          ? Math.pow(2 * t, n) / 2
          : 1 - Math.pow(2 * (1 - t), n) / 2;
      }
    );
  }),
    (jh.Linear.easeNone = jh.none = jh.Linear.easeIn),
    Qh("Elastic", eu("in"), eu("out"), eu()),
    (Ga = 7.5625),
    (za = 1 / (Ha = 2.75)),
    Qh(
      "Bounce",
      function (t) {
        return 1 - Va(1 - t);
      },
      (Va = function (t) {
        return t < za
          ? Ga * t * t
          : t < 0.7272727272727273
          ? Ga * Math.pow(t - 1.5 / Ha, 2) + 0.75
          : t < 0.9090909090909092
          ? Ga * (t -= 2.25 / Ha) * t + 0.9375
          : Ga * Math.pow(t - 2.625 / Ha, 2) + 0.984375;
      })
    ),
    Qh("Expo", function (t) {
      return t ? Math.pow(2, 10 * (t - 1)) : 0;
    }),
    Qh("Circ", function (t) {
      return -(Ja(1 - t * t) - 1);
    }),
    Qh("Sine", function (t) {
      return 1 === t ? 1 : 1 - $a(t * Ka);
    }),
    Qh("Back", nu("in"), nu("out"), nu()),
    (jh.SteppedEase =
      jh.steps =
      gl.SteppedEase =
        {
          config: function (t, e) {
            void 0 === t && (t = 1);
            var n = 1 / t,
              i = t + (e ? 0 : 1),
              r = e ? 1 : 0;
            return function (t) {
              return (((i * vh(0, 0.99999999, t)) | 0) + r) * n;
            };
          },
        }),
    (Wa.ease = jh["quad.out"]),
    Ll(
      "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
      function (t) {
        return (Pl += t + "," + t + "Params,");
      }
    );
  var iu = function (t, e) {
      (this.id = Za++),
        (t._gsap = this),
        (this.target = t),
        (this.harness = e),
        (this.get = e ? e.get : Dl),
        (this.set = e ? e.getSetter : bu);
    },
    ru = (function () {
      function t(t) {
        (this.vars = t),
          (this._delay = +t.delay || 0),
          (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
            ((this._rDelay = t.repeatDelay || 0),
            (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
          (this._ts = 1),
          dh(this, +t.duration, 1, 1),
          (this.data = t.data),
          Sa || Xh.wake();
      }
      var e = t.prototype;
      return (
        (e.delay = function (t) {
          return t || 0 === t
            ? (this.parent &&
                this.parent.smoothChildTiming &&
                this.startTime(this._start + t - this._delay),
              (this._delay = t),
              this)
            : this._delay;
        }),
        (e.duration = function (t) {
          return arguments.length
            ? this.totalDuration(
                this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
              )
            : this.totalDuration() && this._dur;
        }),
        (e.totalDuration = function (t) {
          return arguments.length
            ? ((this._dirty = 0),
              dh(
                this,
                this._repeat < 0
                  ? t
                  : (t - this._repeat * this._rDelay) / (this._repeat + 1)
              ))
            : this._tDur;
        }),
        (e.totalTime = function (t, e) {
          if ((Wh(), !arguments.length)) return this._tTime;
          var n = this._dp;
          if (n && n.smoothChildTiming && this._ts) {
            for (
              sh(this, t), !n._dp || n.parent || oh(n, this);
              n && n.parent;

            )
              n.parent._time !==
                n._start +
                  (n._ts >= 0
                    ? n._tTime / n._ts
                    : (n.totalDuration() - n._tTime) / -n._ts) &&
                n.totalTime(n._tTime, !0),
                (n = n.parent);
            !this.parent &&
              this._dp.autoRemoveChildren &&
              ((this._ts > 0 && t < this._tDur) ||
                (this._ts < 0 && t > 0) ||
                (!this._tDur && !t)) &&
              ah(this._dp, this, this._start - this._delay);
          }
          return (
            (this._tTime !== t ||
              (!this._dur && !e) ||
              (this._initted && Math.abs(this._zTime) === Ya) ||
              (!t && !this._initted && (this.add || this._ptLookup))) &&
              (this._ts || (this._pTime = t), Hl(this, t, e)),
            this
          );
        }),
        (e.time = function (t, e) {
          return arguments.length
            ? this.totalTime(
                Math.min(this.totalDuration(), t + eh(this)) %
                  (this._dur + this._rDelay) || (t ? this._dur : 0),
                e
              )
            : this._time;
        }),
        (e.totalProgress = function (t, e) {
          return arguments.length
            ? this.totalTime(this.totalDuration() * t, e)
            : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.ratio;
        }),
        (e.progress = function (t, e) {
          return arguments.length
            ? this.totalTime(
                this.duration() *
                  (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                  eh(this),
                e
              )
            : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.ratio;
        }),
        (e.iteration = function (t, e) {
          var n = this.duration() + this._rDelay;
          return arguments.length
            ? this.totalTime(this._time + (t - 1) * n, e)
            : this._repeat
            ? nh(this._tTime, n) + 1
            : 1;
        }),
        (e.timeScale = function (t) {
          if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
          if (this._rts === t) return this;
          var e =
            this.parent && this._ts ? ih(this.parent._time, this) : this._tTime;
          return (
            (this._rts = +t || 0),
            (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
            this.totalTime(vh(-this._delay, this._tDur, e), !0),
            rh(this),
            Ql(this)
          );
        }),
        (e.paused = function (t) {
          return arguments.length
            ? (this._ps !== t &&
                ((this._ps = t),
                t
                  ? ((this._pTime =
                      this._tTime || Math.max(-this._delay, this.rawTime())),
                    (this._ts = this._act = 0))
                  : (Wh(),
                    (this._ts = this._rts),
                    this.totalTime(
                      this.parent && !this.parent.smoothChildTiming
                        ? this.rawTime()
                        : this._tTime || this._pTime,
                      1 === this.progress() &&
                        Math.abs(this._zTime) !== Ya &&
                        (this._tTime -= Ya)
                    ))),
              this)
            : this._ps;
        }),
        (e.startTime = function (t) {
          if (arguments.length) {
            this._start = t;
            var e = this.parent || this._dp;
            return (
              e && (e._sort || !this.parent) && ah(e, this, t - this._delay),
              this
            );
          }
          return this._start;
        }),
        (e.endTime = function (t) {
          return (
            this._start +
            (sl(t) ? this.totalDuration() : this.duration()) /
              Math.abs(this._ts || 1)
          );
        }),
        (e.rawTime = function (t) {
          var e = this.parent || this._dp;
          return e
            ? t &&
              (!this._ts ||
                (this._repeat && this._time && this.totalProgress() < 1))
              ? this._tTime % (this._dur + this._rDelay)
              : this._ts
              ? ih(e.rawTime(t), this)
              : this._tTime
            : this._tTime;
        }),
        (e.globalTime = function (t) {
          for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
            (n = e._start + n / (e._ts || 1)), (e = e._dp);
          return n;
        }),
        (e.repeat = function (t) {
          return arguments.length
            ? ((this._repeat = t === 1 / 0 ? -2 : t), ph(this))
            : -2 === this._repeat
            ? 1 / 0
            : this._repeat;
        }),
        (e.repeatDelay = function (t) {
          if (arguments.length) {
            var e = this._time;
            return (this._rDelay = t), ph(this), e ? this.time(e) : this;
          }
          return this._rDelay;
        }),
        (e.yoyo = function (t) {
          return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
        }),
        (e.seek = function (t, e) {
          return this.totalTime(mh(this, t), sl(e));
        }),
        (e.restart = function (t, e) {
          return this.play().totalTime(t ? -this._delay : 0, sl(e));
        }),
        (e.play = function (t, e) {
          return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
        }),
        (e.reverse = function (t, e) {
          return (
            null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
          );
        }),
        (e.pause = function (t, e) {
          return null != t && this.seek(t, e), this.paused(!0);
        }),
        (e.resume = function () {
          return this.paused(!1);
        }),
        (e.reversed = function (t) {
          return arguments.length
            ? (!!t !== this.reversed() &&
                this.timeScale(-this._rts || (t ? -1e-8 : 0)),
              this)
            : this._rts < 0;
        }),
        (e.invalidate = function () {
          return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
        }),
        (e.isActive = function () {
          var t,
            e = this.parent || this._dp,
            n = this._start;
          return !(
            e &&
            !(
              this._ts &&
              this._initted &&
              e.isActive() &&
              (t = e.rawTime(!0)) >= n &&
              t < this.endTime(!0) - Ya
            )
          );
        }),
        (e.eventCallback = function (t, e, n) {
          var i = this.vars;
          return arguments.length > 1
            ? (e
                ? ((i[t] = e),
                  n && (i[t + "Params"] = n),
                  "onUpdate" === t && (this._onUpdate = e))
                : delete i[t],
              this)
            : i[t];
        }),
        (e.then = function (t) {
          var e = this;
          return new Promise(function (n) {
            var i = el(t) ? t : Vl,
              r = function () {
                var t = e.then;
                (e.then = null),
                  el(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                  n(i),
                  (e.then = t);
              };
            (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
            (!e._tTime && e._ts < 0)
              ? r()
              : (e._prom = r);
          });
        }),
        (e.kill = function () {
          Nh(this);
        }),
        t
      );
    })();
  Xl(ru.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1,
  });
  var su = (function (t) {
    function e(e, n) {
      var i;
      return (
        void 0 === e && (e = {}),
        ((i = t.call(this, e) || this).labels = {}),
        (i.smoothChildTiming = !!e.smoothChildTiming),
        (i.autoRemoveChildren = !!e.autoRemoveChildren),
        (i._sort = sl(e.sortChildren)),
        ga && ah(e.parent || ga, fa(i), n),
        e.reversed && i.reverse(),
        e.paused && i.paused(!0),
        e.scrollTrigger && lh(fa(i), e.scrollTrigger),
        i
      );
    }
    ma(e, t);
    var n = e.prototype;
    return (
      (n.to = function (t, e, n) {
        return _h(0, arguments, this), this;
      }),
      (n.from = function (t, e, n) {
        return _h(1, arguments, this), this;
      }),
      (n.fromTo = function (t, e, n, i) {
        return _h(2, arguments, this), this;
      }),
      (n.set = function (t, e, n) {
        return (
          (e.duration = 0),
          (e.parent = this),
          ql(e).repeatDelay || (e.repeat = 0),
          (e.immediateRender = !!e.immediateRender),
          new _u(t, e, mh(this, n), 1),
          this
        );
      }),
      (n.call = function (t, e, n) {
        return ah(this, _u.delayedCall(0, t, e), n);
      }),
      (n.staggerTo = function (t, e, n, i, r, s, o) {
        return (
          (n.duration = e),
          (n.stagger = n.stagger || i),
          (n.onComplete = s),
          (n.onCompleteParams = o),
          (n.parent = this),
          new _u(t, n, mh(this, r)),
          this
        );
      }),
      (n.staggerFrom = function (t, e, n, i, r, s, o) {
        return (
          (n.runBackwards = 1),
          (ql(n).immediateRender = sl(n.immediateRender)),
          this.staggerTo(t, e, n, i, r, s, o)
        );
      }),
      (n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
        return (
          (i.startAt = n),
          (ql(i).immediateRender = sl(i.immediateRender)),
          this.staggerTo(t, e, i, r, s, o, a)
        );
      }),
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          o,
          a,
          l,
          h,
          u,
          c,
          d,
          p,
          f,
          m = this._time,
          _ = this._dirty ? this.totalDuration() : this._tDur,
          g = this._dur,
          v = t <= 0 ? 0 : Ul(t),
          y = this._zTime < 0 != t < 0 && (this._initted || !g);
        if (
          (this !== ga && v > _ && t >= 0 && (v = _),
          v !== this._tTime || n || y)
        ) {
          if (
            (m !== this._time &&
              g &&
              ((v += this._time - m), (t += this._time - m)),
            (i = v),
            (c = this._start),
            (l = !(u = this._ts)),
            y && (g || (m = this._zTime), (t || !e) && (this._zTime = t)),
            this._repeat)
          ) {
            if (
              ((p = this._yoyo),
              (a = g + this._rDelay),
              this._repeat < -1 && t < 0)
            )
              return this.totalTime(100 * a + t, e, n);
            if (
              ((i = Ul(v % a)),
              v === _
                ? ((o = this._repeat), (i = g))
                : ((o = ~~(v / a)) && o === v / a && ((i = g), o--),
                  i > g && (i = g)),
              (d = nh(this._tTime, a)),
              !m && this._tTime && d !== o && (d = o),
              p && 1 & o && ((i = g - i), (f = 1)),
              o !== d && !this._lock)
            ) {
              var x = p && 1 & d,
                b = x === (p && 1 & o);
              if (
                (o < d && (x = !x),
                (m = x ? 0 : g),
                (this._lock = 1),
                (this.render(m || (f ? 0 : Ul(o * a)), e, !g)._lock = 0),
                (this._tTime = v),
                !e && this.parent && Oh(this, "onRepeat"),
                this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
                (m && m !== this._time) ||
                  l !== !this._ts ||
                  (this.vars.onRepeat && !this.parent && !this._act))
              )
                return this;
              if (
                ((g = this._dur),
                (_ = this._tDur),
                b &&
                  ((this._lock = 2),
                  (m = x ? g : -1e-4),
                  this.render(m, !0),
                  this.vars.repeatRefresh && !f && this.invalidate()),
                (this._lock = 0),
                !this._ts && !l)
              )
                return this;
              Jh(this, f);
            }
          }
          if (
            (this._hasPause &&
              !this._forcing &&
              this._lock < 2 &&
              ((h = (function (t, e, n) {
                var i;
                if (n > e)
                  for (i = t._first; i && i._start <= n; ) {
                    if ("isPause" === i.data && i._start > e) return i;
                    i = i._next;
                  }
                else
                  for (i = t._last; i && i._start >= n; ) {
                    if ("isPause" === i.data && i._start < e) return i;
                    i = i._prev;
                  }
              })(this, Ul(m), Ul(i))),
              h && (v -= i - (i = h._start))),
            (this._tTime = v),
            (this._time = i),
            (this._act = !u),
            this._initted ||
              ((this._onUpdate = this.vars.onUpdate),
              (this._initted = 1),
              (this._zTime = t),
              (m = 0)),
            !m && i && !e && (Oh(this, "onStart"), this._tTime !== v))
          )
            return this;
          if (i >= m && t >= 0)
            for (r = this._first; r; ) {
              if (
                ((s = r._next), (r._act || i >= r._start) && r._ts && h !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (i - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (i - r._start) * r._ts,
                    e,
                    n
                  ),
                  i !== this._time || (!this._ts && !l))
                ) {
                  (h = 0), s && (v += this._zTime = -1e-8);
                  break;
                }
              }
              r = s;
            }
          else {
            r = this._last;
            for (var T = t < 0 ? t : i; r; ) {
              if (
                ((s = r._prev), (r._act || T <= r._end) && r._ts && h !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (T - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (T - r._start) * r._ts,
                    e,
                    n
                  ),
                  i !== this._time || (!this._ts && !l))
                ) {
                  (h = 0), s && (v += this._zTime = T ? -1e-8 : Ya);
                  break;
                }
              }
              r = s;
            }
          }
          if (
            h &&
            !e &&
            (this.pause(),
            (h.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1),
            this._ts)
          )
            return (this._start = c), rh(this), this.render(t, e, n);
          this._onUpdate && !e && Oh(this, "onUpdate", !0),
            ((v === _ && this._tTime >= this.totalDuration()) || (!v && m)) &&
              ((c !== this._start && Math.abs(u) === Math.abs(this._ts)) ||
                this._lock ||
                ((t || !g) &&
                  ((v === _ && this._ts > 0) || (!v && this._ts < 0)) &&
                  Jl(this, 1),
                e ||
                  (t < 0 && !m) ||
                  (!v && !m && _) ||
                  (Oh(
                    this,
                    v === _ && t >= 0 ? "onComplete" : "onReverseComplete",
                    !0
                  ),
                  this._prom &&
                    !(v < _ && this.timeScale() > 0) &&
                    this._prom())));
        }
        return this;
      }),
      (n.add = function (t, e) {
        var n = this;
        if ((nl(e) || (e = mh(this, e, t)), !(t instanceof ru))) {
          if (hl(t))
            return (
              t.forEach(function (t) {
                return n.add(t, e);
              }),
              this
            );
          if (tl(t)) return this.addLabel(t, e);
          if (!el(t)) return this;
          t = _u.delayedCall(0, t);
        }
        return this !== t ? ah(this, t, e) : this;
      }),
      (n.getChildren = function (t, e, n, i) {
        void 0 === t && (t = !0),
          void 0 === e && (e = !0),
          void 0 === n && (n = !0),
          void 0 === i && (i = -1e8);
        for (var r = [], s = this._first; s; )
          s._start >= i &&
            (s instanceof _u
              ? e && r.push(s)
              : (n && r.push(s),
                t && r.push.apply(r, s.getChildren(!0, e, n)))),
            (s = s._next);
        return r;
      }),
      (n.getById = function (t) {
        for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
          if (e[n].vars.id === t) return e[n];
      }),
      (n.remove = function (t) {
        return tl(t)
          ? this.removeLabel(t)
          : el(t)
          ? this.killTweensOf(t)
          : (Zl(this, t),
            t === this._recent && (this._recent = this._last),
            $l(this));
      }),
      (n.totalTime = function (e, n) {
        return arguments.length
          ? ((this._forcing = 1),
            !this._dp &&
              this._ts &&
              (this._start = Ul(
                Xh.time -
                  (this._ts > 0
                    ? e / this._ts
                    : (this.totalDuration() - e) / -this._ts)
              )),
            t.prototype.totalTime.call(this, e, n),
            (this._forcing = 0),
            this)
          : this._tTime;
      }),
      (n.addLabel = function (t, e) {
        return (this.labels[t] = mh(this, e)), this;
      }),
      (n.removeLabel = function (t) {
        return delete this.labels[t], this;
      }),
      (n.addPause = function (t, e, n) {
        var i = _u.delayedCall(0, e || El, n);
        return (
          (i.data = "isPause"), (this._hasPause = 1), ah(this, i, mh(this, t))
        );
      }),
      (n.removePause = function (t) {
        var e = this._first;
        for (t = mh(this, t); e; )
          e._start === t && "isPause" === e.data && Jl(e), (e = e._next);
      }),
      (n.killTweensOf = function (t, e, n) {
        for (var i = this.getTweensOf(t, n), r = i.length; r--; )
          ou !== i[r] && i[r].kill(t, e);
        return this;
      }),
      (n.getTweensOf = function (t, e) {
        for (var n, i = [], r = Th(t), s = this._first, o = nl(e); s; )
          s instanceof _u
            ? kl(s._targets, r) &&
              (o
                ? (!ou || (s._initted && s._ts)) &&
                  s.globalTime(0) <= e &&
                  s.globalTime(s.totalDuration()) > e
                : !e || s.isActive()) &&
              i.push(s)
            : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
            (s = s._next);
        return i;
      }),
      (n.tweenTo = function (t, e) {
        e = e || {};
        var n,
          i = this,
          r = mh(i, t),
          s = e,
          o = s.startAt,
          a = s.onStart,
          l = s.onStartParams,
          h = s.immediateRender,
          u = _u.to(
            i,
            Xl(
              {
                ease: e.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration:
                  e.duration ||
                  Math.abs(
                    (r - (o && "time" in o ? o.time : i._time)) / i.timeScale()
                  ) ||
                  Ya,
                onStart: function () {
                  if ((i.pause(), !n)) {
                    var t =
                      e.duration ||
                      Math.abs(
                        (r - (o && "time" in o ? o.time : i._time)) /
                          i.timeScale()
                      );
                    u._dur !== t && dh(u, t, 0, 1).render(u._time, !0, !0),
                      (n = 1);
                  }
                  a && a.apply(u, l || []);
                },
              },
              e
            )
          );
        return h ? u.render(0) : u;
      }),
      (n.tweenFromTo = function (t, e, n) {
        return this.tweenTo(e, Xl({ startAt: { time: mh(this, t) } }, n));
      }),
      (n.recent = function () {
        return this._recent;
      }),
      (n.nextLabel = function (t) {
        return void 0 === t && (t = this._time), Ph(this, mh(this, t));
      }),
      (n.previousLabel = function (t) {
        return void 0 === t && (t = this._time), Ph(this, mh(this, t), 1);
      }),
      (n.currentLabel = function (t) {
        return arguments.length
          ? this.seek(t, !0)
          : this.previousLabel(this._time + Ya);
      }),
      (n.shiftChildren = function (t, e, n) {
        void 0 === n && (n = 0);
        for (var i, r = this._first, s = this.labels; r; )
          r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
        if (e) for (i in s) s[i] >= n && (s[i] += t);
        return $l(this);
      }),
      (n.invalidate = function () {
        var e = this._first;
        for (this._lock = 0; e; ) e.invalidate(), (e = e._next);
        return t.prototype.invalidate.call(this);
      }),
      (n.clear = function (t) {
        void 0 === t && (t = !0);
        for (var e, n = this._first; n; )
          (e = n._next), this.remove(n), (n = e);
        return (
          this._dp && (this._time = this._tTime = this._pTime = 0),
          t && (this.labels = {}),
          $l(this)
        );
      }),
      (n.totalDuration = function (t) {
        var e,
          n,
          i,
          r = 0,
          s = this,
          o = s._last,
          a = ja;
        if (arguments.length)
          return s.timeScale(
            (s._repeat < 0 ? s.duration() : s.totalDuration()) /
              (s.reversed() ? -t : t)
          );
        if (s._dirty) {
          for (i = s.parent; o; )
            (e = o._prev),
              o._dirty && o.totalDuration(),
              (n = o._start) > a && s._sort && o._ts && !s._lock
                ? ((s._lock = 1), (ah(s, o, n - o._delay, 1)._lock = 0))
                : (a = n),
              n < 0 &&
                o._ts &&
                ((r -= n),
                ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                  ((s._start += n / s._ts), (s._time -= n), (s._tTime -= n)),
                s.shiftChildren(-n, !1, -1 / 0),
                (a = 0)),
              o._end > r && o._ts && (r = o._end),
              (o = e);
          dh(s, s === ga && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
        }
        return s._tDur;
      }),
      (e.updateRoot = function (t) {
        if ((ga._ts && (Hl(ga, ih(t, ga)), (Ta = Xh.frame)), Xh.frame >= Cl)) {
          Cl += Xa.autoSleep || 120;
          var e = ga._first;
          if ((!e || !e._ts) && Xa.autoSleep && Xh._listeners.length < 2) {
            for (; e && !e._ts; ) e = e._next;
            e || Xh.sleep();
          }
        }
      }),
      e
    );
  })(ru);
  Xl(su.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
  var ou,
    au,
    lu = function (t, e, n, i, r, s, o) {
      var a,
        l,
        h,
        u,
        c,
        d,
        p,
        f,
        m = new Iu(this._pt, t, e, 0, 1, Su, null, r),
        _ = 0,
        g = 0;
      for (
        m.b = n,
          m.e = i,
          n += "",
          (p = ~(i += "").indexOf("random(")) && (i = Ch(i)),
          s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
          l = n.match(pl) || [];
        (a = pl.exec(i));

      )
        (u = a[0]),
          (c = i.substring(_, a.index)),
          h ? (h = (h + 1) % 5) : "rgba(" === c.substr(-5) && (h = 1),
          u !== l[g++] &&
            ((d = parseFloat(l[g - 1]) || 0),
            (m._pt = {
              _next: m._pt,
              p: c || 1 === g ? c : ",",
              s: d,
              c: "=" === u.charAt(1) ? Bl(d, u) - d : parseFloat(u) - d,
              m: h && h < 4 ? Math.round : 0,
            }),
            (_ = pl.lastIndex));
      return (
        (m.c = _ < i.length ? i.substring(_, i.length) : ""),
        (m.fp = o),
        (fl.test(i) || p) && (m.e = 0),
        (this._pt = m),
        m
      );
    },
    hu = function (t, e, n, i, r, s, o, a, l) {
      el(i) && (i = i(r || 0, t, s));
      var h,
        u = t[e],
        c =
          "get" !== n
            ? n
            : el(u)
            ? l
              ? t[
                  e.indexOf("set") || !el(t["get" + e.substr(3)])
                    ? e
                    : "get" + e.substr(3)
                ](l)
              : t[e]()
            : u,
        d = el(u) ? (l ? yu : vu) : gu;
      if (
        (tl(i) &&
          (~i.indexOf("random(") && (i = Ch(i)),
          "=" === i.charAt(1) &&
            ((h = Bl(c, i) + (yh(c) || 0)) || 0 === h) &&
            (i = h)),
        c !== i || au)
      )
        return isNaN(c * i) || "" === i
          ? (!u && !(e in t) && xl(e, i),
            lu.call(this, t, e, c, i, d, a || Xa.stringFilter, l))
          : ((h = new Iu(
              this._pt,
              t,
              e,
              +c || 0,
              i - (c || 0),
              "boolean" == typeof u ? Eu : Tu,
              0,
              d
            )),
            l && (h.fp = l),
            o && h.modifier(o, this, t),
            (this._pt = h));
    },
    uu = function (t, e, n, i, r, s) {
      var o, a, l, h;
      if (
        Al[t] &&
        !1 !==
          (o = new Al[t]()).init(
            r,
            o.rawVars
              ? e[t]
              : (function (t, e, n, i, r) {
                  if (
                    (el(t) && (t = pu(t, r, e, n, i)),
                    !rl(t) || (t.style && t.nodeType) || hl(t) || ll(t))
                  )
                    return tl(t) ? pu(t, r, e, n, i) : t;
                  var s,
                    o = {};
                  for (s in t) o[s] = pu(t[s], r, e, n, i);
                  return o;
                })(e[t], i, r, s, n),
            n,
            i,
            s
          ) &&
        ((n._pt = a = new Iu(n._pt, r, t, 0, 1, o.render, o, 0, o.priority)),
        n !== Ea)
      )
        for (l = n._ptLookup[n._targets.indexOf(r)], h = o._props.length; h--; )
          l[o._props[h]] = a;
      return o;
    },
    cu = function t(e, n) {
      var i,
        r,
        s,
        o,
        a,
        l,
        h,
        u,
        c,
        d,
        p,
        f,
        m,
        _ = e.vars,
        g = _.ease,
        v = _.startAt,
        y = _.immediateRender,
        x = _.lazy,
        b = _.onUpdate,
        T = _.onUpdateParams,
        E = _.callbackScope,
        S = _.runBackwards,
        w = _.yoyoEase,
        M = _.keyframes,
        A = _.autoRevert,
        R = e._dur,
        C = e._startAt,
        I = e._targets,
        P = e.parent,
        O = P && "nested" === P.data ? P.parent._targets : I,
        N = "auto" === e._overwrite && !_a,
        D = e.timeline;
      if (
        (D && (!M || !g) && (g = "none"),
        (e._ease = $h(g, Wa.ease)),
        (e._yEase = w ? Zh($h(!0 === w ? g : w, Wa.ease)) : 0),
        w &&
          e._yoyo &&
          !e._repeat &&
          ((w = e._yEase), (e._yEase = e._ease), (e._ease = w)),
        (e._from = !D && !!_.runBackwards),
        !D || (M && !_.stagger))
      ) {
        if (
          ((f = (u = I[0] ? Nl(I[0]).harness : 0) && _[u.prop]),
          (i = Yl(_, Sl)),
          C && (Jl(C.render(-1, !0)), (C._lazy = 0)),
          v)
        )
          if (
            (Jl(
              (e._startAt = _u.set(
                I,
                Xl(
                  {
                    data: "isStart",
                    overwrite: !1,
                    parent: P,
                    immediateRender: !0,
                    lazy: sl(x),
                    startAt: null,
                    delay: 0,
                    onUpdate: b,
                    onUpdateParams: T,
                    callbackScope: E,
                    stagger: 0,
                  },
                  v
                )
              ))
            ),
            n < 0 && !y && !A && e._startAt.render(-1, !0),
            y)
          ) {
            if ((n > 0 && !A && (e._startAt = 0), R && n <= 0))
              return void (n && (e._zTime = n));
          } else !1 === A && (e._startAt = 0);
        else if (S && R)
          if (C) !A && (e._startAt = 0);
          else if (
            (n && (y = !1),
            (s = Xl(
              {
                overwrite: !1,
                data: "isFromStart",
                lazy: y && sl(x),
                immediateRender: y,
                stagger: 0,
                parent: P,
              },
              i
            )),
            f && (s[u.prop] = f),
            Jl((e._startAt = _u.set(I, s))),
            n < 0 && e._startAt.render(-1, !0),
            (e._zTime = n),
            y)
          ) {
            if (!n) return;
          } else t(e._startAt, Ya);
        for (
          e._pt = e._ptCache = 0, x = (R && sl(x)) || (x && !R), r = 0;
          r < I.length;
          r++
        ) {
          if (
            ((h = (a = I[r])._gsap || Ol(I)[r]._gsap),
            (e._ptLookup[r] = d = {}),
            Ml[h.id] && wl.length && Gl(),
            (p = O === I ? r : O.indexOf(a)),
            u &&
              !1 !== (c = new u()).init(a, f || i, e, p, O) &&
              ((e._pt = o =
                new Iu(e._pt, a, c.name, 0, 1, c.render, c, 0, c.priority)),
              c._props.forEach(function (t) {
                d[t] = o;
              }),
              c.priority && (l = 1)),
            !u || f)
          )
            for (s in i)
              Al[s] && (c = uu(s, i, e, p, a, O))
                ? c.priority && (l = 1)
                : (d[s] = o =
                    hu.call(e, a, s, "get", i[s], p, O, 0, _.stringFilter));
          e._op && e._op[r] && e.kill(a, e._op[r]),
            N &&
              e._pt &&
              ((ou = e),
              ga.killTweensOf(a, d, e.globalTime(n)),
              (m = !e.parent),
              (ou = 0)),
            e._pt && x && (Ml[h.id] = 1);
        }
        l && Cu(e), e._onInit && e._onInit(e);
      }
      (e._onUpdate = b),
        (e._initted = (!e._op || e._pt) && !m),
        M && n <= 0 && D.render(ja, !0, !0);
    },
    du = function (t, e, n, i) {
      var r,
        s,
        o = e.ease || i || "power1.inOut";
      if (hl(e))
        (s = n[t] || (n[t] = [])),
          e.forEach(function (t, n) {
            return s.push({ t: (n / (e.length - 1)) * 100, v: t, e: o });
          });
      else
        for (r in e)
          (s = n[r] || (n[r] = [])),
            "ease" === r || s.push({ t: parseFloat(t), v: e[r], e: o });
    },
    pu = function (t, e, n, i, r) {
      return el(t)
        ? t.call(e, n, i, r)
        : tl(t) && ~t.indexOf("random(")
        ? Ch(t)
        : t;
    },
    fu = Pl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    mu = {};
  Ll(fu + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) {
    return (mu[t] = 1);
  });
  var _u = (function (t) {
    function e(e, n, i, r) {
      var s;
      "number" == typeof n && ((i.duration = n), (n = i), (i = null));
      var o,
        a,
        l,
        h,
        u,
        c,
        d,
        p,
        f = (s = t.call(this, r ? n : ql(n)) || this).vars,
        m = f.duration,
        _ = f.delay,
        g = f.immediateRender,
        v = f.stagger,
        y = f.overwrite,
        x = f.keyframes,
        b = f.defaults,
        T = f.scrollTrigger,
        E = f.yoyoEase,
        S = n.parent || ga,
        w = (hl(e) || ll(e) ? nl(e[0]) : "length" in n) ? [e] : Th(e);
      if (
        ((s._targets = w.length
          ? Ol(w)
          : bl(
              "GSAP target " + e + " not found. https://greensock.com",
              !Xa.nullTargetWarn
            ) || []),
        (s._ptLookup = []),
        (s._overwrite = y),
        x || v || al(m) || al(_))
      ) {
        if (
          ((n = s.vars),
          (o = s.timeline =
            new su({ data: "nested", defaults: b || {} })).kill(),
          (o.parent = o._dp = fa(s)),
          (o._start = 0),
          v || al(m) || al(_))
        ) {
          if (((h = w.length), (d = v && Sh(v)), rl(v)))
            for (u in v) ~fu.indexOf(u) && (p || (p = {}), (p[u] = v[u]));
          for (a = 0; a < h; a++)
            ((l = Yl(n, mu)).stagger = 0),
              E && (l.yoyoEase = E),
              p && Wl(l, p),
              (c = w[a]),
              (l.duration = +pu(m, fa(s), a, c, w)),
              (l.delay = (+pu(_, fa(s), a, c, w) || 0) - s._delay),
              !v &&
                1 === h &&
                l.delay &&
                ((s._delay = _ = l.delay), (s._start += _), (l.delay = 0)),
              o.to(c, l, d ? d(a, c, w) : 0),
              (o._ease = jh.none);
          o.duration() ? (m = _ = 0) : (s.timeline = 0);
        } else if (x) {
          ql(Xl(o.vars.defaults, { ease: "none" })),
            (o._ease = $h(x.ease || n.ease || "none"));
          var M,
            A,
            R,
            C = 0;
          if (hl(x))
            x.forEach(function (t) {
              return o.to(w, t, ">");
            });
          else {
            for (u in ((l = {}), x))
              "ease" === u || "easeEach" === u || du(u, x[u], l, x.easeEach);
            for (u in l)
              for (
                M = l[u].sort(function (t, e) {
                  return t.t - e.t;
                }),
                  C = 0,
                  a = 0;
                a < M.length;
                a++
              )
                ((R = {
                  ease: (A = M[a]).e,
                  duration: ((A.t - (a ? M[a - 1].t : 0)) / 100) * m,
                })[u] = A.v),
                  o.to(w, R, C),
                  (C += R.duration);
            o.duration() < m && o.to({}, { duration: m - o.duration() });
          }
        }
        m || s.duration((m = o.duration()));
      } else s.timeline = 0;
      return (
        !0 !== y || _a || ((ou = fa(s)), ga.killTweensOf(w), (ou = 0)),
        ah(S, fa(s), i),
        n.reversed && s.reverse(),
        n.paused && s.paused(!0),
        (g ||
          (!m &&
            !x &&
            s._start === Ul(S._time) &&
            sl(g) &&
            th(fa(s)) &&
            "nested" !== S.data)) &&
          ((s._tTime = -1e-8), s.render(Math.max(0, -_))),
        T && lh(fa(s), T),
        s
      );
    }
    ma(e, t);
    var n = e.prototype;
    return (
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          o,
          a,
          l,
          h,
          u,
          c,
          d = this._time,
          p = this._tDur,
          f = this._dur,
          m = t > p - Ya && t >= 0 ? p : t < Ya ? 0 : t;
        if (f) {
          if (
            m !== this._tTime ||
            !t ||
            n ||
            (!this._initted && this._tTime) ||
            (this._startAt && this._zTime < 0 != t < 0)
          ) {
            if (((i = m), (u = this.timeline), this._repeat)) {
              if (((o = f + this._rDelay), this._repeat < -1 && t < 0))
                return this.totalTime(100 * o + t, e, n);
              if (
                ((i = Ul(m % o)),
                m === p
                  ? ((s = this._repeat), (i = f))
                  : ((s = ~~(m / o)) && s === m / o && ((i = f), s--),
                    i > f && (i = f)),
                (l = this._yoyo && 1 & s) && ((c = this._yEase), (i = f - i)),
                (a = nh(this._tTime, o)),
                i === d && !n && this._initted)
              )
                return (this._tTime = m), this;
              s !== a &&
                (u && this._yEase && Jh(u, l),
                !this.vars.repeatRefresh ||
                  l ||
                  this._lock ||
                  ((this._lock = n = 1),
                  (this.render(Ul(o * s), !0).invalidate()._lock = 0)));
            }
            if (!this._initted) {
              if (hh(this, t < 0 ? t : i, n, e)) return (this._tTime = 0), this;
              if (d !== this._time) return this;
              if (f !== this._dur) return this.render(t, e, n);
            }
            if (
              ((this._tTime = m),
              (this._time = i),
              !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
              (this.ratio = h = (c || this._ease)(i / f)),
              this._from && (this.ratio = h = 1 - h),
              i && !d && !e && (Oh(this, "onStart"), this._tTime !== m))
            )
              return this;
            for (r = this._pt; r; ) r.r(h, r.d), (r = r._next);
            (u &&
              u.render(
                t < 0 ? t : !i && l ? -1e-8 : u._dur * u._ease(i / this._dur),
                e,
                n
              )) ||
              (this._startAt && (this._zTime = t)),
              this._onUpdate &&
                !e &&
                (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                Oh(this, "onUpdate")),
              this._repeat &&
                s !== a &&
                this.vars.onRepeat &&
                !e &&
                this.parent &&
                Oh(this, "onRepeat"),
              (m !== this._tDur && m) ||
                this._tTime !== m ||
                (t < 0 &&
                  this._startAt &&
                  !this._onUpdate &&
                  this._startAt.render(t, !0, !0),
                (t || !f) &&
                  ((m === this._tDur && this._ts > 0) ||
                    (!m && this._ts < 0)) &&
                  Jl(this, 1),
                e ||
                  (t < 0 && !d) ||
                  (!m && !d) ||
                  (Oh(this, m === p ? "onComplete" : "onReverseComplete", !0),
                  this._prom &&
                    !(m < p && this.timeScale() > 0) &&
                    this._prom()));
          }
        } else
          !(function (t, e, n, i) {
            var r,
              s,
              o,
              a = t.ratio,
              l =
                e < 0 ||
                (!e &&
                  ((!t._start && uh(t) && (t._initted || !ch(t))) ||
                    ((t._ts < 0 || t._dp._ts < 0) && !ch(t))))
                  ? 0
                  : 1,
              h = t._rDelay,
              u = 0;
            if (
              (h &&
                t._repeat &&
                ((u = vh(0, t._tDur, e)),
                (s = nh(u, h)),
                t._yoyo && 1 & s && (l = 1 - l),
                s !== nh(t._tTime, h) &&
                  ((a = 1 - l),
                  t.vars.repeatRefresh && t._initted && t.invalidate())),
              l !== a || i || t._zTime === Ya || (!e && t._zTime))
            ) {
              if (!t._initted && hh(t, e, i, n)) return;
              for (
                o = t._zTime,
                  t._zTime = e || (n ? Ya : 0),
                  n || (n = e && !o),
                  t.ratio = l,
                  t._from && (l = 1 - l),
                  t._time = 0,
                  t._tTime = u,
                  r = t._pt;
                r;

              )
                r.r(l, r.d), (r = r._next);
              t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                t._onUpdate && !n && Oh(t, "onUpdate"),
                u && t._repeat && !n && t.parent && Oh(t, "onRepeat"),
                (e >= t._tDur || e < 0) &&
                  t.ratio === l &&
                  (l && Jl(t, 1),
                  n ||
                    (Oh(t, l ? "onComplete" : "onReverseComplete", !0),
                    t._prom && t._prom()));
            } else t._zTime || (t._zTime = e);
          })(this, t, e, n);
        return this;
      }),
      (n.targets = function () {
        return this._targets;
      }),
      (n.invalidate = function () {
        return (
          (this._pt =
            this._op =
            this._startAt =
            this._onUpdate =
            this._lazy =
            this.ratio =
              0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(),
          t.prototype.invalidate.call(this)
        );
      }),
      (n.resetTo = function (t, e, n, i) {
        Sa || Xh.wake(), this._ts || this.play();
        var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
        return (
          this._initted || cu(this, r),
          (function (t, e, n, i, r, s, o) {
            var a,
              l,
              h,
              u = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
            if (!u)
              for (
                u = t._ptCache[e] = [], l = t._ptLookup, h = t._targets.length;
                h--;

              ) {
                if ((a = l[h][e]) && a.d && a.d._pt)
                  for (a = a.d._pt; a && a.p !== e; ) a = a._next;
                if (!a)
                  return (au = 1), (t.vars[e] = "+=0"), cu(t, o), (au = 0), 1;
                u.push(a);
              }
            for (h = u.length; h--; )
              ((a = u[h]).s =
                (!i && 0 !== i) || r ? a.s + (i || 0) + s * a.c : i),
                (a.c = n - a.s),
                a.e && (a.e = Fl(n) + yh(a.e)),
                a.b && (a.b = a.s + yh(a.b));
          })(this, t, e, n, i, this._ease(r / this._dur), r)
            ? this.resetTo(t, e, n, i)
            : (sh(this, 0),
              this.parent ||
                Kl(
                  this._dp,
                  this,
                  "_first",
                  "_last",
                  this._dp._sort ? "_start" : 0
                ),
              this.render(0))
        );
      }),
      (n.kill = function (t, e) {
        if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
          return (this._lazy = this._pt = 0), this.parent ? Nh(this) : this;
        if (this.timeline) {
          var n = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(t, e, ou && !0 !== ou.vars.overwrite)
              ._first || Nh(this),
            this.parent &&
              n !== this.timeline.totalDuration() &&
              dh(this, (this._dur * this.timeline._tDur) / n, 0, 1),
            this
          );
        }
        var i,
          r,
          s,
          o,
          a,
          l,
          h,
          u = this._targets,
          c = t ? Th(t) : u,
          d = this._ptLookup,
          p = this._pt;
        if (
          (!e || "all" === e) &&
          (function (t, e) {
            for (
              var n = t.length, i = n === e.length;
              i && n-- && t[n] === e[n];

            );
            return n < 0;
          })(u, c)
        )
          return "all" === e && (this._pt = 0), Nh(this);
        for (
          i = this._op = this._op || [],
            "all" !== e &&
              (tl(e) &&
                ((a = {}),
                Ll(e, function (t) {
                  return (a[t] = 1);
                }),
                (e = a)),
              (e = (function (t, e) {
                var n,
                  i,
                  r,
                  s,
                  o = t[0] ? Nl(t[0]).harness : 0,
                  a = o && o.aliases;
                if (!a) return e;
                for (i in ((n = Wl({}, e)), a))
                  if ((i in n))
                    for (r = (s = a[i].split(",")).length; r--; )
                      n[s[r]] = n[i];
                return n;
              })(u, e))),
            h = u.length;
          h--;

        )
          if (~c.indexOf(u[h]))
            for (a in ((r = d[h]),
            "all" === e
              ? ((i[h] = e), (o = r), (s = {}))
              : ((s = i[h] = i[h] || {}), (o = e)),
            o))
              (l = r && r[a]) &&
                (("kill" in l.d && !0 !== l.d.kill(a)) || Zl(this, l, "_pt"),
                delete r[a]),
                "all" !== s && (s[a] = 1);
        return this._initted && !this._pt && p && Nh(this), this;
      }),
      (e.to = function (t, n) {
        return new e(t, n, arguments[2]);
      }),
      (e.from = function (t, e) {
        return _h(1, arguments);
      }),
      (e.delayedCall = function (t, n, i, r) {
        return new e(n, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: t,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: i,
          onReverseCompleteParams: i,
          callbackScope: r,
        });
      }),
      (e.fromTo = function (t, e, n) {
        return _h(2, arguments);
      }),
      (e.set = function (t, n) {
        return (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n);
      }),
      (e.killTweensOf = function (t, e, n) {
        return ga.killTweensOf(t, e, n);
      }),
      e
    );
  })(ru);
  Xl(_u.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }),
    Ll("staggerTo,staggerFrom,staggerFromTo", function (t) {
      _u[t] = function () {
        var e = new su(),
          n = xh.call(arguments, 0);
        return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
      };
    });
  var gu = function (t, e, n) {
      return (t[e] = n);
    },
    vu = function (t, e, n) {
      return t[e](n);
    },
    yu = function (t, e, n, i) {
      return t[e](i.fp, n);
    },
    xu = function (t, e, n) {
      return t.setAttribute(e, n);
    },
    bu = function (t, e) {
      return el(t[e]) ? vu : il(t[e]) && t.setAttribute ? xu : gu;
    },
    Tu = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
    },
    Eu = function (t, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * t), e);
    },
    Su = function (t, e) {
      var n = e._pt,
        i = "";
      if (!t && e.b) i = e.b;
      else if (1 === t && e.e) i = e.e;
      else {
        for (; n; )
          (i =
            n.p +
            (n.m
              ? n.m(n.s + n.c * t)
              : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
            i),
            (n = n._next);
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    },
    wu = function (t, e) {
      for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
    },
    Mu = function (t, e, n, i) {
      for (var r, s = this._pt; s; )
        (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
    },
    Au = function (t) {
      for (var e, n, i = this._pt; i; )
        (n = i._next),
          (i.p === t && !i.op) || i.op === t
            ? Zl(this, i, "_pt")
            : i.dep || (e = 1),
          (i = n);
      return !e;
    },
    Ru = function (t, e, n, i) {
      i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
    },
    Cu = function (t) {
      for (var e, n, i, r, s = t._pt; s; ) {
        for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
        (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
          (s._next = n) ? (n._prev = s) : (r = s),
          (s = e);
      }
      t._pt = i;
    },
    Iu = (function () {
      function t(t, e, n, i, r, s, o, a, l) {
        (this.t = e),
          (this.s = i),
          (this.c = r),
          (this.p = n),
          (this.r = s || Tu),
          (this.d = o || this),
          (this.set = a || gu),
          (this.pr = l || 0),
          (this._next = t),
          t && (t._prev = this);
      }
      return (
        (t.prototype.modifier = function (t, e, n) {
          (this.mSet = this.mSet || this.set),
            (this.set = Ru),
            (this.m = t),
            (this.mt = n),
            (this.tween = e);
        }),
        t
      );
    })();
  Ll(
    Pl +
      "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    function (t) {
      return (Sl[t] = 1);
    }
  ),
    (gl.TweenMax = gl.TweenLite = _u),
    (gl.TimelineLite = gl.TimelineMax = su),
    (ga = new su({
      sortChildren: !1,
      defaults: Wa,
      autoRemoveChildren: !0,
      id: "root",
      smoothChildTiming: !0,
    })),
    (Xa.stringFilter = Vh);
  var Pu = {
    registerPlugin: function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
      e.forEach(function (t) {
        return Dh(t);
      });
    },
    timeline: function (t) {
      return new su(t);
    },
    getTweensOf: function (t, e) {
      return ga.getTweensOf(t, e);
    },
    getProperty: function (t, e, n, i) {
      tl(t) && (t = Th(t)[0]);
      var r = Nl(t || {}).get,
        s = n ? Vl : zl;
      return (
        "native" === n && (n = ""),
        t
          ? e
            ? s(((Al[e] && Al[e].get) || r)(t, e, n, i))
            : function (e, n, i) {
                return s(((Al[e] && Al[e].get) || r)(t, e, n, i));
              }
          : t
      );
    },
    quickSetter: function (t, e, n) {
      if ((t = Th(t)).length > 1) {
        var i = t.map(function (t) {
            return Du.quickSetter(t, e, n);
          }),
          r = i.length;
        return function (t) {
          for (var e = r; e--; ) i[e](t);
        };
      }
      t = t[0] || {};
      var s = Al[e],
        o = Nl(t),
        a = (o.harness && (o.harness.aliases || {})[e]) || e,
        l = s
          ? function (e) {
              var i = new s();
              (Ea._pt = 0),
                i.init(t, n ? e + n : e, Ea, 0, [t]),
                i.render(1, i),
                Ea._pt && wu(1, Ea);
            }
          : o.set(t, a);
      return s
        ? l
        : function (e) {
            return l(t, a, n ? e + n : e, o, 1);
          };
    },
    quickTo: function (t, e, n) {
      var i,
        r = Du.to(
          t,
          Wl((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
        ),
        s = function (t, n, i) {
          return r.resetTo(e, t, n, i);
        };
      return (s.tween = r), s;
    },
    isTweening: function (t) {
      return ga.getTweensOf(t, !0).length > 0;
    },
    defaults: function (t) {
      return t && t.ease && (t.ease = $h(t.ease, Wa.ease)), jl(Wa, t || {});
    },
    config: function (t) {
      return jl(Xa, t || {});
    },
    registerEffect: function (t) {
      var e = t.name,
        n = t.effect,
        i = t.plugins,
        r = t.defaults,
        s = t.extendTimeline;
      (i || "").split(",").forEach(function (t) {
        return (
          t && !Al[t] && !gl[t] && bl(e + " effect requires " + t + " plugin.")
        );
      }),
        (Rl[e] = function (t, e, i) {
          return n(Th(t), Xl(e || {}, r), i);
        }),
        s &&
          (su.prototype[e] = function (t, n, i) {
            return this.add(Rl[e](t, rl(n) ? n : (i = n) && {}, this), i);
          });
    },
    registerEase: function (t, e) {
      jh[t] = $h(e);
    },
    parseEase: function (t, e) {
      return arguments.length ? $h(t, e) : jh;
    },
    getById: function (t) {
      return ga.getById(t);
    },
    exportRoot: function (t, e) {
      void 0 === t && (t = {});
      var n,
        i,
        r = new su(t);
      for (
        r.smoothChildTiming = sl(t.smoothChildTiming),
          ga.remove(r),
          r._dp = 0,
          r._time = r._tTime = ga._time,
          n = ga._first;
        n;

      )
        (i = n._next),
          (!e &&
            !n._dur &&
            n instanceof _u &&
            n.vars.onComplete === n._targets[0]) ||
            ah(r, n, n._start - n._delay),
          (n = i);
      return ah(ga, r, 0), r;
    },
    utils: {
      wrap: function t(e, n, i) {
        var r = n - e;
        return hl(e)
          ? Rh(e, t(0, e.length), n)
          : gh(i, function (t) {
              return ((r + ((t - e) % r)) % r) + e;
            });
      },
      wrapYoyo: function t(e, n, i) {
        var r = n - e,
          s = 2 * r;
        return hl(e)
          ? Rh(e, t(0, e.length - 1), n)
          : gh(i, function (t) {
              return e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t);
            });
      },
      distribute: Sh,
      random: Ah,
      snap: Mh,
      normalize: function (t, e, n) {
        return Ih(t, e, 0, 1, n);
      },
      getUnit: yh,
      clamp: function (t, e, n) {
        return gh(n, function (n) {
          return vh(t, e, n);
        });
      },
      splitColor: Bh,
      toArray: Th,
      selector: function (t) {
        return (
          (t = Th(t)[0] || bl("Invalid scope") || {}),
          function (e) {
            var n = t.current || t.nativeElement || t;
            return Th(
              e,
              n.querySelectorAll
                ? n
                : n === t
                ? bl("Invalid scope") || xa.createElement("div")
                : t
            );
          }
        );
      },
      mapRange: Ih,
      pipe: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return function (t) {
          return e.reduce(function (t, e) {
            return e(t);
          }, t);
        };
      },
      unitize: function (t, e) {
        return function (n) {
          return t(parseFloat(n)) + (e || yh(n));
        };
      },
      interpolate: function t(e, n, i, r) {
        var s = isNaN(e + n)
          ? 0
          : function (t) {
              return (1 - t) * e + t * n;
            };
        if (!s) {
          var o,
            a,
            l,
            h,
            u,
            c = tl(e),
            d = {};
          if ((!0 === i && (r = 1) && (i = null), c))
            (e = { p: e }), (n = { p: n });
          else if (hl(e) && !hl(n)) {
            for (l = [], h = e.length, u = h - 2, a = 1; a < h; a++)
              l.push(t(e[a - 1], e[a]));
            h--,
              (s = function (t) {
                t *= h;
                var e = Math.min(u, ~~t);
                return l[e](t - e);
              }),
              (i = n);
          } else r || (e = Wl(hl(e) ? [] : {}, e));
          if (!l) {
            for (o in n) hu.call(d, e, o, "get", n[o]);
            s = function (t) {
              return wu(t, d) || (c ? e.p : e);
            };
          }
        }
        return gh(i, s);
      },
      shuffle: Eh,
    },
    install: yl,
    effects: Rl,
    ticker: Xh,
    updateRoot: su.updateRoot,
    plugins: Al,
    globalTimeline: ga,
    core: {
      PropTween: Iu,
      globals: Tl,
      Tween: _u,
      Timeline: su,
      Animation: ru,
      getCache: Nl,
      _removeLinkedListItem: Zl,
      suppressOverwrites: function (t) {
        return (_a = t);
      },
    },
  };
  Ll("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
    return (Pu[t] = _u[t]);
  }),
    Xh.add(su.updateRoot),
    (Ea = Pu.to({}, { duration: 0 }));
  var Ou = function (t, e) {
      for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
        n = n._next;
      return n;
    },
    Nu = function (t, e) {
      return {
        name: t,
        rawVars: 1,
        init: function (t, n, i) {
          i._onInit = function (t) {
            var i, r;
            if (
              (tl(n) &&
                ((i = {}),
                Ll(n, function (t) {
                  return (i[t] = 1);
                }),
                (n = i)),
              e)
            ) {
              for (r in ((i = {}), n)) i[r] = e(n[r]);
              n = i;
            }
            !(function (t, e) {
              var n,
                i,
                r,
                s = t._targets;
              for (n in e)
                for (i = s.length; i--; )
                  (r = t._ptLookup[i][n]) &&
                    (r = r.d) &&
                    (r._pt && (r = Ou(r, n)),
                    r && r.modifier && r.modifier(e[n], t, s[i], n));
            })(t, n);
          };
        },
      };
    },
    Du =
      Pu.registerPlugin(
        {
          name: "attr",
          init: function (t, e, n, i, r) {
            var s, o;
            for (s in e)
              (o = this.add(
                t,
                "setAttribute",
                (t.getAttribute(s) || 0) + "",
                e[s],
                i,
                r,
                0,
                0,
                s
              )) && (o.op = s),
                this._props.push(s);
          },
        },
        {
          name: "endArray",
          init: function (t, e) {
            for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n]);
          },
        },
        Nu("roundProps", wh),
        Nu("modifiers"),
        Nu("snap", Mh)
      ) || Pu;
  (_u.version = su.version = Du.version = "3.10.4"),
    (ba = 1),
    ol() && Wh(),
    jh.Power0,
    jh.Power1,
    jh.Power2;
  var Lu = jh.Power3;
  jh.Power4,
    jh.Linear,
    jh.Quad,
    jh.Cubic,
    jh.Quart,
    jh.Quint,
    jh.Strong,
    jh.Elastic,
    jh.Back,
    jh.SteppedEase,
    jh.Bounce,
    jh.Sine,
    jh.Expo,
    jh.Circ;
  var Fu,
    Uu,
    Bu,
    ku,
    Gu,
    Hu,
    zu,
    Vu = {},
    Xu = 180 / Math.PI,
    Wu = Math.PI / 180,
    ju = Math.atan2,
    Yu = /([A-Z])/g,
    qu = /(left|right|width|margin|padding|x)/i,
    Ku = /[\s,\(]\S/,
    Zu = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity",
    },
    Ju = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
    },
    $u = function (t, e) {
      return e.set(
        e.t,
        e.p,
        1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
        e
      );
    },
    Qu = function (t, e) {
      return e.set(
        e.t,
        e.p,
        t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
        e
      );
    },
    tc = function (t, e) {
      var n = e.s + e.c * t;
      e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
    },
    ec = function (t, e) {
      return e.set(e.t, e.p, t ? e.e : e.b, e);
    },
    nc = function (t, e) {
      return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
    },
    ic = function (t, e, n) {
      return (t.style[e] = n);
    },
    rc = function (t, e, n) {
      return t.style.setProperty(e, n);
    },
    sc = function (t, e, n) {
      return (t._gsap[e] = n);
    },
    oc = function (t, e, n) {
      return (t._gsap.scaleX = t._gsap.scaleY = n);
    },
    ac = function (t, e, n, i, r) {
      var s = t._gsap;
      (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
    },
    lc = function (t, e, n, i, r) {
      var s = t._gsap;
      (s[e] = n), s.renderTransform(r, s);
    },
    hc = "transform",
    uc = hc + "Origin",
    cc = function (t, e) {
      var n = Uu.createElementNS
        ? Uu.createElementNS(
            (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
            t
          )
        : Uu.createElement(t);
      return n.style ? n : Uu.createElement(t);
    },
    dc = function t(e, n, i) {
      var r = getComputedStyle(e);
      return (
        r[n] ||
        r.getPropertyValue(n.replace(Yu, "-$1").toLowerCase()) ||
        r.getPropertyValue(n) ||
        (!i && t(e, fc(n) || n, 1)) ||
        ""
      );
    },
    pc = "O,Moz,ms,Ms,Webkit".split(","),
    fc = function (t, e, n) {
      var i = (e || Gu).style,
        r = 5;
      if (t in i && !n) return t;
      for (
        t = t.charAt(0).toUpperCase() + t.substr(1);
        r-- && !(pc[r] + t in i);

      );
      return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? pc[r] : "") + t;
    },
    mc = function () {
      "undefined" != typeof window &&
        window.document &&
        ((Fu = window),
        (Uu = Fu.document),
        (Bu = Uu.documentElement),
        (Gu = cc("div") || { style: {} }),
        cc("div"),
        (hc = fc(hc)),
        (uc = hc + "Origin"),
        (Gu.style.cssText =
          "border-width:0;line-height:0;position:absolute;padding:0"),
        (zu = !!fc("perspective")),
        (ku = 1));
    },
    _c = function t(e) {
      var n,
        i = cc(
          "svg",
          (this.ownerSVGElement &&
            this.ownerSVGElement.getAttribute("xmlns")) ||
            "http://www.w3.org/2000/svg"
        ),
        r = this.parentNode,
        s = this.nextSibling,
        o = this.style.cssText;
      if (
        (Bu.appendChild(i),
        i.appendChild(this),
        (this.style.display = "block"),
        e)
      )
        try {
          (n = this.getBBox()),
            (this._gsapBBox = this.getBBox),
            (this.getBBox = t);
        } catch (a) {}
      else this._gsapBBox && (n = this._gsapBBox());
      return (
        r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
        Bu.removeChild(i),
        (this.style.cssText = o),
        n
      );
    },
    gc = function (t, e) {
      for (var n = e.length; n--; )
        if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
    },
    vc = function (t) {
      var e;
      try {
        e = t.getBBox();
      } catch (n) {
        e = _c.call(t, !0);
      }
      return (
        (e && (e.width || e.height)) ||
          t.getBBox === _c ||
          (e = _c.call(t, !0)),
        !e || e.width || e.x || e.y
          ? e
          : {
              x: +gc(t, ["x", "cx", "x1"]) || 0,
              y: +gc(t, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0,
            }
      );
    },
    yc = function (t) {
      return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !vc(t));
    },
    xc = function (t, e) {
      if (e) {
        var n = t.style;
        e in Vu && e !== uc && (e = hc),
          n.removeProperty
            ? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) ||
                (e = "-" + e),
              n.removeProperty(e.replace(Yu, "-$1").toLowerCase()))
            : n.removeAttribute(e);
      }
    },
    bc = function (t, e, n, i, r, s) {
      var o = new Iu(t._pt, e, n, 0, 1, s ? nc : ec);
      return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o;
    },
    Tc = { deg: 1, rad: 1, turn: 1 },
    Ec = function t(e, n, i, r) {
      var s,
        o,
        a,
        l,
        h = parseFloat(i) || 0,
        u = (i + "").trim().substr((h + "").length) || "px",
        c = Gu.style,
        d = qu.test(n),
        p = "svg" === e.tagName.toLowerCase(),
        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
        m = 100,
        _ = "px" === r,
        g = "%" === r;
      return r === u || !h || Tc[r] || Tc[u]
        ? h
        : ("px" !== u && !_ && (h = t(e, n, i, "px")),
          (l = e.getCTM && yc(e)),
          (!g && "%" !== u) || (!Vu[n] && !~n.indexOf("adius"))
            ? ((c[d ? "width" : "height"] = m + (_ ? u : r)),
              (o =
                ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
                  ? e
                  : e.parentNode),
              l && (o = (e.ownerSVGElement || {}).parentNode),
              (o && o !== Uu && o.appendChild) || (o = Uu.body),
              (a = o._gsap) && g && a.width && d && a.time === Xh.time
                ? Fl((h / a.width) * m)
                : ((g || "%" === u) && (c.position = dc(e, "position")),
                  o === e && (c.position = "static"),
                  o.appendChild(Gu),
                  (s = Gu[f]),
                  o.removeChild(Gu),
                  (c.position = "absolute"),
                  d && g && (((a = Nl(o)).time = Xh.time), (a.width = o[f])),
                  Fl(_ ? (s * h) / m : s && h ? (m / s) * h : 0)))
            : ((s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
              Fl(g ? (h / s) * m : (h / 100) * s)));
    },
    Sc = function (t, e, n, i) {
      var r;
      return (
        ku || mc(),
        e in Zu &&
          "transform" !== e &&
          ~(e = Zu[e]).indexOf(",") &&
          (e = e.split(",")[0]),
        Vu[e] && "transform" !== e
          ? ((r = Lc(t, i)),
            (r =
              "transformOrigin" !== e
                ? r[e]
                : r.svg
                ? r.origin
                : Fc(dc(t, uc)) + " " + r.zOrigin + "px"))
          : (!(r = t.style[e]) ||
              "auto" === r ||
              i ||
              ~(r + "").indexOf("calc(")) &&
            (r =
              (Rc[e] && Rc[e](t, e, n)) ||
              dc(t, e) ||
              Dl(t, e) ||
              ("opacity" === e ? 1 : 0)),
        n && !~(r + "").trim().indexOf(" ") ? Ec(t, e, r, n) + n : r
      );
    },
    wc = function (t, e, n, i) {
      if (!n || "none" === n) {
        var r = fc(e, t, 1),
          s = r && dc(t, r, 1);
        s && s !== n
          ? ((e = r), (n = s))
          : "borderColor" === e && (n = dc(t, "borderTopColor"));
      }
      var o,
        a,
        l,
        h,
        u,
        c,
        d,
        p,
        f,
        m,
        _,
        g = new Iu(this._pt, t.style, e, 0, 1, Su),
        v = 0,
        y = 0;
      if (
        ((g.b = n),
        (g.e = i),
        (n += ""),
        "auto" === (i += "") &&
          ((t.style[e] = i), (i = dc(t, e) || i), (t.style[e] = n)),
        Vh((o = [n, i])),
        (i = o[1]),
        (l = (n = o[0]).match(dl) || []),
        (i.match(dl) || []).length)
      ) {
        for (; (a = dl.exec(i)); )
          (d = a[0]),
            (f = i.substring(v, a.index)),
            u
              ? (u = (u + 1) % 5)
              : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                (u = 1),
            d !== (c = l[y++] || "") &&
              ((h = parseFloat(c) || 0),
              (_ = c.substr((h + "").length)),
              "=" === d.charAt(1) && (d = Bl(h, d) + _),
              (p = parseFloat(d)),
              (m = d.substr((p + "").length)),
              (v = dl.lastIndex - m.length),
              m ||
                ((m = m || Xa.units[e] || _),
                v === i.length && ((i += m), (g.e += m))),
              _ !== m && (h = Ec(t, e, c, m) || 0),
              (g._pt = {
                _next: g._pt,
                p: f || 1 === y ? f : ",",
                s: h,
                c: p - h,
                m: (u && u < 4) || "zIndex" === e ? Math.round : 0,
              }));
        g.c = v < i.length ? i.substring(v, i.length) : "";
      } else g.r = "display" === e && "none" === i ? nc : ec;
      return fl.test(i) && (g.e = 0), (this._pt = g), g;
    },
    Mc = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%",
    },
    Ac = function (t, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var n,
          i,
          r,
          s = e.t,
          o = s.style,
          a = e.u,
          l = s._gsap;
        if ("all" === a || !0 === a) (o.cssText = ""), (i = 1);
        else
          for (r = (a = a.split(",")).length; --r > -1; )
            (n = a[r]),
              Vu[n] && ((i = 1), (n = "transformOrigin" === n ? uc : hc)),
              xc(s, n);
        i &&
          (xc(s, hc),
          l &&
            (l.svg && s.removeAttribute("transform"),
            Lc(s, 1),
            (l.uncache = 1)));
      }
    },
    Rc = {
      clearProps: function (t, e, n, i, r) {
        if ("isFromStart" !== r.data) {
          var s = (t._pt = new Iu(t._pt, e, n, 0, 0, Ac));
          return (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1;
        }
      },
    },
    Cc = [1, 0, 0, 1, 0, 0],
    Ic = {},
    Pc = function (t) {
      return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
    },
    Oc = function (t) {
      var e = dc(t, hc);
      return Pc(e) ? Cc : e.substr(7).match(cl).map(Fl);
    },
    Nc = function (t, e) {
      var n,
        i,
        r,
        s,
        o = t._gsap || Nl(t),
        a = t.style,
        l = Oc(t);
      return o.svg && t.getAttribute("transform")
        ? "1,0,0,1,0,0" ===
          (l = [
            (r = t.transform.baseVal.consolidate().matrix).a,
            r.b,
            r.c,
            r.d,
            r.e,
            r.f,
          ]).join(",")
          ? Cc
          : l
        : (l !== Cc ||
            t.offsetParent ||
            t === Bu ||
            o.svg ||
            ((r = a.display),
            (a.display = "block"),
            ((n = t.parentNode) && t.offsetParent) ||
              ((s = 1), (i = t.nextSibling), Bu.appendChild(t)),
            (l = Oc(t)),
            r ? (a.display = r) : xc(t, "display"),
            s &&
              (i
                ? n.insertBefore(t, i)
                : n
                ? n.appendChild(t)
                : Bu.removeChild(t))),
          e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
    },
    Dc = function (t, e, n, i, r, s) {
      var o,
        a,
        l,
        h = t._gsap,
        u = r || Nc(t, !0),
        c = h.xOrigin || 0,
        d = h.yOrigin || 0,
        p = h.xOffset || 0,
        f = h.yOffset || 0,
        m = u[0],
        _ = u[1],
        g = u[2],
        v = u[3],
        y = u[4],
        x = u[5],
        b = e.split(" "),
        T = parseFloat(b[0]) || 0,
        E = parseFloat(b[1]) || 0;
      n
        ? u !== Cc &&
          (a = m * v - _ * g) &&
          ((l = T * (-_ / a) + E * (m / a) - (m * x - _ * y) / a),
          (T = T * (v / a) + E * (-g / a) + (g * x - v * y) / a),
          (E = l))
        : ((T = (o = vc(t)).x + (~b[0].indexOf("%") ? (T / 100) * o.width : T)),
          (E =
            o.y + (~(b[1] || b[0]).indexOf("%") ? (E / 100) * o.height : E))),
        i || (!1 !== i && h.smooth)
          ? ((y = T - c),
            (x = E - d),
            (h.xOffset = p + (y * m + x * g) - y),
            (h.yOffset = f + (y * _ + x * v) - x))
          : (h.xOffset = h.yOffset = 0),
        (h.xOrigin = T),
        (h.yOrigin = E),
        (h.smooth = !!i),
        (h.origin = e),
        (h.originIsAbsolute = !!n),
        (t.style[uc] = "0px 0px"),
        s &&
          (bc(s, h, "xOrigin", c, T),
          bc(s, h, "yOrigin", d, E),
          bc(s, h, "xOffset", p, h.xOffset),
          bc(s, h, "yOffset", f, h.yOffset)),
        t.setAttribute("data-svg-origin", T + " " + E);
    },
    Lc = function (t, e) {
      var n = t._gsap || new iu(t);
      if ("x" in n && !e && !n.uncache) return n;
      var i,
        r,
        s,
        o,
        a,
        l,
        h,
        u,
        c,
        d,
        p,
        f,
        m,
        _,
        g,
        v,
        y,
        x,
        b,
        T,
        E,
        S,
        w,
        M,
        A,
        R,
        C,
        I,
        P,
        O,
        N,
        D,
        L = t.style,
        F = n.scaleX < 0,
        U = "px",
        B = "deg",
        k = dc(t, uc) || "0";
      return (
        (i = r = s = l = h = u = c = d = p = 0),
        (o = a = 1),
        (n.svg = !(!t.getCTM || !yc(t))),
        (_ = Nc(t, n.svg)),
        n.svg &&
          ((M =
            (!n.uncache || "0px 0px" === k) &&
            !e &&
            t.getAttribute("data-svg-origin")),
          Dc(t, M || k, !!M || n.originIsAbsolute, !1 !== n.smooth, _)),
        (f = n.xOrigin || 0),
        (m = n.yOrigin || 0),
        _ !== Cc &&
          ((x = _[0]),
          (b = _[1]),
          (T = _[2]),
          (E = _[3]),
          (i = S = _[4]),
          (r = w = _[5]),
          6 === _.length
            ? ((o = Math.sqrt(x * x + b * b)),
              (a = Math.sqrt(E * E + T * T)),
              (l = x || b ? ju(b, x) * Xu : 0),
              (c = T || E ? ju(T, E) * Xu + l : 0) &&
                (a *= Math.abs(Math.cos(c * Wu))),
              n.svg && ((i -= f - (f * x + m * T)), (r -= m - (f * b + m * E))))
            : ((D = _[6]),
              (O = _[7]),
              (C = _[8]),
              (I = _[9]),
              (P = _[10]),
              (N = _[11]),
              (i = _[12]),
              (r = _[13]),
              (s = _[14]),
              (h = (g = ju(D, P)) * Xu),
              g &&
                ((M = S * (v = Math.cos(-g)) + C * (y = Math.sin(-g))),
                (A = w * v + I * y),
                (R = D * v + P * y),
                (C = S * -y + C * v),
                (I = w * -y + I * v),
                (P = D * -y + P * v),
                (N = O * -y + N * v),
                (S = M),
                (w = A),
                (D = R)),
              (u = (g = ju(-T, P)) * Xu),
              g &&
                ((v = Math.cos(-g)),
                (N = E * (y = Math.sin(-g)) + N * v),
                (x = M = x * v - C * y),
                (b = A = b * v - I * y),
                (T = R = T * v - P * y)),
              (l = (g = ju(b, x)) * Xu),
              g &&
                ((M = x * (v = Math.cos(g)) + b * (y = Math.sin(g))),
                (A = S * v + w * y),
                (b = b * v - x * y),
                (w = w * v - S * y),
                (x = M),
                (S = A)),
              h &&
                Math.abs(h) + Math.abs(l) > 359.9 &&
                ((h = l = 0), (u = 180 - u)),
              (o = Fl(Math.sqrt(x * x + b * b + T * T))),
              (a = Fl(Math.sqrt(w * w + D * D))),
              (g = ju(S, w)),
              (c = Math.abs(g) > 2e-4 ? g * Xu : 0),
              (p = N ? 1 / (N < 0 ? -N : N) : 0)),
          n.svg &&
            ((M = t.getAttribute("transform")),
            (n.forceCSS = t.setAttribute("transform", "") || !Pc(dc(t, hc))),
            M && t.setAttribute("transform", M))),
        Math.abs(c) > 90 &&
          Math.abs(c) < 270 &&
          (F
            ? ((o *= -1),
              (c += l <= 0 ? 180 : -180),
              (l += l <= 0 ? 180 : -180))
            : ((a *= -1), (c += c <= 0 ? 180 : -180))),
        (e = e || n.uncache),
        (n.x =
          i -
          ((n.xPercent =
            i &&
            ((!e && n.xPercent) ||
              (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
            ? (t.offsetWidth * n.xPercent) / 100
            : 0) +
          U),
        (n.y =
          r -
          ((n.yPercent =
            r &&
            ((!e && n.yPercent) ||
              (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)))
            ? (t.offsetHeight * n.yPercent) / 100
            : 0) +
          U),
        (n.z = s + U),
        (n.scaleX = Fl(o)),
        (n.scaleY = Fl(a)),
        (n.rotation = Fl(l) + B),
        (n.rotationX = Fl(h) + B),
        (n.rotationY = Fl(u) + B),
        (n.skewX = c + B),
        (n.skewY = d + B),
        (n.transformPerspective = p + U),
        (n.zOrigin = parseFloat(k.split(" ")[2]) || 0) && (L[uc] = Fc(k)),
        (n.xOffset = n.yOffset = 0),
        (n.force3D = Xa.force3D),
        (n.renderTransform = n.svg ? Vc : zu ? zc : Bc),
        (n.uncache = 0),
        n
      );
    },
    Fc = function (t) {
      return (t = t.split(" "))[0] + " " + t[1];
    },
    Uc = function (t, e, n) {
      var i = yh(e);
      return Fl(parseFloat(e) + parseFloat(Ec(t, "x", n + "px", i))) + i;
    },
    Bc = function (t, e) {
      (e.z = "0px"),
        (e.rotationY = e.rotationX = "0deg"),
        (e.force3D = 0),
        zc(t, e);
    },
    kc = "0deg",
    Gc = "0px",
    Hc = ") ",
    zc = function (t, e) {
      var n = e || this,
        i = n.xPercent,
        r = n.yPercent,
        s = n.x,
        o = n.y,
        a = n.z,
        l = n.rotation,
        h = n.rotationY,
        u = n.rotationX,
        c = n.skewX,
        d = n.skewY,
        p = n.scaleX,
        f = n.scaleY,
        m = n.transformPerspective,
        _ = n.force3D,
        g = n.target,
        v = n.zOrigin,
        y = "",
        x = ("auto" === _ && t && 1 !== t) || !0 === _;
      if (v && (u !== kc || h !== kc)) {
        var b,
          T = parseFloat(h) * Wu,
          E = Math.sin(T),
          S = Math.cos(T);
        (T = parseFloat(u) * Wu),
          (b = Math.cos(T)),
          (s = Uc(g, s, E * b * -v)),
          (o = Uc(g, o, -Math.sin(T) * -v)),
          (a = Uc(g, a, S * b * -v + v));
      }
      m !== Gc && (y += "perspective(" + m + Hc),
        (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
        (x || s !== Gc || o !== Gc || a !== Gc) &&
          (y +=
            a !== Gc || x
              ? "translate3d(" + s + ", " + o + ", " + a + ") "
              : "translate(" + s + ", " + o + Hc),
        l !== kc && (y += "rotate(" + l + Hc),
        h !== kc && (y += "rotateY(" + h + Hc),
        u !== kc && (y += "rotateX(" + u + Hc),
        (c === kc && d === kc) || (y += "skew(" + c + ", " + d + Hc),
        (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + Hc),
        (g.style[hc] = y || "translate(0, 0)");
    },
    Vc = function (t, e) {
      var n,
        i,
        r,
        s,
        o,
        a = e || this,
        l = a.xPercent,
        h = a.yPercent,
        u = a.x,
        c = a.y,
        d = a.rotation,
        p = a.skewX,
        f = a.skewY,
        m = a.scaleX,
        _ = a.scaleY,
        g = a.target,
        v = a.xOrigin,
        y = a.yOrigin,
        x = a.xOffset,
        b = a.yOffset,
        T = a.forceCSS,
        E = parseFloat(u),
        S = parseFloat(c);
      (d = parseFloat(d)),
        (p = parseFloat(p)),
        (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
        d || p
          ? ((d *= Wu),
            (p *= Wu),
            (n = Math.cos(d) * m),
            (i = Math.sin(d) * m),
            (r = Math.sin(d - p) * -_),
            (s = Math.cos(d - p) * _),
            p &&
              ((f *= Wu),
              (o = Math.tan(p - f)),
              (r *= o = Math.sqrt(1 + o * o)),
              (s *= o),
              f &&
                ((o = Math.tan(f)), (n *= o = Math.sqrt(1 + o * o)), (i *= o))),
            (n = Fl(n)),
            (i = Fl(i)),
            (r = Fl(r)),
            (s = Fl(s)))
          : ((n = m), (s = _), (i = r = 0)),
        ((E && !~(u + "").indexOf("px")) || (S && !~(c + "").indexOf("px"))) &&
          ((E = Ec(g, "x", u, "px")), (S = Ec(g, "y", c, "px"))),
        (v || y || x || b) &&
          ((E = Fl(E + v - (v * n + y * r) + x)),
          (S = Fl(S + y - (v * i + y * s) + b))),
        (l || h) &&
          ((o = g.getBBox()),
          (E = Fl(E + (l / 100) * o.width)),
          (S = Fl(S + (h / 100) * o.height))),
        (o =
          "matrix(" +
          n +
          "," +
          i +
          "," +
          r +
          "," +
          s +
          "," +
          E +
          "," +
          S +
          ")"),
        g.setAttribute("transform", o),
        T && (g.style[hc] = o);
    },
    Xc = function (t, e, n, i, r) {
      var s,
        o,
        a = 360,
        l = tl(r),
        h = parseFloat(r) * (l && ~r.indexOf("rad") ? Xu : 1) - i,
        u = i + h + "deg";
      return (
        l &&
          ("short" === (s = r.split("_")[1]) &&
            (h %= a) !== h % 180 &&
            (h += h < 0 ? a : -360),
          "cw" === s && h < 0
            ? (h = ((h + 36e9) % a) - ~~(h / a) * a)
            : "ccw" === s && h > 0 && (h = ((h - 36e9) % a) - ~~(h / a) * a)),
        (t._pt = o = new Iu(t._pt, e, n, i, h, $u)),
        (o.e = u),
        (o.u = "deg"),
        t._props.push(n),
        o
      );
    },
    Wc = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    jc = function (t, e, n) {
      var i,
        r,
        s,
        o,
        a,
        l,
        h,
        u = Wc({}, n._gsap),
        c = n.style;
      for (r in (u.svg
        ? ((s = n.getAttribute("transform")),
          n.setAttribute("transform", ""),
          (c[hc] = e),
          (i = Lc(n, 1)),
          xc(n, hc),
          n.setAttribute("transform", s))
        : ((s = getComputedStyle(n)[hc]),
          (c[hc] = e),
          (i = Lc(n, 1)),
          (c[hc] = s)),
      Vu))
        (s = u[r]) !== (o = i[r]) &&
          "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
          ((a = yh(s) !== (h = yh(o)) ? Ec(n, r, s, h) : parseFloat(s)),
          (l = parseFloat(o)),
          (t._pt = new Iu(t._pt, i, r, a, l - a, Ju)),
          (t._pt.u = h || 0),
          t._props.push(r));
      Wc(i, u);
    };
  Ll("padding,margin,Width,Radius", function (t, e) {
    var n = "Top",
      i = "Right",
      r = "Bottom",
      s = "Left",
      o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(function (
        n
      ) {
        return e < 2 ? t + n : "border" + n + t;
      });
    Rc[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
      var s, a;
      if (arguments.length < 4)
        return (
          (s = o.map(function (e) {
            return Sc(t, e, n);
          })),
          5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a
        );
      (s = (i + "").split(" ")),
        (a = {}),
        o.forEach(function (t, e) {
          return (a[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
        }),
        t.init(e, a, r);
    };
  });
  var Yc,
    qc,
    Kc,
    Zc = {
      name: "css",
      register: mc,
      targetTest: function (t) {
        return t.style && t.nodeType;
      },
      init: function (t, e, n, i, r) {
        var s,
          o,
          a,
          l,
          h,
          u,
          c,
          d,
          p,
          f,
          m,
          _,
          g,
          v,
          y,
          x,
          b,
          T,
          E,
          S = this._props,
          w = t.style,
          M = n.vars.startAt;
        for (c in (ku || mc(), e))
          if (
            "autoRound" !== c &&
            ((o = e[c]), !Al[c] || !uu(c, e, n, i, t, r))
          )
            if (
              ((h = typeof o),
              (u = Rc[c]),
              "function" === h && (h = typeof (o = o.call(n, i, t, r))),
              "string" === h && ~o.indexOf("random(") && (o = Ch(o)),
              u)
            )
              u(this, t, c, o, n) && (y = 1);
            else if ("--" === c.substr(0, 2))
              (s = (getComputedStyle(t).getPropertyValue(c) + "").trim()),
                (o += ""),
                (Hh.lastIndex = 0),
                Hh.test(s) || ((d = yh(s)), (p = yh(o))),
                p ? d !== p && (s = Ec(t, c, s, p) + p) : d && (o += d),
                this.add(w, "setProperty", s, o, i, r, 0, 0, c),
                S.push(c);
            else if ("undefined" !== h) {
              if (
                (M && c in M
                  ? ((s =
                      "function" == typeof M[c] ? M[c].call(n, i, t, r) : M[c]),
                    tl(s) && ~s.indexOf("random(") && (s = Ch(s)),
                    yh(s + "") || (s += Xa.units[c] || yh(Sc(t, c)) || ""),
                    "=" === (s + "").charAt(1) && (s = Sc(t, c)))
                  : (s = Sc(t, c)),
                (l = parseFloat(s)),
                (f = "string" === h && "=" === o.charAt(1) && o.substr(0, 2)) &&
                  (o = o.substr(2)),
                (a = parseFloat(o)),
                c in Zu &&
                  ("autoAlpha" === c &&
                    (1 === l &&
                      "hidden" === Sc(t, "visibility") &&
                      a &&
                      (l = 0),
                    bc(
                      this,
                      w,
                      "visibility",
                      l ? "inherit" : "hidden",
                      a ? "inherit" : "hidden",
                      !a
                    )),
                  "scale" !== c &&
                    "transform" !== c &&
                    ~(c = Zu[c]).indexOf(",") &&
                    (c = c.split(",")[0])),
                (m = c in Vu))
              )
                if (
                  (_ ||
                    (((g = t._gsap).renderTransform && !e.parseTransform) ||
                      Lc(t, e.parseTransform),
                    (v = !1 !== e.smoothOrigin && g.smooth),
                    ((_ = this._pt =
                      new Iu(
                        this._pt,
                        w,
                        hc,
                        0,
                        1,
                        g.renderTransform,
                        g,
                        0,
                        -1
                      )).dep = 1)),
                  "scale" === c)
                )
                  (this._pt = new Iu(
                    this._pt,
                    g,
                    "scaleY",
                    g.scaleY,
                    (f ? Bl(g.scaleY, f + a) : a) - g.scaleY || 0
                  )),
                    S.push("scaleY", c),
                    (c += "X");
                else {
                  if ("transformOrigin" === c) {
                    (b = void 0),
                      (T = void 0),
                      (E = void 0),
                      (b = (x = o).split(" ")),
                      (T = b[0]),
                      (E = b[1] || "50%"),
                      ("top" !== T &&
                        "bottom" !== T &&
                        "left" !== E &&
                        "right" !== E) ||
                        ((x = T), (T = E), (E = x)),
                      (b[0] = Mc[T] || T),
                      (b[1] = Mc[E] || E),
                      (o = b.join(" ")),
                      g.svg
                        ? Dc(t, o, 0, v, 0, this)
                        : ((p = parseFloat(o.split(" ")[2]) || 0) !==
                            g.zOrigin && bc(this, g, "zOrigin", g.zOrigin, p),
                          bc(this, w, c, Fc(s), Fc(o)));
                    continue;
                  }
                  if ("svgOrigin" === c) {
                    Dc(t, o, 1, v, 0, this);
                    continue;
                  }
                  if (c in Ic) {
                    Xc(this, g, c, l, f ? Bl(l, f + o) : o);
                    continue;
                  }
                  if ("smoothOrigin" === c) {
                    bc(this, g, "smooth", g.smooth, o);
                    continue;
                  }
                  if ("force3D" === c) {
                    g[c] = o;
                    continue;
                  }
                  if ("transform" === c) {
                    jc(this, o, t);
                    continue;
                  }
                }
              else c in w || (c = fc(c) || c);
              if (
                m ||
                ((a || 0 === a) && (l || 0 === l) && !Ku.test(o) && c in w)
              )
                a || (a = 0),
                  (d = (s + "").substr((l + "").length)) !==
                    (p = yh(o) || (c in Xa.units ? Xa.units[c] : d)) &&
                    (l = Ec(t, c, s, p)),
                  (this._pt = new Iu(
                    this._pt,
                    m ? g : w,
                    c,
                    l,
                    (f ? Bl(l, f + a) : a) - l,
                    m || ("px" !== p && "zIndex" !== c) || !1 === e.autoRound
                      ? Ju
                      : tc
                  )),
                  (this._pt.u = p || 0),
                  d !== p && "%" !== p && ((this._pt.b = s), (this._pt.r = Qu));
              else if (c in w) wc.call(this, t, c, s, f ? f + o : o);
              else {
                if (!(c in t)) {
                  xl(c, o);
                  continue;
                }
                this.add(t, c, s || t[c], f ? f + o : o, i, r);
              }
              S.push(c);
            }
        y && Cu(this);
      },
      get: Sc,
      aliases: Zu,
      getSetter: function (t, e, n) {
        var i = Zu[e];
        return (
          i && i.indexOf(",") < 0 && (e = i),
          e in Vu && e !== uc && (t._gsap.x || Sc(t, "x"))
            ? n && Hu === n
              ? "scale" === e
                ? oc
                : sc
              : (Hu = n || {}) && ("scale" === e ? ac : lc)
            : t.style && !il(t.style[e])
            ? ic
            : ~e.indexOf("-")
            ? rc
            : bu(t, e)
        );
      },
      core: { _removeProperty: xc, _getMatrix: Nc },
    };
  (Du.utils.checkPrefix = fc),
    (Kc = Ll(
      (Yc = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") +
        "," +
        (qc = "rotation,rotationX,rotationY,skewX,skewY") +
        ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
      function (t) {
        Vu[t] = 1;
      }
    )),
    Ll(qc, function (t) {
      (Xa.units[t] = "deg"), (Ic[t] = 1);
    }),
    (Zu[Kc[13]] = Yc + "," + qc),
    Ll(
      "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
      function (t) {
        var e = t.split(":");
        Zu[e[1]] = Kc[e[0]];
      }
    ),
    Ll(
      "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
      function (t) {
        Xa.units[t] = "px";
      }
    ),
    Du.registerPlugin(Zc);
  var Jc = Du.registerPlugin(Zc) || Du;
  Jc.core.Tween;
  var $c = 0;
  function Qc(t, n, i, r, s) {
    var o,
      a,
      l = {};
    for (a in n) "ref" == a ? (o = n[a]) : (l[a] = n[a]);
    var h = {
      type: t,
      props: l,
      key: i,
      ref: o,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --$c,
      __source: s,
      __self: r,
    };
    if ("function" == typeof t && (o = t.defaultProps))
      for (a in o) void 0 === l[a] && (l[a] = o[a]);
    return e.vnode && e.vnode(h), h;
  }
  let td = "/";
  td = "https://designer-threads-wc.netlify.app/";
  const ed = {
    apiKey: "AIzaSyA4ejI9WIiV2cM26aj-02dJdUtP5nWKguo",
    authDomain: "design-threads.firebaseapp.com",
    databaseURL: "https://design-threads-default-rtdb.firebaseio.com",
    projectId: "design-threads",
    storageBucket: "design-threads.appspot.com",
    messagingSenderId: "344888432111",
    appId: "1:344888432111:web:7135a68fd29f51874dd21a",
    measurementId: "G-909WJCMPV5",
  };
  function nd(t) {
    const e = pa(Pe(ed)),
      [n, i] = tt(),
      [r, s] = tt(Date.now());
    let o = ha($o(e, "cursors/"), la(10));
    const a = $o(e, "cursors/" + r),
      l = () => {
        var t;
        _o("remove", (t = a)._path), ta(t, null);
      };
    return (
      et(() => {
        sa(o, (t) => {
          const e = t.val() || [],
            n = Object.values(e).filter((t) => Date.now() - t.date < 1e5);
          n
            .filter((t) => t.id != r)
            .forEach((t) => {
              Jc.to("#cursor-" + t.id, { x: t.x, y: t.y });
            }),
            n && i(n);
        }),
          (window.onbeforeunload = () => {
            l();
          });
      }, []),
      Qc("div", {
        onMouseEnter: (t) =>
          ((t, e) => {
            ta(a, { id: t, x: e.offsetX, y: e.offsetY, date: Date.now() });
          })(r, t),
        onMouseMove: (t) =>
          ((t, e) => {
            ea(a, { id: t, x: e.offsetX, y: e.offsetY, date: Date.now() });
          })(r, t),
        onMouseLeave: l,
        style: { position: "relative" },
        children: [
          n &&
            n
              .filter((t) => t.id != r)
              .map((t) =>
                Qc(
                  "div",
                  {
                    id: "cursor-" + t.id,
                    style: {
                      zIndex: "100",
                      position: "absolute",
                      pointerEvents: "none",
                    },
                    children: Qc("img", {
                      alt: "Cursor",
                      width: 24,
                      src: "https://designer-threads-wc.netlify.app/assets/cursors/drawing.png",
                    }),
                  },
                  t.id
                )
              ),
          t.children,
        ],
      })
    );
  }
  var id = setTimeout;
  function rd(t) {
    return Boolean(t && void 0 !== t.length);
  }
  function sd() {}
  function od(t) {
    if (!(this instanceof od))
      throw new TypeError("Promises must be constructed via new");
    if ("function" != typeof t) throw new TypeError("not a function");
    (this._state = 0),
      (this._handled = !1),
      (this._value = void 0),
      (this._deferreds = []),
      dd(t, this);
  }
  function ad(t, e) {
    for (; 3 === t._state; ) t = t._value;
    0 !== t._state
      ? ((t._handled = !0),
        od._immediateFn(function () {
          var n = 1 === t._state ? e.onFulfilled : e.onRejected;
          if (null !== n) {
            var i;
            try {
              i = n(t._value);
            } catch (r) {
              return void hd(e.promise, r);
            }
            ld(e.promise, i);
          } else (1 === t._state ? ld : hd)(e.promise, t._value);
        }))
      : t._deferreds.push(e);
  }
  function ld(t, e) {
    try {
      if (e === t)
        throw new TypeError("A promise cannot be resolved with itself.");
      if (e && ("object" == typeof e || "function" == typeof e)) {
        var n = e.then;
        if (e instanceof od) return (t._state = 3), (t._value = e), void ud(t);
        if ("function" == typeof n)
          return void dd(
            ((i = n),
            (r = e),
            function () {
              i.apply(r, arguments);
            }),
            t
          );
      }
      (t._state = 1), (t._value = e), ud(t);
    } catch (s) {
      hd(t, s);
    }
    var i, r;
  }
  function hd(t, e) {
    (t._state = 2), (t._value = e), ud(t);
  }
  function ud(t) {
    2 === t._state &&
      0 === t._deferreds.length &&
      od._immediateFn(function () {
        t._handled || od._unhandledRejectionFn(t._value);
      });
    for (var e = 0, n = t._deferreds.length; e < n; e++) ad(t, t._deferreds[e]);
    t._deferreds = null;
  }
  function cd(t, e, n) {
    (this.onFulfilled = "function" == typeof t ? t : null),
      (this.onRejected = "function" == typeof e ? e : null),
      (this.promise = n);
  }
  function dd(t, e) {
    var n = !1;
    try {
      t(
        function (t) {
          n || ((n = !0), ld(e, t));
        },
        function (t) {
          n || ((n = !0), hd(e, t));
        }
      );
    } catch (i) {
      if (n) return;
      (n = !0), hd(e, i);
    }
  }
  (od.prototype.catch = function (t) {
    return this.then(null, t);
  }),
    (od.prototype.then = function (t, e) {
      var n = new this.constructor(sd);
      return ad(this, new cd(t, e, n)), n;
    }),
    (od.prototype.finally = function (t) {
      var e = this.constructor;
      return this.then(
        function (n) {
          return e.resolve(t()).then(function () {
            return n;
          });
        },
        function (n) {
          return e.resolve(t()).then(function () {
            return e.reject(n);
          });
        }
      );
    }),
    (od.all = function (t) {
      return new od(function (e, n) {
        if (!rd(t)) return n(new TypeError("Promise.all accepts an array"));
        var i = Array.prototype.slice.call(t);
        if (0 === i.length) return e([]);
        var r = i.length;
        function s(t, o) {
          try {
            if (o && ("object" == typeof o || "function" == typeof o)) {
              var a = o.then;
              if ("function" == typeof a)
                return void a.call(
                  o,
                  function (e) {
                    s(t, e);
                  },
                  n
                );
            }
            (i[t] = o), 0 == --r && e(i);
          } catch (l) {
            n(l);
          }
        }
        for (var o = 0; o < i.length; o++) s(o, i[o]);
      });
    }),
    (od.allSettled = function (t) {
      return new this(function (e, n) {
        if (!t || void 0 === t.length)
          return n(
            new TypeError(
              typeof t +
                " " +
                t +
                " is not iterable(cannot read property Symbol(Symbol.iterator))"
            )
          );
        var i = Array.prototype.slice.call(t);
        if (0 === i.length) return e([]);
        var r = i.length;
        function s(t, n) {
          if (n && ("object" == typeof n || "function" == typeof n)) {
            var o = n.then;
            if ("function" == typeof o)
              return void o.call(
                n,
                function (e) {
                  s(t, e);
                },
                function (n) {
                  (i[t] = { status: "rejected", reason: n }), 0 == --r && e(i);
                }
              );
          }
          (i[t] = { status: "fulfilled", value: n }), 0 == --r && e(i);
        }
        for (var o = 0; o < i.length; o++) s(o, i[o]);
      });
    }),
    (od.resolve = function (t) {
      return t && "object" == typeof t && t.constructor === od
        ? t
        : new od(function (e) {
            e(t);
          });
    }),
    (od.reject = function (t) {
      return new od(function (e, n) {
        n(t);
      });
    }),
    (od.race = function (t) {
      return new od(function (e, n) {
        if (!rd(t)) return n(new TypeError("Promise.race accepts an array"));
        for (var i = 0, r = t.length; i < r; i++) od.resolve(t[i]).then(e, n);
      });
    }),
    (od._immediateFn =
      ("function" == typeof setImmediate &&
        function (t) {
          setImmediate(t);
        }) ||
      function (t) {
        id(t, 0);
      }),
    (od._unhandledRejectionFn = function (t) {
      "undefined" != typeof console &&
        console &&
        console.warn("Possible Unhandled Promise Rejection:", t);
    });
  var pd =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
        ? self
        : {},
    fd = Object.getOwnPropertySymbols,
    md = Object.prototype.hasOwnProperty,
    _d = Object.prototype.propertyIsEnumerable;
  function gd(t) {
    if (null == t)
      throw new TypeError(
        "Object.assign cannot be called with null or undefined"
      );
    return Object(t);
  }
  var vd = (function () {
    try {
      if (!Object.assign) return !1;
      var t = new String("abc");
      if (((t[5] = "de"), "5" === Object.getOwnPropertyNames(t)[0])) return !1;
      for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
      var i = Object.getOwnPropertyNames(e).map(function (t) {
        return e[t];
      });
      if ("0123456789" !== i.join("")) return !1;
      var r = {};
      return (
        "abcdefghijklmnopqrst".split("").forEach(function (t) {
          r[t] = t;
        }),
        "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
      );
    } catch (s) {
      return !1;
    }
  })()
    ? Object.assign
    : function (t, e) {
        for (var n, i, r = gd(t), s = 1; s < arguments.length; s++) {
          for (var o in (n = Object(arguments[s])))
            md.call(n, o) && (r[o] = n[o]);
          if (fd) {
            i = fd(n);
            for (var a = 0; a < i.length; a++)
              _d.call(n, i[a]) && (r[i[a]] = n[i[a]]);
          }
        }
        return r;
      };
  "undefined" == typeof globalThis &&
    ("undefined" != typeof self
      ? (self.globalThis = self)
      : "undefined" != typeof global && (global.globalThis = global)),
    globalThis.Promise || (globalThis.Promise = od),
    Object.assign || (Object.assign = vd);
  if (
    ((Date.now && Date.prototype.getTime) ||
      (Date.now = function () {
        return new Date().getTime();
      }),
    !globalThis.performance || !globalThis.performance.now)
  ) {
    var yd = Date.now();
    globalThis.performance || (globalThis.performance = {}),
      (globalThis.performance.now = function () {
        return Date.now() - yd;
      });
  }
  for (
    var xd,
      bd,
      Td,
      Ed,
      Sd,
      wd,
      Md,
      Ad,
      Rd,
      Cd,
      Id,
      Pd,
      Od,
      Nd,
      Dd,
      Ld,
      Fd,
      Ud,
      Bd,
      kd,
      Gd,
      Hd,
      zd,
      Vd,
      Xd,
      Wd,
      jd,
      Yd,
      qd,
      Kd,
      Zd,
      Jd,
      $d,
      Qd,
      tp,
      ep,
      np,
      ip,
      rp,
      sp,
      op = Date.now(),
      ap = ["ms", "moz", "webkit", "o"],
      lp = 0;
    lp < ap.length && !globalThis.requestAnimationFrame;
    ++lp
  ) {
    var hp = ap[lp];
    (globalThis.requestAnimationFrame =
      globalThis[hp + "RequestAnimationFrame"]),
      (globalThis.cancelAnimationFrame =
        globalThis[hp + "CancelAnimationFrame"] ||
        globalThis[hp + "CancelRequestAnimationFrame"]);
  }
  globalThis.requestAnimationFrame ||
    (globalThis.requestAnimationFrame = function (t) {
      if ("function" != typeof t) throw new TypeError(t + "is not a function");
      var e = Date.now(),
        n = 16 + op - e;
      return (
        n < 0 && (n = 0),
        (op = e),
        globalThis.self.setTimeout(function () {
          (op = Date.now()), t(performance.now());
        }, n)
      );
    }),
    globalThis.cancelAnimationFrame ||
      (globalThis.cancelAnimationFrame = function (t) {
        return clearTimeout(t);
      }),
    Math.sign ||
      (Math.sign = function (t) {
        return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1;
      }),
    Number.isInteger ||
      (Number.isInteger = function (t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
      }),
    globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array),
    globalThis.Float32Array || (globalThis.Float32Array = Array),
    globalThis.Uint32Array || (globalThis.Uint32Array = Array),
    globalThis.Uint16Array || (globalThis.Uint16Array = Array),
    globalThis.Uint8Array || (globalThis.Uint8Array = Array),
    globalThis.Int32Array || (globalThis.Int32Array = Array),
    ((bd = xd || (xd = {}))[(bd.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
    (bd[(bd.WEBGL = 1)] = "WEBGL"),
    (bd[(bd.WEBGL2 = 2)] = "WEBGL2"),
    ((Ed = Td || (Td = {}))[(Ed.UNKNOWN = 0)] = "UNKNOWN"),
    (Ed[(Ed.WEBGL = 1)] = "WEBGL"),
    (Ed[(Ed.CANVAS = 2)] = "CANVAS"),
    ((wd = Sd || (Sd = {}))[(wd.COLOR = 16384)] = "COLOR"),
    (wd[(wd.DEPTH = 256)] = "DEPTH"),
    (wd[(wd.STENCIL = 1024)] = "STENCIL"),
    ((Ad = Md || (Md = {}))[(Ad.NORMAL = 0)] = "NORMAL"),
    (Ad[(Ad.ADD = 1)] = "ADD"),
    (Ad[(Ad.MULTIPLY = 2)] = "MULTIPLY"),
    (Ad[(Ad.SCREEN = 3)] = "SCREEN"),
    (Ad[(Ad.OVERLAY = 4)] = "OVERLAY"),
    (Ad[(Ad.DARKEN = 5)] = "DARKEN"),
    (Ad[(Ad.LIGHTEN = 6)] = "LIGHTEN"),
    (Ad[(Ad.COLOR_DODGE = 7)] = "COLOR_DODGE"),
    (Ad[(Ad.COLOR_BURN = 8)] = "COLOR_BURN"),
    (Ad[(Ad.HARD_LIGHT = 9)] = "HARD_LIGHT"),
    (Ad[(Ad.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
    (Ad[(Ad.DIFFERENCE = 11)] = "DIFFERENCE"),
    (Ad[(Ad.EXCLUSION = 12)] = "EXCLUSION"),
    (Ad[(Ad.HUE = 13)] = "HUE"),
    (Ad[(Ad.SATURATION = 14)] = "SATURATION"),
    (Ad[(Ad.COLOR = 15)] = "COLOR"),
    (Ad[(Ad.LUMINOSITY = 16)] = "LUMINOSITY"),
    (Ad[(Ad.NORMAL_NPM = 17)] = "NORMAL_NPM"),
    (Ad[(Ad.ADD_NPM = 18)] = "ADD_NPM"),
    (Ad[(Ad.SCREEN_NPM = 19)] = "SCREEN_NPM"),
    (Ad[(Ad.NONE = 20)] = "NONE"),
    (Ad[(Ad.SRC_OVER = 0)] = "SRC_OVER"),
    (Ad[(Ad.SRC_IN = 21)] = "SRC_IN"),
    (Ad[(Ad.SRC_OUT = 22)] = "SRC_OUT"),
    (Ad[(Ad.SRC_ATOP = 23)] = "SRC_ATOP"),
    (Ad[(Ad.DST_OVER = 24)] = "DST_OVER"),
    (Ad[(Ad.DST_IN = 25)] = "DST_IN"),
    (Ad[(Ad.DST_OUT = 26)] = "DST_OUT"),
    (Ad[(Ad.DST_ATOP = 27)] = "DST_ATOP"),
    (Ad[(Ad.ERASE = 26)] = "ERASE"),
    (Ad[(Ad.SUBTRACT = 28)] = "SUBTRACT"),
    (Ad[(Ad.XOR = 29)] = "XOR"),
    ((Cd = Rd || (Rd = {}))[(Cd.POINTS = 0)] = "POINTS"),
    (Cd[(Cd.LINES = 1)] = "LINES"),
    (Cd[(Cd.LINE_LOOP = 2)] = "LINE_LOOP"),
    (Cd[(Cd.LINE_STRIP = 3)] = "LINE_STRIP"),
    (Cd[(Cd.TRIANGLES = 4)] = "TRIANGLES"),
    (Cd[(Cd.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
    (Cd[(Cd.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN"),
    ((Pd = Id || (Id = {}))[(Pd.RGBA = 6408)] = "RGBA"),
    (Pd[(Pd.RGB = 6407)] = "RGB"),
    (Pd[(Pd.RG = 33319)] = "RG"),
    (Pd[(Pd.RED = 6403)] = "RED"),
    (Pd[(Pd.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
    (Pd[(Pd.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
    (Pd[(Pd.RG_INTEGER = 33320)] = "RG_INTEGER"),
    (Pd[(Pd.RED_INTEGER = 36244)] = "RED_INTEGER"),
    (Pd[(Pd.ALPHA = 6406)] = "ALPHA"),
    (Pd[(Pd.LUMINANCE = 6409)] = "LUMINANCE"),
    (Pd[(Pd.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
    (Pd[(Pd.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
    (Pd[(Pd.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
    ((Nd = Od || (Od = {}))[(Nd.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
    (Nd[(Nd.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
    (Nd[(Nd.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
      "TEXTURE_CUBE_MAP_POSITIVE_X"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_X"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
      "TEXTURE_CUBE_MAP_POSITIVE_Y"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
      "TEXTURE_CUBE_MAP_POSITIVE_Z"),
    (Nd[(Nd.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
    ((Ld = Dd || (Dd = {}))[(Ld.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
    (Ld[(Ld.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
    (Ld[(Ld.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
    (Ld[(Ld.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
    (Ld[(Ld.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
    (Ld[(Ld.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
    (Ld[(Ld.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
      "UNSIGNED_INT_10F_11F_11F_REV"),
    (Ld[(Ld.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
      "UNSIGNED_INT_2_10_10_10_REV"),
    (Ld[(Ld.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
    (Ld[(Ld.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
    (Ld[(Ld.BYTE = 5120)] = "BYTE"),
    (Ld[(Ld.SHORT = 5122)] = "SHORT"),
    (Ld[(Ld.INT = 5124)] = "INT"),
    (Ld[(Ld.FLOAT = 5126)] = "FLOAT"),
    (Ld[(Ld.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
      "FLOAT_32_UNSIGNED_INT_24_8_REV"),
    (Ld[(Ld.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
    ((Ud = Fd || (Fd = {}))[(Ud.FLOAT = 0)] = "FLOAT"),
    (Ud[(Ud.INT = 1)] = "INT"),
    (Ud[(Ud.UINT = 2)] = "UINT"),
    ((kd = Bd || (Bd = {}))[(kd.NEAREST = 0)] = "NEAREST"),
    (kd[(kd.LINEAR = 1)] = "LINEAR"),
    ((Hd = Gd || (Gd = {}))[(Hd.CLAMP = 33071)] = "CLAMP"),
    (Hd[(Hd.REPEAT = 10497)] = "REPEAT"),
    (Hd[(Hd.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT"),
    ((Vd = zd || (zd = {}))[(Vd.OFF = 0)] = "OFF"),
    (Vd[(Vd.POW2 = 1)] = "POW2"),
    (Vd[(Vd.ON = 2)] = "ON"),
    (Vd[(Vd.ON_MANUAL = 3)] = "ON_MANUAL"),
    ((Wd = Xd || (Xd = {}))[(Wd.NPM = 0)] = "NPM"),
    (Wd[(Wd.UNPACK = 1)] = "UNPACK"),
    (Wd[(Wd.PMA = 2)] = "PMA"),
    (Wd[(Wd.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
    (Wd[(Wd.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
    (Wd[(Wd.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
    (Wd[(Wd.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA"),
    ((Yd = jd || (jd = {}))[(Yd.NO = 0)] = "NO"),
    (Yd[(Yd.YES = 1)] = "YES"),
    (Yd[(Yd.AUTO = 2)] = "AUTO"),
    (Yd[(Yd.BLEND = 0)] = "BLEND"),
    (Yd[(Yd.CLEAR = 1)] = "CLEAR"),
    (Yd[(Yd.BLIT = 2)] = "BLIT"),
    ((Kd = qd || (qd = {}))[(Kd.AUTO = 0)] = "AUTO"),
    (Kd[(Kd.MANUAL = 1)] = "MANUAL"),
    ((Jd = Zd || (Zd = {})).LOW = "lowp"),
    (Jd.MEDIUM = "mediump"),
    (Jd.HIGH = "highp"),
    ((Qd = $d || ($d = {}))[(Qd.NONE = 0)] = "NONE"),
    (Qd[(Qd.SCISSOR = 1)] = "SCISSOR"),
    (Qd[(Qd.STENCIL = 2)] = "STENCIL"),
    (Qd[(Qd.SPRITE = 3)] = "SPRITE"),
    (Qd[(Qd.COLOR = 4)] = "COLOR"),
    ((ep = tp || (tp = {}))[(ep.RED = 1)] = "RED"),
    (ep[(ep.GREEN = 2)] = "GREEN"),
    (ep[(ep.BLUE = 4)] = "BLUE"),
    (ep[(ep.ALPHA = 8)] = "ALPHA"),
    ((ip = np || (np = {}))[(ip.NONE = 0)] = "NONE"),
    (ip[(ip.LOW = 2)] = "LOW"),
    (ip[(ip.MEDIUM = 4)] = "MEDIUM"),
    (ip[(ip.HIGH = 8)] = "HIGH"),
    ((sp = rp || (rp = {}))[(sp.ELEMENT_ARRAY_BUFFER = 34963)] =
      "ELEMENT_ARRAY_BUFFER"),
    (sp[(sp.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
    (sp[(sp.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
  var up = {
      createCanvas: function (t, e) {
        var n = document.createElement("canvas");
        return (n.width = t), (n.height = e), n;
      },
      getWebGLRenderingContext: function () {
        return WebGLRenderingContext;
      },
      getNavigator: function () {
        return navigator;
      },
      getBaseUrl: function () {
        var t;
        return null !== (t = document.baseURI) && void 0 !== t
          ? t
          : window.location.href;
      },
      fetch: function (t, e) {
        return fetch(t, e);
      },
    },
    cp = /iPhone/i,
    dp = /iPod/i,
    pp = /iPad/i,
    fp = /\biOS-universal(?:.+)Mac\b/i,
    mp = /\bAndroid(?:.+)Mobile\b/i,
    _p = /Android/i,
    gp = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    vp = /Silk/i,
    yp = /Windows Phone/i,
    xp = /\bWindows(?:.+)ARM\b/i,
    bp = /BlackBerry/i,
    Tp = /BB10/i,
    Ep = /Opera Mini/i,
    Sp = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    wp = /Mobile(?:.+)Firefox\b/i,
    Mp = function (t) {
      return (
        void 0 !== t &&
        "MacIntel" === t.platform &&
        "number" == typeof t.maxTouchPoints &&
        t.maxTouchPoints > 1 &&
        "undefined" == typeof MSStream
      );
    };
  var Ap = (function (t) {
    var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
    t || "undefined" == typeof navigator
      ? "string" == typeof t
        ? (e.userAgent = t)
        : t &&
          t.userAgent &&
          (e = {
            userAgent: t.userAgent,
            platform: t.platform,
            maxTouchPoints: t.maxTouchPoints || 0,
          })
      : (e = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0,
        });
    var n = e.userAgent,
      i = n.split("[FBAN");
    void 0 !== i[1] && (n = i[0]),
      void 0 !== (i = n.split("Twitter"))[1] && (n = i[0]);
    var r = (function (t) {
        return function (e) {
          return e.test(t);
        };
      })(n),
      s = {
        apple: {
          phone: r(cp) && !r(yp),
          ipod: r(dp),
          tablet: !r(cp) && (r(pp) || Mp(e)) && !r(yp),
          universal: r(fp),
          device: (r(cp) || r(dp) || r(pp) || r(fp) || Mp(e)) && !r(yp),
        },
        amazon: {
          phone: r(gp),
          tablet: !r(gp) && r(vp),
          device: r(gp) || r(vp),
        },
        android: {
          phone: (!r(yp) && r(gp)) || (!r(yp) && r(mp)),
          tablet: !r(yp) && !r(gp) && !r(mp) && (r(vp) || r(_p)),
          device:
            (!r(yp) && (r(gp) || r(vp) || r(mp) || r(_p))) || r(/\bokhttp\b/i),
        },
        windows: { phone: r(yp), tablet: r(xp), device: r(yp) || r(xp) },
        other: {
          blackberry: r(bp),
          blackberry10: r(Tp),
          opera: r(Ep),
          firefox: r(wp),
          chrome: r(Sp),
          device: r(bp) || r(Tp) || r(Ep) || r(wp) || r(Sp),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      };
    return (
      (s.any =
        s.apple.device ||
        s.android.device ||
        s.windows.device ||
        s.other.device),
      (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
      (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
      s
    );
  })(globalThis.navigator);
  var Rp = {
      ADAPTER: up,
      MIPMAP_TEXTURES: zd.POW2,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      FILTER_MULTISAMPLE: np.NONE,
      SPRITE_MAX_TEXTURES: (function (t) {
        var e = !0;
        if (Ap.tablet || Ap.phone) {
          var n;
          if (Ap.apple.device)
            if ((n = navigator.userAgent.match(/OS (\d+)_(\d+)?/)))
              parseInt(n[1], 10) < 11 && (e = !1);
          if (Ap.android.device)
            if ((n = navigator.userAgent.match(/Android\s([0-9.]*)/)))
              parseInt(n[1], 10) < 7 && (e = !1);
        }
        return e ? t : 4;
      })(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: !1,
        autoDensity: !1,
        backgroundColor: 0,
        backgroundAlpha: 1,
        useContextAlpha: !0,
        clearBeforeRender: !0,
        preserveDrawingBuffer: !1,
        width: 800,
        height: 600,
        legacy: !1,
      },
      GC_MODE: qd.AUTO,
      GC_MAX_IDLE: 3600,
      GC_MAX_CHECK_COUNT: 600,
      WRAP_MODE: Gd.CLAMP,
      SCALE_MODE: Bd.LINEAR,
      PRECISION_VERTEX: Zd.HIGH,
      PRECISION_FRAGMENT: Ap.apple.device ? Zd.HIGH : Zd.MEDIUM,
      CAN_UPLOAD_SAME_BUFFER: !Ap.apple.device,
      CREATE_IMAGE_BITMAP: !1,
      ROUND_PIXELS: !1,
    },
    Cp = { exports: {} };
  !(function (t) {
    var e = Object.prototype.hasOwnProperty,
      n = "~";
    function i() {}
    function r(t, e, n) {
      (this.fn = t), (this.context = e), (this.once = n || !1);
    }
    function s(t, e, i, s, o) {
      if ("function" != typeof i)
        throw new TypeError("The listener must be a function");
      var a = new r(i, s || t, o),
        l = n ? n + e : e;
      return (
        t._events[l]
          ? t._events[l].fn
            ? (t._events[l] = [t._events[l], a])
            : t._events[l].push(a)
          : ((t._events[l] = a), t._eventsCount++),
        t
      );
    }
    function o(t, e) {
      0 == --t._eventsCount ? (t._events = new i()) : delete t._events[e];
    }
    function a() {
      (this._events = new i()), (this._eventsCount = 0);
    }
    Object.create &&
      ((i.prototype = Object.create(null)), new i().__proto__ || (n = !1)),
      (a.prototype.eventNames = function () {
        var t,
          i,
          r = [];
        if (0 === this._eventsCount) return r;
        for (i in (t = this._events))
          e.call(t, i) && r.push(n ? i.slice(1) : i);
        return Object.getOwnPropertySymbols
          ? r.concat(Object.getOwnPropertySymbols(t))
          : r;
      }),
      (a.prototype.listeners = function (t) {
        var e = n ? n + t : t,
          i = this._events[e];
        if (!i) return [];
        if (i.fn) return [i.fn];
        for (var r = 0, s = i.length, o = new Array(s); r < s; r++)
          o[r] = i[r].fn;
        return o;
      }),
      (a.prototype.listenerCount = function (t) {
        var e = n ? n + t : t,
          i = this._events[e];
        return i ? (i.fn ? 1 : i.length) : 0;
      }),
      (a.prototype.emit = function (t, e, i, r, s, o) {
        var a = n ? n + t : t;
        if (!this._events[a]) return !1;
        var l,
          h,
          u = this._events[a],
          c = arguments.length;
        if (u.fn) {
          switch ((u.once && this.removeListener(t, u.fn, void 0, !0), c)) {
            case 1:
              return u.fn.call(u.context), !0;
            case 2:
              return u.fn.call(u.context, e), !0;
            case 3:
              return u.fn.call(u.context, e, i), !0;
            case 4:
              return u.fn.call(u.context, e, i, r), !0;
            case 5:
              return u.fn.call(u.context, e, i, r, s), !0;
            case 6:
              return u.fn.call(u.context, e, i, r, s, o), !0;
          }
          for (h = 1, l = new Array(c - 1); h < c; h++) l[h - 1] = arguments[h];
          u.fn.apply(u.context, l);
        } else {
          var d,
            p = u.length;
          for (h = 0; h < p; h++)
            switch (
              (u[h].once && this.removeListener(t, u[h].fn, void 0, !0), c)
            ) {
              case 1:
                u[h].fn.call(u[h].context);
                break;
              case 2:
                u[h].fn.call(u[h].context, e);
                break;
              case 3:
                u[h].fn.call(u[h].context, e, i);
                break;
              case 4:
                u[h].fn.call(u[h].context, e, i, r);
                break;
              default:
                if (!l)
                  for (d = 1, l = new Array(c - 1); d < c; d++)
                    l[d - 1] = arguments[d];
                u[h].fn.apply(u[h].context, l);
            }
        }
        return !0;
      }),
      (a.prototype.on = function (t, e, n) {
        return s(this, t, e, n, !1);
      }),
      (a.prototype.once = function (t, e, n) {
        return s(this, t, e, n, !0);
      }),
      (a.prototype.removeListener = function (t, e, i, r) {
        var s = n ? n + t : t;
        if (!this._events[s]) return this;
        if (!e) return o(this, s), this;
        var a = this._events[s];
        if (a.fn)
          a.fn !== e || (r && !a.once) || (i && a.context !== i) || o(this, s);
        else {
          for (var l = 0, h = [], u = a.length; l < u; l++)
            (a[l].fn !== e || (r && !a[l].once) || (i && a[l].context !== i)) &&
              h.push(a[l]);
          h.length ? (this._events[s] = 1 === h.length ? h[0] : h) : o(this, s);
        }
        return this;
      }),
      (a.prototype.removeAllListeners = function (t) {
        var e;
        return (
          t
            ? ((e = n ? n + t : t), this._events[e] && o(this, e))
            : ((this._events = new i()), (this._eventsCount = 0)),
          this
        );
      }),
      (a.prototype.off = a.prototype.removeListener),
      (a.prototype.addListener = a.prototype.on),
      (a.prefixed = n),
      (a.EventEmitter = a),
      (t.exports = a);
  })(Cp);
  const Ip = Cp.exports;
  var Pp = { exports: {} };
  function Op(t, e, n) {
    n = n || 2;
    var i,
      r,
      s,
      o,
      a,
      l,
      h,
      u = e && e.length,
      c = u ? e[0] * n : t.length,
      d = Np(t, 0, c, n, !0),
      p = [];
    if (!d || d.next === d.prev) return p;
    if (
      (u &&
        (d = (function (t, e, n, i) {
          var r,
            s,
            o,
            a = [];
          for (r = 0, s = e.length; r < s; r++)
            (o = Np(
              t,
              e[r] * i,
              r < s - 1 ? e[r + 1] * i : t.length,
              i,
              !1
            )) === o.next && (o.steiner = !0),
              a.push(Xp(o));
          for (a.sort(Gp), r = 0; r < a.length; r++) n = Hp(a[r], n);
          return n;
        })(t, e, d, n)),
      t.length > 80 * n)
    ) {
      (i = s = t[0]), (r = o = t[1]);
      for (var f = n; f < c; f += n)
        (a = t[f]) < i && (i = a),
          (l = t[f + 1]) < r && (r = l),
          a > s && (s = a),
          l > o && (o = l);
      h = 0 !== (h = Math.max(s - i, o - r)) ? 32767 / h : 0;
    }
    return Lp(d, p, n, i, r, h, 0), p;
  }
  function Np(t, e, n, i, r) {
    var s, o;
    if (r === rf(t, e, n, i) > 0)
      for (s = e; s < n; s += i) o = tf(s, t[s], t[s + 1], o);
    else for (s = n - i; s >= e; s -= i) o = tf(s, t[s], t[s + 1], o);
    return o && qp(o, o.next) && (ef(o), (o = o.next)), o;
  }
  function Dp(t, e) {
    if (!t) return t;
    e || (e = t);
    var n,
      i = t;
    do {
      if (
        ((n = !1), i.steiner || (!qp(i, i.next) && 0 !== Yp(i.prev, i, i.next)))
      )
        i = i.next;
      else {
        if ((ef(i), (i = e = i.prev) === i.next)) break;
        n = !0;
      }
    } while (n || i !== e);
    return e;
  }
  function Lp(t, e, n, i, r, s, o) {
    if (t) {
      !o &&
        s &&
        (function (t, e, n, i) {
          var r = t;
          do {
            0 === r.z && (r.z = Vp(r.x, r.y, e, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== t);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              var e,
                n,
                i,
                r,
                s,
                o,
                a,
                l,
                h = 1;
              do {
                for (n = t, t = null, s = null, o = 0; n; ) {
                  for (
                    o++, i = n, a = 0, e = 0;
                    e < h && (a++, (i = i.nextZ));
                    e++
                  );
                  for (l = h; a > 0 || (l > 0 && i); )
                    0 !== a && (0 === l || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), a--)
                      : ((r = i), (i = i.nextZ), l--),
                      s ? (s.nextZ = r) : (t = r),
                      (r.prevZ = s),
                      (s = r);
                  n = i;
                }
                (s.nextZ = null), (h *= 2);
              } while (o > 1);
            })(r);
        })(t, i, r, s);
      for (var a, l, h = t; t.prev !== t.next; )
        if (((a = t.prev), (l = t.next), s ? Up(t, i, r, s) : Fp(t)))
          e.push((a.i / n) | 0),
            e.push((t.i / n) | 0),
            e.push((l.i / n) | 0),
            ef(t),
            (t = l.next),
            (h = l.next);
        else if ((t = l) === h) {
          o
            ? 1 === o
              ? Lp((t = Bp(Dp(t), e, n)), e, n, i, r, s, 2)
              : 2 === o && kp(t, e, n, i, r, s)
            : Lp(Dp(t), e, n, i, r, s, 1);
          break;
        }
    }
  }
  function Fp(t) {
    var e = t.prev,
      n = t,
      i = t.next;
    if (Yp(e, n, i) >= 0) return !1;
    for (
      var r = e.x,
        s = n.x,
        o = i.x,
        a = e.y,
        l = n.y,
        h = i.y,
        u = r < s ? (r < o ? r : o) : s < o ? s : o,
        c = a < l ? (a < h ? a : h) : l < h ? l : h,
        d = r > s ? (r > o ? r : o) : s > o ? s : o,
        p = a > l ? (a > h ? a : h) : l > h ? l : h,
        f = i.next;
      f !== e;

    ) {
      if (
        f.x >= u &&
        f.x <= d &&
        f.y >= c &&
        f.y <= p &&
        Wp(r, a, s, l, o, h, f.x, f.y) &&
        Yp(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.next;
    }
    return !0;
  }
  function Up(t, e, n, i) {
    var r = t.prev,
      s = t,
      o = t.next;
    if (Yp(r, s, o) >= 0) return !1;
    for (
      var a = r.x,
        l = s.x,
        h = o.x,
        u = r.y,
        c = s.y,
        d = o.y,
        p = a < l ? (a < h ? a : h) : l < h ? l : h,
        f = u < c ? (u < d ? u : d) : c < d ? c : d,
        m = a > l ? (a > h ? a : h) : l > h ? l : h,
        _ = u > c ? (u > d ? u : d) : c > d ? c : d,
        g = Vp(p, f, e, n, i),
        v = Vp(m, _, e, n, i),
        y = t.prevZ,
        x = t.nextZ;
      y && y.z >= g && x && x.z <= v;

    ) {
      if (
        y.x >= p &&
        y.x <= m &&
        y.y >= f &&
        y.y <= _ &&
        y !== r &&
        y !== o &&
        Wp(a, u, l, c, h, d, y.x, y.y) &&
        Yp(y.prev, y, y.next) >= 0
      )
        return !1;
      if (
        ((y = y.prevZ),
        x.x >= p &&
          x.x <= m &&
          x.y >= f &&
          x.y <= _ &&
          x !== r &&
          x !== o &&
          Wp(a, u, l, c, h, d, x.x, x.y) &&
          Yp(x.prev, x, x.next) >= 0)
      )
        return !1;
      x = x.nextZ;
    }
    for (; y && y.z >= g; ) {
      if (
        y.x >= p &&
        y.x <= m &&
        y.y >= f &&
        y.y <= _ &&
        y !== r &&
        y !== o &&
        Wp(a, u, l, c, h, d, y.x, y.y) &&
        Yp(y.prev, y, y.next) >= 0
      )
        return !1;
      y = y.prevZ;
    }
    for (; x && x.z <= v; ) {
      if (
        x.x >= p &&
        x.x <= m &&
        x.y >= f &&
        x.y <= _ &&
        x !== r &&
        x !== o &&
        Wp(a, u, l, c, h, d, x.x, x.y) &&
        Yp(x.prev, x, x.next) >= 0
      )
        return !1;
      x = x.nextZ;
    }
    return !0;
  }
  function Bp(t, e, n) {
    var i = t;
    do {
      var r = i.prev,
        s = i.next.next;
      !qp(r, s) &&
        Kp(r, i, i.next, s) &&
        $p(r, s) &&
        $p(s, r) &&
        (e.push((r.i / n) | 0),
        e.push((i.i / n) | 0),
        e.push((s.i / n) | 0),
        ef(i),
        ef(i.next),
        (i = t = s)),
        (i = i.next);
    } while (i !== t);
    return Dp(i);
  }
  function kp(t, e, n, i, r, s) {
    var o = t;
    do {
      for (var a = o.next.next; a !== o.prev; ) {
        if (o.i !== a.i && jp(o, a)) {
          var l = Qp(o, a);
          return (
            (o = Dp(o, o.next)),
            (l = Dp(l, l.next)),
            Lp(o, e, n, i, r, s, 0),
            void Lp(l, e, n, i, r, s, 0)
          );
        }
        a = a.next;
      }
      o = o.next;
    } while (o !== t);
  }
  function Gp(t, e) {
    return t.x - e.x;
  }
  function Hp(t, e) {
    var n = (function (t, e) {
      var n,
        i = e,
        r = t.x,
        s = t.y,
        o = -1 / 0;
      do {
        if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
          var a = i.x + ((s - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
          if (
            a <= r &&
            a > o &&
            ((o = a), (n = i.x < i.next.x ? i : i.next), a === r)
          )
            return n;
        }
        i = i.next;
      } while (i !== e);
      if (!n) return null;
      var l,
        h = n,
        u = n.x,
        c = n.y,
        d = 1 / 0;
      i = n;
      do {
        r >= i.x &&
          i.x >= u &&
          r !== i.x &&
          Wp(s < c ? r : o, s, u, c, s < c ? o : r, s, i.x, i.y) &&
          ((l = Math.abs(s - i.y) / (r - i.x)),
          $p(i, t) &&
            (l < d || (l === d && (i.x > n.x || (i.x === n.x && zp(n, i))))) &&
            ((n = i), (d = l))),
          (i = i.next);
      } while (i !== h);
      return n;
    })(t, e);
    if (!n) return e;
    var i = Qp(n, t);
    return Dp(i, i.next), Dp(n, n.next);
  }
  function zp(t, e) {
    return Yp(t.prev, t, e.prev) < 0 && Yp(e.next, t, t.next) < 0;
  }
  function Vp(t, e, n, i, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = ((t - n) * r) | 0) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = ((e - i) * r) | 0) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function Xp(t) {
    var e = t,
      n = t;
    do {
      (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
    } while (e !== t);
    return n;
  }
  function Wp(t, e, n, i, r, s, o, a) {
    return (
      (r - o) * (e - a) >= (t - o) * (s - a) &&
      (t - o) * (i - a) >= (n - o) * (e - a) &&
      (n - o) * (s - a) >= (r - o) * (i - a)
    );
  }
  function jp(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !(function (t, e) {
        var n = t;
        do {
          if (
            n.i !== t.i &&
            n.next.i !== t.i &&
            n.i !== e.i &&
            n.next.i !== e.i &&
            Kp(n, n.next, t, e)
          )
            return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      })(t, e) &&
      (($p(t, e) &&
        $p(e, t) &&
        (function (t, e) {
          var n = t,
            i = !1,
            r = (t.x + e.x) / 2,
            s = (t.y + e.y) / 2;
          do {
            n.y > s != n.next.y > s &&
              n.next.y !== n.y &&
              r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
              (i = !i),
              (n = n.next);
          } while (n !== t);
          return i;
        })(t, e) &&
        (Yp(t.prev, t, e.prev) || Yp(t, e.prev, e))) ||
        (qp(t, e) && Yp(t.prev, t, t.next) > 0 && Yp(e.prev, e, e.next) > 0))
    );
  }
  function Yp(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
  }
  function qp(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function Kp(t, e, n, i) {
    var r = Jp(Yp(t, e, n)),
      s = Jp(Yp(t, e, i)),
      o = Jp(Yp(n, i, t)),
      a = Jp(Yp(n, i, e));
    return (
      (r !== s && o !== a) ||
      !(0 !== r || !Zp(t, n, e)) ||
      !(0 !== s || !Zp(t, i, e)) ||
      !(0 !== o || !Zp(n, t, i)) ||
      !(0 !== a || !Zp(n, e, i))
    );
  }
  function Zp(t, e, n) {
    return (
      e.x <= Math.max(t.x, n.x) &&
      e.x >= Math.min(t.x, n.x) &&
      e.y <= Math.max(t.y, n.y) &&
      e.y >= Math.min(t.y, n.y)
    );
  }
  function Jp(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }
  function $p(t, e) {
    return Yp(t.prev, t, t.next) < 0
      ? Yp(t, e, t.next) >= 0 && Yp(t, t.prev, e) >= 0
      : Yp(t, e, t.prev) < 0 || Yp(t, t.next, e) < 0;
  }
  function Qp(t, e) {
    var n = new nf(t.i, t.x, t.y),
      i = new nf(e.i, e.x, e.y),
      r = t.next,
      s = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (n.next = r),
      (r.prev = n),
      (i.next = n),
      (n.prev = i),
      (s.next = i),
      (i.prev = s),
      i
    );
  }
  function tf(t, e, n, i) {
    var r = new nf(t, e, n);
    return (
      i
        ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function ef(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function nf(t, e, n) {
    (this.i = t),
      (this.x = e),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  function rf(t, e, n, i) {
    for (var r = 0, s = e, o = n - i; s < n; s += i)
      (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
    return r;
  }
  (Pp.exports = Op),
    (Pp.exports.default = Op),
    (Op.deviation = function (t, e, n, i) {
      var r = e && e.length,
        s = r ? e[0] * n : t.length,
        o = Math.abs(rf(t, 0, s, n));
      if (r)
        for (var a = 0, l = e.length; a < l; a++) {
          var h = e[a] * n,
            u = a < l - 1 ? e[a + 1] * n : t.length;
          o -= Math.abs(rf(t, h, u, n));
        }
      var c = 0;
      for (a = 0; a < i.length; a += 3) {
        var d = i[a] * n,
          p = i[a + 1] * n,
          f = i[a + 2] * n;
        c += Math.abs(
          (t[d] - t[f]) * (t[p + 1] - t[d + 1]) -
            (t[d] - t[p]) * (t[f + 1] - t[d + 1])
        );
      }
      return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o);
    }),
    (Op.flatten = function (t) {
      for (
        var e = t[0][0].length,
          n = { vertices: [], holes: [], dimensions: e },
          i = 0,
          r = 0;
        r < t.length;
        r++
      ) {
        for (var s = 0; s < t[r].length; s++)
          for (var o = 0; o < e; o++) n.vertices.push(t[r][s][o]);
        r > 0 && ((i += t[r - 1].length), n.holes.push(i));
      }
      return n;
    });
  var sf,
    of,
    af = { exports: {} };
  (sf = af),
    (of = af.exports),
    (function (t) {
      var e = of && !of.nodeType && of,
        n = sf && !sf.nodeType && sf,
        i = "object" == typeof pd && pd;
      (i.global !== i && i.window !== i && i.self !== i) || (t = i);
      var r,
        s,
        o = 2147483647,
        a = 36,
        l = /^xn--/,
        h = /[^\x20-\x7E]/,
        u = /[\x2E\u3002\uFF0E\uFF61]/g,
        c = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input",
        },
        d = Math.floor,
        p = String.fromCharCode;
      function f(t) {
        throw RangeError(c[t]);
      }
      function m(t, e) {
        for (var n = t.length, i = []; n--; ) i[n] = e(t[n]);
        return i;
      }
      function _(t, e) {
        var n = t.split("@"),
          i = "";
        return (
          n.length > 1 && ((i = n[0] + "@"), (t = n[1])),
          i + m((t = t.replace(u, ".")).split("."), e).join(".")
        );
      }
      function g(t) {
        for (var e, n, i = [], r = 0, s = t.length; r < s; )
          (e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < s
            ? 56320 == (64512 & (n = t.charCodeAt(r++)))
              ? i.push(((1023 & e) << 10) + (1023 & n) + 65536)
              : (i.push(e), r--)
            : i.push(e);
        return i;
      }
      function v(t) {
        return m(t, function (t) {
          var e = "";
          return (
            t > 65535 &&
              ((e += p((((t -= 65536) >>> 10) & 1023) | 55296)),
              (t = 56320 | (1023 & t))),
            (e += p(t))
          );
        }).join("");
      }
      function y(t, e) {
        return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
      }
      function x(t, e, n) {
        var i = 0;
        for (t = n ? d(t / 700) : t >> 1, t += d(t / e); t > 455; i += a)
          t = d(t / 35);
        return d(i + (36 * t) / (t + 38));
      }
      function b(t) {
        var e,
          n,
          i,
          r,
          s,
          l,
          h,
          u,
          c,
          p,
          m,
          _ = [],
          g = t.length,
          y = 0,
          b = 128,
          T = 72;
        for ((n = t.lastIndexOf("-")) < 0 && (n = 0), i = 0; i < n; ++i)
          t.charCodeAt(i) >= 128 && f("not-basic"), _.push(t.charCodeAt(i));
        for (r = n > 0 ? n + 1 : 0; r < g; ) {
          for (
            s = y, l = 1, h = a;
            r >= g && f("invalid-input"),
              ((u =
                (m = t.charCodeAt(r++)) - 48 < 10
                  ? m - 22
                  : m - 65 < 26
                  ? m - 65
                  : m - 97 < 26
                  ? m - 97
                  : a) >= a ||
                u > d((o - y) / l)) &&
                f("overflow"),
              (y += u * l),
              !(u < (c = h <= T ? 1 : h >= T + 26 ? 26 : h - T));
            h += a
          )
            l > d(o / (p = a - c)) && f("overflow"), (l *= p);
          (T = x(y - s, (e = _.length + 1), 0 == s)),
            d(y / e) > o - b && f("overflow"),
            (b += d(y / e)),
            (y %= e),
            _.splice(y++, 0, b);
        }
        return v(_);
      }
      function T(t) {
        var e,
          n,
          i,
          r,
          s,
          l,
          h,
          u,
          c,
          m,
          _,
          v,
          b,
          T,
          E,
          S = [];
        for (v = (t = g(t)).length, e = 128, n = 0, s = 72, l = 0; l < v; ++l)
          (_ = t[l]) < 128 && S.push(p(_));
        for (i = r = S.length, r && S.push("-"); i < v; ) {
          for (h = o, l = 0; l < v; ++l) (_ = t[l]) >= e && _ < h && (h = _);
          for (
            h - e > d((o - n) / (b = i + 1)) && f("overflow"),
              n += (h - e) * b,
              e = h,
              l = 0;
            l < v;
            ++l
          )
            if (((_ = t[l]) < e && ++n > o && f("overflow"), _ == e)) {
              for (
                u = n, c = a;
                !(u < (m = c <= s ? 1 : c >= s + 26 ? 26 : c - s));
                c += a
              )
                (E = u - m),
                  (T = a - m),
                  S.push(p(y(m + (E % T), 0))),
                  (u = d(E / T));
              S.push(p(y(u, 0))), (s = x(n, b, i == r)), (n = 0), ++i;
            }
          ++n, ++e;
        }
        return S.join("");
      }
      if (
        ((r = {
          version: "1.3.2",
          ucs2: { decode: g, encode: v },
          decode: b,
          encode: T,
          toASCII: function (t) {
            return _(t, function (t) {
              return h.test(t) ? "xn--" + T(t) : t;
            });
          },
          toUnicode: function (t) {
            return _(t, function (t) {
              return l.test(t) ? b(t.slice(4).toLowerCase()) : t;
            });
          },
        }),
        e && n)
      )
        if (sf.exports == e) n.exports = r;
        else for (s in r) r.hasOwnProperty(s) && (e[s] = r[s]);
      else t.punycode = r;
    })(pd);
  var lf = {};
  function hf(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var uf = function (t) {
    switch (typeof t) {
      case "string":
        return t;
      case "boolean":
        return t ? "true" : "false";
      case "number":
        return isFinite(t) ? t : "";
      default:
        return "";
    }
  };
  (lf.decode = lf.parse =
    function (t, e, n, i) {
      (e = e || "&"), (n = n || "=");
      var r = {};
      if ("string" != typeof t || 0 === t.length) return r;
      var s = /\+/g;
      t = t.split(e);
      var o = 1e3;
      i && "number" == typeof i.maxKeys && (o = i.maxKeys);
      var a = t.length;
      o > 0 && a > o && (a = o);
      for (var l = 0; l < a; ++l) {
        var h,
          u,
          c,
          d,
          p = t[l].replace(s, "%20"),
          f = p.indexOf(n);
        f >= 0
          ? ((h = p.substr(0, f)), (u = p.substr(f + 1)))
          : ((h = p), (u = "")),
          (c = decodeURIComponent(h)),
          (d = decodeURIComponent(u)),
          hf(r, c)
            ? Array.isArray(r[c])
              ? r[c].push(d)
              : (r[c] = [r[c], d])
            : (r[c] = d);
      }
      return r;
    }),
    (lf.encode = lf.stringify =
      function (t, e, n, i) {
        return (
          (e = e || "&"),
          (n = n || "="),
          null === t && (t = void 0),
          "object" == typeof t
            ? Object.keys(t)
                .map(function (i) {
                  var r = encodeURIComponent(uf(i)) + n;
                  return Array.isArray(t[i])
                    ? t[i]
                        .map(function (t) {
                          return r + encodeURIComponent(uf(t));
                        })
                        .join(e)
                    : r + encodeURIComponent(uf(t[i]));
                })
                .join(e)
            : i
            ? encodeURIComponent(uf(i)) + n + encodeURIComponent(uf(t))
            : ""
        );
      });
  var cf = af.exports,
    df = {
      isString: function (t) {
        return "string" == typeof t;
      },
      isObject: function (t) {
        return "object" == typeof t && null !== t;
      },
      isNull: function (t) {
        return null === t;
      },
      isNullOrUndefined: function (t) {
        return null == t;
      },
    },
    pf = Zf,
    ff = function (t, e) {
      return Zf(t, !1, !0).resolve(e);
    },
    mf = function (t) {
      df.isString(t) && (t = Zf(t));
      return t instanceof _f ? t.format() : _f.prototype.format.call(t);
    };
  function _f() {
    (this.protocol = null),
      (this.slashes = null),
      (this.auth = null),
      (this.host = null),
      (this.port = null),
      (this.hostname = null),
      (this.hash = null),
      (this.search = null),
      (this.query = null),
      (this.pathname = null),
      (this.path = null),
      (this.href = null);
  }
  var gf,
    vf,
    yf,
    xf,
    bf,
    Tf,
    Ef,
    Sf,
    wf,
    Mf,
    Af,
    Rf,
    Cf,
    If,
    Pf,
    Of,
    Nf,
    Df,
    Lf,
    Ff,
    Uf = /^([a-z0-9.+-]+:)/i,
    Bf = /:[0-9]*$/,
    kf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    Gf = ["{", "}", "|", "\\", "^", "`"].concat([
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "\t",
    ]),
    Hf = ["'"].concat(Gf),
    zf = ["%", "/", "?", ";", "#"].concat(Hf),
    Vf = ["/", "?", "#"],
    Xf = /^[+a-z0-9A-Z_-]{0,63}$/,
    Wf = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    jf = { javascript: !0, "javascript:": !0 },
    Yf = { javascript: !0, "javascript:": !0 },
    qf = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0,
    },
    Kf = lf;
  function Zf(t, e, n) {
    if (t && df.isObject(t) && t instanceof _f) return t;
    var i = new _f();
    return i.parse(t, e, n), i;
  }
  (_f.prototype.parse = function (t, e, n) {
    if (!df.isString(t))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
    var i = t.indexOf("?"),
      r = -1 !== i && i < t.indexOf("#") ? "?" : "#",
      s = t.split(r);
    s[0] = s[0].replace(/\\/g, "/");
    var o = (t = s.join(r));
    if (((o = o.trim()), !n && 1 === t.split("#").length)) {
      var a = kf.exec(o);
      if (a)
        return (
          (this.path = o),
          (this.href = o),
          (this.pathname = a[1]),
          a[2]
            ? ((this.search = a[2]),
              (this.query = e
                ? Kf.parse(this.search.substr(1))
                : this.search.substr(1)))
            : e && ((this.search = ""), (this.query = {})),
          this
        );
    }
    var l = Uf.exec(o);
    if (l) {
      var h = (l = l[0]).toLowerCase();
      (this.protocol = h), (o = o.substr(l.length));
    }
    if (n || l || o.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var u = "//" === o.substr(0, 2);
      !u || (l && Yf[l]) || ((o = o.substr(2)), (this.slashes = !0));
    }
    if (!Yf[l] && (u || (l && !qf[l]))) {
      for (var c, d, p = -1, f = 0; f < Vf.length; f++) {
        -1 !== (m = o.indexOf(Vf[f])) && (-1 === p || m < p) && (p = m);
      }
      -1 !== (d = -1 === p ? o.lastIndexOf("@") : o.lastIndexOf("@", p)) &&
        ((c = o.slice(0, d)),
        (o = o.slice(d + 1)),
        (this.auth = decodeURIComponent(c))),
        (p = -1);
      for (f = 0; f < zf.length; f++) {
        var m;
        -1 !== (m = o.indexOf(zf[f])) && (-1 === p || m < p) && (p = m);
      }
      -1 === p && (p = o.length),
        (this.host = o.slice(0, p)),
        (o = o.slice(p)),
        this.parseHost(),
        (this.hostname = this.hostname || "");
      var _ =
        "[" === this.hostname[0] &&
        "]" === this.hostname[this.hostname.length - 1];
      if (!_)
        for (
          var g = this.hostname.split(/\./), v = ((f = 0), g.length);
          f < v;
          f++
        ) {
          var y = g[f];
          if (y && !y.match(Xf)) {
            for (var x = "", b = 0, T = y.length; b < T; b++)
              y.charCodeAt(b) > 127 ? (x += "x") : (x += y[b]);
            if (!x.match(Xf)) {
              var E = g.slice(0, f),
                S = g.slice(f + 1),
                w = y.match(Wf);
              w && (E.push(w[1]), S.unshift(w[2])),
                S.length && (o = "/" + S.join(".") + o),
                (this.hostname = E.join("."));
              break;
            }
          }
        }
      this.hostname.length > 255
        ? (this.hostname = "")
        : (this.hostname = this.hostname.toLowerCase()),
        _ || (this.hostname = cf.toASCII(this.hostname));
      var M = this.port ? ":" + this.port : "",
        A = this.hostname || "";
      (this.host = A + M),
        (this.href += this.host),
        _ &&
          ((this.hostname = this.hostname.substr(1, this.hostname.length - 2)),
          "/" !== o[0] && (o = "/" + o));
    }
    if (!jf[h])
      for (f = 0, v = Hf.length; f < v; f++) {
        var R = Hf[f];
        if (-1 !== o.indexOf(R)) {
          var C = encodeURIComponent(R);
          C === R && (C = escape(R)), (o = o.split(R).join(C));
        }
      }
    var I = o.indexOf("#");
    -1 !== I && ((this.hash = o.substr(I)), (o = o.slice(0, I)));
    var P = o.indexOf("?");
    if (
      (-1 !== P
        ? ((this.search = o.substr(P)),
          (this.query = o.substr(P + 1)),
          e && (this.query = Kf.parse(this.query)),
          (o = o.slice(0, P)))
        : e && ((this.search = ""), (this.query = {})),
      o && (this.pathname = o),
      qf[h] && this.hostname && !this.pathname && (this.pathname = "/"),
      this.pathname || this.search)
    ) {
      M = this.pathname || "";
      var O = this.search || "";
      this.path = M + O;
    }
    return (this.href = this.format()), this;
  }),
    (_f.prototype.format = function () {
      var t = this.auth || "";
      t && ((t = (t = encodeURIComponent(t)).replace(/%3A/i, ":")), (t += "@"));
      var e = this.protocol || "",
        n = this.pathname || "",
        i = this.hash || "",
        r = !1,
        s = "";
      this.host
        ? (r = t + this.host)
        : this.hostname &&
          ((r =
            t +
            (-1 === this.hostname.indexOf(":")
              ? this.hostname
              : "[" + this.hostname + "]")),
          this.port && (r += ":" + this.port)),
        this.query &&
          df.isObject(this.query) &&
          Object.keys(this.query).length &&
          (s = Kf.stringify(this.query));
      var o = this.search || (s && "?" + s) || "";
      return (
        e && ":" !== e.substr(-1) && (e += ":"),
        this.slashes || ((!e || qf[e]) && !1 !== r)
          ? ((r = "//" + (r || "")), n && "/" !== n.charAt(0) && (n = "/" + n))
          : r || (r = ""),
        i && "#" !== i.charAt(0) && (i = "#" + i),
        o && "?" !== o.charAt(0) && (o = "?" + o),
        e +
          r +
          (n = n.replace(/[?#]/g, function (t) {
            return encodeURIComponent(t);
          })) +
          (o = o.replace("#", "%23")) +
          i
      );
    }),
    (_f.prototype.resolve = function (t) {
      return this.resolveObject(Zf(t, !1, !0)).format();
    }),
    (_f.prototype.resolveObject = function (t) {
      if (df.isString(t)) {
        var e = new _f();
        e.parse(t, !1, !0), (t = e);
      }
      for (var n = new _f(), i = Object.keys(this), r = 0; r < i.length; r++) {
        var s = i[r];
        n[s] = this[s];
      }
      if (((n.hash = t.hash), "" === t.href)) return (n.href = n.format()), n;
      if (t.slashes && !t.protocol) {
        for (var o = Object.keys(t), a = 0; a < o.length; a++) {
          var l = o[a];
          "protocol" !== l && (n[l] = t[l]);
        }
        return (
          qf[n.protocol] &&
            n.hostname &&
            !n.pathname &&
            (n.path = n.pathname = "/"),
          (n.href = n.format()),
          n
        );
      }
      if (t.protocol && t.protocol !== n.protocol) {
        if (!qf[t.protocol]) {
          for (var h = Object.keys(t), u = 0; u < h.length; u++) {
            var c = h[u];
            n[c] = t[c];
          }
          return (n.href = n.format()), n;
        }
        if (((n.protocol = t.protocol), t.host || Yf[t.protocol]))
          n.pathname = t.pathname;
        else {
          for (
            var d = (t.pathname || "").split("/");
            d.length && !(t.host = d.shift());

          );
          t.host || (t.host = ""),
            t.hostname || (t.hostname = ""),
            "" !== d[0] && d.unshift(""),
            d.length < 2 && d.unshift(""),
            (n.pathname = d.join("/"));
        }
        if (
          ((n.search = t.search),
          (n.query = t.query),
          (n.host = t.host || ""),
          (n.auth = t.auth),
          (n.hostname = t.hostname || t.host),
          (n.port = t.port),
          n.pathname || n.search)
        ) {
          var p = n.pathname || "",
            f = n.search || "";
          n.path = p + f;
        }
        return (n.slashes = n.slashes || t.slashes), (n.href = n.format()), n;
      }
      var m = n.pathname && "/" === n.pathname.charAt(0),
        _ = t.host || (t.pathname && "/" === t.pathname.charAt(0)),
        g = _ || m || (n.host && t.pathname),
        v = g,
        y = (n.pathname && n.pathname.split("/")) || [],
        x =
          ((d = (t.pathname && t.pathname.split("/")) || []),
          n.protocol && !qf[n.protocol]);
      if (
        (x &&
          ((n.hostname = ""),
          (n.port = null),
          n.host && ("" === y[0] ? (y[0] = n.host) : y.unshift(n.host)),
          (n.host = ""),
          t.protocol &&
            ((t.hostname = null),
            (t.port = null),
            t.host && ("" === d[0] ? (d[0] = t.host) : d.unshift(t.host)),
            (t.host = null)),
          (g = g && ("" === d[0] || "" === y[0]))),
        _)
      )
        (n.host = t.host || "" === t.host ? t.host : n.host),
          (n.hostname =
            t.hostname || "" === t.hostname ? t.hostname : n.hostname),
          (n.search = t.search),
          (n.query = t.query),
          (y = d);
      else if (d.length)
        y || (y = []),
          y.pop(),
          (y = y.concat(d)),
          (n.search = t.search),
          (n.query = t.query);
      else if (!df.isNullOrUndefined(t.search)) {
        if (x)
          (n.hostname = n.host = y.shift()),
            (w = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) &&
              ((n.auth = w.shift()), (n.host = n.hostname = w.shift()));
        return (
          (n.search = t.search),
          (n.query = t.query),
          (df.isNull(n.pathname) && df.isNull(n.search)) ||
            (n.path =
              (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
          (n.href = n.format()),
          n
        );
      }
      if (!y.length)
        return (
          (n.pathname = null),
          n.search ? (n.path = "/" + n.search) : (n.path = null),
          (n.href = n.format()),
          n
        );
      for (
        var b = y.slice(-1)[0],
          T =
            ((n.host || t.host || y.length > 1) && ("." === b || ".." === b)) ||
            "" === b,
          E = 0,
          S = y.length;
        S >= 0;
        S--
      )
        "." === (b = y[S])
          ? y.splice(S, 1)
          : ".." === b
          ? (y.splice(S, 1), E++)
          : E && (y.splice(S, 1), E--);
      if (!g && !v) for (; E--; E) y.unshift("..");
      !g || "" === y[0] || (y[0] && "/" === y[0].charAt(0)) || y.unshift(""),
        T && "/" !== y.join("/").substr(-1) && y.push("");
      var w,
        M = "" === y[0] || (y[0] && "/" === y[0].charAt(0));
      x &&
        ((n.hostname = n.host = M ? "" : y.length ? y.shift() : ""),
        (w = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) &&
          ((n.auth = w.shift()), (n.host = n.hostname = w.shift())));
      return (
        (g = g || (n.host && y.length)) && !M && y.unshift(""),
        y.length
          ? (n.pathname = y.join("/"))
          : ((n.pathname = null), (n.path = null)),
        (df.isNull(n.pathname) && df.isNull(n.search)) ||
          (n.path =
            (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
        (n.auth = t.auth || n.auth),
        (n.slashes = n.slashes || t.slashes),
        (n.href = n.format()),
        n
      );
    }),
    (_f.prototype.parseHost = function () {
      var t = this.host,
        e = Bf.exec(t);
      e &&
        (":" !== (e = e[0]) && (this.port = e.substr(1)),
        (t = t.substr(0, t.length - e.length))),
        t && (this.hostname = t);
    }),
    (function (t) {
      (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.WEBGL2 = 2)] = "WEBGL2");
    })(gf || (gf = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(vf || (vf = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })(yf || (yf = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(xf || (xf = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(bf || (bf = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(Tf || (Tf = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(Ef || (Ef = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(Sf || (Sf = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(wf || (wf = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(Mf || (Mf = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(Af || (Af = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })(Rf || (Rf = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(Cf || (Cf = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(If || (If = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(Pf || (Pf = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(Of || (Of = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(Nf || (Nf = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(Df || (Df = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(Lf || (Lf = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(Ff || (Ff = {}));
  var Jf = { parse: pf, format: mf, resolve: ff };
  (Rp.RETINA_PREFIX = /@([0-9\.]+)x/),
    (Rp.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
  var $f,
    Qf = !1;
  var tm = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32",
  };
  function em(t, e) {
    return (
      void 0 === e && (e = []),
      (e[0] = ((t >> 16) & 255) / 255),
      (e[1] = ((t >> 8) & 255) / 255),
      (e[2] = (255 & t) / 255),
      e
    );
  }
  function nm(t) {
    var e = t.toString(16);
    return "#" + (e = "000000".substring(0, 6 - e.length) + e);
  }
  function im(t) {
    return (
      "string" == typeof t &&
        "#" === (t = tm[t.toLowerCase()] || t)[0] &&
        (t = t.slice(1)),
      parseInt(t, 16)
    );
  }
  var rm = (function () {
    for (var t = [], e = [], n = 0; n < 32; n++) (t[n] = n), (e[n] = n);
    (t[xf.NORMAL_NPM] = xf.NORMAL),
      (t[xf.ADD_NPM] = xf.ADD),
      (t[xf.SCREEN_NPM] = xf.SCREEN),
      (e[xf.NORMAL] = xf.NORMAL_NPM),
      (e[xf.ADD] = xf.ADD_NPM),
      (e[xf.SCREEN] = xf.SCREEN_NPM);
    var i = [];
    return i.push(e), i.push(t), i;
  })();
  function sm(t, e) {
    return rm[e ? 1 : 0][t];
  }
  function om(t, e) {
    if (1 === e) return ((255 * e) << 24) + t;
    if (0 === e) return 0;
    var n = (t >> 16) & 255,
      i = (t >> 8) & 255,
      r = 255 & t;
    return (
      ((255 * e) << 24) +
      ((n = (n * e + 0.5) | 0) << 16) +
      ((i = (i * e + 0.5) | 0) << 8) +
      (r = (r * e + 0.5) | 0)
    );
  }
  function am(t, e, n, i) {
    return (
      ((n = n || new Float32Array(4))[0] = ((t >> 16) & 255) / 255),
      (n[1] = ((t >> 8) & 255) / 255),
      (n[2] = (255 & t) / 255),
      (i || void 0 === i) && ((n[0] *= e), (n[1] *= e), (n[2] *= e)),
      (n[3] = e),
      n
    );
  }
  function lm(t) {
    if (4 === t.BYTES_PER_ELEMENT)
      return t instanceof Float32Array
        ? "Float32Array"
        : t instanceof Uint32Array
        ? "Uint32Array"
        : "Int32Array";
    if (2 === t.BYTES_PER_ELEMENT) {
      if (t instanceof Uint16Array) return "Uint16Array";
    } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
      return "Uint8Array";
    return null;
  }
  function hm(t) {
    return (
      (t += 0 === t ? 1 : 0),
      --t,
      (t |= t >>> 1),
      (t |= t >>> 2),
      (t |= t >>> 4),
      (t |= t >>> 8),
      (t |= t >>> 16) + 1
    );
  }
  function um(t) {
    return !(t & (t - 1) || !t);
  }
  function cm(t) {
    var e = (t > 65535 ? 1 : 0) << 4,
      n = ((t >>>= e) > 255 ? 1 : 0) << 3;
    return (
      (e |= n),
      (e |= n = ((t >>>= n) > 15 ? 1 : 0) << 2),
      (e |= n = ((t >>>= n) > 3 ? 1 : 0) << 1) | ((t >>>= n) >> 1)
    );
  }
  function dm(t, e, n) {
    var i,
      r = t.length;
    if (!(e >= r || 0 === n)) {
      var s = r - (n = e + n > r ? r - e : n);
      for (i = e; i < s; ++i) t[i] = t[i + n];
      t.length = s;
    }
  }
  function pm(t) {
    return 0 === t ? 0 : t < 0 ? -1 : 1;
  }
  var fm = 0;
  function mm() {
    return ++fm;
  }
  var _m = {};
  function gm(t, e, n) {
    if ((void 0 === n && (n = 3), !_m[e])) {
      var i = new Error().stack;
      void 0 === i
        ? console.warn(
            "PixiJS Deprecation Warning: ",
            e + "\nDeprecated since v" + t
          )
        : ((i = i.split("\n").splice(n).join("\n")),
          console.groupCollapsed
            ? (console.groupCollapsed(
                "%cPixiJS Deprecation Warning: %c%s",
                "color:#614108;background:#fffbe6",
                "font-weight:normal;color:#614108;background:#fffbe6",
                e + "\nDeprecated since v" + t
              ),
              console.warn(i),
              console.groupEnd())
            : (console.warn(
                "PixiJS Deprecation Warning: ",
                e + "\nDeprecated since v" + t
              ),
              console.warn(i))),
        (_m[e] = !0);
    }
  }
  var vm,
    ym = {},
    xm = Object.create(null),
    bm = Object.create(null),
    Tm = (function () {
      function t(t, e, n) {
        (this.canvas = Rp.ADAPTER.createCanvas()),
          (this.context = this.canvas.getContext("2d")),
          (this.resolution = n || Rp.RESOLUTION),
          this.resize(t, e);
      }
      return (
        (t.prototype.clear = function () {
          this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }),
        (t.prototype.resize = function (t, e) {
          (this.canvas.width = Math.round(t * this.resolution)),
            (this.canvas.height = Math.round(e * this.resolution));
        }),
        (t.prototype.destroy = function () {
          (this.context = null), (this.canvas = null);
        }),
        Object.defineProperty(t.prototype, "width", {
          get: function () {
            return this.canvas.width;
          },
          set: function (t) {
            this.canvas.width = Math.round(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "height", {
          get: function () {
            return this.canvas.height;
          },
          set: function (t) {
            this.canvas.height = Math.round(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })();
  function Em(t, e) {
    var n = Rp.RETINA_PREFIX.exec(t);
    return n ? parseFloat(n[1]) : void 0 !== e ? e : 1;
  }
  var Sm,
    wm,
    Mm = 2 * Math.PI,
    Am = 180 / Math.PI,
    Rm = Math.PI / 180;
  ((wm = Sm || (Sm = {}))[(wm.POLY = 0)] = "POLY"),
    (wm[(wm.RECT = 1)] = "RECT"),
    (wm[(wm.CIRC = 2)] = "CIRC"),
    (wm[(wm.ELIP = 3)] = "ELIP"),
    (wm[(wm.RREC = 4)] = "RREC");
  var Cm = (function () {
      function t(t, e) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          (this.x = 0),
          (this.y = 0),
          (this.x = t),
          (this.y = e);
      }
      return (
        (t.prototype.clone = function () {
          return new t(this.x, this.y);
        }),
        (t.prototype.copyFrom = function (t) {
          return this.set(t.x, t.y), this;
        }),
        (t.prototype.copyTo = function (t) {
          return t.set(this.x, this.y), t;
        }),
        (t.prototype.equals = function (t) {
          return t.x === this.x && t.y === this.y;
        }),
        (t.prototype.set = function (t, e) {
          return (
            void 0 === t && (t = 0),
            void 0 === e && (e = t),
            (this.x = t),
            (this.y = e),
            this
          );
        }),
        (t.prototype.toString = function () {
          return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
        }),
        t
      );
    })(),
    Im = [new Cm(), new Cm(), new Cm(), new Cm()],
    Pm = (function () {
      function t(t, e, n, i) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          void 0 === n && (n = 0),
          void 0 === i && (i = 0),
          (this.x = Number(t)),
          (this.y = Number(e)),
          (this.width = Number(n)),
          (this.height = Number(i)),
          (this.type = Sm.RECT);
      }
      return (
        Object.defineProperty(t.prototype, "left", {
          get: function () {
            return this.x;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "right", {
          get: function () {
            return this.x + this.width;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "top", {
          get: function () {
            return this.y;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "bottom", {
          get: function () {
            return this.y + this.height;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "EMPTY", {
          get: function () {
            return new t(0, 0, 0, 0);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.clone = function () {
          return new t(this.x, this.y, this.width, this.height);
        }),
        (t.prototype.copyFrom = function (t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }),
        (t.prototype.copyTo = function (t) {
          return (
            (t.x = this.x),
            (t.y = this.y),
            (t.width = this.width),
            (t.height = this.height),
            t
          );
        }),
        (t.prototype.contains = function (t, e) {
          return (
            !(this.width <= 0 || this.height <= 0) &&
            t >= this.x &&
            t < this.x + this.width &&
            e >= this.y &&
            e < this.y + this.height
          );
        }),
        (t.prototype.intersects = function (t, e) {
          if (!e) {
            var n = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= n) return !1;
            var i = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > i;
          }
          var r = this.left,
            s = this.right,
            o = this.top,
            a = this.bottom;
          if (s <= r || a <= o) return !1;
          var l = Im[0].set(t.left, t.top),
            h = Im[1].set(t.left, t.bottom),
            u = Im[2].set(t.right, t.top),
            c = Im[3].set(t.right, t.bottom);
          if (u.x <= l.x || h.y <= l.y) return !1;
          var d = Math.sign(e.a * e.d - e.b * e.c);
          if (0 === d) return !1;
          if (
            (e.apply(l, l),
            e.apply(h, h),
            e.apply(u, u),
            e.apply(c, c),
            Math.max(l.x, h.x, u.x, c.x) <= r ||
              Math.min(l.x, h.x, u.x, c.x) >= s ||
              Math.max(l.y, h.y, u.y, c.y) <= o ||
              Math.min(l.y, h.y, u.y, c.y) >= a)
          )
            return !1;
          var p = d * (h.y - l.y),
            f = d * (l.x - h.x),
            m = p * r + f * o,
            _ = p * s + f * o,
            g = p * r + f * a,
            v = p * s + f * a;
          if (
            Math.max(m, _, g, v) <= p * l.x + f * l.y ||
            Math.min(m, _, g, v) >= p * c.x + f * c.y
          )
            return !1;
          var y = d * (l.y - u.y),
            x = d * (u.x - l.x),
            b = y * r + x * o,
            T = y * s + x * o,
            E = y * r + x * a,
            S = y * s + x * a;
          return !(
            Math.max(b, T, E, S) <= y * l.x + x * l.y ||
            Math.min(b, T, E, S) >= y * c.x + x * c.y
          );
        }),
        (t.prototype.pad = function (t, e) {
          return (
            void 0 === t && (t = 0),
            void 0 === e && (e = t),
            (this.x -= t),
            (this.y -= e),
            (this.width += 2 * t),
            (this.height += 2 * e),
            this
          );
        }),
        (t.prototype.fit = function (t) {
          var e = Math.max(this.x, t.x),
            n = Math.min(this.x + this.width, t.x + t.width),
            i = Math.max(this.y, t.y),
            r = Math.min(this.y + this.height, t.y + t.height);
          return (
            (this.x = e),
            (this.width = Math.max(n - e, 0)),
            (this.y = i),
            (this.height = Math.max(r - i, 0)),
            this
          );
        }),
        (t.prototype.ceil = function (t, e) {
          void 0 === t && (t = 1), void 0 === e && (e = 0.001);
          var n = Math.ceil((this.x + this.width - e) * t) / t,
            i = Math.ceil((this.y + this.height - e) * t) / t;
          return (
            (this.x = Math.floor((this.x + e) * t) / t),
            (this.y = Math.floor((this.y + e) * t) / t),
            (this.width = n - this.x),
            (this.height = i - this.y),
            this
          );
        }),
        (t.prototype.enlarge = function (t) {
          var e = Math.min(this.x, t.x),
            n = Math.max(this.x + this.width, t.x + t.width),
            i = Math.min(this.y, t.y),
            r = Math.max(this.y + this.height, t.y + t.height);
          return (
            (this.x = e),
            (this.width = n - e),
            (this.y = i),
            (this.height = r - i),
            this
          );
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:Rectangle x=" +
            this.x +
            " y=" +
            this.y +
            " width=" +
            this.width +
            " height=" +
            this.height +
            "]"
          );
        }),
        t
      );
    })(),
    Om = (function () {
      function t(t, e, n) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          void 0 === n && (n = 0),
          (this.x = t),
          (this.y = e),
          (this.radius = n),
          (this.type = Sm.CIRC);
      }
      return (
        (t.prototype.clone = function () {
          return new t(this.x, this.y, this.radius);
        }),
        (t.prototype.contains = function (t, e) {
          if (this.radius <= 0) return !1;
          var n = this.radius * this.radius,
            i = this.x - t,
            r = this.y - e;
          return (i *= i) + (r *= r) <= n;
        }),
        (t.prototype.getBounds = function () {
          return new Pm(
            this.x - this.radius,
            this.y - this.radius,
            2 * this.radius,
            2 * this.radius
          );
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:Circle x=" +
            this.x +
            " y=" +
            this.y +
            " radius=" +
            this.radius +
            "]"
          );
        }),
        t
      );
    })(),
    Nm = (function () {
      function t(t, e, n, i) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          void 0 === n && (n = 0),
          void 0 === i && (i = 0),
          (this.x = t),
          (this.y = e),
          (this.width = n),
          (this.height = i),
          (this.type = Sm.ELIP);
      }
      return (
        (t.prototype.clone = function () {
          return new t(this.x, this.y, this.width, this.height);
        }),
        (t.prototype.contains = function (t, e) {
          if (this.width <= 0 || this.height <= 0) return !1;
          var n = (t - this.x) / this.width,
            i = (e - this.y) / this.height;
          return (n *= n) + (i *= i) <= 1;
        }),
        (t.prototype.getBounds = function () {
          return new Pm(
            this.x - this.width,
            this.y - this.height,
            this.width,
            this.height
          );
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:Ellipse x=" +
            this.x +
            " y=" +
            this.y +
            " width=" +
            this.width +
            " height=" +
            this.height +
            "]"
          );
        }),
        t
      );
    })(),
    Dm = (function () {
      function t() {
        for (var t = arguments, e = [], n = 0; n < arguments.length; n++)
          e[n] = t[n];
        var i = Array.isArray(e[0]) ? e[0] : e;
        if ("number" != typeof i[0]) {
          for (var r = [], s = 0, o = i.length; s < o; s++)
            r.push(i[s].x, i[s].y);
          i = r;
        }
        (this.points = i), (this.type = Sm.POLY), (this.closeStroke = !0);
      }
      return (
        (t.prototype.clone = function () {
          var e = new t(this.points.slice());
          return (e.closeStroke = this.closeStroke), e;
        }),
        (t.prototype.contains = function (t, e) {
          for (
            var n = !1, i = this.points.length / 2, r = 0, s = i - 1;
            r < i;
            s = r++
          ) {
            var o = this.points[2 * r],
              a = this.points[2 * r + 1],
              l = this.points[2 * s],
              h = this.points[2 * s + 1];
            a > e != h > e && t < ((e - a) / (h - a)) * (l - o) + o && (n = !n);
          }
          return n;
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:PolygoncloseStroke=" +
            this.closeStroke +
            "points=" +
            this.points.reduce(function (t, e) {
              return t + ", " + e;
            }, "") +
            "]"
          );
        }),
        t
      );
    })(),
    Lm = (function () {
      function t(t, e, n, i, r) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          void 0 === n && (n = 0),
          void 0 === i && (i = 0),
          void 0 === r && (r = 20),
          (this.x = t),
          (this.y = e),
          (this.width = n),
          (this.height = i),
          (this.radius = r),
          (this.type = Sm.RREC);
      }
      return (
        (t.prototype.clone = function () {
          return new t(this.x, this.y, this.width, this.height, this.radius);
        }),
        (t.prototype.contains = function (t, e) {
          if (this.width <= 0 || this.height <= 0) return !1;
          if (
            t >= this.x &&
            t <= this.x + this.width &&
            e >= this.y &&
            e <= this.y + this.height
          ) {
            var n = Math.max(
              0,
              Math.min(this.radius, Math.min(this.width, this.height) / 2)
            );
            if (
              (e >= this.y + n && e <= this.y + this.height - n) ||
              (t >= this.x + n && t <= this.x + this.width - n)
            )
              return !0;
            var i = t - (this.x + n),
              r = e - (this.y + n),
              s = n * n;
            if (i * i + r * r <= s) return !0;
            if ((i = t - (this.x + this.width - n)) * i + r * r <= s) return !0;
            if (i * i + (r = e - (this.y + this.height - n)) * r <= s)
              return !0;
            if ((i = t - (this.x + n)) * i + r * r <= s) return !0;
          }
          return !1;
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:RoundedRectangle x=" +
            this.x +
            " y=" +
            this.y +
            "width=" +
            this.width +
            " height=" +
            this.height +
            " radius=" +
            this.radius +
            "]"
          );
        }),
        t
      );
    })(),
    Fm = (function () {
      function t(t, e, n, i) {
        void 0 === n && (n = 0),
          void 0 === i && (i = 0),
          (this._x = n),
          (this._y = i),
          (this.cb = t),
          (this.scope = e);
      }
      return (
        (t.prototype.clone = function (e, n) {
          return (
            void 0 === e && (e = this.cb),
            void 0 === n && (n = this.scope),
            new t(e, n, this._x, this._y)
          );
        }),
        (t.prototype.set = function (t, e) {
          return (
            void 0 === t && (t = 0),
            void 0 === e && (e = t),
            (this._x === t && this._y === e) ||
              ((this._x = t), (this._y = e), this.cb.call(this.scope)),
            this
          );
        }),
        (t.prototype.copyFrom = function (t) {
          return (
            (this._x === t.x && this._y === t.y) ||
              ((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
            this
          );
        }),
        (t.prototype.copyTo = function (t) {
          return t.set(this._x, this._y), t;
        }),
        (t.prototype.equals = function (t) {
          return t.x === this._x && t.y === this._y;
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]"
          );
        }),
        Object.defineProperty(t.prototype, "x", {
          get: function () {
            return this._x;
          },
          set: function (t) {
            this._x !== t && ((this._x = t), this.cb.call(this.scope));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "y", {
          get: function () {
            return this._y;
          },
          set: function (t) {
            this._y !== t && ((this._y = t), this.cb.call(this.scope));
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })(),
    Um = (function () {
      function t(t, e, n, i, r, s) {
        void 0 === t && (t = 1),
          void 0 === e && (e = 0),
          void 0 === n && (n = 0),
          void 0 === i && (i = 1),
          void 0 === r && (r = 0),
          void 0 === s && (s = 0),
          (this.array = null),
          (this.a = t),
          (this.b = e),
          (this.c = n),
          (this.d = i),
          (this.tx = r),
          (this.ty = s);
      }
      return (
        (t.prototype.fromArray = function (t) {
          (this.a = t[0]),
            (this.b = t[1]),
            (this.c = t[3]),
            (this.d = t[4]),
            (this.tx = t[2]),
            (this.ty = t[5]);
        }),
        (t.prototype.set = function (t, e, n, i, r, s) {
          return (
            (this.a = t),
            (this.b = e),
            (this.c = n),
            (this.d = i),
            (this.tx = r),
            (this.ty = s),
            this
          );
        }),
        (t.prototype.toArray = function (t, e) {
          this.array || (this.array = new Float32Array(9));
          var n = e || this.array;
          return (
            t
              ? ((n[0] = this.a),
                (n[1] = this.b),
                (n[2] = 0),
                (n[3] = this.c),
                (n[4] = this.d),
                (n[5] = 0),
                (n[6] = this.tx),
                (n[7] = this.ty),
                (n[8] = 1))
              : ((n[0] = this.a),
                (n[1] = this.c),
                (n[2] = this.tx),
                (n[3] = this.b),
                (n[4] = this.d),
                (n[5] = this.ty),
                (n[6] = 0),
                (n[7] = 0),
                (n[8] = 1)),
            n
          );
        }),
        (t.prototype.apply = function (t, e) {
          e = e || new Cm();
          var n = t.x,
            i = t.y;
          return (
            (e.x = this.a * n + this.c * i + this.tx),
            (e.y = this.b * n + this.d * i + this.ty),
            e
          );
        }),
        (t.prototype.applyInverse = function (t, e) {
          e = e || new Cm();
          var n = 1 / (this.a * this.d + this.c * -this.b),
            i = t.x,
            r = t.y;
          return (
            (e.x =
              this.d * n * i +
              -this.c * n * r +
              (this.ty * this.c - this.tx * this.d) * n),
            (e.y =
              this.a * n * r +
              -this.b * n * i +
              (-this.ty * this.a + this.tx * this.b) * n),
            e
          );
        }),
        (t.prototype.translate = function (t, e) {
          return (this.tx += t), (this.ty += e), this;
        }),
        (t.prototype.scale = function (t, e) {
          return (
            (this.a *= t),
            (this.d *= e),
            (this.c *= t),
            (this.b *= e),
            (this.tx *= t),
            (this.ty *= e),
            this
          );
        }),
        (t.prototype.rotate = function (t) {
          var e = Math.cos(t),
            n = Math.sin(t),
            i = this.a,
            r = this.c,
            s = this.tx;
          return (
            (this.a = i * e - this.b * n),
            (this.b = i * n + this.b * e),
            (this.c = r * e - this.d * n),
            (this.d = r * n + this.d * e),
            (this.tx = s * e - this.ty * n),
            (this.ty = s * n + this.ty * e),
            this
          );
        }),
        (t.prototype.append = function (t) {
          var e = this.a,
            n = this.b,
            i = this.c,
            r = this.d;
          return (
            (this.a = t.a * e + t.b * i),
            (this.b = t.a * n + t.b * r),
            (this.c = t.c * e + t.d * i),
            (this.d = t.c * n + t.d * r),
            (this.tx = t.tx * e + t.ty * i + this.tx),
            (this.ty = t.tx * n + t.ty * r + this.ty),
            this
          );
        }),
        (t.prototype.setTransform = function (t, e, n, i, r, s, o, a, l) {
          return (
            (this.a = Math.cos(o + l) * r),
            (this.b = Math.sin(o + l) * r),
            (this.c = -Math.sin(o - a) * s),
            (this.d = Math.cos(o - a) * s),
            (this.tx = t - (n * this.a + i * this.c)),
            (this.ty = e - (n * this.b + i * this.d)),
            this
          );
        }),
        (t.prototype.prepend = function (t) {
          var e = this.tx;
          if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
            var n = this.a,
              i = this.c;
            (this.a = n * t.a + this.b * t.c),
              (this.b = n * t.b + this.b * t.d),
              (this.c = i * t.a + this.d * t.c),
              (this.d = i * t.b + this.d * t.d);
          }
          return (
            (this.tx = e * t.a + this.ty * t.c + t.tx),
            (this.ty = e * t.b + this.ty * t.d + t.ty),
            this
          );
        }),
        (t.prototype.decompose = function (t) {
          var e = this.a,
            n = this.b,
            i = this.c,
            r = this.d,
            s = t.pivot,
            o = -Math.atan2(-i, r),
            a = Math.atan2(n, e),
            l = Math.abs(o + a);
          return (
            l < 1e-5 || Math.abs(Mm - l) < 1e-5
              ? ((t.rotation = a), (t.skew.x = t.skew.y = 0))
              : ((t.rotation = 0), (t.skew.x = o), (t.skew.y = a)),
            (t.scale.x = Math.sqrt(e * e + n * n)),
            (t.scale.y = Math.sqrt(i * i + r * r)),
            (t.position.x = this.tx + (s.x * e + s.y * i)),
            (t.position.y = this.ty + (s.x * n + s.y * r)),
            t
          );
        }),
        (t.prototype.invert = function () {
          var t = this.a,
            e = this.b,
            n = this.c,
            i = this.d,
            r = this.tx,
            s = t * i - e * n;
          return (
            (this.a = i / s),
            (this.b = -e / s),
            (this.c = -n / s),
            (this.d = t / s),
            (this.tx = (n * this.ty - i * r) / s),
            (this.ty = -(t * this.ty - e * r) / s),
            this
          );
        }),
        (t.prototype.identity = function () {
          return (
            (this.a = 1),
            (this.b = 0),
            (this.c = 0),
            (this.d = 1),
            (this.tx = 0),
            (this.ty = 0),
            this
          );
        }),
        (t.prototype.clone = function () {
          var e = new t();
          return (
            (e.a = this.a),
            (e.b = this.b),
            (e.c = this.c),
            (e.d = this.d),
            (e.tx = this.tx),
            (e.ty = this.ty),
            e
          );
        }),
        (t.prototype.copyTo = function (t) {
          return (
            (t.a = this.a),
            (t.b = this.b),
            (t.c = this.c),
            (t.d = this.d),
            (t.tx = this.tx),
            (t.ty = this.ty),
            t
          );
        }),
        (t.prototype.copyFrom = function (t) {
          return (
            (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            (this.d = t.d),
            (this.tx = t.tx),
            (this.ty = t.ty),
            this
          );
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:Matrix a=" +
            this.a +
            " b=" +
            this.b +
            " c=" +
            this.c +
            " d=" +
            this.d +
            " tx=" +
            this.tx +
            " ty=" +
            this.ty +
            "]"
          );
        }),
        Object.defineProperty(t, "IDENTITY", {
          get: function () {
            return new t();
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "TEMP_MATRIX", {
          get: function () {
            return new t();
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })(),
    Bm = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    km = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    Gm = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    Hm = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    zm = [],
    Vm = [],
    Xm = Math.sign;
  !(function () {
    for (var t = 0; t < 16; t++) {
      var e = [];
      zm.push(e);
      for (var n = 0; n < 16; n++)
        for (
          var i = Xm(Bm[t] * Bm[n] + Gm[t] * km[n]),
            r = Xm(km[t] * Bm[n] + Hm[t] * km[n]),
            s = Xm(Bm[t] * Gm[n] + Gm[t] * Hm[n]),
            o = Xm(km[t] * Gm[n] + Hm[t] * Hm[n]),
            a = 0;
          a < 16;
          a++
        )
          if (Bm[a] === i && km[a] === r && Gm[a] === s && Hm[a] === o) {
            e.push(a);
            break;
          }
    }
    for (t = 0; t < 16; t++) {
      var l = new Um();
      l.set(Bm[t], km[t], Gm[t], Hm[t], 0, 0), Vm.push(l);
    }
  })();
  var Wm = {
      E: 0,
      SE: 1,
      S: 2,
      SW: 3,
      W: 4,
      NW: 5,
      N: 6,
      NE: 7,
      MIRROR_VERTICAL: 8,
      MAIN_DIAGONAL: 10,
      MIRROR_HORIZONTAL: 12,
      REVERSE_DIAGONAL: 14,
      uX: function (t) {
        return Bm[t];
      },
      uY: function (t) {
        return km[t];
      },
      vX: function (t) {
        return Gm[t];
      },
      vY: function (t) {
        return Hm[t];
      },
      inv: function (t) {
        return 8 & t ? 15 & t : 7 & -t;
      },
      add: function (t, e) {
        return zm[t][e];
      },
      sub: function (t, e) {
        return zm[t][Wm.inv(e)];
      },
      rotate180: function (t) {
        return 4 ^ t;
      },
      isVertical: function (t) {
        return 2 == (3 & t);
      },
      byDirection: function (t, e) {
        return 2 * Math.abs(t) <= Math.abs(e)
          ? e >= 0
            ? Wm.S
            : Wm.N
          : 2 * Math.abs(e) <= Math.abs(t)
          ? t > 0
            ? Wm.E
            : Wm.W
          : e > 0
          ? t > 0
            ? Wm.SE
            : Wm.SW
          : t > 0
          ? Wm.NE
          : Wm.NW;
      },
      matrixAppendRotationInv: function (t, e, n, i) {
        void 0 === n && (n = 0), void 0 === i && (i = 0);
        var r = Vm[Wm.inv(e)];
        (r.tx = n), (r.ty = i), t.append(r);
      },
    },
    jm = (function () {
      function t() {
        (this.worldTransform = new Um()),
          (this.localTransform = new Um()),
          (this.position = new Fm(this.onChange, this, 0, 0)),
          (this.scale = new Fm(this.onChange, this, 1, 1)),
          (this.pivot = new Fm(this.onChange, this, 0, 0)),
          (this.skew = new Fm(this.updateSkew, this, 0, 0)),
          (this._rotation = 0),
          (this._cx = 1),
          (this._sx = 0),
          (this._cy = 0),
          (this._sy = 1),
          (this._localID = 0),
          (this._currentLocalID = 0),
          (this._worldID = 0),
          (this._parentID = 0);
      }
      return (
        (t.prototype.onChange = function () {
          this._localID++;
        }),
        (t.prototype.updateSkew = function () {
          (this._cx = Math.cos(this._rotation + this.skew.y)),
            (this._sx = Math.sin(this._rotation + this.skew.y)),
            (this._cy = -Math.sin(this._rotation - this.skew.x)),
            (this._sy = Math.cos(this._rotation - this.skew.x)),
            this._localID++;
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/math:Transform position=(" +
            this.position.x +
            ", " +
            this.position.y +
            ") rotation=" +
            this.rotation +
            " scale=(" +
            this.scale.x +
            ", " +
            this.scale.y +
            ") skew=(" +
            this.skew.x +
            ", " +
            this.skew.y +
            ") ]"
          );
        }),
        (t.prototype.updateLocalTransform = function () {
          var t = this.localTransform;
          this._localID !== this._currentLocalID &&
            ((t.a = this._cx * this.scale.x),
            (t.b = this._sx * this.scale.x),
            (t.c = this._cy * this.scale.y),
            (t.d = this._sy * this.scale.y),
            (t.tx =
              this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
            (t.ty =
              this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
            (this._currentLocalID = this._localID),
            (this._parentID = -1));
        }),
        (t.prototype.updateTransform = function (t) {
          var e = this.localTransform;
          if (
            (this._localID !== this._currentLocalID &&
              ((e.a = this._cx * this.scale.x),
              (e.b = this._sx * this.scale.x),
              (e.c = this._cy * this.scale.y),
              (e.d = this._sy * this.scale.y),
              (e.tx =
                this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
              (e.ty =
                this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
              (this._currentLocalID = this._localID),
              (this._parentID = -1)),
            this._parentID !== t._worldID)
          ) {
            var n = t.worldTransform,
              i = this.worldTransform;
            (i.a = e.a * n.a + e.b * n.c),
              (i.b = e.a * n.b + e.b * n.d),
              (i.c = e.c * n.a + e.d * n.c),
              (i.d = e.c * n.b + e.d * n.d),
              (i.tx = e.tx * n.a + e.ty * n.c + n.tx),
              (i.ty = e.tx * n.b + e.ty * n.d + n.ty),
              (this._parentID = t._worldID),
              this._worldID++;
          }
        }),
        (t.prototype.setFromMatrix = function (t) {
          t.decompose(this), this._localID++;
        }),
        Object.defineProperty(t.prototype, "rotation", {
          get: function () {
            return this._rotation;
          },
          set: function (t) {
            this._rotation !== t && ((this._rotation = t), this.updateSkew());
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.IDENTITY = new t()),
        t
      );
    })();
  Rp.SORTABLE_CHILDREN = !1;
  var Ym = (function () {
      function t() {
        (this.minX = 1 / 0),
          (this.minY = 1 / 0),
          (this.maxX = -1 / 0),
          (this.maxY = -1 / 0),
          (this.rect = null),
          (this.updateID = -1);
      }
      return (
        (t.prototype.isEmpty = function () {
          return this.minX > this.maxX || this.minY > this.maxY;
        }),
        (t.prototype.clear = function () {
          (this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = -1 / 0),
            (this.maxY = -1 / 0);
        }),
        (t.prototype.getRectangle = function (t) {
          return this.minX > this.maxX || this.minY > this.maxY
            ? Pm.EMPTY
            : (((t = t || new Pm(0, 0, 1, 1)).x = this.minX),
              (t.y = this.minY),
              (t.width = this.maxX - this.minX),
              (t.height = this.maxY - this.minY),
              t);
        }),
        (t.prototype.addPoint = function (t) {
          (this.minX = Math.min(this.minX, t.x)),
            (this.maxX = Math.max(this.maxX, t.x)),
            (this.minY = Math.min(this.minY, t.y)),
            (this.maxY = Math.max(this.maxY, t.y));
        }),
        (t.prototype.addPointMatrix = function (t, e) {
          var n = t.a,
            i = t.b,
            r = t.c,
            s = t.d,
            o = t.tx,
            a = t.ty,
            l = n * e.x + r * e.y + o,
            h = i * e.x + s * e.y + a;
          (this.minX = Math.min(this.minX, l)),
            (this.maxX = Math.max(this.maxX, l)),
            (this.minY = Math.min(this.minY, h)),
            (this.maxY = Math.max(this.maxY, h));
        }),
        (t.prototype.addQuad = function (t) {
          var e = this.minX,
            n = this.minY,
            i = this.maxX,
            r = this.maxY,
            s = t[0],
            o = t[1];
          (e = s < e ? s : e),
            (n = o < n ? o : n),
            (i = s > i ? s : i),
            (r = o > r ? o : r),
            (e = (s = t[2]) < e ? s : e),
            (n = (o = t[3]) < n ? o : n),
            (i = s > i ? s : i),
            (r = o > r ? o : r),
            (e = (s = t[4]) < e ? s : e),
            (n = (o = t[5]) < n ? o : n),
            (i = s > i ? s : i),
            (r = o > r ? o : r),
            (e = (s = t[6]) < e ? s : e),
            (n = (o = t[7]) < n ? o : n),
            (i = s > i ? s : i),
            (r = o > r ? o : r),
            (this.minX = e),
            (this.minY = n),
            (this.maxX = i),
            (this.maxY = r);
        }),
        (t.prototype.addFrame = function (t, e, n, i, r) {
          this.addFrameMatrix(t.worldTransform, e, n, i, r);
        }),
        (t.prototype.addFrameMatrix = function (t, e, n, i, r) {
          var s = t.a,
            o = t.b,
            a = t.c,
            l = t.d,
            h = t.tx,
            u = t.ty,
            c = this.minX,
            d = this.minY,
            p = this.maxX,
            f = this.maxY,
            m = s * e + a * n + h,
            _ = o * e + l * n + u;
          (c = m < c ? m : c),
            (d = _ < d ? _ : d),
            (p = m > p ? m : p),
            (f = _ > f ? _ : f),
            (c = (m = s * i + a * n + h) < c ? m : c),
            (d = (_ = o * i + l * n + u) < d ? _ : d),
            (p = m > p ? m : p),
            (f = _ > f ? _ : f),
            (c = (m = s * e + a * r + h) < c ? m : c),
            (d = (_ = o * e + l * r + u) < d ? _ : d),
            (p = m > p ? m : p),
            (f = _ > f ? _ : f),
            (c = (m = s * i + a * r + h) < c ? m : c),
            (d = (_ = o * i + l * r + u) < d ? _ : d),
            (p = m > p ? m : p),
            (f = _ > f ? _ : f),
            (this.minX = c),
            (this.minY = d),
            (this.maxX = p),
            (this.maxY = f);
        }),
        (t.prototype.addVertexData = function (t, e, n) {
          for (
            var i = this.minX,
              r = this.minY,
              s = this.maxX,
              o = this.maxY,
              a = e;
            a < n;
            a += 2
          ) {
            var l = t[a],
              h = t[a + 1];
            (i = l < i ? l : i),
              (r = h < r ? h : r),
              (s = l > s ? l : s),
              (o = h > o ? h : o);
          }
          (this.minX = i), (this.minY = r), (this.maxX = s), (this.maxY = o);
        }),
        (t.prototype.addVertices = function (t, e, n, i) {
          this.addVerticesMatrix(t.worldTransform, e, n, i);
        }),
        (t.prototype.addVerticesMatrix = function (t, e, n, i, r, s) {
          void 0 === r && (r = 0), void 0 === s && (s = r);
          for (
            var o = t.a,
              a = t.b,
              l = t.c,
              h = t.d,
              u = t.tx,
              c = t.ty,
              d = this.minX,
              p = this.minY,
              f = this.maxX,
              m = this.maxY,
              _ = n;
            _ < i;
            _ += 2
          ) {
            var g = e[_],
              v = e[_ + 1],
              y = o * g + l * v + u,
              x = h * v + a * g + c;
            (d = Math.min(d, y - r)),
              (f = Math.max(f, y + r)),
              (p = Math.min(p, x - s)),
              (m = Math.max(m, x + s));
          }
          (this.minX = d), (this.minY = p), (this.maxX = f), (this.maxY = m);
        }),
        (t.prototype.addBounds = function (t) {
          var e = this.minX,
            n = this.minY,
            i = this.maxX,
            r = this.maxY;
          (this.minX = t.minX < e ? t.minX : e),
            (this.minY = t.minY < n ? t.minY : n),
            (this.maxX = t.maxX > i ? t.maxX : i),
            (this.maxY = t.maxY > r ? t.maxY : r);
        }),
        (t.prototype.addBoundsMask = function (t, e) {
          var n = t.minX > e.minX ? t.minX : e.minX,
            i = t.minY > e.minY ? t.minY : e.minY,
            r = t.maxX < e.maxX ? t.maxX : e.maxX,
            s = t.maxY < e.maxY ? t.maxY : e.maxY;
          if (n <= r && i <= s) {
            var o = this.minX,
              a = this.minY,
              l = this.maxX,
              h = this.maxY;
            (this.minX = n < o ? n : o),
              (this.minY = i < a ? i : a),
              (this.maxX = r > l ? r : l),
              (this.maxY = s > h ? s : h);
          }
        }),
        (t.prototype.addBoundsMatrix = function (t, e) {
          this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
        }),
        (t.prototype.addBoundsArea = function (t, e) {
          var n = t.minX > e.x ? t.minX : e.x,
            i = t.minY > e.y ? t.minY : e.y,
            r = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
            s = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
          if (n <= r && i <= s) {
            var o = this.minX,
              a = this.minY,
              l = this.maxX,
              h = this.maxY;
            (this.minX = n < o ? n : o),
              (this.minY = i < a ? i : a),
              (this.maxX = r > l ? r : l),
              (this.maxY = s > h ? s : h);
          }
        }),
        (t.prototype.pad = function (t, e) {
          void 0 === t && (t = 0),
            void 0 === e && (e = t),
            this.isEmpty() ||
              ((this.minX -= t),
              (this.maxX += t),
              (this.minY -= e),
              (this.maxY += e));
        }),
        (t.prototype.addFramePad = function (t, e, n, i, r, s) {
          (t -= r),
            (e -= s),
            (n += r),
            (i += s),
            (this.minX = this.minX < t ? this.minX : t),
            (this.maxX = this.maxX > n ? this.maxX : n),
            (this.minY = this.minY < e ? this.minY : e),
            (this.maxY = this.maxY > i ? this.maxY : i);
        }),
        t
      );
    })(),
    qm = function (t, e) {
      return (qm =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function Km(t, e) {
    function n() {
      this.constructor = t;
    }
    qm(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var Zm,
    Jm,
    $m,
    Qm,
    t_,
    e_,
    n_,
    i_,
    r_,
    s_,
    o_,
    a_,
    l_,
    h_,
    u_,
    c_,
    d_,
    p_,
    f_,
    m_,
    __ = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (
          (e.tempDisplayObjectParent = null),
          (e.transform = new jm()),
          (e.alpha = 1),
          (e.visible = !0),
          (e.renderable = !0),
          (e.cullable = !1),
          (e.cullArea = null),
          (e.parent = null),
          (e.worldAlpha = 1),
          (e._lastSortedIndex = 0),
          (e._zIndex = 0),
          (e.filterArea = null),
          (e.filters = null),
          (e._enabledFilters = null),
          (e._bounds = new Ym()),
          (e._localBounds = null),
          (e._boundsID = 0),
          (e._boundsRect = null),
          (e._localBoundsRect = null),
          (e._mask = null),
          (e._maskRefCount = 0),
          (e._destroyed = !1),
          (e.isSprite = !1),
          (e.isMask = !1),
          e
        );
      }
      return (
        Km(e, t),
        (e.mixin = function (t) {
          for (var n = Object.keys(t), i = 0; i < n.length; ++i) {
            var r = n[i];
            Object.defineProperty(
              e.prototype,
              r,
              Object.getOwnPropertyDescriptor(t, r)
            );
          }
        }),
        Object.defineProperty(e.prototype, "destroyed", {
          get: function () {
            return this._destroyed;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype._recursivePostUpdateTransform = function () {
          this.parent
            ? (this.parent._recursivePostUpdateTransform(),
              this.transform.updateTransform(this.parent.transform))
            : this.transform.updateTransform(
                this._tempDisplayObjectParent.transform
              );
        }),
        (e.prototype.updateTransform = function () {
          this._boundsID++,
            this.transform.updateTransform(this.parent.transform),
            (this.worldAlpha = this.alpha * this.parent.worldAlpha);
        }),
        (e.prototype.getBounds = function (t, e) {
          return (
            t ||
              (this.parent
                ? (this._recursivePostUpdateTransform(), this.updateTransform())
                : ((this.parent = this._tempDisplayObjectParent),
                  this.updateTransform(),
                  (this.parent = null))),
            this._bounds.updateID !== this._boundsID &&
              (this.calculateBounds(),
              (this._bounds.updateID = this._boundsID)),
            e ||
              (this._boundsRect || (this._boundsRect = new Pm()),
              (e = this._boundsRect)),
            this._bounds.getRectangle(e)
          );
        }),
        (e.prototype.getLocalBounds = function (t) {
          t ||
            (this._localBoundsRect || (this._localBoundsRect = new Pm()),
            (t = this._localBoundsRect)),
            this._localBounds || (this._localBounds = new Ym());
          var e = this.transform,
            n = this.parent;
          (this.parent = null),
            (this.transform = this._tempDisplayObjectParent.transform);
          var i = this._bounds,
            r = this._boundsID;
          this._bounds = this._localBounds;
          var s = this.getBounds(!1, t);
          return (
            (this.parent = n),
            (this.transform = e),
            (this._bounds = i),
            (this._bounds.updateID += this._boundsID - r),
            s
          );
        }),
        (e.prototype.toGlobal = function (t, e, n) {
          return (
            void 0 === n && (n = !1),
            n ||
              (this._recursivePostUpdateTransform(),
              this.parent
                ? this.displayObjectUpdateTransform()
                : ((this.parent = this._tempDisplayObjectParent),
                  this.displayObjectUpdateTransform(),
                  (this.parent = null))),
            this.worldTransform.apply(t, e)
          );
        }),
        (e.prototype.toLocal = function (t, e, n, i) {
          return (
            e && (t = e.toGlobal(t, n, i)),
            i ||
              (this._recursivePostUpdateTransform(),
              this.parent
                ? this.displayObjectUpdateTransform()
                : ((this.parent = this._tempDisplayObjectParent),
                  this.displayObjectUpdateTransform(),
                  (this.parent = null))),
            this.worldTransform.applyInverse(t, n)
          );
        }),
        (e.prototype.setParent = function (t) {
          if (!t || !t.addChild)
            throw new Error("setParent: Argument must be a Container");
          return t.addChild(this), t;
        }),
        (e.prototype.setTransform = function (t, e, n, i, r, s, o, a, l) {
          return (
            void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            void 0 === n && (n = 1),
            void 0 === i && (i = 1),
            void 0 === r && (r = 0),
            void 0 === s && (s = 0),
            void 0 === o && (o = 0),
            void 0 === a && (a = 0),
            void 0 === l && (l = 0),
            (this.position.x = t),
            (this.position.y = e),
            (this.scale.x = n || 1),
            (this.scale.y = i || 1),
            (this.rotation = r),
            (this.skew.x = s),
            (this.skew.y = o),
            (this.pivot.x = a),
            (this.pivot.y = l),
            this
          );
        }),
        (e.prototype.destroy = function (t) {
          this.parent && this.parent.removeChild(this),
            (this._destroyed = !0),
            (this.transform = null),
            (this.parent = null),
            (this._bounds = null),
            (this.mask = null),
            (this.cullArea = null),
            (this.filters = null),
            (this.filterArea = null),
            (this.hitArea = null),
            (this.interactive = !1),
            (this.interactiveChildren = !1),
            this.emit("destroyed"),
            this.removeAllListeners();
        }),
        Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
          get: function () {
            return (
              null === this.tempDisplayObjectParent &&
                (this.tempDisplayObjectParent = new g_()),
              this.tempDisplayObjectParent
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.enableTempParent = function () {
          var t = this.parent;
          return (this.parent = this._tempDisplayObjectParent), t;
        }),
        (e.prototype.disableTempParent = function (t) {
          this.parent = t;
        }),
        Object.defineProperty(e.prototype, "x", {
          get: function () {
            return this.position.x;
          },
          set: function (t) {
            this.transform.position.x = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "y", {
          get: function () {
            return this.position.y;
          },
          set: function (t) {
            this.transform.position.y = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "worldTransform", {
          get: function () {
            return this.transform.worldTransform;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "localTransform", {
          get: function () {
            return this.transform.localTransform;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "position", {
          get: function () {
            return this.transform.position;
          },
          set: function (t) {
            this.transform.position.copyFrom(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "scale", {
          get: function () {
            return this.transform.scale;
          },
          set: function (t) {
            this.transform.scale.copyFrom(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "pivot", {
          get: function () {
            return this.transform.pivot;
          },
          set: function (t) {
            this.transform.pivot.copyFrom(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "skew", {
          get: function () {
            return this.transform.skew;
          },
          set: function (t) {
            this.transform.skew.copyFrom(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "rotation", {
          get: function () {
            return this.transform.rotation;
          },
          set: function (t) {
            this.transform.rotation = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "angle", {
          get: function () {
            return this.transform.rotation * Am;
          },
          set: function (t) {
            this.transform.rotation = t * Rm;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "zIndex", {
          get: function () {
            return this._zIndex;
          },
          set: function (t) {
            (this._zIndex = t), this.parent && (this.parent.sortDirty = !0);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "worldVisible", {
          get: function () {
            var t = this;
            do {
              if (!t.visible) return !1;
              t = t.parent;
            } while (t);
            return !0;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "mask", {
          get: function () {
            return this._mask;
          },
          set: function (t) {
            if (this._mask !== t) {
              var e;
              if (this._mask)
                (e = this._mask.isMaskData
                  ? this._mask.maskObject
                  : this._mask) &&
                  (e._maskRefCount--,
                  0 === e._maskRefCount &&
                    ((e.renderable = !0), (e.isMask = !1)));
              if (((this._mask = t), this._mask))
                (e = this._mask.isMaskData
                  ? this._mask.maskObject
                  : this._mask) &&
                  (0 === e._maskRefCount &&
                    ((e.renderable = !1), (e.isMask = !0)),
                  e._maskRefCount++);
            }
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(Ip),
    g_ = (function (t) {
      function e() {
        var e = (null !== t && t.apply(this, arguments)) || this;
        return (e.sortDirty = null), e;
      }
      return Km(e, t), e;
    })(__);
  function v_(t, e) {
    return t.zIndex === e.zIndex
      ? t._lastSortedIndex - e._lastSortedIndex
      : t.zIndex - e.zIndex;
  }
  (__.prototype.displayObjectUpdateTransform = __.prototype.updateTransform),
    (function (t) {
      (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.WEBGL2 = 2)] = "WEBGL2");
    })(Zm || (Zm = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(Jm || (Jm = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })($m || ($m = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(Qm || (Qm = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(t_ || (t_ = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(e_ || (e_ = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(n_ || (n_ = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(i_ || (i_ = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(r_ || (r_ = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(s_ || (s_ = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(o_ || (o_ = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })(a_ || (a_ = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(l_ || (l_ = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(h_ || (h_ = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(u_ || (u_ = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(c_ || (c_ = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(d_ || (d_ = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(p_ || (p_ = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(f_ || (f_ = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(m_ || (m_ = {}));
  var y_ = (function (t) {
    function e() {
      var e = t.call(this) || this;
      return (
        (e.children = []),
        (e.sortableChildren = Rp.SORTABLE_CHILDREN),
        (e.sortDirty = !1),
        e
      );
    }
    return (
      Km(e, t),
      (e.prototype.onChildrenChange = function (t) {}),
      (e.prototype.addChild = function () {
        for (var t = arguments, e = [], n = 0; n < arguments.length; n++)
          e[n] = t[n];
        if (e.length > 1)
          for (var i = 0; i < e.length; i++) this.addChild(e[i]);
        else {
          var r = e[0];
          r.parent && r.parent.removeChild(r),
            (r.parent = this),
            (this.sortDirty = !0),
            (r.transform._parentID = -1),
            this.children.push(r),
            this._boundsID++,
            this.onChildrenChange(this.children.length - 1),
            this.emit("childAdded", r, this, this.children.length - 1),
            r.emit("added", this);
        }
        return e[0];
      }),
      (e.prototype.addChildAt = function (t, e) {
        if (e < 0 || e > this.children.length)
          throw new Error(
            t +
              "addChildAt: The index " +
              e +
              " supplied is out of bounds " +
              this.children.length
          );
        return (
          t.parent && t.parent.removeChild(t),
          (t.parent = this),
          (this.sortDirty = !0),
          (t.transform._parentID = -1),
          this.children.splice(e, 0, t),
          this._boundsID++,
          this.onChildrenChange(e),
          t.emit("added", this),
          this.emit("childAdded", t, this, e),
          t
        );
      }),
      (e.prototype.swapChildren = function (t, e) {
        if (t !== e) {
          var n = this.getChildIndex(t),
            i = this.getChildIndex(e);
          (this.children[n] = e),
            (this.children[i] = t),
            this.onChildrenChange(n < i ? n : i);
        }
      }),
      (e.prototype.getChildIndex = function (t) {
        var e = this.children.indexOf(t);
        if (-1 === e)
          throw new Error(
            "The supplied DisplayObject must be a child of the caller"
          );
        return e;
      }),
      (e.prototype.setChildIndex = function (t, e) {
        if (e < 0 || e >= this.children.length)
          throw new Error(
            "The index " +
              e +
              " supplied is out of bounds " +
              this.children.length
          );
        var n = this.getChildIndex(t);
        dm(this.children, n, 1),
          this.children.splice(e, 0, t),
          this.onChildrenChange(e);
      }),
      (e.prototype.getChildAt = function (t) {
        if (t < 0 || t >= this.children.length)
          throw new Error("getChildAt: Index (" + t + ") does not exist.");
        return this.children[t];
      }),
      (e.prototype.removeChild = function () {
        for (var t = arguments, e = [], n = 0; n < arguments.length; n++)
          e[n] = t[n];
        if (e.length > 1)
          for (var i = 0; i < e.length; i++) this.removeChild(e[i]);
        else {
          var r = e[0],
            s = this.children.indexOf(r);
          if (-1 === s) return null;
          (r.parent = null),
            (r.transform._parentID = -1),
            dm(this.children, s, 1),
            this._boundsID++,
            this.onChildrenChange(s),
            r.emit("removed", this),
            this.emit("childRemoved", r, this, s);
        }
        return e[0];
      }),
      (e.prototype.removeChildAt = function (t) {
        var e = this.getChildAt(t);
        return (
          (e.parent = null),
          (e.transform._parentID = -1),
          dm(this.children, t, 1),
          this._boundsID++,
          this.onChildrenChange(t),
          e.emit("removed", this),
          this.emit("childRemoved", e, this, t),
          e
        );
      }),
      (e.prototype.removeChildren = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var n,
          i = t,
          r = e - i;
        if (r > 0 && r <= e) {
          n = this.children.splice(i, r);
          for (var s = 0; s < n.length; ++s)
            (n[s].parent = null),
              n[s].transform && (n[s].transform._parentID = -1);
          this._boundsID++, this.onChildrenChange(t);
          for (s = 0; s < n.length; ++s)
            n[s].emit("removed", this),
              this.emit("childRemoved", n[s], this, s);
          return n;
        }
        if (0 === r && 0 === this.children.length) return [];
        throw new RangeError(
          "removeChildren: numeric values are outside the acceptable range."
        );
      }),
      (e.prototype.sortChildren = function () {
        for (var t = !1, e = 0, n = this.children.length; e < n; ++e) {
          var i = this.children[e];
          (i._lastSortedIndex = e), t || 0 === i.zIndex || (t = !0);
        }
        t && this.children.length > 1 && this.children.sort(v_),
          (this.sortDirty = !1);
      }),
      (e.prototype.updateTransform = function () {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
          this._boundsID++,
          this.transform.updateTransform(this.parent.transform),
          (this.worldAlpha = this.alpha * this.parent.worldAlpha);
        for (var t = 0, e = this.children.length; t < e; ++t) {
          var n = this.children[t];
          n.visible && n.updateTransform();
        }
      }),
      (e.prototype.calculateBounds = function () {
        this._bounds.clear(), this._calculateBounds();
        for (var t = 0; t < this.children.length; t++) {
          var e = this.children[t];
          if (e.visible && e.renderable)
            if ((e.calculateBounds(), e._mask)) {
              var n = e._mask.isMaskData ? e._mask.maskObject : e._mask;
              n
                ? (n.calculateBounds(),
                  this._bounds.addBoundsMask(e._bounds, n._bounds))
                : this._bounds.addBounds(e._bounds);
            } else
              e.filterArea
                ? this._bounds.addBoundsArea(e._bounds, e.filterArea)
                : this._bounds.addBounds(e._bounds);
        }
        this._bounds.updateID = this._boundsID;
      }),
      (e.prototype.getLocalBounds = function (e, n) {
        void 0 === n && (n = !1);
        var i = t.prototype.getLocalBounds.call(this, e);
        if (!n)
          for (var r = 0, s = this.children.length; r < s; ++r) {
            var o = this.children[r];
            o.visible && o.updateTransform();
          }
        return i;
      }),
      (e.prototype._calculateBounds = function () {}),
      (e.prototype._renderWithCulling = function (t) {
        var n = t.renderTexture.sourceFrame;
        if (n.width > 0 && n.height > 0) {
          var i, r;
          if (
            (this.cullArea
              ? ((i = this.cullArea), (r = this.worldTransform))
              : this._render !== e.prototype._render &&
                (i = this.getBounds(!0)),
            i && n.intersects(i, r))
          )
            this._render(t);
          else if (this.cullArea) return;
          for (var s = 0, o = this.children.length; s < o; ++s) {
            var a = this.children[s],
              l = a.cullable;
            (a.cullable = l || !this.cullArea), a.render(t), (a.cullable = l);
          }
        }
      }),
      (e.prototype.render = function (t) {
        if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
          if (this._mask || (this.filters && this.filters.length))
            this.renderAdvanced(t);
          else if (this.cullable) this._renderWithCulling(t);
          else {
            this._render(t);
            for (var e = 0, n = this.children.length; e < n; ++e)
              this.children[e].render(t);
          }
      }),
      (e.prototype.renderAdvanced = function (t) {
        var e = this.filters,
          n = this._mask;
        if (e) {
          this._enabledFilters || (this._enabledFilters = []),
            (this._enabledFilters.length = 0);
          for (var i = 0; i < e.length; i++)
            e[i].enabled && this._enabledFilters.push(e[i]);
        }
        var r =
          (e && this._enabledFilters && this._enabledFilters.length) ||
          (n &&
            (!n.isMaskData ||
              (n.enabled && (n.autoDetect || n.type !== d_.NONE))));
        if (
          (r && t.batch.flush(),
          e &&
            this._enabledFilters &&
            this._enabledFilters.length &&
            t.filter.push(this, this._enabledFilters),
          n && t.mask.push(this, this._mask),
          this.cullable)
        )
          this._renderWithCulling(t);
        else {
          this._render(t);
          i = 0;
          for (var s = this.children.length; i < s; ++i)
            this.children[i].render(t);
        }
        r && t.batch.flush(),
          n && t.mask.pop(this),
          e &&
            this._enabledFilters &&
            this._enabledFilters.length &&
            t.filter.pop();
      }),
      (e.prototype._render = function (t) {}),
      (e.prototype.destroy = function (e) {
        t.prototype.destroy.call(this), (this.sortDirty = !1);
        var n = "boolean" == typeof e ? e : e && e.children,
          i = this.removeChildren(0, this.children.length);
        if (n) for (var r = 0; r < i.length; ++r) i[r].destroy(e);
      }),
      Object.defineProperty(e.prototype, "width", {
        get: function () {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function (t) {
          var e = this.getLocalBounds().width;
          (this.scale.x = 0 !== e ? t / e : 1), (this._width = t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "height", {
        get: function () {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function (t) {
          var e = this.getLocalBounds().height;
          (this.scale.y = 0 !== e ? t / e : 1), (this._height = t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      e
    );
  })(__);
  y_.prototype.containerUpdateTransform = y_.prototype.updateTransform;
  var x_,
    b_,
    T_ = function () {
      return (
        (T_ =
          Object.assign ||
          function (t) {
            for (var e, n = arguments, i = 1, r = arguments.length; i < r; i++)
              for (var s in (e = n[i]))
                Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
            return t;
          }),
        T_.apply(this, arguments)
      );
    };
  ((b_ = x_ || (x_ = {})).Application = "application"),
    (b_.RendererPlugin = "renderer-webgl-plugin"),
    (b_.CanvasRendererPlugin = "renderer-canvas-plugin"),
    (b_.Loader = "loader"),
    (b_.LoadParser = "load-parser"),
    (b_.ResolveParser = "resolve-parser"),
    (b_.CacheParser = "cache-parser"),
    (b_.DetectionParser = "detection-parser");
  var E_,
    S_,
    w_ = function (t) {
      if ("function" == typeof t || ("object" == typeof t && t.extension)) {
        if (!t.extension)
          throw new Error("Extension class must have an extension object");
        var e =
          "object" != typeof t.extension ? { type: t.extension } : t.extension;
        t = T_(T_({}, e), { ref: t });
      }
      if ("object" != typeof t) throw new Error("Invalid extension type");
      return "string" == typeof (t = T_({}, t)).type && (t.type = [t.type]), t;
    },
    M_ = {
      _addHandlers: null,
      _removeHandlers: null,
      _queue: {},
      remove: function () {
        for (
          var t = arguments, e = this, n = [], i = 0;
          i < arguments.length;
          i++
        )
          n[i] = t[i];
        return (
          n.map(w_).forEach(function (t) {
            t.type.forEach(function (n) {
              var i, r;
              return null === (r = (i = e._removeHandlers)[n]) || void 0 === r
                ? void 0
                : r.call(i, t);
            });
          }),
          this
        );
      },
      add: function () {
        for (
          var t = arguments, e = this, n = [], i = 0;
          i < arguments.length;
          i++
        )
          n[i] = t[i];
        return (
          n.map(w_).forEach(function (t) {
            t.type.forEach(function (n) {
              var i = e._addHandlers,
                r = e._queue;
              i[n] ? i[n](t) : ((r[n] = r[n] || []), r[n].push(t));
            });
          }),
          this
        );
      },
      handle: function (t, e, n) {
        var i = (this._addHandlers = this._addHandlers || {}),
          r = (this._removeHandlers = this._removeHandlers || {});
        if (i[t] || r[t])
          throw new Error("Extension type " + t + " already has a handler");
        (i[t] = e), (r[t] = n);
        var s = this._queue;
        return (
          s[t] &&
            (s[t].forEach(function (t) {
              return e(t);
            }),
            delete s[t]),
          this
        );
      },
      handleByMap: function (t, e) {
        return this.handle(
          t,
          function (t) {
            e[t.name] = t.ref;
          },
          function (t) {
            delete e[t.name];
          }
        );
      },
      handleByList: function (t, e) {
        return this.handle(
          t,
          function (n) {
            var i, r;
            e.push(n.ref),
              t === x_.Loader &&
                (null === (r = (i = n.ref).add) || void 0 === r || r.call(i));
          },
          function (t) {
            var n = e.indexOf(t.ref);
            -1 !== n && e.splice(n, 1);
          }
        );
      },
    },
    A_ = (function () {
      function t(t) {
        (this.items = []), (this._name = t), (this._aliasCount = 0);
      }
      return (
        (t.prototype.emit = function (t, e, n, i, r, s, o, a) {
          if (arguments.length > 8) throw new Error("max arguments reached");
          var l = this,
            h = l.name,
            u = l.items;
          this._aliasCount++;
          for (var c = 0, d = u.length; c < d; c++)
            u[c][h](t, e, n, i, r, s, o, a);
          return u === this.items && this._aliasCount--, this;
        }),
        (t.prototype.ensureNonAliasedItems = function () {
          this._aliasCount > 0 &&
            this.items.length > 1 &&
            ((this._aliasCount = 0), (this.items = this.items.slice(0)));
        }),
        (t.prototype.add = function (t) {
          return (
            t[this._name] &&
              (this.ensureNonAliasedItems(),
              this.remove(t),
              this.items.push(t)),
            this
          );
        }),
        (t.prototype.remove = function (t) {
          var e = this.items.indexOf(t);
          return (
            -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
            this
          );
        }),
        (t.prototype.contains = function (t) {
          return -1 !== this.items.indexOf(t);
        }),
        (t.prototype.removeAll = function () {
          return this.ensureNonAliasedItems(), (this.items.length = 0), this;
        }),
        (t.prototype.destroy = function () {
          this.removeAll(), (this.items = null), (this._name = null);
        }),
        Object.defineProperty(t.prototype, "empty", {
          get: function () {
            return 0 === this.items.length;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "name", {
          get: function () {
            return this._name;
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })();
  Object.defineProperties(A_.prototype, {
    dispatch: { value: A_.prototype.emit },
    run: { value: A_.prototype.emit },
  }),
    (Rp.TARGET_FPMS = 0.06),
    ((S_ = E_ || (E_ = {}))[(S_.INTERACTION = 50)] = "INTERACTION"),
    (S_[(S_.HIGH = 25)] = "HIGH"),
    (S_[(S_.NORMAL = 0)] = "NORMAL"),
    (S_[(S_.LOW = -25)] = "LOW"),
    (S_[(S_.UTILITY = -50)] = "UTILITY");
  var R_ = (function () {
      function t(t, e, n, i) {
        void 0 === e && (e = null),
          void 0 === n && (n = 0),
          void 0 === i && (i = !1),
          (this.next = null),
          (this.previous = null),
          (this._destroyed = !1),
          (this.fn = t),
          (this.context = e),
          (this.priority = n),
          (this.once = i);
      }
      return (
        (t.prototype.match = function (t, e) {
          return (
            void 0 === e && (e = null), this.fn === t && this.context === e
          );
        }),
        (t.prototype.emit = function (t) {
          this.fn &&
            (this.context ? this.fn.call(this.context, t) : this.fn(t));
          var e = this.next;
          return (
            this.once && this.destroy(!0),
            this._destroyed && (this.next = null),
            e
          );
        }),
        (t.prototype.connect = function (t) {
          (this.previous = t),
            t.next && (t.next.previous = this),
            (this.next = t.next),
            (t.next = this);
        }),
        (t.prototype.destroy = function (t) {
          void 0 === t && (t = !1),
            (this._destroyed = !0),
            (this.fn = null),
            (this.context = null),
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous);
          var e = this.next;
          return (this.next = t ? null : e), (this.previous = null), e;
        }),
        t
      );
    })(),
    C_ = (function () {
      function t() {
        var t = this;
        (this.autoStart = !1),
          (this.deltaTime = 1),
          (this.lastTime = -1),
          (this.speed = 1),
          (this.started = !1),
          (this._requestId = null),
          (this._maxElapsedMS = 100),
          (this._minElapsedMS = 0),
          (this._protected = !1),
          (this._lastFrame = -1),
          (this._head = new R_(null, null, 1 / 0)),
          (this.deltaMS = 1 / Rp.TARGET_FPMS),
          (this.elapsedMS = 1 / Rp.TARGET_FPMS),
          (this._tick = function (e) {
            (t._requestId = null),
              t.started &&
                (t.update(e),
                t.started &&
                  null === t._requestId &&
                  t._head.next &&
                  (t._requestId = requestAnimationFrame(t._tick)));
          });
      }
      return (
        (t.prototype._requestIfNeeded = function () {
          null === this._requestId &&
            this._head.next &&
            ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)));
        }),
        (t.prototype._cancelIfNeeded = function () {
          null !== this._requestId &&
            (cancelAnimationFrame(this._requestId), (this._requestId = null));
        }),
        (t.prototype._startIfPossible = function () {
          this.started
            ? this._requestIfNeeded()
            : this.autoStart && this.start();
        }),
        (t.prototype.add = function (t, e, n) {
          return (
            void 0 === n && (n = E_.NORMAL), this._addListener(new R_(t, e, n))
          );
        }),
        (t.prototype.addOnce = function (t, e, n) {
          return (
            void 0 === n && (n = E_.NORMAL),
            this._addListener(new R_(t, e, n, !0))
          );
        }),
        (t.prototype._addListener = function (t) {
          var e = this._head.next,
            n = this._head;
          if (e) {
            for (; e; ) {
              if (t.priority > e.priority) {
                t.connect(n);
                break;
              }
              (n = e), (e = e.next);
            }
            t.previous || t.connect(n);
          } else t.connect(n);
          return this._startIfPossible(), this;
        }),
        (t.prototype.remove = function (t, e) {
          for (var n = this._head.next; n; )
            n = n.match(t, e) ? n.destroy() : n.next;
          return this._head.next || this._cancelIfNeeded(), this;
        }),
        Object.defineProperty(t.prototype, "count", {
          get: function () {
            if (!this._head) return 0;
            for (var t = 0, e = this._head; (e = e.next); ) t++;
            return t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.start = function () {
          this.started || ((this.started = !0), this._requestIfNeeded());
        }),
        (t.prototype.stop = function () {
          this.started && ((this.started = !1), this._cancelIfNeeded());
        }),
        (t.prototype.destroy = function () {
          if (!this._protected) {
            this.stop();
            for (var t = this._head.next; t; ) t = t.destroy(!0);
            this._head.destroy(), (this._head = null);
          }
        }),
        (t.prototype.update = function (t) {
          var e;
          if ((void 0 === t && (t = performance.now()), t > this.lastTime)) {
            if (
              ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS &&
                (e = this._maxElapsedMS),
              (e *= this.speed),
              this._minElapsedMS)
            ) {
              var n = (t - this._lastFrame) | 0;
              if (n < this._minElapsedMS) return;
              this._lastFrame = t - (n % this._minElapsedMS);
            }
            (this.deltaMS = e),
              (this.deltaTime = this.deltaMS * Rp.TARGET_FPMS);
            for (var i = this._head, r = i.next; r; )
              r = r.emit(this.deltaTime);
            i.next || this._cancelIfNeeded();
          } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          this.lastTime = t;
        }),
        Object.defineProperty(t.prototype, "FPS", {
          get: function () {
            return 1e3 / this.elapsedMS;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "minFPS", {
          get: function () {
            return 1e3 / this._maxElapsedMS;
          },
          set: function (t) {
            var e = Math.min(this.maxFPS, t),
              n = Math.min(Math.max(0, e) / 1e3, Rp.TARGET_FPMS);
            this._maxElapsedMS = 1 / n;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "maxFPS", {
          get: function () {
            return this._minElapsedMS
              ? Math.round(1e3 / this._minElapsedMS)
              : 0;
          },
          set: function (t) {
            if (0 === t) this._minElapsedMS = 0;
            else {
              var e = Math.max(this.minFPS, t);
              this._minElapsedMS = 1 / (e / 1e3);
            }
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "shared", {
          get: function () {
            if (!t._shared) {
              var e = (t._shared = new t());
              (e.autoStart = !0), (e._protected = !0);
            }
            return t._shared;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "system", {
          get: function () {
            if (!t._system) {
              var e = (t._system = new t());
              (e.autoStart = !0), (e._protected = !0);
            }
            return t._system;
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })(),
    I_ = (function () {
      function t() {}
      return (
        (t.init = function (t) {
          var e = this;
          (t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t)),
            Object.defineProperty(this, "ticker", {
              set: function (t) {
                this._ticker && this._ticker.remove(this.render, this),
                  (this._ticker = t),
                  t && t.add(this.render, this, E_.LOW);
              },
              get: function () {
                return this._ticker;
              },
            }),
            (this.stop = function () {
              e._ticker.stop();
            }),
            (this.start = function () {
              e._ticker.start();
            }),
            (this._ticker = null),
            (this.ticker = t.sharedTicker ? C_.shared : new C_()),
            t.autoStart && this.start();
        }),
        (t.destroy = function () {
          if (this._ticker) {
            var t = this._ticker;
            (this.ticker = null), t.destroy();
          }
        }),
        (t.extension = x_.Application),
        t
      );
    })();
  (Rp.PREFER_ENV = Ap.any ? gf.WEBGL : gf.WEBGL2),
    (Rp.STRICT_TEXTURE_CACHE = !1);
  var P_ = [];
  function O_(t, e) {
    if (!t) return null;
    var n = "";
    if ("string" == typeof t) {
      var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
      i && (n = i[1].toLowerCase());
    }
    for (var r = P_.length - 1; r >= 0; --r) {
      var s = P_[r];
      if (s.test && s.test(t, n)) return new s(t, e);
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  var N_ = function (t, e) {
    return (N_ =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  function D_(t, e) {
    function n() {
      this.constructor = t;
    }
    N_(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var L_ = function () {
    return (
      (L_ =
        Object.assign ||
        function (t) {
          for (var e, n = arguments, i = 1, r = arguments.length; i < r; i++)
            for (var s in (e = n[i]))
              Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
          return t;
        }),
      L_.apply(this, arguments)
    );
  };
  var F_ = (function () {
      function t(t, e) {
        void 0 === t && (t = 0),
          void 0 === e && (e = 0),
          (this._width = t),
          (this._height = e),
          (this.destroyed = !1),
          (this.internal = !1),
          (this.onResize = new A_("setRealSize")),
          (this.onUpdate = new A_("update")),
          (this.onError = new A_("onError"));
      }
      return (
        (t.prototype.bind = function (t) {
          this.onResize.add(t),
            this.onUpdate.add(t),
            this.onError.add(t),
            (this._width || this._height) &&
              this.onResize.emit(this._width, this._height);
        }),
        (t.prototype.unbind = function (t) {
          this.onResize.remove(t),
            this.onUpdate.remove(t),
            this.onError.remove(t);
        }),
        (t.prototype.resize = function (t, e) {
          (t === this._width && e === this._height) ||
            ((this._width = t), (this._height = e), this.onResize.emit(t, e));
        }),
        Object.defineProperty(t.prototype, "valid", {
          get: function () {
            return !!this._width && !!this._height;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.update = function () {
          this.destroyed || this.onUpdate.emit();
        }),
        (t.prototype.load = function () {
          return Promise.resolve(this);
        }),
        Object.defineProperty(t.prototype, "width", {
          get: function () {
            return this._width;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "height", {
          get: function () {
            return this._height;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.style = function (t, e, n) {
          return !1;
        }),
        (t.prototype.dispose = function () {}),
        (t.prototype.destroy = function () {
          this.destroyed ||
            ((this.destroyed = !0),
            this.dispose(),
            this.onError.removeAll(),
            (this.onError = null),
            this.onResize.removeAll(),
            (this.onResize = null),
            this.onUpdate.removeAll(),
            (this.onUpdate = null));
        }),
        (t.test = function (t, e) {
          return !1;
        }),
        t
      );
    })(),
    U_ = (function (t) {
      function e(e, n) {
        var i = this,
          r = n || {},
          s = r.width,
          o = r.height;
        if (!s || !o) throw new Error("BufferResource width or height invalid");
        return ((i = t.call(this, s, o) || this).data = e), i;
      }
      return (
        D_(e, t),
        (e.prototype.upload = function (t, e, n) {
          var i = t.gl;
          i.pixelStorei(
            i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            e.alphaMode === Cf.UNPACK
          );
          var r = e.realWidth,
            s = e.realHeight;
          return (
            n.width === r && n.height === s
              ? i.texSubImage2D(
                  e.target,
                  0,
                  0,
                  0,
                  r,
                  s,
                  e.format,
                  n.type,
                  this.data
                )
              : ((n.width = r),
                (n.height = s),
                i.texImage2D(
                  e.target,
                  0,
                  n.internalFormat,
                  r,
                  s,
                  0,
                  e.format,
                  n.type,
                  this.data
                )),
            !0
          );
        }),
        (e.prototype.dispose = function () {
          this.data = null;
        }),
        (e.test = function (t) {
          return (
            t instanceof Float32Array ||
            t instanceof Uint8Array ||
            t instanceof Uint32Array
          );
        }),
        e
      );
    })(F_),
    B_ = { scaleMode: Mf.NEAREST, format: Tf.RGBA, alphaMode: Cf.NPM },
    k_ = (function (t) {
      function e(e, n) {
        void 0 === e && (e = null), void 0 === n && (n = null);
        var i = t.call(this) || this,
          r = (n = n || {}).alphaMode,
          s = n.mipmap,
          o = n.anisotropicLevel,
          a = n.scaleMode,
          l = n.width,
          h = n.height,
          u = n.wrapMode,
          c = n.format,
          d = n.type,
          p = n.target,
          f = n.resolution,
          m = n.resourceOptions;
        return (
          !e || e instanceof F_ || ((e = O_(e, m)).internal = !0),
          (i.resolution = f || Rp.RESOLUTION),
          (i.width = Math.round((l || 0) * i.resolution) / i.resolution),
          (i.height = Math.round((h || 0) * i.resolution) / i.resolution),
          (i._mipmap = void 0 !== s ? s : Rp.MIPMAP_TEXTURES),
          (i.anisotropicLevel = void 0 !== o ? o : Rp.ANISOTROPIC_LEVEL),
          (i._wrapMode = u || Rp.WRAP_MODE),
          (i._scaleMode = void 0 !== a ? a : Rp.SCALE_MODE),
          (i.format = c || Tf.RGBA),
          (i.type = d || Sf.UNSIGNED_BYTE),
          (i.target = p || Ef.TEXTURE_2D),
          (i.alphaMode = void 0 !== r ? r : Cf.UNPACK),
          (i.uid = mm()),
          (i.touched = 0),
          (i.isPowerOfTwo = !1),
          i._refreshPOT(),
          (i._glTextures = {}),
          (i.dirtyId = 0),
          (i.dirtyStyleId = 0),
          (i.cacheId = null),
          (i.valid = l > 0 && h > 0),
          (i.textureCacheIds = []),
          (i.destroyed = !1),
          (i.resource = null),
          (i._batchEnabled = 0),
          (i._batchLocation = 0),
          (i.parentTextureArray = null),
          i.setResource(e),
          i
        );
      }
      return (
        D_(e, t),
        Object.defineProperty(e.prototype, "realWidth", {
          get: function () {
            return Math.round(this.width * this.resolution);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "realHeight", {
          get: function () {
            return Math.round(this.height * this.resolution);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "mipmap", {
          get: function () {
            return this._mipmap;
          },
          set: function (t) {
            this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "scaleMode", {
          get: function () {
            return this._scaleMode;
          },
          set: function (t) {
            this._scaleMode !== t &&
              ((this._scaleMode = t), this.dirtyStyleId++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "wrapMode", {
          get: function () {
            return this._wrapMode;
          },
          set: function (t) {
            this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.setStyle = function (t, e) {
          var n;
          return (
            void 0 !== t &&
              t !== this.scaleMode &&
              ((this.scaleMode = t), (n = !0)),
            void 0 !== e && e !== this.mipmap && ((this.mipmap = e), (n = !0)),
            n && this.dirtyStyleId++,
            this
          );
        }),
        (e.prototype.setSize = function (t, e, n) {
          return (n = n || this.resolution), this.setRealSize(t * n, e * n, n);
        }),
        (e.prototype.setRealSize = function (t, e, n) {
          return (
            (this.resolution = n || this.resolution),
            (this.width = Math.round(t) / this.resolution),
            (this.height = Math.round(e) / this.resolution),
            this._refreshPOT(),
            this.update(),
            this
          );
        }),
        (e.prototype._refreshPOT = function () {
          this.isPowerOfTwo = um(this.realWidth) && um(this.realHeight);
        }),
        (e.prototype.setResolution = function (t) {
          var e = this.resolution;
          return (
            e === t ||
              ((this.resolution = t),
              this.valid &&
                ((this.width = Math.round(this.width * e) / t),
                (this.height = Math.round(this.height * e) / t),
                this.emit("update", this)),
              this._refreshPOT()),
            this
          );
        }),
        (e.prototype.setResource = function (t) {
          if (this.resource === t) return this;
          if (this.resource) throw new Error("Resource can be set only once");
          return t.bind(this), (this.resource = t), this;
        }),
        (e.prototype.update = function () {
          this.valid
            ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this))
            : this.width > 0 &&
              this.height > 0 &&
              ((this.valid = !0),
              this.emit("loaded", this),
              this.emit("update", this));
        }),
        (e.prototype.onError = function (t) {
          this.emit("error", this, t);
        }),
        (e.prototype.destroy = function () {
          this.resource &&
            (this.resource.unbind(this),
            this.resource.internal && this.resource.destroy(),
            (this.resource = null)),
            this.cacheId &&
              (delete bm[this.cacheId],
              delete xm[this.cacheId],
              (this.cacheId = null)),
            this.dispose(),
            e.removeFromCache(this),
            (this.textureCacheIds = null),
            (this.destroyed = !0);
        }),
        (e.prototype.dispose = function () {
          this.emit("dispose", this);
        }),
        (e.prototype.castToBaseTexture = function () {
          return this;
        }),
        (e.from = function (t, n, i) {
          void 0 === i && (i = Rp.STRICT_TEXTURE_CACHE);
          var r = "string" == typeof t,
            s = null;
          if (r) s = t;
          else {
            if (!t._pixiId) {
              var o = (n && n.pixiIdPrefix) || "pixiid";
              t._pixiId = o + "_" + mm();
            }
            s = t._pixiId;
          }
          var a = bm[s];
          if (r && i && !a)
            throw new Error(
              'The cacheId "' + s + '" does not exist in BaseTextureCache.'
            );
          return a || (((a = new e(t, n)).cacheId = s), e.addToCache(a, s)), a;
        }),
        (e.fromBuffer = function (t, n, i, r) {
          t = t || new Float32Array(n * i * 4);
          var s = new U_(t, { width: n, height: i }),
            o = t instanceof Float32Array ? Sf.FLOAT : Sf.UNSIGNED_BYTE;
          return new e(
            s,
            Object.assign(B_, r || { width: n, height: i, type: o })
          );
        }),
        (e.addToCache = function (t, e) {
          e &&
            (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
            bm[e] &&
              console.warn(
                "BaseTexture added to the cache with an id [" +
                  e +
                  "] that already had an entry"
              ),
            (bm[e] = t));
        }),
        (e.removeFromCache = function (t) {
          if ("string" == typeof t) {
            var e = bm[t];
            if (e) {
              var n = e.textureCacheIds.indexOf(t);
              return n > -1 && e.textureCacheIds.splice(n, 1), delete bm[t], e;
            }
          } else if (t && t.textureCacheIds) {
            for (var i = 0; i < t.textureCacheIds.length; ++i)
              delete bm[t.textureCacheIds[i]];
            return (t.textureCacheIds.length = 0), t;
          }
          return null;
        }),
        (e._globalBatch = 0),
        e
      );
    })(Ip),
    G_ = (function (t) {
      function e(e, n) {
        var i = this,
          r = n || {},
          s = r.width,
          o = r.height;
        ((i = t.call(this, s, o) || this).items = []), (i.itemDirtyIds = []);
        for (var a = 0; a < e; a++) {
          var l = new k_();
          i.items.push(l), i.itemDirtyIds.push(-2);
        }
        return (i.length = e), (i._load = null), (i.baseTexture = null), i;
      }
      return (
        D_(e, t),
        (e.prototype.initFromArray = function (t, e) {
          for (var n = 0; n < this.length; n++)
            t[n] &&
              (t[n].castToBaseTexture
                ? this.addBaseTextureAt(t[n].castToBaseTexture(), n)
                : t[n] instanceof F_
                ? this.addResourceAt(t[n], n)
                : this.addResourceAt(O_(t[n], e), n));
        }),
        (e.prototype.dispose = function () {
          for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
          (this.items = null), (this.itemDirtyIds = null), (this._load = null);
        }),
        (e.prototype.addResourceAt = function (t, e) {
          if (!this.items[e])
            throw new Error("Index " + e + " is out of bounds");
          return (
            t.valid && !this.valid && this.resize(t.width, t.height),
            this.items[e].setResource(t),
            this
          );
        }),
        (e.prototype.bind = function (e) {
          if (null !== this.baseTexture)
            throw new Error(
              "Only one base texture per TextureArray is allowed"
            );
          t.prototype.bind.call(this, e);
          for (var n = 0; n < this.length; n++)
            (this.items[n].parentTextureArray = e),
              this.items[n].on("update", e.update, e);
        }),
        (e.prototype.unbind = function (e) {
          t.prototype.unbind.call(this, e);
          for (var n = 0; n < this.length; n++)
            (this.items[n].parentTextureArray = null),
              this.items[n].off("update", e.update, e);
        }),
        (e.prototype.load = function () {
          var t = this;
          if (this._load) return this._load;
          var e = this.items
            .map(function (t) {
              return t.resource;
            })
            .filter(function (t) {
              return t;
            })
            .map(function (t) {
              return t.load();
            });
          return (
            (this._load = Promise.all(e).then(function () {
              var e = t.items[0],
                n = e.realWidth,
                i = e.realHeight;
              return t.resize(n, i), Promise.resolve(t);
            })),
            this._load
          );
        }),
        e
      );
    })(F_),
    H_ = (function (t) {
      function e(e, n) {
        var i,
          r,
          s = this,
          o = n || {},
          a = o.width,
          l = o.height;
        return (
          Array.isArray(e) ? ((i = e), (r = e.length)) : (r = e),
          (s = t.call(this, r, { width: a, height: l }) || this),
          i && s.initFromArray(i, n),
          s
        );
      }
      return (
        D_(e, t),
        (e.prototype.addBaseTextureAt = function (t, e) {
          if (!t.resource)
            throw new Error("ArrayResource does not support RenderTexture");
          return this.addResourceAt(t.resource, e), this;
        }),
        (e.prototype.bind = function (e) {
          t.prototype.bind.call(this, e), (e.target = Ef.TEXTURE_2D_ARRAY);
        }),
        (e.prototype.upload = function (t, e, n) {
          var i = this,
            r = i.length,
            s = i.itemDirtyIds,
            o = i.items,
            a = t.gl;
          n.dirtyId < 0 &&
            a.texImage3D(
              a.TEXTURE_2D_ARRAY,
              0,
              n.internalFormat,
              this._width,
              this._height,
              r,
              0,
              e.format,
              n.type,
              null
            );
          for (var l = 0; l < r; l++) {
            var h = o[l];
            s[l] < h.dirtyId &&
              ((s[l] = h.dirtyId),
              h.valid &&
                a.texSubImage3D(
                  a.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  l,
                  h.resource.width,
                  h.resource.height,
                  1,
                  e.format,
                  n.type,
                  h.resource.source
                ));
          }
          return !0;
        }),
        e
      );
    })(G_),
    z_ = (function (t) {
      function e(e) {
        var n = this,
          i = e,
          r = i.naturalWidth || i.videoWidth || i.width,
          s = i.naturalHeight || i.videoHeight || i.height;
        return (
          ((n = t.call(this, r, s) || this).source = e), (n.noSubImage = !1), n
        );
      }
      return (
        D_(e, t),
        (e.crossOrigin = function (t, e, n) {
          void 0 === n && 0 !== e.indexOf("data:")
            ? (t.crossOrigin = (function (t, e) {
                if (
                  (void 0 === e && (e = globalThis.location),
                  0 === t.indexOf("data:"))
                )
                  return "";
                (e = e || globalThis.location),
                  vm || (vm = document.createElement("a")),
                  (vm.href = t);
                var n = Jf.parse(vm.href),
                  i = (!n.port && "" === e.port) || n.port === e.port;
                return n.hostname === e.hostname &&
                  i &&
                  n.protocol === e.protocol
                  ? ""
                  : "anonymous";
              })(e))
            : !1 !== n &&
              (t.crossOrigin = "string" == typeof n ? n : "anonymous");
        }),
        (e.prototype.upload = function (t, e, n, i) {
          var r = t.gl,
            s = e.realWidth,
            o = e.realHeight;
          if ((i = i || this.source) instanceof HTMLImageElement) {
            if (!i.complete || 0 === i.naturalWidth) return !1;
          } else if (i instanceof HTMLVideoElement && i.readyState <= 1)
            return !1;
          return (
            r.pixelStorei(
              r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              e.alphaMode === Cf.UNPACK
            ),
            this.noSubImage ||
            e.target !== r.TEXTURE_2D ||
            n.width !== s ||
            n.height !== o
              ? ((n.width = s),
                (n.height = o),
                r.texImage2D(
                  e.target,
                  0,
                  n.internalFormat,
                  e.format,
                  n.type,
                  i
                ))
              : r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, e.format, n.type, i),
            !0
          );
        }),
        (e.prototype.update = function () {
          if (!this.destroyed) {
            var e = this.source,
              n = e.naturalWidth || e.videoWidth || e.width,
              i = e.naturalHeight || e.videoHeight || e.height;
            this.resize(n, i), t.prototype.update.call(this);
          }
        }),
        (e.prototype.dispose = function () {
          this.source = null;
        }),
        e
      );
    })(F_),
    V_ = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        D_(e, t),
        (e.test = function (t) {
          var e = globalThis.OffscreenCanvas;
          return (
            !!(e && t instanceof e) ||
            (globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement)
          );
        }),
        e
      );
    })(z_),
    X_ = (function (t) {
      function e(n, i) {
        var r = this,
          s = i || {},
          o = s.width,
          a = s.height,
          l = s.autoLoad,
          h = s.linkBaseTexture;
        if (n && n.length !== e.SIDES)
          throw new Error("Invalid length. Got " + n.length + ", expected 6");
        r = t.call(this, 6, { width: o, height: a }) || this;
        for (var u = 0; u < e.SIDES; u++)
          r.items[u].target = Ef.TEXTURE_CUBE_MAP_POSITIVE_X + u;
        return (
          (r.linkBaseTexture = !1 !== h),
          n && r.initFromArray(n, i),
          !1 !== l && r.load(),
          r
        );
      }
      return (
        D_(e, t),
        (e.prototype.bind = function (e) {
          t.prototype.bind.call(this, e), (e.target = Ef.TEXTURE_CUBE_MAP);
        }),
        (e.prototype.addBaseTextureAt = function (t, e, n) {
          if (!this.items[e])
            throw new Error("Index " + e + " is out of bounds");
          if (
            !this.linkBaseTexture ||
            t.parentTextureArray ||
            Object.keys(t._glTextures).length > 0
          ) {
            if (!t.resource)
              throw new Error(
                "CubeResource does not support copying of renderTexture."
              );
            this.addResourceAt(t.resource, e);
          } else
            (t.target = Ef.TEXTURE_CUBE_MAP_POSITIVE_X + e),
              (t.parentTextureArray = this.baseTexture),
              (this.items[e] = t);
          return (
            t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
            (this.items[e] = t),
            this
          );
        }),
        (e.prototype.upload = function (t, n, i) {
          for (var r = this.itemDirtyIds, s = 0; s < e.SIDES; s++) {
            var o = this.items[s];
            (r[s] < o.dirtyId || i.dirtyId < n.dirtyId) &&
              (o.valid && o.resource
                ? (o.resource.upload(t, o, i), (r[s] = o.dirtyId))
                : r[s] < -1 &&
                  (t.gl.texImage2D(
                    o.target,
                    0,
                    i.internalFormat,
                    n.realWidth,
                    n.realHeight,
                    0,
                    n.format,
                    i.type,
                    null
                  ),
                  (r[s] = -1)));
          }
          return !0;
        }),
        (e.test = function (t) {
          return Array.isArray(t) && t.length === e.SIDES;
        }),
        (e.SIDES = 6),
        e
      );
    })(G_),
    W_ = (function (t) {
      function e(e, n) {
        var i = this;
        if (((n = n || {}), !(e instanceof HTMLImageElement))) {
          var r = new Image();
          z_.crossOrigin(r, e, n.crossorigin), (r.src = e), (e = r);
        }
        return (
          (i = t.call(this, e) || this),
          !e.complete &&
            i._width &&
            i._height &&
            ((i._width = 0), (i._height = 0)),
          (i.url = e.src),
          (i._process = null),
          (i.preserveBitmap = !1),
          (i.createBitmap =
            (void 0 !== n.createBitmap
              ? n.createBitmap
              : Rp.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap),
          (i.alphaMode = "number" == typeof n.alphaMode ? n.alphaMode : null),
          (i.bitmap = null),
          (i._load = null),
          !1 !== n.autoLoad && i.load(),
          i
        );
      }
      return (
        D_(e, t),
        (e.prototype.load = function (t) {
          var e = this;
          return (
            this._load ||
              (void 0 !== t && (this.createBitmap = t),
              (this._load = new Promise(function (t, n) {
                var i = e.source;
                e.url = i.src;
                var r = function () {
                  e.destroyed ||
                    ((i.onload = null),
                    (i.onerror = null),
                    e.resize(i.width, i.height),
                    (e._load = null),
                    e.createBitmap ? t(e.process()) : t(e));
                };
                i.complete && i.src
                  ? r()
                  : ((i.onload = r),
                    (i.onerror = function (t) {
                      n(t), e.onError.emit(t);
                    }));
              }))),
            this._load
          );
        }),
        (e.prototype.process = function () {
          var t = this,
            e = this.source;
          if (null !== this._process) return this._process;
          if (null !== this.bitmap || !globalThis.createImageBitmap)
            return Promise.resolve(this);
          var n = globalThis.createImageBitmap,
            i = !e.crossOrigin || "anonymous" === e.crossOrigin;
          return (
            (this._process = fetch(e.src, { mode: i ? "cors" : "no-cors" })
              .then(function (t) {
                return t.blob();
              })
              .then(function (i) {
                return n(i, 0, 0, e.width, e.height, {
                  premultiplyAlpha:
                    t.alphaMode === Cf.UNPACK ? "premultiply" : "none",
                });
              })
              .then(function (e) {
                return t.destroyed
                  ? Promise.reject()
                  : ((t.bitmap = e),
                    t.update(),
                    (t._process = null),
                    Promise.resolve(t));
              })),
            this._process
          );
        }),
        (e.prototype.upload = function (e, n, i) {
          if (
            ("number" == typeof this.alphaMode &&
              (n.alphaMode = this.alphaMode),
            !this.createBitmap)
          )
            return t.prototype.upload.call(this, e, n, i);
          if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
          if (
            (t.prototype.upload.call(this, e, n, i, this.bitmap),
            !this.preserveBitmap)
          ) {
            var r = !0,
              s = n._glTextures;
            for (var o in s) {
              var a = s[o];
              if (a !== i && a.dirtyId !== n.dirtyId) {
                r = !1;
                break;
              }
            }
            r &&
              (this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
          }
          return !0;
        }),
        (e.prototype.dispose = function () {
          (this.source.onload = null),
            (this.source.onerror = null),
            t.prototype.dispose.call(this),
            this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
            (this._process = null),
            (this._load = null);
        }),
        (e.test = function (t) {
          return "string" == typeof t || t instanceof HTMLImageElement;
        }),
        e
      );
    })(z_),
    j_ = (function (t) {
      function e(e, n) {
        var i = this;
        return (
          (n = n || {}),
          ((i =
            t.call(this, document.createElement("canvas")) || this)._width = 0),
          (i._height = 0),
          (i.svg = e),
          (i.scale = n.scale || 1),
          (i._overrideWidth = n.width),
          (i._overrideHeight = n.height),
          (i._resolve = null),
          (i._crossorigin = n.crossorigin),
          (i._load = null),
          !1 !== n.autoLoad && i.load(),
          i
        );
      }
      return (
        D_(e, t),
        (e.prototype.load = function () {
          var t = this;
          return (
            this._load ||
              (this._load = new Promise(function (n) {
                if (
                  ((t._resolve = function () {
                    t.resize(t.source.width, t.source.height), n(t);
                  }),
                  e.SVG_XML.test(t.svg.trim()))
                ) {
                  if (!btoa)
                    throw new Error(
                      "Your browser doesn't support base64 conversions."
                    );
                  t.svg =
                    "data:image/svg+xml;base64," +
                    btoa(unescape(encodeURIComponent(t.svg)));
                }
                t._loadSvg();
              })),
            this._load
          );
        }),
        (e.prototype._loadSvg = function () {
          var t = this,
            e = new Image();
          z_.crossOrigin(e, this.svg, this._crossorigin),
            (e.src = this.svg),
            (e.onerror = function (n) {
              t._resolve && ((e.onerror = null), t.onError.emit(n));
            }),
            (e.onload = function () {
              if (t._resolve) {
                var n = e.width,
                  i = e.height;
                if (!n || !i)
                  throw new Error(
                    "The SVG image must have width and height defined (in pixels), canvas API needs them."
                  );
                var r = n * t.scale,
                  s = i * t.scale;
                (t._overrideWidth || t._overrideHeight) &&
                  ((r = t._overrideWidth || (t._overrideHeight / i) * n),
                  (s = t._overrideHeight || (t._overrideWidth / n) * i)),
                  (r = Math.round(r)),
                  (s = Math.round(s));
                var o = t.source;
                (o.width = r),
                  (o.height = s),
                  (o._pixiId = "canvas_" + mm()),
                  o.getContext("2d").drawImage(e, 0, 0, n, i, 0, 0, r, s),
                  t._resolve(),
                  (t._resolve = null);
              }
            });
        }),
        (e.getSize = function (t) {
          var n = e.SVG_SIZE.exec(t),
            i = {};
          return (
            n &&
              ((i[n[1]] = Math.round(parseFloat(n[3]))),
              (i[n[5]] = Math.round(parseFloat(n[7])))),
            i
          );
        }),
        (e.prototype.dispose = function () {
          t.prototype.dispose.call(this),
            (this._resolve = null),
            (this._crossorigin = null);
        }),
        (e.test = function (t, n) {
          return (
            "svg" === n ||
            ("string" == typeof t &&
              /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)) ||
            ("string" == typeof t && e.SVG_XML.test(t))
          );
        }),
        (e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
        (e.SVG_SIZE =
          /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i),
        e
      );
    })(z_),
    Y_ = (function (t) {
      function e(n, i) {
        var r = this;
        if (((i = i || {}), !(n instanceof HTMLVideoElement))) {
          var s = document.createElement("video");
          s.setAttribute("preload", "auto"),
            s.setAttribute("webkit-playsinline", ""),
            s.setAttribute("playsinline", ""),
            "string" == typeof n && (n = [n]);
          var o = n[0].src || n[0];
          z_.crossOrigin(s, o, i.crossorigin);
          for (var a = 0; a < n.length; ++a) {
            var l = document.createElement("source"),
              h = n[a],
              u = h.src,
              c = h.mime,
              d = (u = u || n[a]).split("?").shift().toLowerCase(),
              p = d.slice(d.lastIndexOf(".") + 1);
            (c = c || e.MIME_TYPES[p] || "video/" + p),
              (l.src = u),
              (l.type = c),
              s.appendChild(l);
          }
          n = s;
        }
        return (
          ((r = t.call(this, n) || this).noSubImage = !0),
          (r._autoUpdate = !0),
          (r._isConnectedToTicker = !1),
          (r._updateFPS = i.updateFPS || 0),
          (r._msToNextUpdate = 0),
          (r.autoPlay = !1 !== i.autoPlay),
          (r._load = null),
          (r._resolve = null),
          (r._onCanPlay = r._onCanPlay.bind(r)),
          (r._onError = r._onError.bind(r)),
          !1 !== i.autoLoad && r.load(),
          r
        );
      }
      return (
        D_(e, t),
        (e.prototype.update = function (e) {
          if (!this.destroyed) {
            var n = C_.shared.elapsedMS * this.source.playbackRate;
            (this._msToNextUpdate = Math.floor(this._msToNextUpdate - n)),
              (!this._updateFPS || this._msToNextUpdate <= 0) &&
                (t.prototype.update.call(this),
                (this._msToNextUpdate = this._updateFPS
                  ? Math.floor(1e3 / this._updateFPS)
                  : 0));
          }
        }),
        (e.prototype.load = function () {
          var t = this;
          if (this._load) return this._load;
          var e = this.source;
          return (
            (e.readyState === e.HAVE_ENOUGH_DATA ||
              e.readyState === e.HAVE_FUTURE_DATA) &&
              e.width &&
              e.height &&
              (e.complete = !0),
            e.addEventListener("play", this._onPlayStart.bind(this)),
            e.addEventListener("pause", this._onPlayStop.bind(this)),
            this._isSourceReady()
              ? this._onCanPlay()
              : (e.addEventListener("canplay", this._onCanPlay),
                e.addEventListener("canplaythrough", this._onCanPlay),
                e.addEventListener("error", this._onError, !0)),
            (this._load = new Promise(function (n) {
              t.valid ? n(t) : ((t._resolve = n), e.load());
            })),
            this._load
          );
        }),
        (e.prototype._onError = function (t) {
          this.source.removeEventListener("error", this._onError, !0),
            this.onError.emit(t);
        }),
        (e.prototype._isSourcePlaying = function () {
          var t = this.source;
          return (
            t.currentTime > 0 &&
            !1 === t.paused &&
            !1 === t.ended &&
            t.readyState > 2
          );
        }),
        (e.prototype._isSourceReady = function () {
          var t = this.source;
          return 3 === t.readyState || 4 === t.readyState;
        }),
        (e.prototype._onPlayStart = function () {
          this.valid || this._onCanPlay(),
            this.autoUpdate &&
              !this._isConnectedToTicker &&
              (C_.shared.add(this.update, this),
              (this._isConnectedToTicker = !0));
        }),
        (e.prototype._onPlayStop = function () {
          this._isConnectedToTicker &&
            (C_.shared.remove(this.update, this),
            (this._isConnectedToTicker = !1));
        }),
        (e.prototype._onCanPlay = function () {
          var t = this.source;
          t.removeEventListener("canplay", this._onCanPlay),
            t.removeEventListener("canplaythrough", this._onCanPlay);
          var e = this.valid;
          this.resize(t.videoWidth, t.videoHeight),
            !e &&
              this._resolve &&
              (this._resolve(this), (this._resolve = null)),
            this._isSourcePlaying()
              ? this._onPlayStart()
              : this.autoPlay && t.play();
        }),
        (e.prototype.dispose = function () {
          this._isConnectedToTicker &&
            (C_.shared.remove(this.update, this),
            (this._isConnectedToTicker = !1));
          var e = this.source;
          e &&
            (e.removeEventListener("error", this._onError, !0),
            e.pause(),
            (e.src = ""),
            e.load()),
            t.prototype.dispose.call(this);
        }),
        Object.defineProperty(e.prototype, "autoUpdate", {
          get: function () {
            return this._autoUpdate;
          },
          set: function (t) {
            t !== this._autoUpdate &&
              ((this._autoUpdate = t),
              !this._autoUpdate && this._isConnectedToTicker
                ? (C_.shared.remove(this.update, this),
                  (this._isConnectedToTicker = !1))
                : this._autoUpdate &&
                  !this._isConnectedToTicker &&
                  this._isSourcePlaying() &&
                  (C_.shared.add(this.update, this),
                  (this._isConnectedToTicker = !0)));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "updateFPS", {
          get: function () {
            return this._updateFPS;
          },
          set: function (t) {
            t !== this._updateFPS && (this._updateFPS = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.test = function (t, n) {
          return (
            (globalThis.HTMLVideoElement && t instanceof HTMLVideoElement) ||
            e.TYPES.indexOf(n) > -1
          );
        }),
        (e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"]),
        (e.MIME_TYPES = {
          ogv: "video/ogg",
          mov: "video/quicktime",
          m4v: "video/mp4",
        }),
        e
      );
    })(z_),
    q_ = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        D_(e, t),
        (e.test = function (t) {
          return (
            !!globalThis.createImageBitmap &&
            "undefined" != typeof ImageBitmap &&
            t instanceof ImageBitmap
          );
        }),
        e
      );
    })(z_);
  P_.push(W_, q_, V_, Y_, j_, U_, X_, H_);
  var K_ = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        D_(e, t),
        (e.prototype.upload = function (t, e, n) {
          var i = t.gl;
          i.pixelStorei(
            i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            e.alphaMode === Cf.UNPACK
          );
          var r = e.realWidth,
            s = e.realHeight;
          return (
            n.width === r && n.height === s
              ? i.texSubImage2D(
                  e.target,
                  0,
                  0,
                  0,
                  r,
                  s,
                  e.format,
                  n.type,
                  this.data
                )
              : ((n.width = r),
                (n.height = s),
                i.texImage2D(
                  e.target,
                  0,
                  n.internalFormat,
                  r,
                  s,
                  0,
                  e.format,
                  n.type,
                  this.data
                )),
            !0
          );
        }),
        e
      );
    })(U_),
    Z_ = (function () {
      function t(t, e) {
        (this.width = Math.round(t || 100)),
          (this.height = Math.round(e || 100)),
          (this.stencil = !1),
          (this.depth = !1),
          (this.dirtyId = 0),
          (this.dirtyFormat = 0),
          (this.dirtySize = 0),
          (this.depthTexture = null),
          (this.colorTextures = []),
          (this.glFramebuffers = {}),
          (this.disposeRunner = new A_("disposeFramebuffer")),
          (this.multisample = Lf.NONE);
      }
      return (
        Object.defineProperty(t.prototype, "colorTexture", {
          get: function () {
            return this.colorTextures[0];
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.addColorTexture = function (t, e) {
          return (
            void 0 === t && (t = 0),
            (this.colorTextures[t] =
              e ||
              new k_(null, {
                scaleMode: Mf.NEAREST,
                resolution: 1,
                mipmap: Rf.OFF,
                width: this.width,
                height: this.height,
              })),
            this.dirtyId++,
            this.dirtyFormat++,
            this
          );
        }),
        (t.prototype.addDepthTexture = function (t) {
          return (
            (this.depthTexture =
              t ||
              new k_(new K_(null, { width: this.width, height: this.height }), {
                scaleMode: Mf.NEAREST,
                resolution: 1,
                width: this.width,
                height: this.height,
                mipmap: Rf.OFF,
                format: Tf.DEPTH_COMPONENT,
                type: Sf.UNSIGNED_SHORT,
              })),
            this.dirtyId++,
            this.dirtyFormat++,
            this
          );
        }),
        (t.prototype.enableDepth = function () {
          return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
        }),
        (t.prototype.enableStencil = function () {
          return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
        }),
        (t.prototype.resize = function (t, e) {
          if (
            ((t = Math.round(t)),
            (e = Math.round(e)),
            t !== this.width || e !== this.height)
          ) {
            (this.width = t),
              (this.height = e),
              this.dirtyId++,
              this.dirtySize++;
            for (var n = 0; n < this.colorTextures.length; n++) {
              var i = this.colorTextures[n],
                r = i.resolution;
              i.setSize(t / r, e / r);
            }
            if (this.depthTexture) {
              r = this.depthTexture.resolution;
              this.depthTexture.setSize(t / r, e / r);
            }
          }
        }),
        (t.prototype.dispose = function () {
          this.disposeRunner.emit(this, !1);
        }),
        (t.prototype.destroyDepthTexture = function () {
          this.depthTexture &&
            (this.depthTexture.destroy(),
            (this.depthTexture = null),
            ++this.dirtyId,
            ++this.dirtyFormat);
        }),
        t
      );
    })(),
    J_ = (function (t) {
      function e(e) {
        void 0 === e && (e = {});
        var n = this;
        if ("number" == typeof e) {
          var i = arguments[0],
            r = arguments[1],
            s = arguments[2],
            o = arguments[3];
          e = { width: i, height: r, scaleMode: s, resolution: o };
        }
        return (
          (e.width = e.width || 100),
          (e.height = e.height || 100),
          (e.multisample = void 0 !== e.multisample ? e.multisample : Lf.NONE),
          ((n = t.call(this, null, e) || this).mipmap = Rf.OFF),
          (n.valid = !0),
          (n.clearColor = [0, 0, 0, 0]),
          (n.framebuffer = new Z_(n.realWidth, n.realHeight).addColorTexture(
            0,
            n
          )),
          (n.framebuffer.multisample = e.multisample),
          (n.maskStack = []),
          (n.filterStack = [{}]),
          n
        );
      }
      return (
        D_(e, t),
        (e.prototype.resize = function (t, e) {
          this.framebuffer.resize(t * this.resolution, e * this.resolution),
            this.setRealSize(this.framebuffer.width, this.framebuffer.height);
        }),
        (e.prototype.dispose = function () {
          this.framebuffer.dispose(), t.prototype.dispose.call(this);
        }),
        (e.prototype.destroy = function () {
          t.prototype.destroy.call(this),
            this.framebuffer.destroyDepthTexture(),
            (this.framebuffer = null);
        }),
        e
      );
    })(k_),
    $_ = (function () {
      function t() {
        (this.x0 = 0),
          (this.y0 = 0),
          (this.x1 = 1),
          (this.y1 = 0),
          (this.x2 = 1),
          (this.y2 = 1),
          (this.x3 = 0),
          (this.y3 = 1),
          (this.uvsFloat32 = new Float32Array(8));
      }
      return (
        (t.prototype.set = function (t, e, n) {
          var i = e.width,
            r = e.height;
          if (n) {
            var s = t.width / 2 / i,
              o = t.height / 2 / r,
              a = t.x / i + s,
              l = t.y / r + o;
            (n = Wm.add(n, Wm.NW)),
              (this.x0 = a + s * Wm.uX(n)),
              (this.y0 = l + o * Wm.uY(n)),
              (n = Wm.add(n, 2)),
              (this.x1 = a + s * Wm.uX(n)),
              (this.y1 = l + o * Wm.uY(n)),
              (n = Wm.add(n, 2)),
              (this.x2 = a + s * Wm.uX(n)),
              (this.y2 = l + o * Wm.uY(n)),
              (n = Wm.add(n, 2)),
              (this.x3 = a + s * Wm.uX(n)),
              (this.y3 = l + o * Wm.uY(n));
          } else
            (this.x0 = t.x / i),
              (this.y0 = t.y / r),
              (this.x1 = (t.x + t.width) / i),
              (this.y1 = t.y / r),
              (this.x2 = (t.x + t.width) / i),
              (this.y2 = (t.y + t.height) / r),
              (this.x3 = t.x / i),
              (this.y3 = (t.y + t.height) / r);
          (this.uvsFloat32[0] = this.x0),
            (this.uvsFloat32[1] = this.y0),
            (this.uvsFloat32[2] = this.x1),
            (this.uvsFloat32[3] = this.y1),
            (this.uvsFloat32[4] = this.x2),
            (this.uvsFloat32[5] = this.y2),
            (this.uvsFloat32[6] = this.x3),
            (this.uvsFloat32[7] = this.y3);
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/core:TextureUvs x0=" +
            this.x0 +
            " y0=" +
            this.y0 +
            " x1=" +
            this.x1 +
            " y1=" +
            this.y1 +
            " x2=" +
            this.x2 +
            " y2=" +
            this.y2 +
            " x3=" +
            this.x3 +
            " y3=" +
            this.y3 +
            "]"
          );
        }),
        t
      );
    })(),
    Q_ = new $_();
  function tg(t) {
    (t.destroy = function () {}),
      (t.on = function () {}),
      (t.once = function () {}),
      (t.emit = function () {});
  }
  var eg = (function (t) {
      function e(n, i, r, s, o, a) {
        var l = t.call(this) || this;
        if (
          ((l.noFrame = !1),
          i || ((l.noFrame = !0), (i = new Pm(0, 0, 1, 1))),
          n instanceof e && (n = n.baseTexture),
          (l.baseTexture = n),
          (l._frame = i),
          (l.trim = s),
          (l.valid = !1),
          (l._uvs = Q_),
          (l.uvMatrix = null),
          (l.orig = r || i),
          (l._rotate = Number(o || 0)),
          !0 === o)
        )
          l._rotate = 2;
        else if (l._rotate % 2 != 0)
          throw new Error(
            "attempt to use diamond-shaped UVs. If you are sure, set rotation manually"
          );
        return (
          (l.defaultAnchor = a ? new Cm(a.x, a.y) : new Cm(0, 0)),
          (l._updateID = 0),
          (l.textureCacheIds = []),
          n.valid
            ? l.noFrame
              ? n.valid && l.onBaseTextureUpdated(n)
              : (l.frame = i)
            : n.once("loaded", l.onBaseTextureUpdated, l),
          l.noFrame && n.on("update", l.onBaseTextureUpdated, l),
          l
        );
      }
      return (
        D_(e, t),
        (e.prototype.update = function () {
          this.baseTexture.resource && this.baseTexture.resource.update();
        }),
        (e.prototype.onBaseTextureUpdated = function (t) {
          if (this.noFrame) {
            if (!this.baseTexture.valid) return;
            (this._frame.width = t.width),
              (this._frame.height = t.height),
              (this.valid = !0),
              this.updateUvs();
          } else this.frame = this._frame;
          this.emit("update", this);
        }),
        (e.prototype.destroy = function (t) {
          if (this.baseTexture) {
            if (t) {
              var n = this.baseTexture.resource;
              n && n.url && xm[n.url] && e.removeFromCache(n.url),
                this.baseTexture.destroy();
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
              this.baseTexture.off("update", this.onBaseTextureUpdated, this),
              (this.baseTexture = null);
          }
          (this._frame = null),
            (this._uvs = null),
            (this.trim = null),
            (this.orig = null),
            (this.valid = !1),
            e.removeFromCache(this),
            (this.textureCacheIds = null);
        }),
        (e.prototype.clone = function () {
          var t = this._frame.clone(),
            n = this._frame === this.orig ? t : this.orig.clone(),
            i = new e(
              this.baseTexture,
              !this.noFrame && t,
              n,
              this.trim && this.trim.clone(),
              this.rotate,
              this.defaultAnchor
            );
          return this.noFrame && (i._frame = t), i;
        }),
        (e.prototype.updateUvs = function () {
          this._uvs === Q_ && (this._uvs = new $_()),
            this._uvs.set(this._frame, this.baseTexture, this.rotate),
            this._updateID++;
        }),
        (e.from = function (t, n, i) {
          void 0 === n && (n = {}),
            void 0 === i && (i = Rp.STRICT_TEXTURE_CACHE);
          var r = "string" == typeof t,
            s = null;
          if (r) s = t;
          else if (t instanceof k_) {
            if (!t.cacheId) {
              var o = (n && n.pixiIdPrefix) || "pixiid";
              (t.cacheId = o + "-" + mm()), k_.addToCache(t, t.cacheId);
            }
            s = t.cacheId;
          } else {
            if (!t._pixiId) {
              o = (n && n.pixiIdPrefix) || "pixiid";
              t._pixiId = o + "_" + mm();
            }
            s = t._pixiId;
          }
          var a = xm[s];
          if (r && i && !a)
            throw new Error(
              'The cacheId "' + s + '" does not exist in TextureCache.'
            );
          return (
            a || t instanceof k_
              ? !a && t instanceof k_ && ((a = new e(t)), e.addToCache(a, s))
              : (n.resolution || (n.resolution = Em(t)),
                ((a = new e(new k_(t, n))).baseTexture.cacheId = s),
                k_.addToCache(a.baseTexture, s),
                e.addToCache(a, s)),
            a
          );
        }),
        (e.fromURL = function (t, n) {
          var i = Object.assign(
              { autoLoad: !1 },
              null == n ? void 0 : n.resourceOptions
            ),
            r = e.from(t, Object.assign({ resourceOptions: i }, n), !1),
            s = r.baseTexture.resource;
          return r.baseTexture.valid
            ? Promise.resolve(r)
            : s.load().then(function () {
                return Promise.resolve(r);
              });
        }),
        (e.fromBuffer = function (t, n, i, r) {
          return new e(k_.fromBuffer(t, n, i, r));
        }),
        (e.fromLoader = function (t, n, i, r) {
          var s = new k_(
              t,
              Object.assign({ scaleMode: Rp.SCALE_MODE, resolution: Em(n) }, r)
            ),
            o = s.resource;
          o instanceof W_ && (o.url = n);
          var a = new e(s);
          return (
            i || (i = n),
            k_.addToCache(a.baseTexture, i),
            e.addToCache(a, i),
            i !== n && (k_.addToCache(a.baseTexture, n), e.addToCache(a, n)),
            a.baseTexture.valid
              ? Promise.resolve(a)
              : new Promise(function (t) {
                  a.baseTexture.once("loaded", function () {
                    return t(a);
                  });
                })
          );
        }),
        (e.addToCache = function (t, e) {
          e &&
            (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
            xm[e] &&
              console.warn(
                "Texture added to the cache with an id [" +
                  e +
                  "] that already had an entry"
              ),
            (xm[e] = t));
        }),
        (e.removeFromCache = function (t) {
          if ("string" == typeof t) {
            var e = xm[t];
            if (e) {
              var n = e.textureCacheIds.indexOf(t);
              return n > -1 && e.textureCacheIds.splice(n, 1), delete xm[t], e;
            }
          } else if (t && t.textureCacheIds) {
            for (var i = 0; i < t.textureCacheIds.length; ++i)
              xm[t.textureCacheIds[i]] === t && delete xm[t.textureCacheIds[i]];
            return (t.textureCacheIds.length = 0), t;
          }
          return null;
        }),
        Object.defineProperty(e.prototype, "resolution", {
          get: function () {
            return this.baseTexture.resolution;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "frame", {
          get: function () {
            return this._frame;
          },
          set: function (t) {
            (this._frame = t), (this.noFrame = !1);
            var e = t.x,
              n = t.y,
              i = t.width,
              r = t.height,
              s = e + i > this.baseTexture.width,
              o = n + r > this.baseTexture.height;
            if (s || o) {
              var a = s && o ? "and" : "or",
                l =
                  "X: " +
                  e +
                  " + " +
                  i +
                  " = " +
                  (e + i) +
                  " > " +
                  this.baseTexture.width,
                h =
                  "Y: " +
                  n +
                  " + " +
                  r +
                  " = " +
                  (n + r) +
                  " > " +
                  this.baseTexture.height;
              throw new Error(
                "Texture Error: frame does not fit inside the base Texture dimensions: " +
                  l +
                  " " +
                  a +
                  " " +
                  h
              );
            }
            (this.valid = i && r && this.baseTexture.valid),
              this.trim || this.rotate || (this.orig = t),
              this.valid && this.updateUvs();
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "rotate", {
          get: function () {
            return this._rotate;
          },
          set: function (t) {
            (this._rotate = t), this.valid && this.updateUvs();
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "width", {
          get: function () {
            return this.orig.width;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "height", {
          get: function () {
            return this.orig.height;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.castToBaseTexture = function () {
          return this.baseTexture;
        }),
        Object.defineProperty(e, "EMPTY", {
          get: function () {
            return (
              e._EMPTY ||
                ((e._EMPTY = new e(new k_())),
                tg(e._EMPTY),
                tg(e._EMPTY.baseTexture)),
              e._EMPTY
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e, "WHITE", {
          get: function () {
            if (!e._WHITE) {
              var t = Rp.ADAPTER.createCanvas(16, 16),
                n = t.getContext("2d");
              (t.width = 16),
                (t.height = 16),
                (n.fillStyle = "white"),
                n.fillRect(0, 0, 16, 16),
                (e._WHITE = new e(k_.from(t))),
                tg(e._WHITE),
                tg(e._WHITE.baseTexture);
            }
            return e._WHITE;
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(Ip),
    ng = (function (t) {
      function e(e, n) {
        var i = t.call(this, e, n) || this;
        return (
          (i.valid = !0),
          (i.filterFrame = null),
          (i.filterPoolKey = null),
          i.updateUvs(),
          i
        );
      }
      return (
        D_(e, t),
        Object.defineProperty(e.prototype, "framebuffer", {
          get: function () {
            return this.baseTexture.framebuffer;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "multisample", {
          get: function () {
            return this.framebuffer.multisample;
          },
          set: function (t) {
            this.framebuffer.multisample = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.resize = function (t, e, n) {
          void 0 === n && (n = !0);
          var i = this.baseTexture.resolution,
            r = Math.round(t * i) / i,
            s = Math.round(e * i) / i;
          (this.valid = r > 0 && s > 0),
            (this._frame.width = this.orig.width = r),
            (this._frame.height = this.orig.height = s),
            n && this.baseTexture.resize(r, s),
            this.updateUvs();
        }),
        (e.prototype.setResolution = function (t) {
          var e = this.baseTexture;
          e.resolution !== t &&
            (e.setResolution(t), this.resize(e.width, e.height, !1));
        }),
        (e.create = function (t) {
          for (var n = arguments, i = [], r = 1; r < arguments.length; r++)
            i[r - 1] = n[r];
          return (
            "number" == typeof t &&
              (gm(
                "6.0.0",
                "Arguments (width, height, scaleMode, resolution) have been deprecated."
              ),
              (t = {
                width: t,
                height: i[0],
                scaleMode: i[1],
                resolution: i[2],
              })),
            new e(new J_(t))
          );
        }),
        e
      );
    })(eg),
    ig = (function () {
      function t(t) {
        (this.texturePool = {}),
          (this.textureOptions = t || {}),
          (this.enableFullScreen = !1),
          (this._pixelsWidth = 0),
          (this._pixelsHeight = 0);
      }
      return (
        (t.prototype.createTexture = function (t, e, n) {
          void 0 === n && (n = Lf.NONE);
          var i = new J_(
            Object.assign(
              { width: t, height: e, resolution: 1, multisample: n },
              this.textureOptions
            )
          );
          return new ng(i);
        }),
        (t.prototype.getOptimalTexture = function (t, e, n, i) {
          var r;
          void 0 === n && (n = 1),
            void 0 === i && (i = Lf.NONE),
            (t = Math.ceil(t * n - 1e-6)),
            (e = Math.ceil(e * n - 1e-6)),
            this.enableFullScreen &&
            t === this._pixelsWidth &&
            e === this._pixelsHeight
              ? (r = i > 1 ? -i : -1)
              : ((r =
                  (((65535 & (t = hm(t))) << 16) | (65535 & (e = hm(e)))) >>>
                  0),
                i > 1 && (r += 4294967296 * i)),
            this.texturePool[r] || (this.texturePool[r] = []);
          var s = this.texturePool[r].pop();
          return (
            s || (s = this.createTexture(t, e, i)),
            (s.filterPoolKey = r),
            s.setResolution(n),
            s
          );
        }),
        (t.prototype.getFilterTexture = function (t, e, n) {
          var i = this.getOptimalTexture(
            t.width,
            t.height,
            e || t.resolution,
            n || Lf.NONE
          );
          return (i.filterFrame = t.filterFrame), i;
        }),
        (t.prototype.returnTexture = function (t) {
          var e = t.filterPoolKey;
          (t.filterFrame = null), this.texturePool[e].push(t);
        }),
        (t.prototype.returnFilterTexture = function (t) {
          this.returnTexture(t);
        }),
        (t.prototype.clear = function (t) {
          if ((t = !1 !== t))
            for (var e in this.texturePool) {
              var n = this.texturePool[e];
              if (n) for (var i = 0; i < n.length; i++) n[i].destroy(!0);
            }
          this.texturePool = {};
        }),
        (t.prototype.setScreenSize = function (t) {
          if (
            t.width !== this._pixelsWidth ||
            t.height !== this._pixelsHeight
          ) {
            for (var e in ((this.enableFullScreen =
              t.width > 0 && t.height > 0),
            this.texturePool))
              if (Number(e) < 0) {
                var n = this.texturePool[e];
                if (n) for (var i = 0; i < n.length; i++) n[i].destroy(!0);
                this.texturePool[e] = [];
              }
            (this._pixelsWidth = t.width), (this._pixelsHeight = t.height);
          }
        }),
        (t.SCREEN_KEY = -1),
        t
      );
    })(),
    rg = (function () {
      function t(t, e, n, i, r, s, o) {
        void 0 === e && (e = 0),
          void 0 === n && (n = !1),
          void 0 === i && (i = Sf.FLOAT),
          (this.buffer = t),
          (this.size = e),
          (this.normalized = n),
          (this.type = i),
          (this.stride = r),
          (this.start = s),
          (this.instance = o);
      }
      return (
        (t.prototype.destroy = function () {
          this.buffer = null;
        }),
        (t.from = function (e, n, i, r, s) {
          return new t(e, n, i, r, s);
        }),
        t
      );
    })(),
    sg = 0,
    og = (function () {
      function t(t, e, n) {
        void 0 === e && (e = !0),
          void 0 === n && (n = !1),
          (this.data = t || new Float32Array(1)),
          (this._glBuffers = {}),
          (this._updateID = 0),
          (this.index = n),
          (this.static = e),
          (this.id = sg++),
          (this.disposeRunner = new A_("disposeBuffer"));
      }
      return (
        (t.prototype.update = function (t) {
          t instanceof Array && (t = new Float32Array(t)),
            (this.data = t || this.data),
            this._updateID++;
        }),
        (t.prototype.dispose = function () {
          this.disposeRunner.emit(this, !1);
        }),
        (t.prototype.destroy = function () {
          this.dispose(), (this.data = null);
        }),
        Object.defineProperty(t.prototype, "index", {
          get: function () {
            return this.type === Ff.ELEMENT_ARRAY_BUFFER;
          },
          set: function (t) {
            this.type = t ? Ff.ELEMENT_ARRAY_BUFFER : Ff.ARRAY_BUFFER;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.from = function (e) {
          return e instanceof Array && (e = new Float32Array(e)), new t(e);
        }),
        t
      );
    })(),
    ag = {
      Float32Array: Float32Array,
      Uint32Array: Uint32Array,
      Int32Array: Int32Array,
      Uint8Array: Uint8Array,
    };
  var lg = { 5126: 4, 5123: 2, 5121: 1 },
    hg = 0,
    ug = {
      Float32Array: Float32Array,
      Uint32Array: Uint32Array,
      Int32Array: Int32Array,
      Uint8Array: Uint8Array,
      Uint16Array: Uint16Array,
    },
    cg = (function () {
      function t(t, e) {
        void 0 === t && (t = []),
          void 0 === e && (e = {}),
          (this.buffers = t),
          (this.indexBuffer = null),
          (this.attributes = e),
          (this.glVertexArrayObjects = {}),
          (this.id = hg++),
          (this.instanced = !1),
          (this.instanceCount = 1),
          (this.disposeRunner = new A_("disposeGeometry")),
          (this.refCount = 0);
      }
      return (
        (t.prototype.addAttribute = function (t, e, n, i, r, s, o, a) {
          if (
            (void 0 === n && (n = 0),
            void 0 === i && (i = !1),
            void 0 === a && (a = !1),
            !e)
          )
            throw new Error(
              "You must pass a buffer when creating an attribute"
            );
          e instanceof og ||
            (e instanceof Array && (e = new Float32Array(e)), (e = new og(e)));
          var l = t.split("|");
          if (l.length > 1) {
            for (var h = 0; h < l.length; h++)
              this.addAttribute(l[h], e, n, i, r);
            return this;
          }
          var u = this.buffers.indexOf(e);
          return (
            -1 === u && (this.buffers.push(e), (u = this.buffers.length - 1)),
            (this.attributes[t] = new rg(u, n, i, r, s, o, a)),
            (this.instanced = this.instanced || a),
            this
          );
        }),
        (t.prototype.getAttribute = function (t) {
          return this.attributes[t];
        }),
        (t.prototype.getBuffer = function (t) {
          return this.buffers[this.getAttribute(t).buffer];
        }),
        (t.prototype.addIndex = function (t) {
          return (
            t instanceof og ||
              (t instanceof Array && (t = new Uint16Array(t)), (t = new og(t))),
            (t.type = Ff.ELEMENT_ARRAY_BUFFER),
            (this.indexBuffer = t),
            -1 === this.buffers.indexOf(t) && this.buffers.push(t),
            this
          );
        }),
        (t.prototype.getIndex = function () {
          return this.indexBuffer;
        }),
        (t.prototype.interleave = function () {
          if (
            1 === this.buffers.length ||
            (2 === this.buffers.length && this.indexBuffer)
          )
            return this;
          var t,
            e = [],
            n = [],
            i = new og();
          for (t in this.attributes) {
            var r = this.attributes[t],
              s = this.buffers[r.buffer];
            e.push(s.data), n.push((r.size * lg[r.type]) / 4), (r.buffer = 0);
          }
          for (
            i.data = (function (t, e) {
              for (var n = 0, i = 0, r = {}, s = 0; s < t.length; s++)
                (i += e[s]), (n += t[s].length);
              var o = new ArrayBuffer(4 * n),
                a = null,
                l = 0;
              for (s = 0; s < t.length; s++) {
                var h = e[s],
                  u = t[s],
                  c = lm(u);
                r[c] || (r[c] = new ag[c](o)), (a = r[c]);
                for (var d = 0; d < u.length; d++)
                  a[((d / h) | 0) * i + l + (d % h)] = u[d];
                l += h;
              }
              return new Float32Array(o);
            })(e, n),
              t = 0;
            t < this.buffers.length;
            t++
          )
            this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
          return (
            (this.buffers = [i]),
            this.indexBuffer && this.buffers.push(this.indexBuffer),
            this
          );
        }),
        (t.prototype.getSize = function () {
          for (var t in this.attributes) {
            var e = this.attributes[t];
            return (
              this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
            );
          }
          return 0;
        }),
        (t.prototype.dispose = function () {
          this.disposeRunner.emit(this, !1);
        }),
        (t.prototype.destroy = function () {
          this.dispose(),
            (this.buffers = null),
            (this.indexBuffer = null),
            (this.attributes = null);
        }),
        (t.prototype.clone = function () {
          for (var e = new t(), n = 0; n < this.buffers.length; n++)
            e.buffers[n] = new og(this.buffers[n].data.slice(0));
          for (var n in this.attributes) {
            var i = this.attributes[n];
            e.attributes[n] = new rg(
              i.buffer,
              i.size,
              i.normalized,
              i.type,
              i.stride,
              i.start,
              i.instance
            );
          }
          return (
            this.indexBuffer &&
              ((e.indexBuffer =
                e.buffers[this.buffers.indexOf(this.indexBuffer)]),
              (e.indexBuffer.type = Ff.ELEMENT_ARRAY_BUFFER)),
            e
          );
        }),
        (t.merge = function (e) {
          for (
            var n, i = new t(), r = [], s = [], o = [], a = 0;
            a < e.length;
            a++
          ) {
            n = e[a];
            for (var l = 0; l < n.buffers.length; l++)
              (s[l] = s[l] || 0),
                (s[l] += n.buffers[l].data.length),
                (o[l] = 0);
          }
          for (a = 0; a < n.buffers.length; a++)
            (r[a] = new ug[lm(n.buffers[a].data)](s[a])),
              (i.buffers[a] = new og(r[a]));
          for (a = 0; a < e.length; a++) {
            n = e[a];
            for (l = 0; l < n.buffers.length; l++)
              r[l].set(n.buffers[l].data, o[l]),
                (o[l] += n.buffers[l].data.length);
          }
          if (((i.attributes = n.attributes), n.indexBuffer)) {
            (i.indexBuffer = i.buffers[n.buffers.indexOf(n.indexBuffer)]),
              (i.indexBuffer.type = Ff.ELEMENT_ARRAY_BUFFER);
            var h = 0,
              u = 0,
              c = 0,
              d = 0;
            for (a = 0; a < n.buffers.length; a++)
              if (n.buffers[a] !== n.indexBuffer) {
                d = a;
                break;
              }
            for (var a in n.attributes) {
              var p = n.attributes[a];
              (0 | p.buffer) === d && (u += (p.size * lg[p.type]) / 4);
            }
            for (a = 0; a < e.length; a++) {
              var f = e[a].indexBuffer.data;
              for (l = 0; l < f.length; l++) i.indexBuffer.data[l + c] += h;
              (h += e[a].buffers[d].data.length / u), (c += f.length);
            }
          }
          return i;
        }),
        t
      );
    })(),
    dg = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (
          e
            .addAttribute(
              "aVertexPosition",
              new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
            )
            .addIndex([0, 1, 3, 2]),
          e
        );
      }
      return D_(e, t), e;
    })(cg),
    pg = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (
          (e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
          (e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
          (e.vertexBuffer = new og(e.vertices)),
          (e.uvBuffer = new og(e.uvs)),
          e
            .addAttribute("aVertexPosition", e.vertexBuffer)
            .addAttribute("aTextureCoord", e.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]),
          e
        );
      }
      return (
        D_(e, t),
        (e.prototype.map = function (t, e) {
          var n = 0,
            i = 0;
          return (
            (this.uvs[0] = n),
            (this.uvs[1] = i),
            (this.uvs[2] = n + e.width / t.width),
            (this.uvs[3] = i),
            (this.uvs[4] = n + e.width / t.width),
            (this.uvs[5] = i + e.height / t.height),
            (this.uvs[6] = n),
            (this.uvs[7] = i + e.height / t.height),
            (n = e.x),
            (i = e.y),
            (this.vertices[0] = n),
            (this.vertices[1] = i),
            (this.vertices[2] = n + e.width),
            (this.vertices[3] = i),
            (this.vertices[4] = n + e.width),
            (this.vertices[5] = i + e.height),
            (this.vertices[6] = n),
            (this.vertices[7] = i + e.height),
            this.invalidate(),
            this
          );
        }),
        (e.prototype.invalidate = function () {
          return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
        }),
        e
      );
    })(cg),
    fg = 0,
    mg = (function () {
      function t(t, e, n) {
        (this.group = !0),
          (this.syncUniforms = {}),
          (this.dirtyId = 0),
          (this.id = fg++),
          (this.static = !!e),
          (this.ubo = !!n),
          t instanceof og
            ? ((this.buffer = t),
              (this.buffer.type = Ff.UNIFORM_BUFFER),
              (this.autoManage = !1),
              (this.ubo = !0))
            : ((this.uniforms = t),
              this.ubo &&
                ((this.buffer = new og(new Float32Array(1))),
                (this.buffer.type = Ff.UNIFORM_BUFFER),
                (this.autoManage = !0)));
      }
      return (
        (t.prototype.update = function () {
          this.dirtyId++,
            !this.autoManage && this.buffer && this.buffer.update();
        }),
        (t.prototype.add = function (e, n, i) {
          if (this.ubo)
            throw new Error(
              "[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them"
            );
          this.uniforms[e] = new t(n, i);
        }),
        (t.from = function (e, n, i) {
          return new t(e, n, i);
        }),
        (t.uboFrom = function (e, n) {
          return new t(e, null == n || n, !0);
        }),
        t
      );
    })(),
    _g = (function () {
      function t() {
        (this.renderTexture = null),
          (this.target = null),
          (this.legacy = !1),
          (this.resolution = 1),
          (this.multisample = Lf.NONE),
          (this.sourceFrame = new Pm()),
          (this.destinationFrame = new Pm()),
          (this.bindingSourceFrame = new Pm()),
          (this.bindingDestinationFrame = new Pm()),
          (this.filters = []),
          (this.transform = null);
      }
      return (
        (t.prototype.clear = function () {
          (this.target = null),
            (this.filters = null),
            (this.renderTexture = null);
        }),
        t
      );
    })(),
    gg = [new Cm(), new Cm(), new Cm(), new Cm()],
    vg = new Um(),
    yg = (function () {
      function t(t) {
        (this.renderer = t),
          (this.defaultFilterStack = [{}]),
          (this.texturePool = new ig()),
          this.texturePool.setScreenSize(t.view),
          (this.statePool = []),
          (this.quad = new dg()),
          (this.quadUv = new pg()),
          (this.tempRect = new Pm()),
          (this.activeState = {}),
          (this.globalUniforms = new mg(
            {
              outputFrame: new Pm(),
              inputSize: new Float32Array(4),
              inputPixel: new Float32Array(4),
              inputClamp: new Float32Array(4),
              resolution: 1,
              filterArea: new Float32Array(4),
              filterClamp: new Float32Array(4),
            },
            !0
          )),
          (this.forceClear = !1),
          (this.useMaxPadding = !1);
      }
      return (
        (t.prototype.push = function (t, e) {
          for (
            var n,
              i,
              r = this.renderer,
              s = this.defaultFilterStack,
              o = this.statePool.pop() || new _g(),
              a = this.renderer.renderTexture,
              l = e[0].resolution,
              h = e[0].multisample,
              u = e[0].padding,
              c = e[0].autoFit,
              d = null === (n = e[0].legacy) || void 0 === n || n,
              p = 1;
            p < e.length;
            p++
          ) {
            var f = e[p];
            (l = Math.min(l, f.resolution)),
              (h = Math.min(h, f.multisample)),
              (u = this.useMaxPadding ? Math.max(u, f.padding) : u + f.padding),
              (c = c && f.autoFit),
              (d = d || null === (i = f.legacy) || void 0 === i || i);
          }
          1 === s.length &&
            (this.defaultFilterStack[0].renderTexture = a.current),
            s.push(o),
            (o.resolution = l),
            (o.multisample = h),
            (o.legacy = d),
            (o.target = t),
            o.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
            o.sourceFrame.pad(u);
          var m = this.tempRect.copyFrom(a.sourceFrame);
          r.projection.transform &&
            this.transformAABB(vg.copyFrom(r.projection.transform).invert(), m),
            c
              ? (o.sourceFrame.fit(m),
                (o.sourceFrame.width <= 0 || o.sourceFrame.height <= 0) &&
                  ((o.sourceFrame.width = 0), (o.sourceFrame.height = 0)))
              : o.sourceFrame.intersects(m) ||
                ((o.sourceFrame.width = 0), (o.sourceFrame.height = 0)),
            this.roundFrame(
              o.sourceFrame,
              a.current ? a.current.resolution : r.resolution,
              a.sourceFrame,
              a.destinationFrame,
              r.projection.transform
            ),
            (o.renderTexture = this.getOptimalFilterTexture(
              o.sourceFrame.width,
              o.sourceFrame.height,
              l,
              h
            )),
            (o.filters = e),
            (o.destinationFrame.width = o.renderTexture.width),
            (o.destinationFrame.height = o.renderTexture.height);
          var _ = this.tempRect;
          (_.x = 0),
            (_.y = 0),
            (_.width = o.sourceFrame.width),
            (_.height = o.sourceFrame.height),
            (o.renderTexture.filterFrame = o.sourceFrame),
            o.bindingSourceFrame.copyFrom(a.sourceFrame),
            o.bindingDestinationFrame.copyFrom(a.destinationFrame),
            (o.transform = r.projection.transform),
            (r.projection.transform = null),
            a.bind(o.renderTexture, o.sourceFrame, _),
            r.framebuffer.clear(0, 0, 0, 0);
        }),
        (t.prototype.pop = function () {
          var t = this.defaultFilterStack,
            e = t.pop(),
            n = e.filters;
          this.activeState = e;
          var i = this.globalUniforms.uniforms;
          (i.outputFrame = e.sourceFrame), (i.resolution = e.resolution);
          var r = i.inputSize,
            s = i.inputPixel,
            o = i.inputClamp;
          if (
            ((r[0] = e.destinationFrame.width),
            (r[1] = e.destinationFrame.height),
            (r[2] = 1 / r[0]),
            (r[3] = 1 / r[1]),
            (s[0] = Math.round(r[0] * e.resolution)),
            (s[1] = Math.round(r[1] * e.resolution)),
            (s[2] = 1 / s[0]),
            (s[3] = 1 / s[1]),
            (o[0] = 0.5 * s[2]),
            (o[1] = 0.5 * s[3]),
            (o[2] = e.sourceFrame.width * r[2] - 0.5 * s[2]),
            (o[3] = e.sourceFrame.height * r[3] - 0.5 * s[3]),
            e.legacy)
          ) {
            var a = i.filterArea;
            (a[0] = e.destinationFrame.width),
              (a[1] = e.destinationFrame.height),
              (a[2] = e.sourceFrame.x),
              (a[3] = e.sourceFrame.y),
              (i.filterClamp = i.inputClamp);
          }
          this.globalUniforms.update();
          var l = t[t.length - 1];
          if ((this.renderer.framebuffer.blit(), 1 === n.length))
            n[0].apply(this, e.renderTexture, l.renderTexture, If.BLEND, e),
              this.returnFilterTexture(e.renderTexture);
          else {
            var h = e.renderTexture,
              u = this.getOptimalFilterTexture(h.width, h.height, e.resolution);
            u.filterFrame = h.filterFrame;
            var c = 0;
            for (c = 0; c < n.length - 1; ++c) {
              1 === c &&
                e.multisample > 1 &&
                ((u = this.getOptimalFilterTexture(
                  h.width,
                  h.height,
                  e.resolution
                )).filterFrame = h.filterFrame),
                n[c].apply(this, h, u, If.CLEAR, e);
              var d = h;
              (h = u), (u = d);
            }
            n[c].apply(this, h, l.renderTexture, If.BLEND, e),
              c > 1 &&
                e.multisample > 1 &&
                this.returnFilterTexture(e.renderTexture),
              this.returnFilterTexture(h),
              this.returnFilterTexture(u);
          }
          e.clear(), this.statePool.push(e);
        }),
        (t.prototype.bindAndClear = function (t, e) {
          void 0 === e && (e = If.CLEAR);
          var n = this.renderer,
            i = n.renderTexture,
            r = n.state;
          if (
            (t ===
            this.defaultFilterStack[this.defaultFilterStack.length - 1]
              .renderTexture
              ? (this.renderer.projection.transform =
                  this.activeState.transform)
              : (this.renderer.projection.transform = null),
            t && t.filterFrame)
          ) {
            var s = this.tempRect;
            (s.x = 0),
              (s.y = 0),
              (s.width = t.filterFrame.width),
              (s.height = t.filterFrame.height),
              i.bind(t, t.filterFrame, s);
          } else
            t !==
            this.defaultFilterStack[this.defaultFilterStack.length - 1]
              .renderTexture
              ? i.bind(t)
              : this.renderer.renderTexture.bind(
                  t,
                  this.activeState.bindingSourceFrame,
                  this.activeState.bindingDestinationFrame
                );
          var o = 1 & r.stateId || this.forceClear;
          (e === If.CLEAR || (e === If.BLIT && o)) &&
            this.renderer.framebuffer.clear(0, 0, 0, 0);
        }),
        (t.prototype.applyFilter = function (t, e, n, i) {
          var r = this.renderer;
          r.state.set(t.state),
            this.bindAndClear(n, i),
            (t.uniforms.uSampler = e),
            (t.uniforms.filterGlobals = this.globalUniforms),
            r.shader.bind(t),
            (t.legacy = !!t.program.attributeData.aTextureCoord),
            t.legacy
              ? (this.quadUv.map(e._frame, e.filterFrame),
                r.geometry.bind(this.quadUv),
                r.geometry.draw(bf.TRIANGLES))
              : (r.geometry.bind(this.quad),
                r.geometry.draw(bf.TRIANGLE_STRIP));
        }),
        (t.prototype.calculateSpriteMatrix = function (t, e) {
          var n = this.activeState,
            i = n.sourceFrame,
            r = n.destinationFrame,
            s = e._texture.orig,
            o = t.set(r.width, 0, 0, r.height, i.x, i.y),
            a = e.worldTransform.copyTo(Um.TEMP_MATRIX);
          return (
            a.invert(),
            o.prepend(a),
            o.scale(1 / s.width, 1 / s.height),
            o.translate(e.anchor.x, e.anchor.y),
            o
          );
        }),
        (t.prototype.destroy = function () {
          (this.renderer = null), this.texturePool.clear(!1);
        }),
        (t.prototype.getOptimalFilterTexture = function (t, e, n, i) {
          return (
            void 0 === n && (n = 1),
            void 0 === i && (i = Lf.NONE),
            this.texturePool.getOptimalTexture(t, e, n, i)
          );
        }),
        (t.prototype.getFilterTexture = function (t, e, n) {
          if ("number" == typeof t) {
            var i = t;
            (t = e), (e = i);
          }
          t = t || this.activeState.renderTexture;
          var r = this.texturePool.getOptimalTexture(
            t.width,
            t.height,
            e || t.resolution,
            n || Lf.NONE
          );
          return (r.filterFrame = t.filterFrame), r;
        }),
        (t.prototype.returnFilterTexture = function (t) {
          this.texturePool.returnTexture(t);
        }),
        (t.prototype.emptyPool = function () {
          this.texturePool.clear(!0);
        }),
        (t.prototype.resize = function () {
          this.texturePool.setScreenSize(this.renderer.view);
        }),
        (t.prototype.transformAABB = function (t, e) {
          var n = gg[0],
            i = gg[1],
            r = gg[2],
            s = gg[3];
          n.set(e.left, e.top),
            i.set(e.left, e.bottom),
            r.set(e.right, e.top),
            s.set(e.right, e.bottom),
            t.apply(n, n),
            t.apply(i, i),
            t.apply(r, r),
            t.apply(s, s);
          var o = Math.min(n.x, i.x, r.x, s.x),
            a = Math.min(n.y, i.y, r.y, s.y),
            l = Math.max(n.x, i.x, r.x, s.x),
            h = Math.max(n.y, i.y, r.y, s.y);
          (e.x = o), (e.y = a), (e.width = l - o), (e.height = h - a);
        }),
        (t.prototype.roundFrame = function (t, e, n, i, r) {
          if (
            !(t.width <= 0 || t.height <= 0 || n.width <= 0 || n.height <= 0)
          ) {
            if (r) {
              var s = r.a,
                o = r.b,
                a = r.c,
                l = r.d;
              if (
                (Math.abs(o) > 1e-4 || Math.abs(a) > 1e-4) &&
                (Math.abs(s) > 1e-4 || Math.abs(l) > 1e-4)
              )
                return;
            }
            (r = r ? vg.copyFrom(r) : vg.identity())
              .translate(-n.x, -n.y)
              .scale(i.width / n.width, i.height / n.height)
              .translate(i.x, i.y),
              this.transformAABB(r, t),
              t.ceil(e),
              this.transformAABB(r.invert(), t);
          }
        }),
        t
      );
    })(),
    xg = (function () {
      function t(t) {
        this.renderer = t;
      }
      return (
        (t.prototype.flush = function () {}),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        (t.prototype.start = function () {}),
        (t.prototype.stop = function () {
          this.flush();
        }),
        (t.prototype.render = function (t) {}),
        t
      );
    })(),
    bg = (function () {
      function t(t) {
        (this.renderer = t),
          (this.emptyRenderer = new xg(t)),
          (this.currentRenderer = this.emptyRenderer);
      }
      return (
        (t.prototype.setObjectRenderer = function (t) {
          this.currentRenderer !== t &&
            (this.currentRenderer.stop(),
            (this.currentRenderer = t),
            this.currentRenderer.start());
        }),
        (t.prototype.flush = function () {
          this.setObjectRenderer(this.emptyRenderer);
        }),
        (t.prototype.reset = function () {
          this.setObjectRenderer(this.emptyRenderer);
        }),
        (t.prototype.copyBoundTextures = function (t, e) {
          for (
            var n = this.renderer.texture.boundTextures, i = e - 1;
            i >= 0;
            --i
          )
            (t[i] = n[i] || null), t[i] && (t[i]._batchLocation = i);
        }),
        (t.prototype.boundArray = function (t, e, n, i) {
          for (
            var r = t.elements, s = t.ids, o = t.count, a = 0, l = 0;
            l < o;
            l++
          ) {
            var h = r[l],
              u = h._batchLocation;
            if (u >= 0 && u < i && e[u] === h) s[l] = u;
            else
              for (; a < i; ) {
                var c = e[a];
                if (!c || c._batchEnabled !== n || c._batchLocation !== a) {
                  (s[l] = a), (h._batchLocation = a), (e[a] = h);
                  break;
                }
                a++;
              }
          }
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    Tg = 0,
    Eg = (function () {
      function t(t) {
        (this.renderer = t),
          (this.webGLVersion = 1),
          (this.extensions = {}),
          (this.supports = { uint32Indices: !1 }),
          (this.handleContextLost = this.handleContextLost.bind(this)),
          (this.handleContextRestored = this.handleContextRestored.bind(this)),
          t.view.addEventListener(
            "webglcontextlost",
            this.handleContextLost,
            !1
          ),
          t.view.addEventListener(
            "webglcontextrestored",
            this.handleContextRestored,
            !1
          );
      }
      return (
        Object.defineProperty(t.prototype, "isLost", {
          get: function () {
            return !this.gl || this.gl.isContextLost();
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.contextChange = function (t) {
          (this.gl = t),
            (this.renderer.gl = t),
            (this.renderer.CONTEXT_UID = Tg++),
            t.isContextLost() &&
              t.getExtension("WEBGL_lose_context") &&
              t.getExtension("WEBGL_lose_context").restoreContext();
        }),
        (t.prototype.initFromContext = function (t) {
          (this.gl = t),
            this.validateContext(t),
            (this.renderer.gl = t),
            (this.renderer.CONTEXT_UID = Tg++),
            this.renderer.runners.contextChange.emit(t);
        }),
        (t.prototype.initFromOptions = function (t) {
          var e = this.createContext(this.renderer.view, t);
          this.initFromContext(e);
        }),
        (t.prototype.createContext = function (t, e) {
          var n;
          if (
            (Rp.PREFER_ENV >= gf.WEBGL2 && (n = t.getContext("webgl2", e)), n)
          )
            this.webGLVersion = 2;
          else if (
            ((this.webGLVersion = 1),
            !(n =
              t.getContext("webgl", e) ||
              t.getContext("experimental-webgl", e)))
          )
            throw new Error(
              "This browser does not support WebGL. Try using the canvas renderer"
            );
          return (this.gl = n), this.getExtensions(), this.gl;
        }),
        (t.prototype.getExtensions = function () {
          var t = this.gl,
            e = {
              anisotropicFiltering: t.getExtension(
                "EXT_texture_filter_anisotropic"
              ),
              floatTextureLinear: t.getExtension("OES_texture_float_linear"),
              s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
              s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
              etc: t.getExtension("WEBGL_compressed_texture_etc"),
              etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
              pvrtc:
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
              atc: t.getExtension("WEBGL_compressed_texture_atc"),
              astc: t.getExtension("WEBGL_compressed_texture_astc"),
            };
          1 === this.webGLVersion
            ? Object.assign(this.extensions, e, {
                drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                depthTexture: t.getExtension("WEBGL_depth_texture"),
                loseContext: t.getExtension("WEBGL_lose_context"),
                vertexArrayObject:
                  t.getExtension("OES_vertex_array_object") ||
                  t.getExtension("MOZ_OES_vertex_array_object") ||
                  t.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                floatTexture: t.getExtension("OES_texture_float"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                textureHalfFloat: t.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: t.getExtension(
                  "OES_texture_half_float_linear"
                ),
              })
            : 2 === this.webGLVersion &&
              Object.assign(this.extensions, e, {
                colorBufferFloat: t.getExtension("EXT_color_buffer_float"),
              });
        }),
        (t.prototype.handleContextLost = function (t) {
          t.preventDefault();
        }),
        (t.prototype.handleContextRestored = function () {
          this.renderer.runners.contextChange.emit(this.gl);
        }),
        (t.prototype.destroy = function () {
          var t = this.renderer.view;
          (this.renderer = null),
            t.removeEventListener("webglcontextlost", this.handleContextLost),
            t.removeEventListener(
              "webglcontextrestored",
              this.handleContextRestored
            ),
            this.gl.useProgram(null),
            this.extensions.loseContext &&
              this.extensions.loseContext.loseContext();
        }),
        (t.prototype.postrender = function () {
          this.renderer.renderingToScreen && this.gl.flush();
        }),
        (t.prototype.validateContext = function (t) {
          var e = t.getContextAttributes(),
            n =
              "WebGL2RenderingContext" in globalThis &&
              t instanceof globalThis.WebGL2RenderingContext;
          n && (this.webGLVersion = 2),
            e &&
              !e.stencil &&
              console.warn(
                "Provided WebGL context does not have a stencil buffer, masks may not render correctly"
              );
          var i = n || !!t.getExtension("OES_element_index_uint");
          (this.supports.uint32Indices = i),
            i ||
              console.warn(
                "Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly"
              );
        }),
        t
      );
    })(),
    Sg = function (t) {
      (this.framebuffer = t),
        (this.stencil = null),
        (this.dirtyId = -1),
        (this.dirtyFormat = -1),
        (this.dirtySize = -1),
        (this.multisample = Lf.NONE),
        (this.msaaBuffer = null),
        (this.blitFramebuffer = null),
        (this.mipLevel = 0);
    },
    wg = new Pm(),
    Mg = (function () {
      function t(t) {
        (this.renderer = t),
          (this.managedFramebuffers = []),
          (this.unknownFramebuffer = new Z_(10, 10)),
          (this.msaaSamples = null);
      }
      return (
        (t.prototype.contextChange = function () {
          var t = (this.gl = this.renderer.gl);
          if (
            ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            (this.current = this.unknownFramebuffer),
            (this.viewport = new Pm()),
            (this.hasMRT = !0),
            (this.writeDepthTexture = !0),
            this.disposeAll(!0),
            1 === this.renderer.context.webGLVersion)
          ) {
            var e = this.renderer.context.extensions.drawBuffers,
              n = this.renderer.context.extensions.depthTexture;
            Rp.PREFER_ENV === gf.WEBGL_LEGACY && ((e = null), (n = null)),
              e
                ? (t.drawBuffers = function (t) {
                    return e.drawBuffersWEBGL(t);
                  })
                : ((this.hasMRT = !1), (t.drawBuffers = function () {})),
              n || (this.writeDepthTexture = !1);
          } else
            this.msaaSamples = t.getInternalformatParameter(
              t.RENDERBUFFER,
              t.RGBA8,
              t.SAMPLES
            );
        }),
        (t.prototype.bind = function (t, e, n) {
          void 0 === n && (n = 0);
          var i = this.gl;
          if (t) {
            var r =
              t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t &&
              ((this.current = t),
              i.bindFramebuffer(i.FRAMEBUFFER, r.framebuffer)),
              r.mipLevel !== n &&
                (t.dirtyId++, t.dirtyFormat++, (r.mipLevel = n)),
              r.dirtyId !== t.dirtyId &&
                ((r.dirtyId = t.dirtyId),
                r.dirtyFormat !== t.dirtyFormat
                  ? ((r.dirtyFormat = t.dirtyFormat),
                    (r.dirtySize = t.dirtySize),
                    this.updateFramebuffer(t, n))
                  : r.dirtySize !== t.dirtySize &&
                    ((r.dirtySize = t.dirtySize), this.resizeFramebuffer(t)));
            for (var s = 0; s < t.colorTextures.length; s++) {
              var o = t.colorTextures[s];
              this.renderer.texture.unbind(o.parentTextureArray || o);
            }
            if (
              (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
              e)
            ) {
              var a = e.width >> n,
                l = e.height >> n,
                h = a / e.width;
              this.setViewport(e.x * h, e.y * h, a, l);
            } else {
              (a = t.width >> n), (l = t.height >> n);
              this.setViewport(0, 0, a, l);
            }
          } else
            this.current &&
              ((this.current = null), i.bindFramebuffer(i.FRAMEBUFFER, null)),
              e
                ? this.setViewport(e.x, e.y, e.width, e.height)
                : this.setViewport(
                    0,
                    0,
                    this.renderer.width,
                    this.renderer.height
                  );
        }),
        (t.prototype.setViewport = function (t, e, n, i) {
          var r = this.viewport;
          (t = Math.round(t)),
            (e = Math.round(e)),
            (n = Math.round(n)),
            (i = Math.round(i)),
            (r.width === n && r.height === i && r.x === t && r.y === e) ||
              ((r.x = t),
              (r.y = e),
              (r.width = n),
              (r.height = i),
              this.gl.viewport(t, e, n, i));
        }),
        Object.defineProperty(t.prototype, "size", {
          get: function () {
            return this.current
              ? {
                  x: 0,
                  y: 0,
                  width: this.current.width,
                  height: this.current.height,
                }
              : {
                  x: 0,
                  y: 0,
                  width: this.renderer.width,
                  height: this.renderer.height,
                };
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.clear = function (t, e, n, i, r) {
          void 0 === r && (r = yf.COLOR | yf.DEPTH);
          var s = this.gl;
          s.clearColor(t, e, n, i), s.clear(r);
        }),
        (t.prototype.initFramebuffer = function (t) {
          var e = this.gl,
            n = new Sg(e.createFramebuffer());
          return (
            (n.multisample = this.detectSamples(t.multisample)),
            (t.glFramebuffers[this.CONTEXT_UID] = n),
            this.managedFramebuffers.push(t),
            t.disposeRunner.add(this),
            n
          );
        }),
        (t.prototype.resizeFramebuffer = function (t) {
          var e = this.gl,
            n = t.glFramebuffers[this.CONTEXT_UID];
          n.msaaBuffer &&
            (e.bindRenderbuffer(e.RENDERBUFFER, n.msaaBuffer),
            e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              n.multisample,
              e.RGBA8,
              t.width,
              t.height
            )),
            n.stencil &&
              (e.bindRenderbuffer(e.RENDERBUFFER, n.stencil),
              n.msaaBuffer
                ? e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    n.multisample,
                    e.DEPTH24_STENCIL8,
                    t.width,
                    t.height
                  )
                : e.renderbufferStorage(
                    e.RENDERBUFFER,
                    e.DEPTH_STENCIL,
                    t.width,
                    t.height
                  ));
          var i = t.colorTextures,
            r = i.length;
          e.drawBuffers || (r = Math.min(r, 1));
          for (var s = 0; s < r; s++) {
            var o = i[s],
              a = o.parentTextureArray || o;
            this.renderer.texture.bind(a, 0);
          }
          t.depthTexture &&
            this.writeDepthTexture &&
            this.renderer.texture.bind(t.depthTexture, 0);
        }),
        (t.prototype.updateFramebuffer = function (t, e) {
          var n = this.gl,
            i = t.glFramebuffers[this.CONTEXT_UID],
            r = t.colorTextures,
            s = r.length;
          n.drawBuffers || (s = Math.min(s, 1)),
            i.multisample > 1 && this.canMultisampleFramebuffer(t)
              ? ((i.msaaBuffer = i.msaaBuffer || n.createRenderbuffer()),
                n.bindRenderbuffer(n.RENDERBUFFER, i.msaaBuffer),
                n.renderbufferStorageMultisample(
                  n.RENDERBUFFER,
                  i.multisample,
                  n.RGBA8,
                  t.width,
                  t.height
                ),
                n.framebufferRenderbuffer(
                  n.FRAMEBUFFER,
                  n.COLOR_ATTACHMENT0,
                  n.RENDERBUFFER,
                  i.msaaBuffer
                ))
              : i.msaaBuffer &&
                (n.deleteRenderbuffer(i.msaaBuffer),
                (i.msaaBuffer = null),
                i.blitFramebuffer &&
                  (i.blitFramebuffer.dispose(), (i.blitFramebuffer = null)));
          for (var o = [], a = 0; a < s; a++) {
            var l = r[a],
              h = l.parentTextureArray || l;
            this.renderer.texture.bind(h, 0),
              (0 === a && i.msaaBuffer) ||
                (n.framebufferTexture2D(
                  n.FRAMEBUFFER,
                  n.COLOR_ATTACHMENT0 + a,
                  l.target,
                  h._glTextures[this.CONTEXT_UID].texture,
                  e
                ),
                o.push(n.COLOR_ATTACHMENT0 + a));
          }
          if (
            (o.length > 1 && n.drawBuffers(o), t.depthTexture) &&
            this.writeDepthTexture
          ) {
            var u = t.depthTexture;
            this.renderer.texture.bind(u, 0),
              n.framebufferTexture2D(
                n.FRAMEBUFFER,
                n.DEPTH_ATTACHMENT,
                n.TEXTURE_2D,
                u._glTextures[this.CONTEXT_UID].texture,
                e
              );
          }
          (!t.stencil && !t.depth) || (t.depthTexture && this.writeDepthTexture)
            ? i.stencil && (n.deleteRenderbuffer(i.stencil), (i.stencil = null))
            : ((i.stencil = i.stencil || n.createRenderbuffer()),
              n.bindRenderbuffer(n.RENDERBUFFER, i.stencil),
              i.msaaBuffer
                ? n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    i.multisample,
                    n.DEPTH24_STENCIL8,
                    t.width,
                    t.height
                  )
                : n.renderbufferStorage(
                    n.RENDERBUFFER,
                    n.DEPTH_STENCIL,
                    t.width,
                    t.height
                  ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.DEPTH_STENCIL_ATTACHMENT,
                n.RENDERBUFFER,
                i.stencil
              ));
        }),
        (t.prototype.canMultisampleFramebuffer = function (t) {
          return (
            1 !== this.renderer.context.webGLVersion &&
            t.colorTextures.length <= 1 &&
            !t.depthTexture
          );
        }),
        (t.prototype.detectSamples = function (t) {
          var e = this.msaaSamples,
            n = Lf.NONE;
          if (t <= 1 || null === e) return n;
          for (var i = 0; i < e.length; i++)
            if (e[i] <= t) {
              n = e[i];
              break;
            }
          return 1 === n && (n = Lf.NONE), n;
        }),
        (t.prototype.blit = function (t, e, n) {
          var i = this,
            r = i.current,
            s = i.renderer,
            o = i.gl,
            a = i.CONTEXT_UID;
          if (2 === s.context.webGLVersion && r) {
            var l = r.glFramebuffers[a];
            if (l) {
              if (!t) {
                if (!l.msaaBuffer) return;
                var h = r.colorTextures[0];
                if (!h) return;
                l.blitFramebuffer ||
                  ((l.blitFramebuffer = new Z_(r.width, r.height)),
                  l.blitFramebuffer.addColorTexture(0, h)),
                  (t = l.blitFramebuffer).colorTextures[0] !== h &&
                    ((t.colorTextures[0] = h), t.dirtyId++, t.dirtyFormat++),
                  (t.width === r.width && t.height === r.height) ||
                    ((t.width = r.width),
                    (t.height = r.height),
                    t.dirtyId++,
                    t.dirtySize++);
              }
              e || (((e = wg).width = r.width), (e.height = r.height)),
                n || (n = e);
              var u = e.width === n.width && e.height === n.height;
              this.bind(t),
                o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer),
                o.blitFramebuffer(
                  e.left,
                  e.top,
                  e.right,
                  e.bottom,
                  n.left,
                  n.top,
                  n.right,
                  n.bottom,
                  o.COLOR_BUFFER_BIT,
                  u ? o.NEAREST : o.LINEAR
                );
            }
          }
        }),
        (t.prototype.disposeFramebuffer = function (t, e) {
          var n = t.glFramebuffers[this.CONTEXT_UID],
            i = this.gl;
          if (n) {
            delete t.glFramebuffers[this.CONTEXT_UID];
            var r = this.managedFramebuffers.indexOf(t);
            r >= 0 && this.managedFramebuffers.splice(r, 1),
              t.disposeRunner.remove(this),
              e ||
                (i.deleteFramebuffer(n.framebuffer),
                n.msaaBuffer && i.deleteRenderbuffer(n.msaaBuffer),
                n.stencil && i.deleteRenderbuffer(n.stencil)),
              n.blitFramebuffer && n.blitFramebuffer.dispose();
          }
        }),
        (t.prototype.disposeAll = function (t) {
          var e = this.managedFramebuffers;
          this.managedFramebuffers = [];
          for (var n = 0; n < e.length; n++) this.disposeFramebuffer(e[n], t);
        }),
        (t.prototype.forceStencil = function () {
          var t = this.current;
          if (t) {
            var e = t.glFramebuffers[this.CONTEXT_UID];
            if (e && !e.stencil) {
              t.stencil = !0;
              var n = t.width,
                i = t.height,
                r = this.gl,
                s = r.createRenderbuffer();
              r.bindRenderbuffer(r.RENDERBUFFER, s),
                e.msaaBuffer
                  ? r.renderbufferStorageMultisample(
                      r.RENDERBUFFER,
                      e.multisample,
                      r.DEPTH24_STENCIL8,
                      n,
                      i
                    )
                  : r.renderbufferStorage(
                      r.RENDERBUFFER,
                      r.DEPTH_STENCIL,
                      n,
                      i
                    ),
                (e.stencil = s),
                r.framebufferRenderbuffer(
                  r.FRAMEBUFFER,
                  r.DEPTH_STENCIL_ATTACHMENT,
                  r.RENDERBUFFER,
                  s
                );
            }
          }
        }),
        (t.prototype.reset = function () {
          (this.current = this.unknownFramebuffer), (this.viewport = new Pm());
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    Ag = { 5126: 4, 5123: 2, 5121: 1 },
    Rg = (function () {
      function t(t) {
        (this.renderer = t),
          (this._activeGeometry = null),
          (this._activeVao = null),
          (this.hasVao = !0),
          (this.hasInstance = !0),
          (this.canUseUInt32ElementIndex = !1),
          (this.managedGeometries = {});
      }
      return (
        (t.prototype.contextChange = function () {
          this.disposeAll(!0);
          var t = (this.gl = this.renderer.gl),
            e = this.renderer.context;
          if (
            ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            2 !== e.webGLVersion)
          ) {
            var n = this.renderer.context.extensions.vertexArrayObject;
            Rp.PREFER_ENV === gf.WEBGL_LEGACY && (n = null),
              n
                ? ((t.createVertexArray = function () {
                    return n.createVertexArrayOES();
                  }),
                  (t.bindVertexArray = function (t) {
                    return n.bindVertexArrayOES(t);
                  }),
                  (t.deleteVertexArray = function (t) {
                    return n.deleteVertexArrayOES(t);
                  }))
                : ((this.hasVao = !1),
                  (t.createVertexArray = function () {
                    return null;
                  }),
                  (t.bindVertexArray = function () {
                    return null;
                  }),
                  (t.deleteVertexArray = function () {
                    return null;
                  }));
          }
          if (2 !== e.webGLVersion) {
            var i = t.getExtension("ANGLE_instanced_arrays");
            i
              ? ((t.vertexAttribDivisor = function (t, e) {
                  return i.vertexAttribDivisorANGLE(t, e);
                }),
                (t.drawElementsInstanced = function (t, e, n, r, s) {
                  return i.drawElementsInstancedANGLE(t, e, n, r, s);
                }),
                (t.drawArraysInstanced = function (t, e, n, r) {
                  return i.drawArraysInstancedANGLE(t, e, n, r);
                }))
              : (this.hasInstance = !1);
          }
          this.canUseUInt32ElementIndex =
            2 === e.webGLVersion || !!e.extensions.uint32ElementIndex;
        }),
        (t.prototype.bind = function (t, e) {
          e = e || this.renderer.shader.shader;
          var n = this.gl,
            i = t.glVertexArrayObjects[this.CONTEXT_UID],
            r = !1;
          i ||
            ((this.managedGeometries[t.id] = t),
            t.disposeRunner.add(this),
            (t.glVertexArrayObjects[this.CONTEXT_UID] = i = {}),
            (r = !0));
          var s = i[e.program.id] || this.initGeometryVao(t, e, r);
          (this._activeGeometry = t),
            this._activeVao !== s &&
              ((this._activeVao = s),
              this.hasVao
                ? n.bindVertexArray(s)
                : this.activateVao(t, e.program)),
            this.updateBuffers();
        }),
        (t.prototype.reset = function () {
          this.unbind();
        }),
        (t.prototype.updateBuffers = function () {
          for (
            var t = this._activeGeometry, e = this.renderer.buffer, n = 0;
            n < t.buffers.length;
            n++
          ) {
            var i = t.buffers[n];
            e.update(i);
          }
        }),
        (t.prototype.checkCompatibility = function (t, e) {
          var n = t.attributes,
            i = e.attributeData;
          for (var r in i)
            if (!n[r])
              throw new Error(
                'shader and geometry incompatible, geometry missing the "' +
                  r +
                  '" attribute'
              );
        }),
        (t.prototype.getSignature = function (t, e) {
          var n = t.attributes,
            i = e.attributeData,
            r = ["g", t.id];
          for (var s in n) i[s] && r.push(s, i[s].location);
          return r.join("-");
        }),
        (t.prototype.initGeometryVao = function (t, e, n) {
          void 0 === n && (n = !0);
          var i = this.gl,
            r = this.CONTEXT_UID,
            s = this.renderer.buffer,
            o = e.program;
          o.glPrograms[r] || this.renderer.shader.generateProgram(e),
            this.checkCompatibility(t, o);
          var a = this.getSignature(t, o),
            l = t.glVertexArrayObjects[this.CONTEXT_UID],
            h = l[a];
          if (h) return (l[o.id] = h), h;
          var u = t.buffers,
            c = t.attributes,
            d = {},
            p = {};
          for (var f in u) (d[f] = 0), (p[f] = 0);
          for (var f in c)
            !c[f].size && o.attributeData[f]
              ? (c[f].size = o.attributeData[f].size)
              : c[f].size ||
                console.warn(
                  "PIXI Geometry attribute '" +
                    f +
                    "' size cannot be determined (likely the bound shader does not have the attribute)"
                ),
              (d[c[f].buffer] += c[f].size * Ag[c[f].type]);
          for (var f in c) {
            var m = c[f],
              _ = m.size;
            void 0 === m.stride &&
              (d[m.buffer] === _ * Ag[m.type]
                ? (m.stride = 0)
                : (m.stride = d[m.buffer])),
              void 0 === m.start &&
                ((m.start = p[m.buffer]), (p[m.buffer] += _ * Ag[m.type]));
          }
          (h = i.createVertexArray()), i.bindVertexArray(h);
          for (var g = 0; g < u.length; g++) {
            var v = u[g];
            s.bind(v), n && v._glBuffers[r].refCount++;
          }
          return (
            this.activateVao(t, o),
            (this._activeVao = h),
            (l[o.id] = h),
            (l[a] = h),
            h
          );
        }),
        (t.prototype.disposeGeometry = function (t, e) {
          var n;
          if (this.managedGeometries[t.id]) {
            delete this.managedGeometries[t.id];
            var i = t.glVertexArrayObjects[this.CONTEXT_UID],
              r = this.gl,
              s = t.buffers,
              o =
                null === (n = this.renderer) || void 0 === n
                  ? void 0
                  : n.buffer;
            if ((t.disposeRunner.remove(this), i)) {
              if (o)
                for (var a = 0; a < s.length; a++) {
                  var l = s[a]._glBuffers[this.CONTEXT_UID];
                  l &&
                    (l.refCount--, 0 !== l.refCount || e || o.dispose(s[a], e));
                }
              if (!e)
                for (var h in i)
                  if ("g" === h[0]) {
                    var u = i[h];
                    this._activeVao === u && this.unbind(),
                      r.deleteVertexArray(u);
                  }
              delete t.glVertexArrayObjects[this.CONTEXT_UID];
            }
          }
        }),
        (t.prototype.disposeAll = function (t) {
          for (
            var e = Object.keys(this.managedGeometries), n = 0;
            n < e.length;
            n++
          )
            this.disposeGeometry(this.managedGeometries[e[n]], t);
        }),
        (t.prototype.activateVao = function (t, e) {
          var n = this.gl,
            i = this.CONTEXT_UID,
            r = this.renderer.buffer,
            s = t.buffers,
            o = t.attributes;
          t.indexBuffer && r.bind(t.indexBuffer);
          var a = null;
          for (var l in o) {
            var h = o[l],
              u = s[h.buffer],
              c = u._glBuffers[i];
            if (e.attributeData[l]) {
              a !== c && (r.bind(u), (a = c));
              var d = e.attributeData[l].location;
              if (
                (n.enableVertexAttribArray(d),
                n.vertexAttribPointer(
                  d,
                  h.size,
                  h.type || n.FLOAT,
                  h.normalized,
                  h.stride,
                  h.start
                ),
                h.instance)
              ) {
                if (!this.hasInstance)
                  throw new Error(
                    "geometry error, GPU Instancing is not supported on this device"
                  );
                n.vertexAttribDivisor(d, 1);
              }
            }
          }
        }),
        (t.prototype.draw = function (t, e, n, i) {
          var r = this.gl,
            s = this._activeGeometry;
          if (s.indexBuffer) {
            var o = s.indexBuffer.data.BYTES_PER_ELEMENT,
              a = 2 === o ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
            2 === o || (4 === o && this.canUseUInt32ElementIndex)
              ? s.instanced
                ? r.drawElementsInstanced(
                    t,
                    e || s.indexBuffer.data.length,
                    a,
                    (n || 0) * o,
                    i || 1
                  )
                : r.drawElements(
                    t,
                    e || s.indexBuffer.data.length,
                    a,
                    (n || 0) * o
                  )
              : console.warn("unsupported index buffer type: uint32");
          } else
            s.instanced
              ? r.drawArraysInstanced(t, n, e || s.getSize(), i || 1)
              : r.drawArrays(t, n, e || s.getSize());
          return this;
        }),
        (t.prototype.unbind = function () {
          this.gl.bindVertexArray(null),
            (this._activeVao = null),
            (this._activeGeometry = null);
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    Cg = (function () {
      function t(t) {
        void 0 === t && (t = null),
          (this.type = Nf.NONE),
          (this.autoDetect = !0),
          (this.maskObject = t || null),
          (this.pooled = !1),
          (this.isMaskData = !0),
          (this.resolution = null),
          (this.multisample = Rp.FILTER_MULTISAMPLE),
          (this.enabled = !0),
          (this.colorMask = 15),
          (this._filters = null),
          (this._stencilCounter = 0),
          (this._scissorCounter = 0),
          (this._scissorRect = null),
          (this._scissorRectLocal = null),
          (this._colorMask = 15),
          (this._target = null);
      }
      return (
        Object.defineProperty(t.prototype, "filter", {
          get: function () {
            return this._filters ? this._filters[0] : null;
          },
          set: function (t) {
            t
              ? this._filters
                ? (this._filters[0] = t)
                : (this._filters = [t])
              : (this._filters = null);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.reset = function () {
          this.pooled &&
            ((this.maskObject = null),
            (this.type = Nf.NONE),
            (this.autoDetect = !0)),
            (this._target = null),
            (this._scissorRectLocal = null);
        }),
        (t.prototype.copyCountersOrReset = function (t) {
          t
            ? ((this._stencilCounter = t._stencilCounter),
              (this._scissorCounter = t._scissorCounter),
              (this._scissorRect = t._scissorRect))
            : ((this._stencilCounter = 0),
              (this._scissorCounter = 0),
              (this._scissorRect = null));
        }),
        t
      );
    })();
  function Ig(t, e, n) {
    var i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  function Pg(t, e) {
    var n = t
        .getShaderSource(e)
        .split("\n")
        .map(function (t, e) {
          return e + ": " + t;
        }),
      i = t.getShaderInfoLog(e),
      r = i.split("\n"),
      s = {},
      o = r
        .map(function (t) {
          return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
        })
        .filter(function (t) {
          return !(!t || s[t]) && ((s[t] = !0), !0);
        }),
      a = [""];
    o.forEach(function (t) {
      (n[t - 1] = "%c" + n[t - 1] + "%c"),
        a.push(
          "background: #FF0000; color:#FFFFFF; font-size: 10px",
          "font-size: 10px"
        );
    });
    var l = n.join("\n");
    (a[0] = l),
      console.error(i),
      console.groupCollapsed("click to view full shader code"),
      console.warn.apply(console, a),
      console.groupEnd();
  }
  function Og(t) {
    for (var e = new Array(t), n = 0; n < e.length; n++) e[n] = !1;
    return e;
  }
  function Ng(t, e) {
    switch (t) {
      case "float":
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "vec2":
        return new Float32Array(2 * e);
      case "vec3":
        return new Float32Array(3 * e);
      case "vec4":
        return new Float32Array(4 * e);
      case "ivec2":
        return new Int32Array(2 * e);
      case "ivec3":
        return new Int32Array(3 * e);
      case "ivec4":
        return new Int32Array(4 * e);
      case "uvec2":
        return new Uint32Array(2 * e);
      case "uvec3":
        return new Uint32Array(3 * e);
      case "uvec4":
        return new Uint32Array(4 * e);
      case "bool":
        return !1;
      case "bvec2":
        return Og(2 * e);
      case "bvec3":
        return Og(3 * e);
      case "bvec4":
        return Og(4 * e);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
    }
    return null;
  }
  var Dg,
    Lg = {},
    Fg = Lg;
  function Ug() {
    if (!Dg) {
      Dg = Of.MEDIUM;
      var t = (function () {
        if (Fg === Lg || (Fg && Fg.isContextLost())) {
          var t = Rp.ADAPTER.createCanvas(),
            e = void 0;
          Rp.PREFER_ENV >= gf.WEBGL2 && (e = t.getContext("webgl2", {})),
            e ||
              ((e =
                t.getContext("webgl", {}) ||
                t.getContext("experimental-webgl", {}))
                ? e.getExtension("WEBGL_draw_buffers")
                : (e = null)),
            (Fg = e);
        }
        return Fg;
      })();
      if (t && t.getShaderPrecisionFormat) {
        var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
        Dg = e.precision ? Of.HIGH : Of.MEDIUM;
      }
    }
    return Dg;
  }
  function Bg(t, e, n) {
    if ("precision" !== t.substring(0, 9)) {
      var i = e;
      return (
        e === Of.HIGH && n !== Of.HIGH && (i = Of.MEDIUM),
        "precision " + i + " float;\n" + t
      );
    }
    return n !== Of.HIGH && "precision highp" === t.substring(0, 15)
      ? t.replace("precision highp", "precision mediump")
      : t;
  }
  var kg = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
  };
  function Gg(t) {
    return kg[t];
  }
  var Hg = null,
    zg = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    };
  function Vg(t, e) {
    if (!Hg) {
      var n = Object.keys(zg);
      Hg = {};
      for (var i = 0; i < n.length; ++i) {
        var r = n[i];
        Hg[t[r]] = zg[r];
      }
    }
    return Hg[e];
  }
  var Xg = [
      {
        test: function (t) {
          return "float" === t.type && 1 === t.size;
        },
        code: function (t) {
          return (
            '\n            if(uv["' +
            t +
            '"] !== ud["' +
            t +
            '"].value)\n            {\n                ud["' +
            t +
            '"].value = uv["' +
            t +
            '"]\n                gl.uniform1f(ud["' +
            t +
            '"].location, uv["' +
            t +
            '"])\n            }\n            '
          );
        },
      },
      {
        test: function (t) {
          return (
            ("sampler2D" === t.type ||
              "samplerCube" === t.type ||
              "sampler2DArray" === t.type) &&
            1 === t.size &&
            !t.isArray
          );
        },
        code: function (t) {
          return (
            't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' +
            t +
            '"], t);\n\n            if(ud["' +
            t +
            '"].value !== t)\n            {\n                ud["' +
            t +
            '"].value = t;\n                gl.uniform1i(ud["' +
            t +
            '"].location, t);\n; // eslint-disable-line max-len\n            }'
          );
        },
      },
      {
        test: function (t, e) {
          return "mat3" === t.type && 1 === t.size && void 0 !== e.a;
        },
        code: function (t) {
          return (
            '\n            gl.uniformMatrix3fv(ud["' +
            t +
            '"].location, false, uv["' +
            t +
            '"].toArray(true));\n            '
          );
        },
        codeUbo: function (t) {
          return (
            "\n                var " +
            t +
            "_matrix = uv." +
            t +
            ".toArray(true);\n\n                data[offset] = " +
            t +
            "_matrix[0];\n                data[offset+1] = " +
            t +
            "_matrix[1];\n                data[offset+2] = " +
            t +
            "_matrix[2];\n        \n                data[offset + 4] = " +
            t +
            "_matrix[3];\n                data[offset + 5] = " +
            t +
            "_matrix[4];\n                data[offset + 6] = " +
            t +
            "_matrix[5];\n        \n                data[offset + 8] = " +
            t +
            "_matrix[6];\n                data[offset + 9] = " +
            t +
            "_matrix[7];\n                data[offset + 10] = " +
            t +
            "_matrix[8];\n            "
          );
        },
      },
      {
        test: function (t, e) {
          return "vec2" === t.type && 1 === t.size && void 0 !== e.x;
        },
        code: function (t) {
          return (
            '\n                cv = ud["' +
            t +
            '"].value;\n                v = uv["' +
            t +
            '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' +
            t +
            '"].location, v.x, v.y);\n                }'
          );
        },
        codeUbo: function (t) {
          return (
            "\n                v = uv." +
            t +
            ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            "
          );
        },
      },
      {
        test: function (t) {
          return "vec2" === t.type && 1 === t.size;
        },
        code: function (t) {
          return (
            '\n                cv = ud["' +
            t +
            '"].value;\n                v = uv["' +
            t +
            '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' +
            t +
            '"].location, v[0], v[1]);\n                }\n            '
          );
        },
      },
      {
        test: function (t, e) {
          return "vec4" === t.type && 1 === t.size && void 0 !== e.width;
        },
        code: function (t) {
          return (
            '\n                cv = ud["' +
            t +
            '"].value;\n                v = uv["' +
            t +
            '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' +
            t +
            '"].location, v.x, v.y, v.width, v.height)\n                }'
          );
        },
        codeUbo: function (t) {
          return (
            "\n                    v = uv." +
            t +
            ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                "
          );
        },
      },
      {
        test: function (t) {
          return "vec4" === t.type && 1 === t.size;
        },
        code: function (t) {
          return (
            '\n                cv = ud["' +
            t +
            '"].value;\n                v = uv["' +
            t +
            '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' +
            t +
            '"].location, v[0], v[1], v[2], v[3])\n                }'
          );
        },
      },
    ],
    Wg = {
      float:
        "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
      vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
      vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
      vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
      int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
      ivec2:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
      ivec3:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
      ivec4:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
      uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
      uvec2:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
      uvec3:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
      uvec4:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
      bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
      bvec2:
        "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
      bvec3:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
      bvec4:
        "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: "gl.uniform1i(location, v)",
      samplerCube: "gl.uniform1i(location, v)",
      sampler2DArray: "gl.uniform1i(location, v)",
    },
    jg = {
      float: "gl.uniform1fv(location, v)",
      vec2: "gl.uniform2fv(location, v)",
      vec3: "gl.uniform3fv(location, v)",
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)",
    };
  var Yg,
    qg = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}",
    ].join("\n");
  function Kg(t) {
    for (var e = "", n = 0; n < t; ++n)
      n > 0 && (e += "\nelse "),
        n < t - 1 && (e += "if(test == " + n + ".0){}");
    return e;
  }
  var Zg = 0,
    Jg = {},
    $g = (function () {
      function t(e, n, i) {
        void 0 === i && (i = "pixi-shader"),
          (this.id = Zg++),
          (this.vertexSrc = e || t.defaultVertexSrc),
          (this.fragmentSrc = n || t.defaultFragmentSrc),
          (this.vertexSrc = this.vertexSrc.trim()),
          (this.fragmentSrc = this.fragmentSrc.trim()),
          "#version" !== this.vertexSrc.substring(0, 8) &&
            ((i = i.replace(/\s+/g, "-")),
            Jg[i] ? (Jg[i]++, (i += "-" + Jg[i])) : (Jg[i] = 1),
            (this.vertexSrc =
              "#define SHADER_NAME " + i + "\n" + this.vertexSrc),
            (this.fragmentSrc =
              "#define SHADER_NAME " + i + "\n" + this.fragmentSrc),
            (this.vertexSrc = Bg(this.vertexSrc, Rp.PRECISION_VERTEX, Of.HIGH)),
            (this.fragmentSrc = Bg(
              this.fragmentSrc,
              Rp.PRECISION_FRAGMENT,
              Ug()
            ))),
          (this.glPrograms = {}),
          (this.syncUniforms = null);
      }
      return (
        Object.defineProperty(t, "defaultVertexSrc", {
          get: function () {
            return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "defaultFragmentSrc", {
          get: function () {
            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.from = function (e, n, i) {
          var r = e + n,
            s = ym[r];
          return s || (ym[r] = s = new t(e, n, i)), s;
        }),
        t
      );
    })(),
    Qg = (function () {
      function t(t, e) {
        (this.uniformBindCount = 0),
          (this.program = t),
          (this.uniformGroup = e
            ? e instanceof mg
              ? e
              : new mg(e)
            : new mg({}));
      }
      return (
        (t.prototype.checkUniformExists = function (t, e) {
          if (e.uniforms[t]) return !0;
          for (var n in e.uniforms) {
            var i = e.uniforms[n];
            if (i.group && this.checkUniformExists(t, i)) return !0;
          }
          return !1;
        }),
        (t.prototype.destroy = function () {
          this.uniformGroup = null;
        }),
        Object.defineProperty(t.prototype, "uniforms", {
          get: function () {
            return this.uniformGroup.uniforms;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.from = function (e, n, i) {
          return new t($g.from(e, n), i);
        }),
        t
      );
    })(),
    tv = (function () {
      function t() {
        (this.data = 0),
          (this.blendMode = xf.NORMAL),
          (this.polygonOffset = 0),
          (this.blend = !0),
          (this.depthMask = !0);
      }
      return (
        Object.defineProperty(t.prototype, "blend", {
          get: function () {
            return !!(1 & this.data);
          },
          set: function (t) {
            !!(1 & this.data) !== t && (this.data ^= 1);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "offsets", {
          get: function () {
            return !!(2 & this.data);
          },
          set: function (t) {
            !!(2 & this.data) !== t && (this.data ^= 2);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "culling", {
          get: function () {
            return !!(4 & this.data);
          },
          set: function (t) {
            !!(4 & this.data) !== t && (this.data ^= 4);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "depthTest", {
          get: function () {
            return !!(8 & this.data);
          },
          set: function (t) {
            !!(8 & this.data) !== t && (this.data ^= 8);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "depthMask", {
          get: function () {
            return !!(32 & this.data);
          },
          set: function (t) {
            !!(32 & this.data) !== t && (this.data ^= 32);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "clockwiseFrontFace", {
          get: function () {
            return !!(16 & this.data);
          },
          set: function (t) {
            !!(16 & this.data) !== t && (this.data ^= 16);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "blendMode", {
          get: function () {
            return this._blendMode;
          },
          set: function (t) {
            (this.blend = t !== xf.NONE), (this._blendMode = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "polygonOffset", {
          get: function () {
            return this._polygonOffset;
          },
          set: function (t) {
            (this.offsets = !!t), (this._polygonOffset = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.toString = function () {
          return (
            "[@pixi/core:State blendMode=" +
            this.blendMode +
            " clockwiseFrontFace=" +
            this.clockwiseFrontFace +
            " culling=" +
            this.culling +
            " depthMask=" +
            this.depthMask +
            " polygonOffset=" +
            this.polygonOffset +
            "]"
          );
        }),
        (t.for2d = function () {
          var e = new t();
          return (e.depthTest = !1), (e.blend = !0), e;
        }),
        t
      );
    })(),
    ev = (function (t) {
      function e(n, i, r) {
        var s = this,
          o = $g.from(n || e.defaultVertexSrc, i || e.defaultFragmentSrc);
        return (
          ((s = t.call(this, o, r) || this).padding = 0),
          (s.resolution = Rp.FILTER_RESOLUTION),
          (s.multisample = Rp.FILTER_MULTISAMPLE),
          (s.enabled = !0),
          (s.autoFit = !0),
          (s.state = new tv()),
          s
        );
      }
      return (
        D_(e, t),
        (e.prototype.apply = function (t, e, n, i, r) {
          t.applyFilter(this, e, n, i);
        }),
        Object.defineProperty(e.prototype, "blendMode", {
          get: function () {
            return this.state.blendMode;
          },
          set: function (t) {
            this.state.blendMode = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "resolution", {
          get: function () {
            return this._resolution;
          },
          set: function (t) {
            this._resolution = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e, "defaultVertexSrc", {
          get: function () {
            return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e, "defaultFragmentSrc", {
          get: function () {
            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(Qg),
    nv = new Um(),
    iv = (function () {
      function t(t, e) {
        (this._texture = t),
          (this.mapCoord = new Um()),
          (this.uClampFrame = new Float32Array(4)),
          (this.uClampOffset = new Float32Array(2)),
          (this._textureID = -1),
          (this._updateID = 0),
          (this.clampOffset = 0),
          (this.clampMargin = void 0 === e ? 0.5 : e),
          (this.isSimple = !1);
      }
      return (
        Object.defineProperty(t.prototype, "texture", {
          get: function () {
            return this._texture;
          },
          set: function (t) {
            (this._texture = t), (this._textureID = -1);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.multiplyUvs = function (t, e) {
          void 0 === e && (e = t);
          for (var n = this.mapCoord, i = 0; i < t.length; i += 2) {
            var r = t[i],
              s = t[i + 1];
            (e[i] = r * n.a + s * n.c + n.tx),
              (e[i + 1] = r * n.b + s * n.d + n.ty);
          }
          return e;
        }),
        (t.prototype.update = function (t) {
          var e = this._texture;
          if (!e || !e.valid) return !1;
          if (!t && this._textureID === e._updateID) return !1;
          (this._textureID = e._updateID), this._updateID++;
          var n = e._uvs;
          this.mapCoord.set(
            n.x1 - n.x0,
            n.y1 - n.y0,
            n.x3 - n.x0,
            n.y3 - n.y0,
            n.x0,
            n.y0
          );
          var i = e.orig,
            r = e.trim;
          r &&
            (nv.set(
              i.width / r.width,
              0,
              0,
              i.height / r.height,
              -r.x / r.width,
              -r.y / r.height
            ),
            this.mapCoord.append(nv));
          var s = e.baseTexture,
            o = this.uClampFrame,
            a = this.clampMargin / s.resolution,
            l = this.clampOffset;
          return (
            (o[0] = (e._frame.x + a + l) / s.width),
            (o[1] = (e._frame.y + a + l) / s.height),
            (o[2] = (e._frame.x + e._frame.width - a + l) / s.width),
            (o[3] = (e._frame.y + e._frame.height - a + l) / s.height),
            (this.uClampOffset[0] = l / s.realWidth),
            (this.uClampOffset[1] = l / s.realHeight),
            (this.isSimple =
              e._frame.width === s.width &&
              e._frame.height === s.height &&
              0 === e.rotate),
            !0
          );
        }),
        t
      );
    })(),
    rv = (function (t) {
      function e(e, n, i) {
        var r = this,
          s = null;
        return (
          "string" != typeof e &&
            void 0 === n &&
            void 0 === i &&
            ((s = e), (e = void 0), (n = void 0), (i = void 0)),
          ((r =
            t.call(
              this,
              e ||
                "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n",
              n ||
                "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n",
              i
            ) || this).maskSprite = s),
          (r.maskMatrix = new Um()),
          r
        );
      }
      return (
        D_(e, t),
        Object.defineProperty(e.prototype, "maskSprite", {
          get: function () {
            return this._maskSprite;
          },
          set: function (t) {
            (this._maskSprite = t),
              this._maskSprite && (this._maskSprite.renderable = !1);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.apply = function (t, e, n, i) {
          var r = this._maskSprite,
            s = r._texture;
          s.valid &&
            (s.uvMatrix || (s.uvMatrix = new iv(s, 0)),
            s.uvMatrix.update(),
            (this.uniforms.npmAlpha = s.baseTexture.alphaMode ? 0 : 1),
            (this.uniforms.mask = s),
            (this.uniforms.otherMatrix = t
              .calculateSpriteMatrix(this.maskMatrix, r)
              .prepend(s.uvMatrix.mapCoord)),
            (this.uniforms.alpha = r.worldAlpha),
            (this.uniforms.maskClamp = s.uvMatrix.uClampFrame),
            t.applyFilter(this, e, n, i));
        }),
        e
      );
    })(ev),
    sv = (function () {
      function t(t) {
        (this.renderer = t),
          (this.enableScissor = !0),
          (this.alphaMaskPool = []),
          (this.maskDataPool = []),
          (this.maskStack = []),
          (this.alphaMaskIndex = 0);
      }
      return (
        (t.prototype.setMaskStack = function (t) {
          (this.maskStack = t),
            this.renderer.scissor.setMaskStack(t),
            this.renderer.stencil.setMaskStack(t);
        }),
        (t.prototype.push = function (t, e) {
          var n = e;
          if (!n.isMaskData) {
            var i = this.maskDataPool.pop() || new Cg();
            (i.pooled = !0), (i.maskObject = e), (n = i);
          }
          var r =
            0 !== this.maskStack.length
              ? this.maskStack[this.maskStack.length - 1]
              : null;
          if (
            (n.copyCountersOrReset(r),
            (n._colorMask = r ? r._colorMask : 15),
            n.autoDetect && this.detect(n),
            (n._target = t),
            n.type !== Nf.SPRITE && this.maskStack.push(n),
            n.enabled)
          )
            switch (n.type) {
              case Nf.SCISSOR:
                this.renderer.scissor.push(n);
                break;
              case Nf.STENCIL:
                this.renderer.stencil.push(n);
                break;
              case Nf.SPRITE:
                n.copyCountersOrReset(null), this.pushSpriteMask(n);
                break;
              case Nf.COLOR:
                this.pushColorMask(n);
            }
          n.type === Nf.SPRITE && this.maskStack.push(n);
        }),
        (t.prototype.pop = function (t) {
          var e = this.maskStack.pop();
          if (e && e._target === t) {
            if (e.enabled)
              switch (e.type) {
                case Nf.SCISSOR:
                  this.renderer.scissor.pop(e);
                  break;
                case Nf.STENCIL:
                  this.renderer.stencil.pop(e.maskObject);
                  break;
                case Nf.SPRITE:
                  this.popSpriteMask(e);
                  break;
                case Nf.COLOR:
                  this.popColorMask(e);
              }
            if (
              (e.reset(),
              e.pooled && this.maskDataPool.push(e),
              0 !== this.maskStack.length)
            ) {
              var n = this.maskStack[this.maskStack.length - 1];
              n.type === Nf.SPRITE &&
                n._filters &&
                (n._filters[0].maskSprite = n.maskObject);
            }
          }
        }),
        (t.prototype.detect = function (t) {
          var e = t.maskObject;
          e
            ? e.isSprite
              ? (t.type = Nf.SPRITE)
              : this.enableScissor && this.renderer.scissor.testScissor(t)
              ? (t.type = Nf.SCISSOR)
              : (t.type = Nf.STENCIL)
            : (t.type = Nf.COLOR);
        }),
        (t.prototype.pushSpriteMask = function (t) {
          var e,
            n,
            i = t.maskObject,
            r = t._target,
            s = t._filters;
          s ||
            (s = this.alphaMaskPool[this.alphaMaskIndex]) ||
            (s = this.alphaMaskPool[this.alphaMaskIndex] = [new rv()]);
          var o,
            a,
            l = this.renderer,
            h = l.renderTexture;
          if (h.current) {
            var u = h.current;
            (o = t.resolution || u.resolution),
              (a =
                null !== (e = t.multisample) && void 0 !== e
                  ? e
                  : u.multisample);
          } else
            (o = t.resolution || l.resolution),
              (a =
                null !== (n = t.multisample) && void 0 !== n
                  ? n
                  : l.multisample);
          (s[0].resolution = o), (s[0].multisample = a), (s[0].maskSprite = i);
          var c = r.filterArea;
          (r.filterArea = i.getBounds(!0)),
            l.filter.push(r, s),
            (r.filterArea = c),
            t._filters || this.alphaMaskIndex++;
        }),
        (t.prototype.popSpriteMask = function (t) {
          this.renderer.filter.pop(),
            t._filters
              ? (t._filters[0].maskSprite = null)
              : (this.alphaMaskIndex--,
                (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
        }),
        (t.prototype.pushColorMask = function (t) {
          var e = t._colorMask,
            n = (t._colorMask = e & t.colorMask);
          n !== e &&
            this.renderer.gl.colorMask(
              0 != (1 & n),
              0 != (2 & n),
              0 != (4 & n),
              0 != (8 & n)
            );
        }),
        (t.prototype.popColorMask = function (t) {
          var e = t._colorMask,
            n =
              this.maskStack.length > 0
                ? this.maskStack[this.maskStack.length - 1]._colorMask
                : 15;
          n !== e &&
            this.renderer.gl.colorMask(
              0 != (1 & n),
              0 != (2 & n),
              0 != (4 & n),
              0 != (8 & n)
            );
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    ov = (function () {
      function t(t) {
        (this.renderer = t), (this.maskStack = []), (this.glConst = 0);
      }
      return (
        (t.prototype.getStackLength = function () {
          return this.maskStack.length;
        }),
        (t.prototype.setMaskStack = function (t) {
          var e = this.renderer.gl,
            n = this.getStackLength();
          this.maskStack = t;
          var i = this.getStackLength();
          i !== n &&
            (0 === i
              ? e.disable(this.glConst)
              : (e.enable(this.glConst), this._useCurrent()));
        }),
        (t.prototype._useCurrent = function () {}),
        (t.prototype.destroy = function () {
          (this.renderer = null), (this.maskStack = null);
        }),
        t
      );
    })(),
    av = new Um(),
    lv = [],
    hv = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.glConst = Rp.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST), n
        );
      }
      return (
        D_(e, t),
        (e.prototype.getStackLength = function () {
          var t = this.maskStack[this.maskStack.length - 1];
          return t ? t._scissorCounter : 0;
        }),
        (e.prototype.calcScissorRect = function (t) {
          var e;
          if (!t._scissorRectLocal) {
            var n = t._scissorRect,
              i = t.maskObject,
              r = this.renderer,
              s = r.renderTexture,
              o = i.getBounds(
                !0,
                null !== (e = lv.pop()) && void 0 !== e ? e : new Pm()
              );
            this.roundFrameToPixels(
              o,
              s.current ? s.current.resolution : r.resolution,
              s.sourceFrame,
              s.destinationFrame,
              r.projection.transform
            ),
              n && o.fit(n),
              (t._scissorRectLocal = o);
          }
        }),
        (e.isMatrixRotated = function (t) {
          if (!t) return !1;
          var e = t.a,
            n = t.b,
            i = t.c,
            r = t.d;
          return (
            (Math.abs(n) > 1e-4 || Math.abs(i) > 1e-4) &&
            (Math.abs(e) > 1e-4 || Math.abs(r) > 1e-4)
          );
        }),
        (e.prototype.testScissor = function (t) {
          var n = t.maskObject;
          if (!n.isFastRect || !n.isFastRect()) return !1;
          if (e.isMatrixRotated(n.worldTransform)) return !1;
          if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
          this.calcScissorRect(t);
          var i = t._scissorRectLocal;
          return i.width > 0 && i.height > 0;
        }),
        (e.prototype.roundFrameToPixels = function (t, n, i, r, s) {
          e.isMatrixRotated(s) ||
            ((s = s ? av.copyFrom(s) : av.identity())
              .translate(-i.x, -i.y)
              .scale(r.width / i.width, r.height / i.height)
              .translate(r.x, r.y),
            this.renderer.filter.transformAABB(s, t),
            t.fit(r),
            (t.x = Math.round(t.x * n)),
            (t.y = Math.round(t.y * n)),
            (t.width = Math.round(t.width * n)),
            (t.height = Math.round(t.height * n)));
        }),
        (e.prototype.push = function (t) {
          t._scissorRectLocal || this.calcScissorRect(t);
          var e = this.renderer.gl;
          t._scissorRect || e.enable(e.SCISSOR_TEST),
            t._scissorCounter++,
            (t._scissorRect = t._scissorRectLocal),
            this._useCurrent();
        }),
        (e.prototype.pop = function (t) {
          var e = this.renderer.gl;
          t && lv.push(t._scissorRectLocal),
            this.getStackLength() > 0
              ? this._useCurrent()
              : e.disable(e.SCISSOR_TEST);
        }),
        (e.prototype._useCurrent = function () {
          var t,
            e = this.maskStack[this.maskStack.length - 1]._scissorRect;
          (t = this.renderer.renderTexture.current
            ? e.y
            : this.renderer.height - e.height - e.y),
            this.renderer.gl.scissor(e.x, t, e.width, e.height);
        }),
        e
      );
    })(ov),
    uv = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.glConst = Rp.ADAPTER.getWebGLRenderingContext().STENCIL_TEST), n
        );
      }
      return (
        D_(e, t),
        (e.prototype.getStackLength = function () {
          var t = this.maskStack[this.maskStack.length - 1];
          return t ? t._stencilCounter : 0;
        }),
        (e.prototype.push = function (t) {
          var e = t.maskObject,
            n = this.renderer.gl,
            i = t._stencilCounter;
          0 === i &&
            (this.renderer.framebuffer.forceStencil(),
            n.clearStencil(0),
            n.clear(n.STENCIL_BUFFER_BIT),
            n.enable(n.STENCIL_TEST)),
            t._stencilCounter++;
          var r = t._colorMask;
          0 !== r && ((t._colorMask = 0), n.colorMask(!1, !1, !1, !1)),
            n.stencilFunc(n.EQUAL, i, 4294967295),
            n.stencilOp(n.KEEP, n.KEEP, n.INCR),
            (e.renderable = !0),
            e.render(this.renderer),
            this.renderer.batch.flush(),
            (e.renderable = !1),
            0 !== r &&
              ((t._colorMask = r),
              n.colorMask(
                0 != (1 & r),
                0 != (2 & r),
                0 != (4 & r),
                0 != (8 & r)
              )),
            this._useCurrent();
        }),
        (e.prototype.pop = function (t) {
          var e = this.renderer.gl;
          if (0 === this.getStackLength()) e.disable(e.STENCIL_TEST);
          else {
            var n =
                0 !== this.maskStack.length
                  ? this.maskStack[this.maskStack.length - 1]
                  : null,
              i = n ? n._colorMask : 15;
            0 !== i && ((n._colorMask = 0), e.colorMask(!1, !1, !1, !1)),
              e.stencilOp(e.KEEP, e.KEEP, e.DECR),
              (t.renderable = !0),
              t.render(this.renderer),
              this.renderer.batch.flush(),
              (t.renderable = !1),
              0 !== i &&
                ((n._colorMask = i),
                e.colorMask(
                  0 != (1 & i),
                  0 != (2 & i),
                  0 != (4 & i),
                  0 != (8 & i)
                )),
              this._useCurrent();
          }
        }),
        (e.prototype._useCurrent = function () {
          var t = this.renderer.gl;
          t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
        }),
        e
      );
    })(ov),
    cv = (function () {
      function t(t) {
        (this.renderer = t),
          (this.destinationFrame = null),
          (this.sourceFrame = null),
          (this.defaultFrame = null),
          (this.projectionMatrix = new Um()),
          (this.transform = null);
      }
      return (
        (t.prototype.update = function (t, e, n, i) {
          (this.destinationFrame =
            t || this.destinationFrame || this.defaultFrame),
            (this.sourceFrame = e || this.sourceFrame || t),
            this.calculateProjection(
              this.destinationFrame,
              this.sourceFrame,
              n,
              i
            ),
            this.transform && this.projectionMatrix.append(this.transform);
          var r = this.renderer;
          (r.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
            r.globalUniforms.update(),
            r.shader.shader &&
              r.shader.syncUniformGroup(r.shader.shader.uniforms.globals);
        }),
        (t.prototype.calculateProjection = function (t, e, n, i) {
          var r = this.projectionMatrix,
            s = i ? -1 : 1;
          r.identity(),
            (r.a = (1 / e.width) * 2),
            (r.d = s * ((1 / e.height) * 2)),
            (r.tx = -1 - e.x * r.a),
            (r.ty = -s - e.y * r.d);
        }),
        (t.prototype.setTransform = function (t) {}),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    dv = new Pm(),
    pv = new Pm(),
    fv = (function () {
      function t(t) {
        (this.renderer = t),
          (this.clearColor = t._backgroundColorRgba),
          (this.defaultMaskStack = []),
          (this.current = null),
          (this.sourceFrame = new Pm()),
          (this.destinationFrame = new Pm()),
          (this.viewportFrame = new Pm());
      }
      return (
        (t.prototype.bind = function (t, e, n) {
          void 0 === t && (t = null);
          var i,
            r,
            s,
            o = this.renderer;
          (this.current = t),
            t
              ? ((s = (i = t.baseTexture).resolution),
                e ||
                  ((dv.width = t.frame.width),
                  (dv.height = t.frame.height),
                  (e = dv)),
                n ||
                  ((pv.x = t.frame.x),
                  (pv.y = t.frame.y),
                  (pv.width = e.width),
                  (pv.height = e.height),
                  (n = pv)),
                (r = i.framebuffer))
              : ((s = o.resolution),
                e ||
                  ((dv.width = o.screen.width),
                  (dv.height = o.screen.height),
                  (e = dv)),
                n || (((n = dv).width = e.width), (n.height = e.height)));
          var a = this.viewportFrame;
          (a.x = n.x * s),
            (a.y = n.y * s),
            (a.width = n.width * s),
            (a.height = n.height * s),
            t || (a.y = o.view.height - (a.y + a.height)),
            a.ceil(),
            this.renderer.framebuffer.bind(r, a),
            this.renderer.projection.update(n, e, s, !r),
            t
              ? this.renderer.mask.setMaskStack(i.maskStack)
              : this.renderer.mask.setMaskStack(this.defaultMaskStack),
            this.sourceFrame.copyFrom(e),
            this.destinationFrame.copyFrom(n);
        }),
        (t.prototype.clear = function (t, e) {
          t = this.current
            ? t || this.current.baseTexture.clearColor
            : t || this.clearColor;
          var n = this.destinationFrame,
            i = this.current ? this.current.baseTexture : this.renderer.screen,
            r = n.width !== i.width || n.height !== i.height;
          if (r) {
            var s = this.viewportFrame,
              o = s.x,
              a = s.y,
              l = s.width,
              h = s.height;
            (o = Math.round(o)),
              (a = Math.round(a)),
              (l = Math.round(l)),
              (h = Math.round(h)),
              this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
              this.renderer.gl.scissor(o, a, l, h);
          }
          this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e),
            r && this.renderer.scissor.pop();
        }),
        (t.prototype.resize = function () {
          this.bind(null);
        }),
        (t.prototype.reset = function () {
          this.bind(null);
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })();
  function mv(t, e, n, i, r) {
    n.buffer.update(r);
  }
  var _v = {
      float: "\n        data[offset] = v;\n    ",
      vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
      vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
      vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
      mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
      mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
      mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    ",
    },
    gv = {
      float: 4,
      vec2: 8,
      vec3: 12,
      vec4: 16,
      int: 4,
      ivec2: 8,
      ivec3: 12,
      ivec4: 16,
      uint: 4,
      uvec2: 8,
      uvec3: 12,
      uvec4: 16,
      bool: 4,
      bvec2: 8,
      bvec3: 12,
      bvec4: 16,
      mat2: 32,
      mat3: 48,
      mat4: 64,
    };
  function vv(t, e) {
    if (!t.autoManage) return { size: 0, syncFunc: mv };
    for (
      var n = (function (t, e) {
          var n = [];
          for (var i in t) e[i] && n.push(e[i]);
          return (
            n.sort(function (t, e) {
              return t.index - e.index;
            }),
            n
          );
        })(t.uniforms, e),
        i = (function (t) {
          for (
            var e = t.map(function (t) {
                return { data: t, offset: 0, dataLen: 0, dirty: 0 };
              }),
              n = 0,
              i = 0,
              r = 0,
              s = 0;
            s < e.length;
            s++
          ) {
            var o = e[s];
            if (
              ((n = gv[o.data.type]),
              o.data.size > 1 && (n = Math.max(n, 16) * o.data.size),
              (o.dataLen = n),
              i % n != 0 && i < 16)
            ) {
              var a = (i % n) % 16;
              (i += a), (r += a);
            }
            i + n > 16
              ? ((r = 16 * Math.ceil(r / 16)),
                (o.offset = r),
                (r += n),
                (i = n))
              : ((o.offset = r), (i += n), (r += n));
          }
          return { uboElements: e, size: (r = 16 * Math.ceil(r / 16)) };
        })(n),
        r = i.uboElements,
        s = i.size,
        o = [
          "\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    ",
        ],
        a = 0;
      a < r.length;
      a++
    ) {
      for (
        var l = r[a],
          h = t.uniforms[l.data.name],
          u = l.data.name,
          c = !1,
          d = 0;
        d < Xg.length;
        d++
      ) {
        var p = Xg[d];
        if (p.codeUbo && p.test(l.data, h)) {
          o.push(
            "offset = " + l.offset / 4 + ";",
            Xg[d].codeUbo(l.data.name, h)
          ),
            (c = !0);
          break;
        }
      }
      if (!c)
        if (l.data.size > 1) {
          var f = Gg(l.data.type),
            m = Math.max(gv[l.data.type] / 16, 1),
            _ = f / m,
            g = (4 - (_ % 4)) % 4;
          o.push(
            "\n                cv = ud." +
              u +
              ".value;\n                v = uv." +
              u +
              ";\n                offset = " +
              l.offset / 4 +
              ";\n\n                t = 0;\n\n                for(var i=0; i < " +
              l.data.size * m +
              "; i++)\n                {\n                    for(var j = 0; j < " +
              _ +
              "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " +
              g +
              ";\n                }\n\n                "
          );
        } else {
          var v = _v[l.data.type];
          o.push(
            "\n                cv = ud." +
              u +
              ".value;\n                v = uv." +
              u +
              ";\n                offset = " +
              l.offset / 4 +
              ";\n                " +
              v +
              ";\n                "
          );
        }
    }
    return (
      o.push("\n       renderer.buffer.update(buffer);\n    "),
      {
        size: s,
        syncFunc: new Function(
          "ud",
          "uv",
          "renderer",
          "syncData",
          "buffer",
          o.join("\n")
        ),
      }
    );
  }
  var yv = (function () {
    function t(t, e) {
      (this.program = t),
        (this.uniformData = e),
        (this.uniformGroups = {}),
        (this.uniformDirtyGroups = {}),
        (this.uniformBufferBindings = {});
    }
    return (
      (t.prototype.destroy = function () {
        (this.uniformData = null),
          (this.uniformGroups = null),
          (this.uniformDirtyGroups = null),
          (this.uniformBufferBindings = null),
          (this.program = null);
      }),
      t
    );
  })();
  function xv(t, e) {
    var n = Ig(t, t.VERTEX_SHADER, e.vertexSrc),
      i = Ig(t, t.FRAGMENT_SHADER, e.fragmentSrc),
      r = t.createProgram();
    if (
      (t.attachShader(r, n),
      t.attachShader(r, i),
      t.linkProgram(r),
      t.getProgramParameter(r, t.LINK_STATUS) ||
        (function (t, e, n, i) {
          t.getProgramParameter(e, t.LINK_STATUS) ||
            (t.getShaderParameter(n, t.COMPILE_STATUS) || Pg(t, n),
            t.getShaderParameter(i, t.COMPILE_STATUS) || Pg(t, i),
            console.error("PixiJS Error: Could not initialize shader."),
            "" !== t.getProgramInfoLog(e) &&
              console.warn(
                "PixiJS Warning: gl.getProgramInfoLog()",
                t.getProgramInfoLog(e)
              ));
        })(t, r, n, i),
      (e.attributeData = (function (t, e) {
        for (
          var n = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), r = 0;
          r < i;
          r++
        ) {
          var s = e.getActiveAttrib(t, r);
          if (0 !== s.name.indexOf("gl_")) {
            var o = Vg(e, s.type),
              a = {
                type: o,
                name: s.name,
                size: Gg(o),
                location: e.getAttribLocation(t, s.name),
              };
            n[s.name] = a;
          }
        }
        return n;
      })(r, t)),
      (e.uniformData = (function (t, e) {
        for (
          var n = {}, i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), r = 0;
          r < i;
          r++
        ) {
          var s = e.getActiveUniform(t, r),
            o = s.name.replace(/\[.*?\]$/, ""),
            a = !!s.name.match(/\[.*?\]$/),
            l = Vg(e, s.type);
          n[o] = {
            name: o,
            index: r,
            type: l,
            size: s.size,
            isArray: a,
            value: Ng(l, s.size),
          };
        }
        return n;
      })(r, t)),
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
    ) {
      var s = Object.keys(e.attributeData);
      s.sort(function (t, e) {
        return t > e ? 1 : -1;
      });
      for (var o = 0; o < s.length; o++)
        (e.attributeData[s[o]].location = o), t.bindAttribLocation(r, o, s[o]);
      t.linkProgram(r);
    }
    t.deleteShader(n), t.deleteShader(i);
    var a = {};
    for (var o in e.uniformData) {
      var l = e.uniformData[o];
      a[o] = {
        location: t.getUniformLocation(r, o),
        value: Ng(l.type, l.size),
      };
    }
    return new yv(r, a);
  }
  var bv = 0,
    Tv = { textureCount: 0, uboCount: 0 },
    Ev = (function () {
      function t(t) {
        (this.destroyed = !1),
          (this.renderer = t),
          this.systemCheck(),
          (this.gl = null),
          (this.shader = null),
          (this.program = null),
          (this.cache = {}),
          (this._uboCache = {}),
          (this.id = bv++);
      }
      return (
        (t.prototype.systemCheck = function () {
          if (
            !(function () {
              if ("boolean" == typeof Yg) return Yg;
              try {
                var t = new Function(
                  "param1",
                  "param2",
                  "param3",
                  "return param1[param2] === param3;"
                );
                Yg = !0 === t({ a: "b" }, "a", "b");
              } catch (e) {
                Yg = !1;
              }
              return Yg;
            })()
          )
            throw new Error(
              "Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support."
            );
        }),
        (t.prototype.contextChange = function (t) {
          (this.gl = t), this.reset();
        }),
        (t.prototype.bind = function (t, e) {
          t.uniforms.globals = this.renderer.globalUniforms;
          var n = t.program,
            i =
              n.glPrograms[this.renderer.CONTEXT_UID] ||
              this.generateProgram(t);
          return (
            (this.shader = t),
            this.program !== n &&
              ((this.program = n), this.gl.useProgram(i.program)),
            e ||
              ((Tv.textureCount = 0),
              (Tv.uboCount = 0),
              this.syncUniformGroup(t.uniformGroup, Tv)),
            i
          );
        }),
        (t.prototype.setUniforms = function (t) {
          var e = this.shader.program,
            n = e.glPrograms[this.renderer.CONTEXT_UID];
          e.syncUniforms(n.uniformData, t, this.renderer);
        }),
        (t.prototype.syncUniformGroup = function (t, e) {
          var n = this.getGlProgram();
          (t.static && t.dirtyId === n.uniformDirtyGroups[t.id]) ||
            ((n.uniformDirtyGroups[t.id] = t.dirtyId),
            this.syncUniforms(t, n, e));
        }),
        (t.prototype.syncUniforms = function (t, e, n) {
          (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
            e.uniformData,
            t.uniforms,
            this.renderer,
            n
          );
        }),
        (t.prototype.createSyncGroups = function (t) {
          var e = this.getSignature(t, this.shader.program.uniformData, "u");
          return (
            this.cache[e] ||
              (this.cache[e] = (function (t, e) {
                var n,
                  i = [
                    "\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ",
                  ];
                for (var r in t.uniforms) {
                  var s = e[r];
                  if (s) {
                    for (
                      var o = t.uniforms[r], a = !1, l = 0;
                      l < Xg.length;
                      l++
                    )
                      if (Xg[l].test(s, o)) {
                        i.push(Xg[l].code(r, o)), (a = !0);
                        break;
                      }
                    if (!a) {
                      var h = (1 === s.size ? Wg : jg)[s.type].replace(
                        "location",
                        'ud["' + r + '"].location'
                      );
                      i.push(
                        '\n            cu = ud["' +
                          r +
                          '"];\n            cv = cu.value;\n            v = uv["' +
                          r +
                          '"];\n            ' +
                          h +
                          ";"
                      );
                    }
                  } else
                    (null === (n = t.uniforms[r]) || void 0 === n
                      ? void 0
                      : n.group) &&
                      (t.uniforms[r].ubo
                        ? i.push(
                            "\n                        renderer.shader.syncUniformBufferGroup(uv." +
                              r +
                              ", '" +
                              r +
                              "');\n                    "
                          )
                        : i.push(
                            "\n                        renderer.shader.syncUniformGroup(uv." +
                              r +
                              ", syncData);\n                    "
                          ));
                }
                return new Function(
                  "ud",
                  "uv",
                  "renderer",
                  "syncData",
                  i.join("\n")
                );
              })(t, this.shader.program.uniformData)),
            (t.syncUniforms[this.shader.program.id] = this.cache[e]),
            t.syncUniforms[this.shader.program.id]
          );
        }),
        (t.prototype.syncUniformBufferGroup = function (t, e) {
          var n = this.getGlProgram();
          if (!t.static || 0 !== t.dirtyId || !n.uniformGroups[t.id]) {
            t.dirtyId = 0;
            var i =
              n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, e);
            t.buffer.update(),
              i(n.uniformData, t.uniforms, this.renderer, Tv, t.buffer);
          }
          this.renderer.buffer.bindBufferBase(
            t.buffer,
            n.uniformBufferBindings[e]
          );
        }),
        (t.prototype.createSyncBufferGroup = function (t, e, n) {
          var i = this.renderer.gl;
          this.renderer.buffer.bind(t.buffer);
          var r = this.gl.getUniformBlockIndex(e.program, n);
          (e.uniformBufferBindings[n] = this.shader.uniformBindCount),
            i.uniformBlockBinding(e.program, r, this.shader.uniformBindCount),
            this.shader.uniformBindCount++;
          var s = this.getSignature(t, this.shader.program.uniformData, "ubo"),
            o = this._uboCache[s];
          if (
            (o ||
              (o = this._uboCache[s] = vv(t, this.shader.program.uniformData)),
            t.autoManage)
          ) {
            var a = new Float32Array(o.size / 4);
            t.buffer.update(a);
          }
          return (e.uniformGroups[t.id] = o.syncFunc), e.uniformGroups[t.id];
        }),
        (t.prototype.getSignature = function (t, e, n) {
          var i = t.uniforms,
            r = [n + "-"];
          for (var s in i) r.push(s), e[s] && r.push(e[s].type);
          return r.join("-");
        }),
        (t.prototype.getGlProgram = function () {
          return this.shader
            ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
            : null;
        }),
        (t.prototype.generateProgram = function (t) {
          var e = this.gl,
            n = t.program,
            i = xv(e, n);
          return (n.glPrograms[this.renderer.CONTEXT_UID] = i), i;
        }),
        (t.prototype.reset = function () {
          (this.program = null), (this.shader = null);
        }),
        (t.prototype.destroy = function () {
          (this.renderer = null), (this.destroyed = !0);
        }),
        t
      );
    })();
  var Sv = (function () {
      function t() {
        (this.gl = null),
          (this.stateId = 0),
          (this.polygonOffset = 0),
          (this.blendMode = xf.NONE),
          (this._blendEq = !1),
          (this.map = []),
          (this.map[0] = this.setBlend),
          (this.map[1] = this.setOffset),
          (this.map[2] = this.setCullFace),
          (this.map[3] = this.setDepthTest),
          (this.map[4] = this.setFrontFace),
          (this.map[5] = this.setDepthMask),
          (this.checks = []),
          (this.defaultState = new tv()),
          (this.defaultState.blend = !0);
      }
      return (
        (t.prototype.contextChange = function (t) {
          (this.gl = t),
            (this.blendModes = (function (t, e) {
              return (
                void 0 === e && (e = []),
                (e[xf.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.ADD] = [t.ONE, t.ONE]),
                (e[xf.MULTIPLY] = [
                  t.DST_COLOR,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                ]),
                (e[xf.SCREEN] = [
                  t.ONE,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                ]),
                (e[xf.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.NONE] = [0, 0]),
                (e[xf.NORMAL_NPM] = [
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                ]),
                (e[xf.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
                (e[xf.SCREEN_NPM] = [
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                ]),
                (e[xf.SRC_IN] = [t.DST_ALPHA, t.ZERO]),
                (e[xf.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO]),
                (e[xf.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE]),
                (e[xf.DST_IN] = [t.ZERO, t.SRC_ALPHA]),
                (e[xf.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]),
                (e[xf.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
                (e[xf.SUBTRACT] = [
                  t.ONE,
                  t.ONE,
                  t.ONE,
                  t.ONE,
                  t.FUNC_REVERSE_SUBTRACT,
                  t.FUNC_ADD,
                ]),
                e
              );
            })(t)),
            this.set(this.defaultState),
            this.reset();
        }),
        (t.prototype.set = function (t) {
          if (((t = t || this.defaultState), this.stateId !== t.data)) {
            for (var e = this.stateId ^ t.data, n = 0; e; )
              1 & e && this.map[n].call(this, !!(t.data & (1 << n))),
                (e >>= 1),
                n++;
            this.stateId = t.data;
          }
          for (n = 0; n < this.checks.length; n++) this.checks[n](this, t);
        }),
        (t.prototype.forceState = function (t) {
          t = t || this.defaultState;
          for (var e = 0; e < this.map.length; e++)
            this.map[e].call(this, !!(t.data & (1 << e)));
          for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
          this.stateId = t.data;
        }),
        (t.prototype.setBlend = function (e) {
          this.updateCheck(t.checkBlendMode, e),
            this.gl[e ? "enable" : "disable"](this.gl.BLEND);
        }),
        (t.prototype.setOffset = function (e) {
          this.updateCheck(t.checkPolygonOffset, e),
            this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }),
        (t.prototype.setDepthTest = function (t) {
          this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }),
        (t.prototype.setDepthMask = function (t) {
          this.gl.depthMask(t);
        }),
        (t.prototype.setCullFace = function (t) {
          this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
        }),
        (t.prototype.setFrontFace = function (t) {
          this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
        }),
        (t.prototype.setBlendMode = function (t) {
          if (t !== this.blendMode) {
            this.blendMode = t;
            var e = this.blendModes[t],
              n = this.gl;
            2 === e.length
              ? n.blendFunc(e[0], e[1])
              : n.blendFuncSeparate(e[0], e[1], e[2], e[3]),
              6 === e.length
                ? ((this._blendEq = !0), n.blendEquationSeparate(e[4], e[5]))
                : this._blendEq &&
                  ((this._blendEq = !1),
                  n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD));
          }
        }),
        (t.prototype.setPolygonOffset = function (t, e) {
          this.gl.polygonOffset(t, e);
        }),
        (t.prototype.reset = function () {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
            this.forceState(this.defaultState),
            (this._blendEq = !0),
            (this.blendMode = -1),
            this.setBlendMode(0);
        }),
        (t.prototype.updateCheck = function (t, e) {
          var n = this.checks.indexOf(t);
          e && -1 === n
            ? this.checks.push(t)
            : e || -1 === n || this.checks.splice(n, 1);
        }),
        (t.checkBlendMode = function (t, e) {
          t.setBlendMode(e.blendMode);
        }),
        (t.checkPolygonOffset = function (t, e) {
          t.setPolygonOffset(1, e.polygonOffset);
        }),
        (t.prototype.destroy = function () {
          this.gl = null;
        }),
        t
      );
    })(),
    wv = (function () {
      function t(t) {
        (this.renderer = t),
          (this.count = 0),
          (this.checkCount = 0),
          (this.maxIdle = Rp.GC_MAX_IDLE),
          (this.checkCountMax = Rp.GC_MAX_CHECK_COUNT),
          (this.mode = Rp.GC_MODE);
      }
      return (
        (t.prototype.postrender = function () {
          this.renderer.renderingToScreen &&
            (this.count++,
            this.mode !== Pf.MANUAL &&
              (this.checkCount++,
              this.checkCount > this.checkCountMax &&
                ((this.checkCount = 0), this.run())));
        }),
        (t.prototype.run = function () {
          for (
            var t = this.renderer.texture, e = t.managedTextures, n = !1, i = 0;
            i < e.length;
            i++
          ) {
            var r = e[i];
            !r.framebuffer &&
              this.count - r.touched > this.maxIdle &&
              (t.destroyTexture(r, !0), (e[i] = null), (n = !0));
          }
          if (n) {
            var s = 0;
            for (i = 0; i < e.length; i++) null !== e[i] && (e[s++] = e[i]);
            e.length = s;
          }
        }),
        (t.prototype.unload = function (t) {
          var e = this.renderer.texture,
            n = t._texture;
          n && !n.framebuffer && e.destroyTexture(n);
          for (var i = t.children.length - 1; i >= 0; i--)
            this.unload(t.children[i]);
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })();
  var Mv = function (t) {
      (this.texture = t),
        (this.width = -1),
        (this.height = -1),
        (this.dirtyId = -1),
        (this.dirtyStyleId = -1),
        (this.mipmap = !1),
        (this.wrapMode = 33071),
        (this.type = Sf.UNSIGNED_BYTE),
        (this.internalFormat = Tf.RGBA),
        (this.samplerType = 0);
    },
    Av = (function () {
      function t(t) {
        (this.renderer = t),
          (this.boundTextures = []),
          (this.currentLocation = -1),
          (this.managedTextures = []),
          (this._unknownBoundTextures = !1),
          (this.unknownTexture = new k_()),
          (this.hasIntegerTextures = !1);
      }
      return (
        (t.prototype.contextChange = function () {
          var t = (this.gl = this.renderer.gl);
          (this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            (this.webGLVersion = this.renderer.context.webGLVersion),
            (this.internalFormats = (function (t) {
              var e,
                n,
                i,
                r,
                s,
                o,
                a,
                l,
                h,
                u,
                c,
                d,
                p,
                f,
                m,
                _,
                g,
                v,
                y,
                x,
                b,
                T,
                E;
              return (
                "WebGL2RenderingContext" in globalThis &&
                t instanceof globalThis.WebGL2RenderingContext
                  ? (((e = {})[Sf.UNSIGNED_BYTE] =
                      (((n = {})[Tf.RGBA] = t.RGBA8),
                      (n[Tf.RGB] = t.RGB8),
                      (n[Tf.RG] = t.RG8),
                      (n[Tf.RED] = t.R8),
                      (n[Tf.RGBA_INTEGER] = t.RGBA8UI),
                      (n[Tf.RGB_INTEGER] = t.RGB8UI),
                      (n[Tf.RG_INTEGER] = t.RG8UI),
                      (n[Tf.RED_INTEGER] = t.R8UI),
                      (n[Tf.ALPHA] = t.ALPHA),
                      (n[Tf.LUMINANCE] = t.LUMINANCE),
                      (n[Tf.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
                      n)),
                    (e[Sf.BYTE] =
                      (((i = {})[Tf.RGBA] = t.RGBA8_SNORM),
                      (i[Tf.RGB] = t.RGB8_SNORM),
                      (i[Tf.RG] = t.RG8_SNORM),
                      (i[Tf.RED] = t.R8_SNORM),
                      (i[Tf.RGBA_INTEGER] = t.RGBA8I),
                      (i[Tf.RGB_INTEGER] = t.RGB8I),
                      (i[Tf.RG_INTEGER] = t.RG8I),
                      (i[Tf.RED_INTEGER] = t.R8I),
                      i)),
                    (e[Sf.UNSIGNED_SHORT] =
                      (((r = {})[Tf.RGBA_INTEGER] = t.RGBA16UI),
                      (r[Tf.RGB_INTEGER] = t.RGB16UI),
                      (r[Tf.RG_INTEGER] = t.RG16UI),
                      (r[Tf.RED_INTEGER] = t.R16UI),
                      (r[Tf.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16),
                      r)),
                    (e[Sf.SHORT] =
                      (((s = {})[Tf.RGBA_INTEGER] = t.RGBA16I),
                      (s[Tf.RGB_INTEGER] = t.RGB16I),
                      (s[Tf.RG_INTEGER] = t.RG16I),
                      (s[Tf.RED_INTEGER] = t.R16I),
                      s)),
                    (e[Sf.UNSIGNED_INT] =
                      (((o = {})[Tf.RGBA_INTEGER] = t.RGBA32UI),
                      (o[Tf.RGB_INTEGER] = t.RGB32UI),
                      (o[Tf.RG_INTEGER] = t.RG32UI),
                      (o[Tf.RED_INTEGER] = t.R32UI),
                      (o[Tf.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24),
                      o)),
                    (e[Sf.INT] =
                      (((a = {})[Tf.RGBA_INTEGER] = t.RGBA32I),
                      (a[Tf.RGB_INTEGER] = t.RGB32I),
                      (a[Tf.RG_INTEGER] = t.RG32I),
                      (a[Tf.RED_INTEGER] = t.R32I),
                      a)),
                    (e[Sf.FLOAT] =
                      (((l = {})[Tf.RGBA] = t.RGBA32F),
                      (l[Tf.RGB] = t.RGB32F),
                      (l[Tf.RG] = t.RG32F),
                      (l[Tf.RED] = t.R32F),
                      (l[Tf.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F),
                      l)),
                    (e[Sf.HALF_FLOAT] =
                      (((h = {})[Tf.RGBA] = t.RGBA16F),
                      (h[Tf.RGB] = t.RGB16F),
                      (h[Tf.RG] = t.RG16F),
                      (h[Tf.RED] = t.R16F),
                      h)),
                    (e[Sf.UNSIGNED_SHORT_5_6_5] =
                      (((u = {})[Tf.RGB] = t.RGB565), u)),
                    (e[Sf.UNSIGNED_SHORT_4_4_4_4] =
                      (((c = {})[Tf.RGBA] = t.RGBA4), c)),
                    (e[Sf.UNSIGNED_SHORT_5_5_5_1] =
                      (((d = {})[Tf.RGBA] = t.RGB5_A1), d)),
                    (e[Sf.UNSIGNED_INT_2_10_10_10_REV] =
                      (((p = {})[Tf.RGBA] = t.RGB10_A2),
                      (p[Tf.RGBA_INTEGER] = t.RGB10_A2UI),
                      p)),
                    (e[Sf.UNSIGNED_INT_10F_11F_11F_REV] =
                      (((f = {})[Tf.RGB] = t.R11F_G11F_B10F), f)),
                    (e[Sf.UNSIGNED_INT_5_9_9_9_REV] =
                      (((m = {})[Tf.RGB] = t.RGB9_E5), m)),
                    (e[Sf.UNSIGNED_INT_24_8] =
                      (((_ = {})[Tf.DEPTH_STENCIL] = t.DEPTH24_STENCIL8), _)),
                    (e[Sf.FLOAT_32_UNSIGNED_INT_24_8_REV] =
                      (((g = {})[Tf.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8), g)),
                    (E = e))
                  : (((v = {})[Sf.UNSIGNED_BYTE] =
                      (((y = {})[Tf.RGBA] = t.RGBA),
                      (y[Tf.RGB] = t.RGB),
                      (y[Tf.ALPHA] = t.ALPHA),
                      (y[Tf.LUMINANCE] = t.LUMINANCE),
                      (y[Tf.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
                      y)),
                    (v[Sf.UNSIGNED_SHORT_5_6_5] =
                      (((x = {})[Tf.RGB] = t.RGB), x)),
                    (v[Sf.UNSIGNED_SHORT_4_4_4_4] =
                      (((b = {})[Tf.RGBA] = t.RGBA), b)),
                    (v[Sf.UNSIGNED_SHORT_5_5_5_1] =
                      (((T = {})[Tf.RGBA] = t.RGBA), T)),
                    (E = v)),
                E
              );
            })(t));
          var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
          this.boundTextures.length = e;
          for (var n = 0; n < e; n++) this.boundTextures[n] = null;
          this.emptyTextures = {};
          var i = new Mv(t.createTexture());
          t.bindTexture(t.TEXTURE_2D, i.texture),
            t.texImage2D(
              t.TEXTURE_2D,
              0,
              t.RGBA,
              1,
              1,
              0,
              t.RGBA,
              t.UNSIGNED_BYTE,
              new Uint8Array(4)
            ),
            (this.emptyTextures[t.TEXTURE_2D] = i),
            (this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Mv(
              t.createTexture()
            )),
            t.bindTexture(
              t.TEXTURE_CUBE_MAP,
              this.emptyTextures[t.TEXTURE_CUBE_MAP].texture
            );
          for (n = 0; n < 6; n++)
            t.texImage2D(
              t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
              0,
              t.RGBA,
              1,
              1,
              0,
              t.RGBA,
              t.UNSIGNED_BYTE,
              null
            );
          t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
            t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
          for (n = 0; n < this.boundTextures.length; n++) this.bind(null, n);
        }),
        (t.prototype.bind = function (t, e) {
          void 0 === e && (e = 0);
          var n = this.gl;
          if (
            (t = null == t ? void 0 : t.castToBaseTexture()) &&
            t.valid &&
            !t.parentTextureArray
          ) {
            t.touched = this.renderer.textureGC.count;
            var i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[e] !== t &&
              (this.currentLocation !== e &&
                ((this.currentLocation = e), n.activeTexture(n.TEXTURE0 + e)),
              n.bindTexture(t.target, i.texture)),
              i.dirtyId !== t.dirtyId &&
                (this.currentLocation !== e &&
                  ((this.currentLocation = e), n.activeTexture(n.TEXTURE0 + e)),
                this.updateTexture(t)),
              (this.boundTextures[e] = t);
          } else
            this.currentLocation !== e &&
              ((this.currentLocation = e), n.activeTexture(n.TEXTURE0 + e)),
              n.bindTexture(
                n.TEXTURE_2D,
                this.emptyTextures[n.TEXTURE_2D].texture
              ),
              (this.boundTextures[e] = null);
        }),
        (t.prototype.reset = function () {
          (this._unknownBoundTextures = !0),
            (this.hasIntegerTextures = !1),
            (this.currentLocation = -1);
          for (var t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture;
        }),
        (t.prototype.unbind = function (t) {
          var e = this.gl,
            n = this.boundTextures;
          if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (var i = 0; i < n.length; i++)
              n[i] === this.unknownTexture && this.bind(null, i);
          }
          for (i = 0; i < n.length; i++)
            n[i] === t &&
              (this.currentLocation !== i &&
                (e.activeTexture(e.TEXTURE0 + i), (this.currentLocation = i)),
              e.bindTexture(t.target, this.emptyTextures[t.target].texture),
              (n[i] = null));
        }),
        (t.prototype.ensureSamplerType = function (t) {
          var e = this,
            n = e.boundTextures,
            i = e.hasIntegerTextures,
            r = e.CONTEXT_UID;
          if (i)
            for (var s = t - 1; s >= 0; --s) {
              var o = n[s];
              if (o)
                o._glTextures[r].samplerType !== wf.FLOAT &&
                  this.renderer.texture.unbind(o);
            }
        }),
        (t.prototype.initTexture = function (t) {
          var e = new Mv(this.gl.createTexture());
          return (
            (e.dirtyId = -1),
            (t._glTextures[this.CONTEXT_UID] = e),
            this.managedTextures.push(t),
            t.on("dispose", this.destroyTexture, this),
            e
          );
        }),
        (t.prototype.initTextureType = function (t, e) {
          var n, i;
          (e.internalFormat =
            null !==
              (i =
                null === (n = this.internalFormats[t.type]) || void 0 === n
                  ? void 0
                  : n[t.format]) && void 0 !== i
              ? i
              : t.format),
            2 === this.webGLVersion && t.type === Sf.HALF_FLOAT
              ? (e.type = this.gl.HALF_FLOAT)
              : (e.type = t.type);
        }),
        (t.prototype.updateTexture = function (t) {
          var e = t._glTextures[this.CONTEXT_UID];
          if (e) {
            var n = this.renderer;
            if (
              (this.initTextureType(t, e),
              t.resource && t.resource.upload(n, t, e))
            )
              e.samplerType !== wf.FLOAT && (this.hasIntegerTextures = !0);
            else {
              var i = t.realWidth,
                r = t.realHeight,
                s = n.gl;
              (e.width !== i || e.height !== r || e.dirtyId < 0) &&
                ((e.width = i),
                (e.height = r),
                s.texImage2D(
                  t.target,
                  0,
                  e.internalFormat,
                  i,
                  r,
                  0,
                  t.format,
                  e.type,
                  null
                ));
            }
            t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
              (e.dirtyId = t.dirtyId);
          }
        }),
        (t.prototype.destroyTexture = function (t, e) {
          var n = this.gl;
          if (
            (t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] &&
            (this.unbind(t),
            n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
            t.off("dispose", this.destroyTexture, this),
            delete t._glTextures[this.CONTEXT_UID],
            !e)
          ) {
            var i = this.managedTextures.indexOf(t);
            -1 !== i && dm(this.managedTextures, i, 1);
          }
        }),
        (t.prototype.updateTextureStyle = function (t) {
          var e = t._glTextures[this.CONTEXT_UID];
          e &&
            ((t.mipmap !== Rf.POW2 && 2 === this.webGLVersion) || t.isPowerOfTwo
              ? (e.mipmap = t.mipmap >= 1)
              : (e.mipmap = !1),
            2 === this.webGLVersion || t.isPowerOfTwo
              ? (e.wrapMode = t.wrapMode)
              : (e.wrapMode = Af.CLAMP),
            (t.resource && t.resource.style(this.renderer, t, e)) ||
              this.setStyle(t, e),
            (e.dirtyStyleId = t.dirtyStyleId));
        }),
        (t.prototype.setStyle = function (t, e) {
          var n = this.gl;
          if (
            (e.mipmap &&
              t.mipmap !== Rf.ON_MANUAL &&
              n.generateMipmap(t.target),
            n.texParameteri(t.target, n.TEXTURE_WRAP_S, e.wrapMode),
            n.texParameteri(t.target, n.TEXTURE_WRAP_T, e.wrapMode),
            e.mipmap)
          ) {
            n.texParameteri(
              t.target,
              n.TEXTURE_MIN_FILTER,
              t.scaleMode === Mf.LINEAR
                ? n.LINEAR_MIPMAP_LINEAR
                : n.NEAREST_MIPMAP_NEAREST
            );
            var i = this.renderer.context.extensions.anisotropicFiltering;
            if (i && t.anisotropicLevel > 0 && t.scaleMode === Mf.LINEAR) {
              var r = Math.min(
                t.anisotropicLevel,
                n.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
              );
              n.texParameterf(t.target, i.TEXTURE_MAX_ANISOTROPY_EXT, r);
            }
          } else
            n.texParameteri(
              t.target,
              n.TEXTURE_MIN_FILTER,
              t.scaleMode === Mf.LINEAR ? n.LINEAR : n.NEAREST
            );
          n.texParameteri(
            t.target,
            n.TEXTURE_MAG_FILTER,
            t.scaleMode === Mf.LINEAR ? n.LINEAR : n.NEAREST
          );
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        t
      );
    })(),
    Rv = new Um(),
    Cv = (function (t) {
      function e(e, n) {
        void 0 === e && (e = vf.UNKNOWN);
        var i = t.call(this) || this;
        return (
          (n = Object.assign({}, Rp.RENDER_OPTIONS, n)),
          (i.options = n),
          (i.type = e),
          (i.screen = new Pm(0, 0, n.width, n.height)),
          (i.view = n.view || Rp.ADAPTER.createCanvas()),
          (i.resolution = n.resolution || Rp.RESOLUTION),
          (i.useContextAlpha = n.useContextAlpha),
          (i.autoDensity = !!n.autoDensity),
          (i.preserveDrawingBuffer = n.preserveDrawingBuffer),
          (i.clearBeforeRender = n.clearBeforeRender),
          (i._backgroundColor = 0),
          (i._backgroundColorRgba = [0, 0, 0, 1]),
          (i._backgroundColorString = "#000000"),
          (i.backgroundColor = n.backgroundColor || i._backgroundColor),
          (i.backgroundAlpha = n.backgroundAlpha),
          void 0 !== n.transparent &&
            (gm(
              "6.0.0",
              "Option transparent is deprecated, please use backgroundAlpha instead."
            ),
            (i.useContextAlpha = n.transparent),
            (i.backgroundAlpha = n.transparent ? 0 : 1)),
          (i._lastObjectRendered = null),
          (i.plugins = {}),
          i
        );
      }
      return (
        D_(e, t),
        (e.prototype.initPlugins = function (t) {
          for (var e in t) this.plugins[e] = new t[e](this);
        }),
        Object.defineProperty(e.prototype, "width", {
          get: function () {
            return this.view.width;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "height", {
          get: function () {
            return this.view.height;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.resize = function (t, e) {
          (this.view.width = Math.round(t * this.resolution)),
            (this.view.height = Math.round(e * this.resolution));
          var n = this.view.width / this.resolution,
            i = this.view.height / this.resolution;
          (this.screen.width = n),
            (this.screen.height = i),
            this.autoDensity &&
              ((this.view.style.width = n + "px"),
              (this.view.style.height = i + "px")),
            this.emit("resize", n, i);
        }),
        (e.prototype.generateTexture = function (t, e, n, i) {
          void 0 === e && (e = {}),
            "number" == typeof e &&
              (gm(
                "6.1.0",
                "generateTexture options (scaleMode, resolution, region) are now object options."
              ),
              (e = { scaleMode: e, resolution: n, region: i }));
          var r = e.region,
            s = (function (t, e) {
              var n = {};
              for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) &&
                  e.indexOf(i) < 0 &&
                  (n[i] = t[i]);
              if (
                null != t &&
                "function" == typeof Object.getOwnPropertySymbols
              ) {
                var r = 0;
                for (i = Object.getOwnPropertySymbols(t); r < i.length; r++)
                  e.indexOf(i[r]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(t, i[r]) &&
                    (n[i[r]] = t[i[r]]);
              }
              return n;
            })(e, ["region"]);
          0 === (i = r || t.getLocalBounds(null, !0)).width && (i.width = 1),
            0 === i.height && (i.height = 1);
          var o = ng.create(L_({ width: i.width, height: i.height }, s));
          return (
            (Rv.tx = -i.x),
            (Rv.ty = -i.y),
            this.render(t, {
              renderTexture: o,
              clear: !1,
              transform: Rv,
              skipUpdateTransform: !!t.parent,
            }),
            o
          );
        }),
        (e.prototype.destroy = function (t) {
          for (var e in this.plugins)
            this.plugins[e].destroy(), (this.plugins[e] = null);
          t &&
            this.view.parentNode &&
            this.view.parentNode.removeChild(this.view);
          var n = this;
          (n.plugins = null),
            (n.type = vf.UNKNOWN),
            (n.view = null),
            (n.screen = null),
            (n._tempDisplayObjectParent = null),
            (n.options = null),
            (this._backgroundColorRgba = null),
            (this._backgroundColorString = null),
            (this._lastObjectRendered = null);
        }),
        Object.defineProperty(e.prototype, "backgroundColor", {
          get: function () {
            return this._backgroundColor;
          },
          set: function (t) {
            (this._backgroundColor = t),
              (this._backgroundColorString = nm(t)),
              em(t, this._backgroundColorRgba);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "backgroundAlpha", {
          get: function () {
            return this._backgroundColorRgba[3];
          },
          set: function (t) {
            this._backgroundColorRgba[3] = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(Ip),
    Iv = function (t) {
      (this.buffer = t || null),
        (this.updateID = -1),
        (this.byteLength = -1),
        (this.refCount = 0);
    },
    Pv = (function () {
      function t(t) {
        (this.renderer = t),
          (this.managedBuffers = {}),
          (this.boundBufferBases = {});
      }
      return (
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        (t.prototype.contextChange = function () {
          this.disposeAll(!0),
            (this.gl = this.renderer.gl),
            (this.CONTEXT_UID = this.renderer.CONTEXT_UID);
        }),
        (t.prototype.bind = function (t) {
          var e = this.gl,
            n = this.CONTEXT_UID,
            i = t._glBuffers[n] || this.createGLBuffer(t);
          e.bindBuffer(t.type, i.buffer);
        }),
        (t.prototype.bindBufferBase = function (t, e) {
          var n = this.gl,
            i = this.CONTEXT_UID;
          if (this.boundBufferBases[e] !== t) {
            var r = t._glBuffers[i] || this.createGLBuffer(t);
            (this.boundBufferBases[e] = t),
              n.bindBufferBase(n.UNIFORM_BUFFER, e, r.buffer);
          }
        }),
        (t.prototype.bindBufferRange = function (t, e, n) {
          var i = this.gl,
            r = this.CONTEXT_UID;
          n = n || 0;
          var s = t._glBuffers[r] || this.createGLBuffer(t);
          i.bindBufferRange(i.UNIFORM_BUFFER, e || 0, s.buffer, 256 * n, 256);
        }),
        (t.prototype.update = function (t) {
          var e = this.gl,
            n = this.CONTEXT_UID,
            i = t._glBuffers[n];
          if (t._updateID !== i.updateID)
            if (
              ((i.updateID = t._updateID),
              e.bindBuffer(t.type, i.buffer),
              i.byteLength >= t.data.byteLength)
            )
              e.bufferSubData(t.type, 0, t.data);
            else {
              var r = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
              (i.byteLength = t.data.byteLength),
                e.bufferData(t.type, t.data, r);
            }
        }),
        (t.prototype.dispose = function (t, e) {
          if (this.managedBuffers[t.id]) {
            delete this.managedBuffers[t.id];
            var n = t._glBuffers[this.CONTEXT_UID],
              i = this.gl;
            t.disposeRunner.remove(this),
              n &&
                (e || i.deleteBuffer(n.buffer),
                delete t._glBuffers[this.CONTEXT_UID]);
          }
        }),
        (t.prototype.disposeAll = function (t) {
          for (
            var e = Object.keys(this.managedBuffers), n = 0;
            n < e.length;
            n++
          )
            this.dispose(this.managedBuffers[e[n]], t);
        }),
        (t.prototype.createGLBuffer = function (t) {
          var e = this.CONTEXT_UID,
            n = this.gl;
          return (
            (t._glBuffers[e] = new Iv(n.createBuffer())),
            (this.managedBuffers[t.id] = t),
            t.disposeRunner.add(this),
            t._glBuffers[e]
          );
        }),
        t
      );
    })(),
    Ov = (function (t) {
      function e(n) {
        var i = t.call(this, vf.WEBGL, n) || this;
        return (
          (n = i.options),
          (i.gl = null),
          (i.CONTEXT_UID = 0),
          (i.runners = {
            destroy: new A_("destroy"),
            contextChange: new A_("contextChange"),
            reset: new A_("reset"),
            update: new A_("update"),
            postrender: new A_("postrender"),
            prerender: new A_("prerender"),
            resize: new A_("resize"),
          }),
          i.runners.contextChange.add(i),
          (i.globalUniforms = new mg({ projectionMatrix: new Um() }, !0)),
          i
            .addSystem(sv, "mask")
            .addSystem(Eg, "context")
            .addSystem(Sv, "state")
            .addSystem(Ev, "shader")
            .addSystem(Av, "texture")
            .addSystem(Pv, "buffer")
            .addSystem(Rg, "geometry")
            .addSystem(Mg, "framebuffer")
            .addSystem(hv, "scissor")
            .addSystem(uv, "stencil")
            .addSystem(cv, "projection")
            .addSystem(wv, "textureGC")
            .addSystem(yg, "filter")
            .addSystem(fv, "renderTexture")
            .addSystem(bg, "batch"),
          i.initPlugins(e.__plugins),
          (i.multisample = void 0),
          n.context
            ? i.context.initFromContext(n.context)
            : i.context.initFromOptions({
                alpha: !!i.useContextAlpha,
                antialias: n.antialias,
                premultipliedAlpha:
                  i.useContextAlpha && "notMultiplied" !== i.useContextAlpha,
                stencil: !0,
                preserveDrawingBuffer: n.preserveDrawingBuffer,
                powerPreference: i.options.powerPreference,
              }),
          (i.renderingToScreen = !0),
          (function (t) {
            var e;
            if (!Qf) {
              if (
                Rp.ADAPTER.getNavigator()
                  .userAgent.toLowerCase()
                  .indexOf("chrome") > -1
              ) {
                var n = [
                  "\n %c %c %c PixiJS 6.5.1 -  " +
                    t +
                    "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n",
                  "background: #ff66a5; padding:5px 0;",
                  "background: #ff66a5; padding:5px 0;",
                  "color: #ff66a5; background: #030307; padding:5px 0;",
                  "background: #ff66a5; padding:5px 0;",
                  "background: #ffc3dc; padding:5px 0;",
                  "background: #ff66a5; padding:5px 0;",
                  "color: #ff2424; background: #fff; padding:5px 0;",
                  "color: #ff2424; background: #fff; padding:5px 0;",
                  "color: #ff2424; background: #fff; padding:5px 0;",
                ];
                (e = globalThis.console).log.apply(e, n);
              } else
                globalThis.console &&
                  globalThis.console.log(
                    "PixiJS 6.5.1 - " + t + " - http://www.pixijs.com/"
                  );
              Qf = !0;
            }
          })(2 === i.context.webGLVersion ? "WebGL 2" : "WebGL 1"),
          i.resize(i.options.width, i.options.height),
          i
        );
      }
      return (
        D_(e, t),
        (e.create = function (t) {
          if (
            (void 0 === $f &&
              ($f = (function () {
                var t = {
                  stencil: !0,
                  failIfMajorPerformanceCaveat:
                    Rp.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
                };
                try {
                  if (!Rp.ADAPTER.getWebGLRenderingContext()) return !1;
                  var e = Rp.ADAPTER.createCanvas(),
                    n =
                      e.getContext("webgl", t) ||
                      e.getContext("experimental-webgl", t),
                    i = !(!n || !n.getContextAttributes().stencil);
                  if (n) {
                    var r = n.getExtension("WEBGL_lose_context");
                    r && r.loseContext();
                  }
                  return (n = null), i;
                } catch (s) {
                  return !1;
                }
              })()),
            $f)
          )
            return new e(t);
          throw new Error(
            'WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.'
          );
        }),
        (e.prototype.contextChange = function () {
          var t,
            e = this.gl;
          if (1 === this.context.webGLVersion) {
            var n = e.getParameter(e.FRAMEBUFFER_BINDING);
            e.bindFramebuffer(e.FRAMEBUFFER, null),
              (t = e.getParameter(e.SAMPLES)),
              e.bindFramebuffer(e.FRAMEBUFFER, n);
          } else {
            n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
              (t = e.getParameter(e.SAMPLES)),
              e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
          }
          t >= Lf.HIGH
            ? (this.multisample = Lf.HIGH)
            : t >= Lf.MEDIUM
            ? (this.multisample = Lf.MEDIUM)
            : t >= Lf.LOW
            ? (this.multisample = Lf.LOW)
            : (this.multisample = Lf.NONE);
        }),
        (e.prototype.addSystem = function (t, e) {
          var n = new t(this);
          if (this[e])
            throw new Error('Whoops! The name "' + e + '" is already in use');
          for (var i in ((this[e] = n), this.runners)) this.runners[i].add(n);
          return this;
        }),
        (e.prototype.render = function (t, e) {
          var n, i, r, s;
          if (
            (e &&
              (e instanceof ng
                ? (gm(
                    "6.0.0",
                    "Renderer#render arguments changed, use options instead."
                  ),
                  (n = e),
                  (i = arguments[2]),
                  (r = arguments[3]),
                  (s = arguments[4]))
                : ((n = e.renderTexture),
                  (i = e.clear),
                  (r = e.transform),
                  (s = e.skipUpdateTransform))),
            (this.renderingToScreen = !n),
            this.runners.prerender.emit(),
            this.emit("prerender"),
            (this.projection.transform = r),
            !this.context.isLost)
          ) {
            if ((n || (this._lastObjectRendered = t), !s)) {
              var o = t.enableTempParent();
              t.updateTransform(), t.disableTempParent(o);
            }
            this.renderTexture.bind(n),
              this.batch.currentRenderer.start(),
              (void 0 !== i ? i : this.clearBeforeRender) &&
                this.renderTexture.clear(),
              t.render(this),
              this.batch.currentRenderer.flush(),
              n && n.baseTexture.update(),
              this.runners.postrender.emit(),
              (this.projection.transform = null),
              this.emit("postrender");
          }
        }),
        (e.prototype.generateTexture = function (e, n, i, r) {
          void 0 === n && (n = {});
          var s = t.prototype.generateTexture.call(this, e, n, i, r);
          return this.framebuffer.blit(), s;
        }),
        (e.prototype.resize = function (e, n) {
          t.prototype.resize.call(this, e, n),
            this.runners.resize.emit(this.screen.height, this.screen.width);
        }),
        (e.prototype.reset = function () {
          return this.runners.reset.emit(), this;
        }),
        (e.prototype.clear = function () {
          this.renderTexture.bind(), this.renderTexture.clear();
        }),
        (e.prototype.destroy = function (e) {
          for (var n in (this.runners.destroy.emit(), this.runners))
            this.runners[n].destroy();
          t.prototype.destroy.call(this, e), (this.gl = null);
        }),
        Object.defineProperty(e.prototype, "extract", {
          get: function () {
            return (
              gm(
                "6.0.0",
                "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."
              ),
              this.plugins.extract
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.registerPlugin = function (t, e) {
          gm(
            "6.5.0",
            "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."
          ),
            M_.add({ name: t, type: x_.RendererPlugin, ref: e });
        }),
        (e.__plugins = {}),
        e
      );
    })(Cv);
  M_.handleByMap(x_.RendererPlugin, Ov.__plugins);
  var Nv =
      "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
    Dv = function () {
      (this.texArray = null),
        (this.blend = 0),
        (this.type = bf.TRIANGLES),
        (this.start = 0),
        (this.size = 0),
        (this.data = null);
    },
    Lv = (function () {
      function t() {
        (this.elements = []), (this.ids = []), (this.count = 0);
      }
      return (
        (t.prototype.clear = function () {
          for (var t = 0; t < this.count; t++) this.elements[t] = null;
          this.count = 0;
        }),
        t
      );
    })(),
    Fv = (function () {
      function t(t) {
        "number" == typeof t
          ? (this.rawBinaryData = new ArrayBuffer(t))
          : t instanceof Uint8Array
          ? (this.rawBinaryData = t.buffer)
          : (this.rawBinaryData = t),
          (this.uint32View = new Uint32Array(this.rawBinaryData)),
          (this.float32View = new Float32Array(this.rawBinaryData));
      }
      return (
        Object.defineProperty(t.prototype, "int8View", {
          get: function () {
            return (
              this._int8View ||
                (this._int8View = new Int8Array(this.rawBinaryData)),
              this._int8View
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "uint8View", {
          get: function () {
            return (
              this._uint8View ||
                (this._uint8View = new Uint8Array(this.rawBinaryData)),
              this._uint8View
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "int16View", {
          get: function () {
            return (
              this._int16View ||
                (this._int16View = new Int16Array(this.rawBinaryData)),
              this._int16View
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "uint16View", {
          get: function () {
            return (
              this._uint16View ||
                (this._uint16View = new Uint16Array(this.rawBinaryData)),
              this._uint16View
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "int32View", {
          get: function () {
            return (
              this._int32View ||
                (this._int32View = new Int32Array(this.rawBinaryData)),
              this._int32View
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.view = function (t) {
          return this[t + "View"];
        }),
        (t.prototype.destroy = function () {
          (this.rawBinaryData = null),
            (this._int8View = null),
            (this._uint8View = null),
            (this._int16View = null),
            (this._uint16View = null),
            (this._int32View = null),
            (this.uint32View = null),
            (this.float32View = null);
        }),
        (t.sizeOf = function (t) {
          switch (t) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(t + " isn't a valid view type");
          }
        }),
        t
      );
    })(),
    Uv = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.shaderGenerator = null),
          (n.geometryClass = null),
          (n.vertexSize = null),
          (n.state = tv.for2d()),
          (n.size = 4 * Rp.SPRITE_BATCH_SIZE),
          (n._vertexCount = 0),
          (n._indexCount = 0),
          (n._bufferedElements = []),
          (n._bufferedTextures = []),
          (n._bufferSize = 0),
          (n._shader = null),
          (n._packedGeometries = []),
          (n._packedGeometryPoolSize = 2),
          (n._flushId = 0),
          (n._aBuffers = {}),
          (n._iBuffers = {}),
          (n.MAX_TEXTURES = 1),
          n.renderer.on("prerender", n.onPrerender, n),
          e.runners.contextChange.add(n),
          (n._dcIndex = 0),
          (n._aIndex = 0),
          (n._iIndex = 0),
          (n._attributeBuffer = null),
          (n._indexBuffer = null),
          (n._tempBoundTextures = []),
          n
        );
      }
      return (
        D_(e, t),
        (e.prototype.contextChange = function () {
          var t = this.renderer.gl;
          Rp.PREFER_ENV === gf.WEBGL_LEGACY
            ? (this.MAX_TEXTURES = 1)
            : ((this.MAX_TEXTURES = Math.min(
                t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                Rp.SPRITE_MAX_TEXTURES
              )),
              (this.MAX_TEXTURES = (function (t, e) {
                if (0 === t)
                  throw new Error(
                    "Invalid value of `0` passed to `checkMaxIfStatementsInShader`"
                  );
                for (var n = e.createShader(e.FRAGMENT_SHADER); ; ) {
                  var i = qg.replace(/%forloop%/gi, Kg(t));
                  if (
                    (e.shaderSource(n, i),
                    e.compileShader(n),
                    e.getShaderParameter(n, e.COMPILE_STATUS))
                  )
                    break;
                  t = (t / 2) | 0;
                }
                return t;
              })(this.MAX_TEXTURES, t))),
            (this._shader = this.shaderGenerator.generateShader(
              this.MAX_TEXTURES
            ));
          for (var e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] = new this.geometryClass();
          this.initFlushBuffers();
        }),
        (e.prototype.initFlushBuffers = function () {
          for (
            var t = e._drawCallPool,
              n = e._textureArrayPool,
              i = this.size / 4,
              r = Math.floor(i / this.MAX_TEXTURES) + 1;
            t.length < i;

          )
            t.push(new Dv());
          for (; n.length < r; ) n.push(new Lv());
          for (var s = 0; s < this.MAX_TEXTURES; s++)
            this._tempBoundTextures[s] = null;
        }),
        (e.prototype.onPrerender = function () {
          this._flushId = 0;
        }),
        (e.prototype.render = function (t) {
          t._texture.valid &&
            (this._vertexCount + t.vertexData.length / 2 > this.size &&
              this.flush(),
            (this._vertexCount += t.vertexData.length / 2),
            (this._indexCount += t.indices.length),
            (this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
            (this._bufferedElements[this._bufferSize++] = t));
        }),
        (e.prototype.buildTexturesAndDrawCalls = function () {
          var t = this._bufferedTextures,
            n = this.MAX_TEXTURES,
            i = e._textureArrayPool,
            r = this.renderer.batch,
            s = this._tempBoundTextures,
            o = this.renderer.textureGC.count,
            a = ++k_._globalBatch,
            l = 0,
            h = i[0],
            u = 0;
          r.copyBoundTextures(s, n);
          for (var c = 0; c < this._bufferSize; ++c) {
            var d = t[c];
            (t[c] = null),
              d._batchEnabled !== a &&
                (h.count >= n &&
                  (r.boundArray(h, s, a, n),
                  this.buildDrawCalls(h, u, c),
                  (u = c),
                  (h = i[++l]),
                  ++a),
                (d._batchEnabled = a),
                (d.touched = o),
                (h.elements[h.count++] = d));
          }
          h.count > 0 &&
            (r.boundArray(h, s, a, n),
            this.buildDrawCalls(h, u, this._bufferSize),
            ++l,
            ++a);
          for (c = 0; c < s.length; c++) s[c] = null;
          k_._globalBatch = a;
        }),
        (e.prototype.buildDrawCalls = function (t, n, i) {
          var r = this,
            s = r._bufferedElements,
            o = r._attributeBuffer,
            a = r._indexBuffer,
            l = r.vertexSize,
            h = e._drawCallPool,
            u = this._dcIndex,
            c = this._aIndex,
            d = this._iIndex,
            p = h[u];
          (p.start = this._iIndex), (p.texArray = t);
          for (var f = n; f < i; ++f) {
            var m = s[f],
              _ = m._texture.baseTexture,
              g = rm[_.alphaMode ? 1 : 0][m.blendMode];
            (s[f] = null),
              n < f &&
                p.blend !== g &&
                ((p.size = d - p.start),
                (n = f),
                ((p = h[++u]).texArray = t),
                (p.start = d)),
              this.packInterleavedGeometry(m, o, a, c, d),
              (c += (m.vertexData.length / 2) * l),
              (d += m.indices.length),
              (p.blend = g);
          }
          n < i && ((p.size = d - p.start), ++u),
            (this._dcIndex = u),
            (this._aIndex = c),
            (this._iIndex = d);
        }),
        (e.prototype.bindAndClearTexArray = function (t) {
          for (var e = this.renderer.texture, n = 0; n < t.count; n++)
            e.bind(t.elements[n], t.ids[n]), (t.elements[n] = null);
          t.count = 0;
        }),
        (e.prototype.updateGeometry = function () {
          var t = this,
            e = t._packedGeometries,
            n = t._attributeBuffer,
            i = t._indexBuffer;
          Rp.CAN_UPLOAD_SAME_BUFFER
            ? (e[this._flushId]._buffer.update(n.rawBinaryData),
              e[this._flushId]._indexBuffer.update(i),
              this.renderer.geometry.updateBuffers())
            : (this._packedGeometryPoolSize <= this._flushId &&
                (this._packedGeometryPoolSize++,
                (e[this._flushId] = new this.geometryClass())),
              e[this._flushId]._buffer.update(n.rawBinaryData),
              e[this._flushId]._indexBuffer.update(i),
              this.renderer.geometry.bind(e[this._flushId]),
              this.renderer.geometry.updateBuffers(),
              this._flushId++);
        }),
        (e.prototype.drawBatches = function () {
          for (
            var t = this._dcIndex,
              n = this.renderer,
              i = n.gl,
              r = n.state,
              s = e._drawCallPool,
              o = null,
              a = 0;
            a < t;
            a++
          ) {
            var l = s[a],
              h = l.texArray,
              u = l.type,
              c = l.size,
              d = l.start,
              p = l.blend;
            o !== h && ((o = h), this.bindAndClearTexArray(h)),
              (this.state.blendMode = p),
              r.set(this.state),
              i.drawElements(u, c, i.UNSIGNED_SHORT, 2 * d);
          }
        }),
        (e.prototype.flush = function () {
          0 !== this._vertexCount &&
            ((this._attributeBuffer = this.getAttributeBuffer(
              this._vertexCount
            )),
            (this._indexBuffer = this.getIndexBuffer(this._indexCount)),
            (this._aIndex = 0),
            (this._iIndex = 0),
            (this._dcIndex = 0),
            this.buildTexturesAndDrawCalls(),
            this.updateGeometry(),
            this.drawBatches(),
            (this._bufferSize = 0),
            (this._vertexCount = 0),
            (this._indexCount = 0));
        }),
        (e.prototype.start = function () {
          this.renderer.state.set(this.state),
            this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),
            this.renderer.shader.bind(this._shader),
            Rp.CAN_UPLOAD_SAME_BUFFER &&
              this.renderer.geometry.bind(
                this._packedGeometries[this._flushId]
              );
        }),
        (e.prototype.stop = function () {
          this.flush();
        }),
        (e.prototype.destroy = function () {
          for (var e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] && this._packedGeometries[e].destroy();
          this.renderer.off("prerender", this.onPrerender, this),
            (this._aBuffers = null),
            (this._iBuffers = null),
            (this._packedGeometries = null),
            (this._attributeBuffer = null),
            (this._indexBuffer = null),
            this._shader && (this._shader.destroy(), (this._shader = null)),
            t.prototype.destroy.call(this);
        }),
        (e.prototype.getAttributeBuffer = function (t) {
          var e = hm(Math.ceil(t / 8)),
            n = cm(e),
            i = 8 * e;
          this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
          var r = this._aBuffers[i];
          return (
            r || (this._aBuffers[i] = r = new Fv(i * this.vertexSize * 4)), r
          );
        }),
        (e.prototype.getIndexBuffer = function (t) {
          var e = hm(Math.ceil(t / 12)),
            n = cm(e),
            i = 12 * e;
          this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
          var r = this._iBuffers[n];
          return r || (this._iBuffers[n] = r = new Uint16Array(i)), r;
        }),
        (e.prototype.packInterleavedGeometry = function (t, e, n, i, r) {
          for (
            var s = e.uint32View,
              o = e.float32View,
              a = i / this.vertexSize,
              l = t.uvs,
              h = t.indices,
              u = t.vertexData,
              c = t._texture.baseTexture._batchLocation,
              d = Math.min(t.worldAlpha, 1),
              p =
                d < 1 && t._texture.baseTexture.alphaMode
                  ? om(t._tintRGB, d)
                  : t._tintRGB + ((255 * d) << 24),
              f = 0;
            f < u.length;
            f += 2
          )
            (o[i++] = u[f]),
              (o[i++] = u[f + 1]),
              (o[i++] = l[f]),
              (o[i++] = l[f + 1]),
              (s[i++] = p),
              (o[i++] = c);
          for (f = 0; f < h.length; f++) n[r++] = a + h[f];
        }),
        (e._drawCallPool = []),
        (e._textureArrayPool = []),
        e
      );
    })(xg),
    Bv = (function () {
      function t(t, e) {
        if (
          ((this.vertexSrc = t),
          (this.fragTemplate = e),
          (this.programCache = {}),
          (this.defaultGroupCache = {}),
          e.indexOf("%count%") < 0)
        )
          throw new Error('Fragment template must contain "%count%".');
        if (e.indexOf("%forloop%") < 0)
          throw new Error('Fragment template must contain "%forloop%".');
      }
      return (
        (t.prototype.generateShader = function (t) {
          if (!this.programCache[t]) {
            for (var e = new Int32Array(t), n = 0; n < t; n++) e[n] = n;
            this.defaultGroupCache[t] = mg.from({ uSamplers: e }, !0);
            var i = this.fragTemplate;
            (i = (i = i.replace(/%count%/gi, "" + t)).replace(
              /%forloop%/gi,
              this.generateSampleSrc(t)
            )),
              (this.programCache[t] = new $g(this.vertexSrc, i));
          }
          var r = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Um(),
            default: this.defaultGroupCache[t],
          };
          return new Qg(this.programCache[t], r);
        }),
        (t.prototype.generateSampleSrc = function (t) {
          var e = "";
          (e += "\n"), (e += "\n");
          for (var n = 0; n < t; n++)
            n > 0 && (e += "\nelse "),
              n < t - 1 && (e += "if(vTextureId < " + n + ".5)"),
              (e += "\n{"),
              (e +=
                "\n\tcolor = texture2D(uSamplers[" + n + "], vTextureCoord);"),
              (e += "\n}");
          return (e += "\n"), (e += "\n");
        }),
        t
      );
    })(),
    kv = (function (t) {
      function e(e) {
        void 0 === e && (e = !1);
        var n = t.call(this) || this;
        return (
          (n._buffer = new og(null, e, !1)),
          (n._indexBuffer = new og(null, e, !0)),
          n
            .addAttribute("aVertexPosition", n._buffer, 2, !1, Sf.FLOAT)
            .addAttribute("aTextureCoord", n._buffer, 2, !1, Sf.FLOAT)
            .addAttribute("aColor", n._buffer, 4, !0, Sf.UNSIGNED_BYTE)
            .addAttribute("aTextureId", n._buffer, 1, !0, Sf.FLOAT)
            .addIndex(n._indexBuffer),
          n
        );
      }
      return D_(e, t), e;
    })(cg),
    Gv =
      "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",
    Hv =
      "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",
    zv = (function () {
      function t() {}
      return (
        (t.create = function (t) {
          var e = Object.assign(
              { vertex: Gv, fragment: Hv, geometryClass: kv, vertexSize: 6 },
              t
            ),
            n = e.vertex,
            i = e.fragment,
            r = e.vertexSize,
            s = e.geometryClass;
          return (function (t) {
            function e(e) {
              var o = t.call(this, e) || this;
              return (
                (o.shaderGenerator = new Bv(n, i)),
                (o.geometryClass = s),
                (o.vertexSize = r),
                o
              );
            }
            return D_(e, t), e;
          })(Uv);
        }),
        Object.defineProperty(t, "defaultVertexSrc", {
          get: function () {
            return Gv;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "defaultFragmentTemplate", {
          get: function () {
            return Hv;
          },
          enumerable: !1,
          configurable: !0,
        }),
        t
      );
    })().create();
  Object.assign(zv, { extension: { name: "batch", type: x_.RendererPlugin } });
  __.mixin({
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1,
  });
  var Vv = (function () {
      function t(t) {
        (this.debug = !1),
          (this._isActive = !1),
          (this._isMobileAccessibility = !1),
          (this.pool = []),
          (this.renderId = 0),
          (this.children = []),
          (this.androidUpdateCount = 0),
          (this.androidUpdateFrequency = 500),
          (this._hookDiv = null),
          (Ap.tablet || Ap.phone) && this.createTouchHook();
        var e = document.createElement("div");
        (e.style.width = "100px"),
          (e.style.height = "100px"),
          (e.style.position = "absolute"),
          (e.style.top = "0px"),
          (e.style.left = "0px"),
          (e.style.zIndex = (2).toString()),
          (this.div = e),
          (this.renderer = t),
          (this._onKeyDown = this._onKeyDown.bind(this)),
          (this._onMouseMove = this._onMouseMove.bind(this)),
          globalThis.addEventListener("keydown", this._onKeyDown, !1);
      }
      return (
        Object.defineProperty(t.prototype, "isActive", {
          get: function () {
            return this._isActive;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "isMobileAccessibility", {
          get: function () {
            return this._isMobileAccessibility;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.createTouchHook = function () {
          var t = this,
            e = document.createElement("button");
          (e.style.width = "1px"),
            (e.style.height = "1px"),
            (e.style.position = "absolute"),
            (e.style.top = "-1000px"),
            (e.style.left = "-1000px"),
            (e.style.zIndex = (2).toString()),
            (e.style.backgroundColor = "#FF0000"),
            (e.title = "select to enable accessibility for this content"),
            e.addEventListener("focus", function () {
              (t._isMobileAccessibility = !0),
                t.activate(),
                t.destroyTouchHook();
            }),
            document.body.appendChild(e),
            (this._hookDiv = e);
        }),
        (t.prototype.destroyTouchHook = function () {
          this._hookDiv &&
            (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
        }),
        (t.prototype.activate = function () {
          var t;
          this._isActive ||
            ((this._isActive = !0),
            globalThis.document.addEventListener(
              "mousemove",
              this._onMouseMove,
              !0
            ),
            globalThis.removeEventListener("keydown", this._onKeyDown, !1),
            this.renderer.on("postrender", this.update, this),
            null === (t = this.renderer.view.parentNode) ||
              void 0 === t ||
              t.appendChild(this.div));
        }),
        (t.prototype.deactivate = function () {
          var t;
          this._isActive &&
            !this._isMobileAccessibility &&
            ((this._isActive = !1),
            globalThis.document.removeEventListener(
              "mousemove",
              this._onMouseMove,
              !0
            ),
            globalThis.addEventListener("keydown", this._onKeyDown, !1),
            this.renderer.off("postrender", this.update),
            null === (t = this.div.parentNode) ||
              void 0 === t ||
              t.removeChild(this.div));
        }),
        (t.prototype.updateAccessibleObjects = function (t) {
          if (t.visible && t.accessibleChildren) {
            t.accessible &&
              t.interactive &&
              (t._accessibleActive || this.addChild(t),
              (t.renderId = this.renderId));
            var e = t.children;
            if (e)
              for (var n = 0; n < e.length; n++)
                this.updateAccessibleObjects(e[n]);
          }
        }),
        (t.prototype.update = function () {
          var t = performance.now();
          if (
            !(Ap.android.device && t < this.androidUpdateCount) &&
            ((this.androidUpdateCount = t + this.androidUpdateFrequency),
            this.renderer.renderingToScreen)
          ) {
            this.renderer._lastObjectRendered &&
              this.updateAccessibleObjects(this.renderer._lastObjectRendered);
            var e = this.renderer.view.getBoundingClientRect(),
              n = e.left,
              i = e.top,
              r = e.width,
              s = e.height,
              o = this.renderer,
              a = o.width,
              l = o.height,
              h = o.resolution,
              u = (r / a) * h,
              c = (s / l) * h,
              d = this.div;
            (d.style.left = n + "px"),
              (d.style.top = i + "px"),
              (d.style.width = a + "px"),
              (d.style.height = l + "px");
            for (var p = 0; p < this.children.length; p++) {
              var f = this.children[p];
              if (f.renderId !== this.renderId)
                (f._accessibleActive = !1),
                  dm(this.children, p, 1),
                  this.div.removeChild(f._accessibleDiv),
                  this.pool.push(f._accessibleDiv),
                  (f._accessibleDiv = null),
                  p--;
              else {
                d = f._accessibleDiv;
                var m = f.hitArea,
                  _ = f.worldTransform;
                f.hitArea
                  ? ((d.style.left = (_.tx + m.x * _.a) * u + "px"),
                    (d.style.top = (_.ty + m.y * _.d) * c + "px"),
                    (d.style.width = m.width * _.a * u + "px"),
                    (d.style.height = m.height * _.d * c + "px"))
                  : ((m = f.getBounds()),
                    this.capHitArea(m),
                    (d.style.left = m.x * u + "px"),
                    (d.style.top = m.y * c + "px"),
                    (d.style.width = m.width * u + "px"),
                    (d.style.height = m.height * c + "px"),
                    d.title !== f.accessibleTitle &&
                      null !== f.accessibleTitle &&
                      (d.title = f.accessibleTitle),
                    d.getAttribute("aria-label") !== f.accessibleHint &&
                      null !== f.accessibleHint &&
                      d.setAttribute("aria-label", f.accessibleHint)),
                  (f.accessibleTitle === d.title &&
                    f.tabIndex === d.tabIndex) ||
                    ((d.title = f.accessibleTitle),
                    (d.tabIndex = f.tabIndex),
                    this.debug && this.updateDebugHTML(d));
              }
            }
            this.renderId++;
          }
        }),
        (t.prototype.updateDebugHTML = function (t) {
          t.innerHTML =
            "type: " +
            t.type +
            "</br> title : " +
            t.title +
            "</br> tabIndex: " +
            t.tabIndex;
        }),
        (t.prototype.capHitArea = function (t) {
          t.x < 0 && ((t.width += t.x), (t.x = 0)),
            t.y < 0 && ((t.height += t.y), (t.y = 0));
          var e = this.renderer,
            n = e.width,
            i = e.height;
          t.x + t.width > n && (t.width = n - t.x),
            t.y + t.height > i && (t.height = i - t.y);
        }),
        (t.prototype.addChild = function (t) {
          var e = this.pool.pop();
          e ||
            (((e = document.createElement("button")).style.width = "100px"),
            (e.style.height = "100px"),
            (e.style.backgroundColor = this.debug
              ? "rgba(255,255,255,0.5)"
              : "transparent"),
            (e.style.position = "absolute"),
            (e.style.zIndex = (2).toString()),
            (e.style.borderStyle = "none"),
            navigator.userAgent.toLowerCase().indexOf("chrome") > -1
              ? e.setAttribute("aria-live", "off")
              : e.setAttribute("aria-live", "polite"),
            navigator.userAgent.match(/rv:.*Gecko\//)
              ? e.setAttribute("aria-relevant", "additions")
              : e.setAttribute("aria-relevant", "text"),
            e.addEventListener("click", this._onClick.bind(this)),
            e.addEventListener("focus", this._onFocus.bind(this)),
            e.addEventListener("focusout", this._onFocusOut.bind(this))),
            (e.style.pointerEvents = t.accessiblePointerEvents),
            (e.type = t.accessibleType),
            t.accessibleTitle && null !== t.accessibleTitle
              ? (e.title = t.accessibleTitle)
              : (t.accessibleHint && null !== t.accessibleHint) ||
                (e.title = "displayObject " + t.tabIndex),
            t.accessibleHint &&
              null !== t.accessibleHint &&
              e.setAttribute("aria-label", t.accessibleHint),
            this.debug && this.updateDebugHTML(e),
            (t._accessibleActive = !0),
            (t._accessibleDiv = e),
            (e.displayObject = t),
            this.children.push(t),
            this.div.appendChild(t._accessibleDiv),
            (t._accessibleDiv.tabIndex = t.tabIndex);
        }),
        (t.prototype._onClick = function (t) {
          var e = this.renderer.plugins.interaction,
            n = t.target.displayObject,
            i = e.eventData;
          e.dispatchEvent(n, "click", i),
            e.dispatchEvent(n, "pointertap", i),
            e.dispatchEvent(n, "tap", i);
        }),
        (t.prototype._onFocus = function (t) {
          t.target.getAttribute("aria-live") ||
            t.target.setAttribute("aria-live", "assertive");
          var e = this.renderer.plugins.interaction,
            n = t.target.displayObject,
            i = e.eventData;
          e.dispatchEvent(n, "mouseover", i);
        }),
        (t.prototype._onFocusOut = function (t) {
          t.target.getAttribute("aria-live") ||
            t.target.setAttribute("aria-live", "polite");
          var e = this.renderer.plugins.interaction,
            n = t.target.displayObject,
            i = e.eventData;
          e.dispatchEvent(n, "mouseout", i);
        }),
        (t.prototype._onKeyDown = function (t) {
          9 === t.keyCode && this.activate();
        }),
        (t.prototype._onMouseMove = function (t) {
          (0 === t.movementX && 0 === t.movementY) || this.deactivate();
        }),
        (t.prototype.destroy = function () {
          this.destroyTouchHook(),
            (this.div = null),
            globalThis.document.removeEventListener(
              "mousemove",
              this._onMouseMove,
              !0
            ),
            globalThis.removeEventListener("keydown", this._onKeyDown),
            (this.pool = null),
            (this.children = null),
            (this.renderer = null);
        }),
        (t.extension = {
          name: "accessibility",
          type: [x_.RendererPlugin, x_.CanvasRendererPlugin],
        }),
        t
      );
    })(),
    Xv = (function () {
      function t() {
        (this.pressure = 0),
          (this.rotationAngle = 0),
          (this.twist = 0),
          (this.tangentialPressure = 0),
          (this.global = new Cm()),
          (this.target = null),
          (this.originalEvent = null),
          (this.identifier = null),
          (this.isPrimary = !1),
          (this.button = 0),
          (this.buttons = 0),
          (this.width = 0),
          (this.height = 0),
          (this.tiltX = 0),
          (this.tiltY = 0),
          (this.pointerType = null),
          (this.pressure = 0),
          (this.rotationAngle = 0),
          (this.twist = 0),
          (this.tangentialPressure = 0);
      }
      return (
        Object.defineProperty(t.prototype, "pointerId", {
          get: function () {
            return this.identifier;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.getLocalPosition = function (t, e, n) {
          return t.worldTransform.applyInverse(n || this.global, e);
        }),
        (t.prototype.copyEvent = function (t) {
          "isPrimary" in t && t.isPrimary && (this.isPrimary = !0),
            (this.button = "button" in t && t.button);
          var e = "buttons" in t && t.buttons;
          (this.buttons = Number.isInteger(e) ? e : "which" in t && t.which),
            (this.width = "width" in t && t.width),
            (this.height = "height" in t && t.height),
            (this.tiltX = "tiltX" in t && t.tiltX),
            (this.tiltY = "tiltY" in t && t.tiltY),
            (this.pointerType = "pointerType" in t && t.pointerType),
            (this.pressure = "pressure" in t && t.pressure),
            (this.rotationAngle = "rotationAngle" in t && t.rotationAngle),
            (this.twist = ("twist" in t && t.twist) || 0),
            (this.tangentialPressure =
              ("tangentialPressure" in t && t.tangentialPressure) || 0);
        }),
        (t.prototype.reset = function () {
          this.isPrimary = !1;
        }),
        t
      );
    })(),
    Wv = function (t, e) {
      return (Wv =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  var jv = (function () {
      function t() {
        (this.stopped = !1),
          (this.stopsPropagatingAt = null),
          (this.stopPropagationHint = !1),
          (this.target = null),
          (this.currentTarget = null),
          (this.type = null),
          (this.data = null);
      }
      return (
        (t.prototype.stopPropagation = function () {
          (this.stopped = !0),
            (this.stopPropagationHint = !0),
            (this.stopsPropagatingAt = this.currentTarget);
        }),
        (t.prototype.reset = function () {
          (this.stopped = !1),
            (this.stopsPropagatingAt = null),
            (this.stopPropagationHint = !1),
            (this.currentTarget = null),
            (this.target = null);
        }),
        t
      );
    })(),
    Yv = (function () {
      function t(e) {
        (this._pointerId = e), (this._flags = t.FLAGS.NONE);
      }
      return (
        (t.prototype._doSet = function (t, e) {
          this._flags = e ? this._flags | t : this._flags & ~t;
        }),
        Object.defineProperty(t.prototype, "pointerId", {
          get: function () {
            return this._pointerId;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "flags", {
          get: function () {
            return this._flags;
          },
          set: function (t) {
            this._flags = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "none", {
          get: function () {
            return this._flags === t.FLAGS.NONE;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "over", {
          get: function () {
            return 0 != (this._flags & t.FLAGS.OVER);
          },
          set: function (e) {
            this._doSet(t.FLAGS.OVER, e);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "rightDown", {
          get: function () {
            return 0 != (this._flags & t.FLAGS.RIGHT_DOWN);
          },
          set: function (e) {
            this._doSet(t.FLAGS.RIGHT_DOWN, e);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "leftDown", {
          get: function () {
            return 0 != (this._flags & t.FLAGS.LEFT_DOWN);
          },
          set: function (e) {
            this._doSet(t.FLAGS.LEFT_DOWN, e);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.FLAGS = Object.freeze({
          NONE: 0,
          OVER: 1,
          LEFT_DOWN: 2,
          RIGHT_DOWN: 4,
        })),
        t
      );
    })(),
    qv = (function () {
      function t() {
        this._tempPoint = new Cm();
      }
      return (
        (t.prototype.recursiveFindHit = function (t, e, n, i, r) {
          var s;
          if (!e || !e.visible) return !1;
          var o = t.data.global,
            a = !1,
            l = (r = e.interactive || r),
            h = !0;
          if (e.hitArea)
            i &&
              (e.worldTransform.applyInverse(o, this._tempPoint),
              e.hitArea.contains(this._tempPoint.x, this._tempPoint.y)
                ? (a = !0)
                : ((i = !1), (h = !1))),
              (l = !1);
          else if (e._mask && i) {
            var u = e._mask.isMaskData ? e._mask.maskObject : e._mask;
            u &&
              !(null === (s = u.containsPoint) || void 0 === s
                ? void 0
                : s.call(u, o)) &&
              (i = !1);
          }
          if (h && e.interactiveChildren && e.children)
            for (var c = e.children, d = c.length - 1; d >= 0; d--) {
              var p = c[d],
                f = this.recursiveFindHit(t, p, n, i, l);
              if (f) {
                if (!p.parent) continue;
                (l = !1), f && (t.target && (i = !1), (a = !0));
              }
            }
          return (
            r &&
              (i &&
                !t.target &&
                !e.hitArea &&
                e.containsPoint &&
                e.containsPoint(o) &&
                (a = !0),
              e.interactive &&
                (a && !t.target && (t.target = e), n && n(t, e, !!a))),
            a
          );
        }),
        (t.prototype.findHit = function (t, e, n, i) {
          this.recursiveFindHit(t, e, n, i, !1);
        }),
        t
      );
    })(),
    Kv = {
      interactive: !1,
      interactiveChildren: !0,
      hitArea: null,
      get buttonMode() {
        return "pointer" === this.cursor;
      },
      set buttonMode(t) {
        t
          ? (this.cursor = "pointer")
          : "pointer" === this.cursor && (this.cursor = null);
      },
      cursor: null,
      get trackedPointers() {
        return (
          void 0 === this._trackedPointers && (this._trackedPointers = {}),
          this._trackedPointers
        );
      },
      _trackedPointers: void 0,
    };
  __.mixin(Kv);
  var Zv = { target: null, data: { global: null } },
    Jv = (function (t) {
      function e(e, n) {
        var i = t.call(this) || this;
        return (
          (n = n || {}),
          (i.renderer = e),
          (i.autoPreventDefault =
            void 0 === n.autoPreventDefault || n.autoPreventDefault),
          (i.interactionFrequency = n.interactionFrequency || 10),
          (i.mouse = new Xv()),
          (i.mouse.identifier = 1),
          i.mouse.global.set(-999999),
          (i.activeInteractionData = {}),
          (i.activeInteractionData[1] = i.mouse),
          (i.interactionDataPool = []),
          (i.eventData = new jv()),
          (i.interactionDOMElement = null),
          (i.moveWhenInside = !1),
          (i.eventsAdded = !1),
          (i.tickerAdded = !1),
          (i.mouseOverRenderer = !("PointerEvent" in globalThis)),
          (i.supportsTouchEvents = "ontouchstart" in globalThis),
          (i.supportsPointerEvents = !!globalThis.PointerEvent),
          (i.onPointerUp = i.onPointerUp.bind(i)),
          (i.processPointerUp = i.processPointerUp.bind(i)),
          (i.onPointerCancel = i.onPointerCancel.bind(i)),
          (i.processPointerCancel = i.processPointerCancel.bind(i)),
          (i.onPointerDown = i.onPointerDown.bind(i)),
          (i.processPointerDown = i.processPointerDown.bind(i)),
          (i.onPointerMove = i.onPointerMove.bind(i)),
          (i.processPointerMove = i.processPointerMove.bind(i)),
          (i.onPointerOut = i.onPointerOut.bind(i)),
          (i.processPointerOverOut = i.processPointerOverOut.bind(i)),
          (i.onPointerOver = i.onPointerOver.bind(i)),
          (i.cursorStyles = { default: "inherit", pointer: "pointer" }),
          (i.currentCursorMode = null),
          (i.cursor = null),
          (i.resolution = 1),
          (i.delayedEvents = []),
          (i.search = new qv()),
          (i._tempDisplayObject = new g_()),
          (i._eventListenerOptions = { capture: !0, passive: !1 }),
          (i._useSystemTicker =
            void 0 === n.useSystemTicker || n.useSystemTicker),
          i.setTargetElement(i.renderer.view, i.renderer.resolution),
          i
        );
      }
      return (
        (function (t, e) {
          function n() {
            this.constructor = t;
          }
          Wv(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        })(e, t),
        Object.defineProperty(e.prototype, "useSystemTicker", {
          get: function () {
            return this._useSystemTicker;
          },
          set: function (t) {
            (this._useSystemTicker = t),
              t ? this.addTickerListener() : this.removeTickerListener();
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "lastObjectRendered", {
          get: function () {
            return this.renderer._lastObjectRendered || this._tempDisplayObject;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.hitTest = function (t, e) {
          return (
            (Zv.target = null),
            (Zv.data.global = t),
            e || (e = this.lastObjectRendered),
            this.processInteractive(Zv, e, null, !0),
            Zv.target
          );
        }),
        (e.prototype.setTargetElement = function (t, e) {
          void 0 === e && (e = 1),
            this.removeTickerListener(),
            this.removeEvents(),
            (this.interactionDOMElement = t),
            (this.resolution = e),
            this.addEvents(),
            this.addTickerListener();
        }),
        (e.prototype.addTickerListener = function () {
          !this.tickerAdded &&
            this.interactionDOMElement &&
            this._useSystemTicker &&
            (C_.system.add(this.tickerUpdate, this, E_.INTERACTION),
            (this.tickerAdded = !0));
        }),
        (e.prototype.removeTickerListener = function () {
          this.tickerAdded &&
            (C_.system.remove(this.tickerUpdate, this),
            (this.tickerAdded = !1));
        }),
        (e.prototype.addEvents = function () {
          if (!this.eventsAdded && this.interactionDOMElement) {
            var t = this.interactionDOMElement.style;
            globalThis.navigator.msPointerEnabled
              ? ((t.msContentZooming = "none"), (t.msTouchAction = "none"))
              : this.supportsPointerEvents && (t.touchAction = "none"),
              this.supportsPointerEvents
                ? (globalThis.document.addEventListener(
                    "pointermove",
                    this.onPointerMove,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "pointerdown",
                    this.onPointerDown,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "pointerleave",
                    this.onPointerOut,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "pointerover",
                    this.onPointerOver,
                    this._eventListenerOptions
                  ),
                  globalThis.addEventListener(
                    "pointercancel",
                    this.onPointerCancel,
                    this._eventListenerOptions
                  ),
                  globalThis.addEventListener(
                    "pointerup",
                    this.onPointerUp,
                    this._eventListenerOptions
                  ))
                : (globalThis.document.addEventListener(
                    "mousemove",
                    this.onPointerMove,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "mousedown",
                    this.onPointerDown,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "mouseout",
                    this.onPointerOut,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.addEventListener(
                    "mouseover",
                    this.onPointerOver,
                    this._eventListenerOptions
                  ),
                  globalThis.addEventListener(
                    "mouseup",
                    this.onPointerUp,
                    this._eventListenerOptions
                  )),
              this.supportsTouchEvents &&
                (this.interactionDOMElement.addEventListener(
                  "touchstart",
                  this.onPointerDown,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.addEventListener(
                  "touchcancel",
                  this.onPointerCancel,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.addEventListener(
                  "touchend",
                  this.onPointerUp,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.addEventListener(
                  "touchmove",
                  this.onPointerMove,
                  this._eventListenerOptions
                )),
              (this.eventsAdded = !0);
          }
        }),
        (e.prototype.removeEvents = function () {
          if (this.eventsAdded && this.interactionDOMElement) {
            var t = this.interactionDOMElement.style;
            globalThis.navigator.msPointerEnabled
              ? ((t.msContentZooming = ""), (t.msTouchAction = ""))
              : this.supportsPointerEvents && (t.touchAction = ""),
              this.supportsPointerEvents
                ? (globalThis.document.removeEventListener(
                    "pointermove",
                    this.onPointerMove,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "pointerdown",
                    this.onPointerDown,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "pointerleave",
                    this.onPointerOut,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "pointerover",
                    this.onPointerOver,
                    this._eventListenerOptions
                  ),
                  globalThis.removeEventListener(
                    "pointercancel",
                    this.onPointerCancel,
                    this._eventListenerOptions
                  ),
                  globalThis.removeEventListener(
                    "pointerup",
                    this.onPointerUp,
                    this._eventListenerOptions
                  ))
                : (globalThis.document.removeEventListener(
                    "mousemove",
                    this.onPointerMove,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "mousedown",
                    this.onPointerDown,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "mouseout",
                    this.onPointerOut,
                    this._eventListenerOptions
                  ),
                  this.interactionDOMElement.removeEventListener(
                    "mouseover",
                    this.onPointerOver,
                    this._eventListenerOptions
                  ),
                  globalThis.removeEventListener(
                    "mouseup",
                    this.onPointerUp,
                    this._eventListenerOptions
                  )),
              this.supportsTouchEvents &&
                (this.interactionDOMElement.removeEventListener(
                  "touchstart",
                  this.onPointerDown,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.removeEventListener(
                  "touchcancel",
                  this.onPointerCancel,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.removeEventListener(
                  "touchend",
                  this.onPointerUp,
                  this._eventListenerOptions
                ),
                this.interactionDOMElement.removeEventListener(
                  "touchmove",
                  this.onPointerMove,
                  this._eventListenerOptions
                )),
              (this.interactionDOMElement = null),
              (this.eventsAdded = !1);
          }
        }),
        (e.prototype.tickerUpdate = function (t) {
          (this._deltaTime += t),
            this._deltaTime < this.interactionFrequency ||
              ((this._deltaTime = 0), this.update());
        }),
        (e.prototype.update = function () {
          if (this.interactionDOMElement)
            if (this._didMove) this._didMove = !1;
            else {
              for (var t in ((this.cursor = null), this.activeInteractionData))
                if (this.activeInteractionData.hasOwnProperty(t)) {
                  var e = this.activeInteractionData[t];
                  if (e.originalEvent && "touch" !== e.pointerType) {
                    var n = this.configureInteractionEventForDOMEvent(
                      this.eventData,
                      e.originalEvent,
                      e
                    );
                    this.processInteractive(
                      n,
                      this.lastObjectRendered,
                      this.processPointerOverOut,
                      !0
                    );
                  }
                }
              this.setCursorMode(this.cursor);
            }
        }),
        (e.prototype.setCursorMode = function (t) {
          t = t || "default";
          var e = !0;
          if (
            (globalThis.OffscreenCanvas &&
              this.interactionDOMElement instanceof OffscreenCanvas &&
              (e = !1),
            this.currentCursorMode !== t)
          ) {
            this.currentCursorMode = t;
            var n = this.cursorStyles[t];
            if (n)
              switch (typeof n) {
                case "string":
                  e && (this.interactionDOMElement.style.cursor = n);
                  break;
                case "function":
                  n(t);
                  break;
                case "object":
                  e && Object.assign(this.interactionDOMElement.style, n);
              }
            else
              e &&
                "string" == typeof t &&
                !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) &&
                (this.interactionDOMElement.style.cursor = t);
          }
        }),
        (e.prototype.dispatchEvent = function (t, e, n) {
          (n.stopPropagationHint && t !== n.stopsPropagatingAt) ||
            ((n.currentTarget = t),
            (n.type = e),
            t.emit(e, n),
            t[e] && t[e](n));
        }),
        (e.prototype.delayDispatchEvent = function (t, e, n) {
          this.delayedEvents.push({
            displayObject: t,
            eventString: e,
            eventData: n,
          });
        }),
        (e.prototype.mapPositionToPoint = function (t, e, n) {
          var i;
          i = this.interactionDOMElement.parentElement
            ? this.interactionDOMElement.getBoundingClientRect()
            : {
                x: 0,
                y: 0,
                width: this.interactionDOMElement.width,
                height: this.interactionDOMElement.height,
                left: 0,
                top: 0,
              };
          var r = 1 / this.resolution;
          (t.x =
            (e - i.left) * (this.interactionDOMElement.width / i.width) * r),
            (t.y =
              (n - i.top) * (this.interactionDOMElement.height / i.height) * r);
        }),
        (e.prototype.processInteractive = function (t, e, n, i) {
          var r = this.search.findHit(t, e, n, i),
            s = this.delayedEvents;
          if (!s.length) return r;
          t.stopPropagationHint = !1;
          var o = s.length;
          this.delayedEvents = [];
          for (var a = 0; a < o; a++) {
            var l = s[a],
              h = l.displayObject,
              u = l.eventString,
              c = l.eventData;
            c.stopsPropagatingAt === h && (c.stopPropagationHint = !0),
              this.dispatchEvent(h, u, c);
          }
          return r;
        }),
        (e.prototype.onPointerDown = function (t) {
          if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
            var e = this.normalizeToPointerData(t);
            if (this.autoPreventDefault && e[0].isNormalized)
              (t.cancelable || !("cancelable" in t)) && t.preventDefault();
            for (var n = e.length, i = 0; i < n; i++) {
              var r = e[i],
                s = this.getInteractionDataForPointerId(r),
                o = this.configureInteractionEventForDOMEvent(
                  this.eventData,
                  r,
                  s
                );
              if (
                ((o.data.originalEvent = t),
                this.processInteractive(
                  o,
                  this.lastObjectRendered,
                  this.processPointerDown,
                  !0
                ),
                this.emit("pointerdown", o),
                "touch" === r.pointerType)
              )
                this.emit("touchstart", o);
              else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                var a = 2 === r.button;
                this.emit(a ? "rightdown" : "mousedown", this.eventData);
              }
            }
          }
        }),
        (e.prototype.processPointerDown = function (t, e, n) {
          var i = t.data,
            r = t.data.identifier;
          if (n)
            if (
              (e.trackedPointers[r] || (e.trackedPointers[r] = new Yv(r)),
              this.dispatchEvent(e, "pointerdown", t),
              "touch" === i.pointerType)
            )
              this.dispatchEvent(e, "touchstart", t);
            else if ("mouse" === i.pointerType || "pen" === i.pointerType) {
              var s = 2 === i.button;
              s
                ? (e.trackedPointers[r].rightDown = !0)
                : (e.trackedPointers[r].leftDown = !0),
                this.dispatchEvent(e, s ? "rightdown" : "mousedown", t);
            }
        }),
        (e.prototype.onPointerComplete = function (t, e, n) {
          var i = this.normalizeToPointerData(t),
            r = i.length,
            s = t.target;
          t.composedPath &&
            t.composedPath().length > 0 &&
            (s = t.composedPath()[0]);
          for (
            var o = s !== this.interactionDOMElement ? "outside" : "", a = 0;
            a < r;
            a++
          ) {
            var l = i[a],
              h = this.getInteractionDataForPointerId(l),
              u = this.configureInteractionEventForDOMEvent(
                this.eventData,
                l,
                h
              );
            if (
              ((u.data.originalEvent = t),
              this.processInteractive(u, this.lastObjectRendered, n, e || !o),
              this.emit(e ? "pointercancel" : "pointerup" + o, u),
              "mouse" === l.pointerType || "pen" === l.pointerType)
            ) {
              var c = 2 === l.button;
              this.emit(c ? "rightup" + o : "mouseup" + o, u);
            } else
              "touch" === l.pointerType &&
                (this.emit(e ? "touchcancel" : "touchend" + o, u),
                this.releaseInteractionDataForPointerId(l.pointerId));
          }
        }),
        (e.prototype.onPointerCancel = function (t) {
          (this.supportsTouchEvents && "touch" === t.pointerType) ||
            this.onPointerComplete(t, !0, this.processPointerCancel);
        }),
        (e.prototype.processPointerCancel = function (t, e) {
          var n = t.data,
            i = t.data.identifier;
          void 0 !== e.trackedPointers[i] &&
            (delete e.trackedPointers[i],
            this.dispatchEvent(e, "pointercancel", t),
            "touch" === n.pointerType &&
              this.dispatchEvent(e, "touchcancel", t));
        }),
        (e.prototype.onPointerUp = function (t) {
          (this.supportsTouchEvents && "touch" === t.pointerType) ||
            this.onPointerComplete(t, !1, this.processPointerUp);
        }),
        (e.prototype.processPointerUp = function (t, e, n) {
          var i = t.data,
            r = t.data.identifier,
            s = e.trackedPointers[r],
            o = "touch" === i.pointerType,
            a = "mouse" === i.pointerType || "pen" === i.pointerType,
            l = !1;
          if (a) {
            var h = 2 === i.button,
              u = Yv.FLAGS,
              c = h ? u.RIGHT_DOWN : u.LEFT_DOWN,
              d = void 0 !== s && s.flags & c;
            n
              ? (this.dispatchEvent(e, h ? "rightup" : "mouseup", t),
                d &&
                  (this.dispatchEvent(e, h ? "rightclick" : "click", t),
                  (l = !0)))
              : d &&
                this.dispatchEvent(
                  e,
                  h ? "rightupoutside" : "mouseupoutside",
                  t
                ),
              s && (h ? (s.rightDown = !1) : (s.leftDown = !1));
          }
          n
            ? (this.dispatchEvent(e, "pointerup", t),
              o && this.dispatchEvent(e, "touchend", t),
              s &&
                ((a && !l) || this.dispatchEvent(e, "pointertap", t),
                o && (this.dispatchEvent(e, "tap", t), (s.over = !1))))
            : s &&
              (this.dispatchEvent(e, "pointerupoutside", t),
              o && this.dispatchEvent(e, "touchendoutside", t)),
            s && s.none && delete e.trackedPointers[r];
        }),
        (e.prototype.onPointerMove = function (t) {
          if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
            var e = this.normalizeToPointerData(t);
            ("mouse" !== e[0].pointerType && "pen" !== e[0].pointerType) ||
              ((this._didMove = !0), (this.cursor = null));
            for (var n = e.length, i = 0; i < n; i++) {
              var r = e[i],
                s = this.getInteractionDataForPointerId(r),
                o = this.configureInteractionEventForDOMEvent(
                  this.eventData,
                  r,
                  s
                );
              (o.data.originalEvent = t),
                this.processInteractive(
                  o,
                  this.lastObjectRendered,
                  this.processPointerMove,
                  !0
                ),
                this.emit("pointermove", o),
                "touch" === r.pointerType && this.emit("touchmove", o),
                ("mouse" !== r.pointerType && "pen" !== r.pointerType) ||
                  this.emit("mousemove", o);
            }
            "mouse" === e[0].pointerType && this.setCursorMode(this.cursor);
          }
        }),
        (e.prototype.processPointerMove = function (t, e, n) {
          var i = t.data,
            r = "touch" === i.pointerType,
            s = "mouse" === i.pointerType || "pen" === i.pointerType;
          s && this.processPointerOverOut(t, e, n),
            (this.moveWhenInside && !n) ||
              (this.dispatchEvent(e, "pointermove", t),
              r && this.dispatchEvent(e, "touchmove", t),
              s && this.dispatchEvent(e, "mousemove", t));
        }),
        (e.prototype.onPointerOut = function (t) {
          if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
            var e = this.normalizeToPointerData(t)[0];
            "mouse" === e.pointerType &&
              ((this.mouseOverRenderer = !1), this.setCursorMode(null));
            var n = this.getInteractionDataForPointerId(e),
              i = this.configureInteractionEventForDOMEvent(
                this.eventData,
                e,
                n
              );
            (i.data.originalEvent = e),
              this.processInteractive(
                i,
                this.lastObjectRendered,
                this.processPointerOverOut,
                !1
              ),
              this.emit("pointerout", i),
              "mouse" === e.pointerType || "pen" === e.pointerType
                ? this.emit("mouseout", i)
                : this.releaseInteractionDataForPointerId(n.identifier);
          }
        }),
        (e.prototype.processPointerOverOut = function (t, e, n) {
          var i = t.data,
            r = t.data.identifier,
            s = "mouse" === i.pointerType || "pen" === i.pointerType,
            o = e.trackedPointers[r];
          n && !o && (o = e.trackedPointers[r] = new Yv(r)),
            void 0 !== o &&
              (n && this.mouseOverRenderer
                ? (o.over ||
                    ((o.over = !0),
                    this.delayDispatchEvent(e, "pointerover", t),
                    s && this.delayDispatchEvent(e, "mouseover", t)),
                  s && null === this.cursor && (this.cursor = e.cursor))
                : o.over &&
                  ((o.over = !1),
                  this.dispatchEvent(e, "pointerout", this.eventData),
                  s && this.dispatchEvent(e, "mouseout", t),
                  o.none && delete e.trackedPointers[r]));
        }),
        (e.prototype.onPointerOver = function (t) {
          var e = this.normalizeToPointerData(t)[0],
            n = this.getInteractionDataForPointerId(e),
            i = this.configureInteractionEventForDOMEvent(this.eventData, e, n);
          (i.data.originalEvent = e),
            "mouse" === e.pointerType && (this.mouseOverRenderer = !0),
            this.emit("pointerover", i),
            ("mouse" !== e.pointerType && "pen" !== e.pointerType) ||
              this.emit("mouseover", i);
        }),
        (e.prototype.getInteractionDataForPointerId = function (t) {
          var e,
            n = t.pointerId;
          return (
            1 === n || "mouse" === t.pointerType
              ? (e = this.mouse)
              : this.activeInteractionData[n]
              ? (e = this.activeInteractionData[n])
              : (((e = this.interactionDataPool.pop() || new Xv()).identifier =
                  n),
                (this.activeInteractionData[n] = e)),
            e.copyEvent(t),
            e
          );
        }),
        (e.prototype.releaseInteractionDataForPointerId = function (t) {
          var e = this.activeInteractionData[t];
          e &&
            (delete this.activeInteractionData[t],
            e.reset(),
            this.interactionDataPool.push(e));
        }),
        (e.prototype.configureInteractionEventForDOMEvent = function (t, e, n) {
          return (
            (t.data = n),
            this.mapPositionToPoint(n.global, e.clientX, e.clientY),
            "touch" === e.pointerType &&
              ((e.globalX = n.global.x), (e.globalY = n.global.y)),
            (n.originalEvent = e),
            t.reset(),
            t
          );
        }),
        (e.prototype.normalizeToPointerData = function (t) {
          var e = [];
          if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (var n = 0, i = t.changedTouches.length; n < i; n++) {
              var r = t.changedTouches[n];
              void 0 === r.button && (r.button = t.touches.length ? 1 : 0),
                void 0 === r.buttons && (r.buttons = t.touches.length ? 1 : 0),
                void 0 === r.isPrimary &&
                  (r.isPrimary =
                    1 === t.touches.length && "touchstart" === t.type),
                void 0 === r.width && (r.width = r.radiusX || 1),
                void 0 === r.height && (r.height = r.radiusY || 1),
                void 0 === r.tiltX && (r.tiltX = 0),
                void 0 === r.tiltY && (r.tiltY = 0),
                void 0 === r.pointerType && (r.pointerType = "touch"),
                void 0 === r.pointerId && (r.pointerId = r.identifier || 0),
                void 0 === r.pressure && (r.pressure = r.force || 0.5),
                void 0 === r.twist && (r.twist = 0),
                void 0 === r.tangentialPressure && (r.tangentialPressure = 0),
                void 0 === r.layerX && (r.layerX = r.offsetX = r.clientX),
                void 0 === r.layerY && (r.layerY = r.offsetY = r.clientY),
                (r.isNormalized = !0),
                e.push(r);
            }
          else if (
            globalThis.MouseEvent &&
            (!(t instanceof MouseEvent) ||
              (this.supportsPointerEvents &&
                t instanceof globalThis.PointerEvent))
          )
            e.push(t);
          else {
            var s = t;
            void 0 === s.isPrimary && (s.isPrimary = !0),
              void 0 === s.width && (s.width = 1),
              void 0 === s.height && (s.height = 1),
              void 0 === s.tiltX && (s.tiltX = 0),
              void 0 === s.tiltY && (s.tiltY = 0),
              void 0 === s.pointerType && (s.pointerType = "mouse"),
              void 0 === s.pointerId && (s.pointerId = 1),
              void 0 === s.pressure && (s.pressure = 0.5),
              void 0 === s.twist && (s.twist = 0),
              void 0 === s.tangentialPressure && (s.tangentialPressure = 0),
              (s.isNormalized = !0),
              e.push(s);
          }
          return e;
        }),
        (e.prototype.destroy = function () {
          this.removeEvents(),
            this.removeTickerListener(),
            this.removeAllListeners(),
            (this.renderer = null),
            (this.mouse = null),
            (this.eventData = null),
            (this.interactionDOMElement = null),
            (this.onPointerDown = null),
            (this.processPointerDown = null),
            (this.onPointerUp = null),
            (this.processPointerUp = null),
            (this.onPointerCancel = null),
            (this.processPointerCancel = null),
            (this.onPointerMove = null),
            (this.processPointerMove = null),
            (this.onPointerOut = null),
            (this.processPointerOverOut = null),
            (this.onPointerOver = null),
            (this.search = null);
        }),
        (e.extension = {
          name: "interaction",
          type: [x_.RendererPlugin, x_.CanvasRendererPlugin],
        }),
        e
      );
    })(Ip),
    $v = new Pm(),
    Qv = (function () {
      function t(t) {
        this.renderer = t;
      }
      return (
        (t.prototype.image = function (t, e, n) {
          var i = new Image();
          return (i.src = this.base64(t, e, n)), i;
        }),
        (t.prototype.base64 = function (t, e, n) {
          return this.canvas(t).toDataURL(e, n);
        }),
        (t.prototype.canvas = function (e, n) {
          var i,
            r,
            s = this.renderer,
            o = !1,
            a = !1;
          e &&
            (e instanceof ng
              ? (r = e)
              : ((r = this.renderer.generateTexture(e)), (a = !0))),
            r
              ? ((i = r.baseTexture.resolution),
                (n = null != n ? n : r.frame),
                (o = !1),
                s.renderTexture.bind(r))
              : ((i = s.resolution),
                n || (((n = $v).width = s.width), (n.height = s.height)),
                (o = !0),
                s.renderTexture.bind(null));
          var l = Math.round(n.width * i),
            h = Math.round(n.height * i),
            u = new Tm(l, h, 1),
            c = new Uint8Array(4 * l * h),
            d = s.gl;
          d.readPixels(
            Math.round(n.x * i),
            Math.round(n.y * i),
            l,
            h,
            d.RGBA,
            d.UNSIGNED_BYTE,
            c
          );
          var p = u.context.getImageData(0, 0, l, h);
          if (
            (t.arrayPostDivide(c, p.data), u.context.putImageData(p, 0, 0), o)
          ) {
            var f = new Tm(u.width, u.height, 1);
            f.context.scale(1, -1),
              f.context.drawImage(u.canvas, 0, -h),
              u.destroy(),
              (u = f);
          }
          return a && r.destroy(!0), u.canvas;
        }),
        (t.prototype.pixels = function (e, n) {
          var i,
            r,
            s = this.renderer,
            o = !1;
          e &&
            (e instanceof ng
              ? (r = e)
              : ((r = this.renderer.generateTexture(e)), (o = !0))),
            r
              ? ((i = r.baseTexture.resolution),
                (n = null != n ? n : r.frame),
                s.renderTexture.bind(r))
              : ((i = s.resolution),
                n || (((n = $v).width = s.width), (n.height = s.height)),
                s.renderTexture.bind(null));
          var a = Math.round(n.width * i),
            l = Math.round(n.height * i),
            h = new Uint8Array(4 * a * l),
            u = s.gl;
          return (
            u.readPixels(
              Math.round(n.x * i),
              Math.round(n.y * i),
              a,
              l,
              u.RGBA,
              u.UNSIGNED_BYTE,
              h
            ),
            o && r.destroy(!0),
            t.arrayPostDivide(h, h),
            h
          );
        }),
        (t.prototype.destroy = function () {
          this.renderer = null;
        }),
        (t.arrayPostDivide = function (t, e) {
          for (var n = 0; n < t.length; n += 4) {
            var i = (e[n + 3] = t[n + 3]);
            0 !== i
              ? ((e[n] = Math.round(Math.min((255 * t[n]) / i, 255))),
                (e[n + 1] = Math.round(Math.min((255 * t[n + 1]) / i, 255))),
                (e[n + 2] = Math.round(Math.min((255 * t[n + 2]) / i, 255))))
              : ((e[n] = t[n]), (e[n + 1] = t[n + 1]), (e[n + 2] = t[n + 2]));
          }
        }),
        (t.extension = { name: "extract", type: x_.RendererPlugin }),
        t
      );
    })(),
    ty = (function () {
      function t(t, e, n) {
        void 0 === e && (e = !1),
          (this._fn = t),
          (this._once = e),
          (this._thisArg = n),
          (this._next = this._prev = this._owner = null);
      }
      return (
        (t.prototype.detach = function () {
          return null !== this._owner && (this._owner.detach(this), !0);
        }),
        t
      );
    })();
  function ey(t, e) {
    return (
      t._head
        ? ((t._tail._next = e), (e._prev = t._tail), (t._tail = e))
        : ((t._head = e), (t._tail = e)),
      (e._owner = t),
      e
    );
  }
  var ny,
    iy = (function () {
      function t() {
        this._head = this._tail = void 0;
      }
      return (
        (t.prototype.handlers = function (t) {
          void 0 === t && (t = !1);
          var e = this._head;
          if (t) return !!e;
          for (var n = []; e; ) n.push(e), (e = e._next);
          return n;
        }),
        (t.prototype.has = function (t) {
          if (!(t instanceof ty))
            throw new Error(
              "MiniSignal#has(): First arg must be a SignalBinding object."
            );
          return t._owner === this;
        }),
        (t.prototype.dispatch = function () {
          for (var t = arguments, e = [], n = 0; n < arguments.length; n++)
            e[n] = t[n];
          var i = this._head;
          if (!i) return !1;
          for (; i; )
            i._once && this.detach(i),
              i._fn.apply(i._thisArg, e),
              (i = i._next);
          return !0;
        }),
        (t.prototype.add = function (t, e) {
          if ((void 0 === e && (e = null), "function" != typeof t))
            throw new Error("MiniSignal#add(): First arg must be a Function.");
          return ey(this, new ty(t, !1, e));
        }),
        (t.prototype.once = function (t, e) {
          if ((void 0 === e && (e = null), "function" != typeof t))
            throw new Error("MiniSignal#once(): First arg must be a Function.");
          return ey(this, new ty(t, !0, e));
        }),
        (t.prototype.detach = function (t) {
          if (!(t instanceof ty))
            throw new Error(
              "MiniSignal#detach(): First arg must be a SignalBinding object."
            );
          return (
            t._owner !== this ||
              (t._prev && (t._prev._next = t._next),
              t._next && (t._next._prev = t._prev),
              t === this._head
                ? ((this._head = t._next),
                  null === t._next && (this._tail = null))
                : t === this._tail &&
                  ((this._tail = t._prev), (this._tail._next = null)),
              (t._owner = null)),
            this
          );
        }),
        (t.prototype.detachAll = function () {
          var t = this._head;
          if (!t) return this;
          for (this._head = this._tail = null; t; )
            (t._owner = null), (t = t._next);
          return this;
        }),
        t
      );
    })();
  function ry(t, e) {
    e = e || {};
    for (
      var n = {
          key: [
            "source",
            "protocol",
            "authority",
            "userInfo",
            "user",
            "password",
            "host",
            "port",
            "relative",
            "path",
            "directory",
            "file",
            "query",
            "anchor",
          ],
          q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g },
          parser: {
            strict:
              /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:
              /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
          },
        },
        i = n.parser[e.strictMode ? "strict" : "loose"].exec(t),
        r = {},
        s = 14;
      s--;

    )
      r[n.key[s]] = i[s] || "";
    return (
      (r[n.q.name] = {}),
      r[n.key[12]].replace(n.q.parser, function (t, e, i) {
        e && (r[n.q.name][e] = i);
      }),
      r
    );
  }
  var sy = null;
  function oy() {}
  function ay(t, e, n) {
    e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = n);
  }
  function ly(t) {
    return t.toString().replace("object ", "");
  }
  var hy,
    uy,
    cy,
    dy,
    py,
    fy = (function () {
      function t(e, n, i) {
        if (
          ((this._dequeue = oy),
          (this._onLoadBinding = null),
          (this._elementTimer = 0),
          (this._boundComplete = null),
          (this._boundOnError = null),
          (this._boundOnProgress = null),
          (this._boundOnTimeout = null),
          (this._boundXhrOnError = null),
          (this._boundXhrOnTimeout = null),
          (this._boundXhrOnAbort = null),
          (this._boundXhrOnLoad = null),
          "string" != typeof e || "string" != typeof n)
        )
          throw new Error(
            "Both name and url are required for constructing a resource."
          );
        (i = i || {}),
          (this._flags = 0),
          this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === n.indexOf("data:")),
          (this.name = e),
          (this.url = n),
          (this.extension = this._getExtension()),
          (this.data = null),
          (this.crossOrigin =
            !0 === i.crossOrigin ? "anonymous" : i.crossOrigin),
          (this.timeout = i.timeout || 0),
          (this.loadType = i.loadType || this._determineLoadType()),
          (this.xhrType = i.xhrType),
          (this.metadata = i.metadata || {}),
          (this.error = null),
          (this.xhr = null),
          (this.children = []),
          (this.type = t.TYPE.UNKNOWN),
          (this.progressChunk = 0),
          (this._dequeue = oy),
          (this._onLoadBinding = null),
          (this._elementTimer = 0),
          (this._boundComplete = this.complete.bind(this)),
          (this._boundOnError = this._onError.bind(this)),
          (this._boundOnProgress = this._onProgress.bind(this)),
          (this._boundOnTimeout = this._onTimeout.bind(this)),
          (this._boundXhrOnError = this._xhrOnError.bind(this)),
          (this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this)),
          (this._boundXhrOnAbort = this._xhrOnAbort.bind(this)),
          (this._boundXhrOnLoad = this._xhrOnLoad.bind(this)),
          (this.onStart = new iy()),
          (this.onProgress = new iy()),
          (this.onComplete = new iy()),
          (this.onAfterMiddleware = new iy());
      }
      return (
        (t.setExtensionLoadType = function (e, n) {
          ay(t._loadTypeMap, e, n);
        }),
        (t.setExtensionXhrType = function (e, n) {
          ay(t._xhrTypeMap, e, n);
        }),
        Object.defineProperty(t.prototype, "isDataUrl", {
          get: function () {
            return this._hasFlag(t.STATUS_FLAGS.DATA_URL);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "isComplete", {
          get: function () {
            return this._hasFlag(t.STATUS_FLAGS.COMPLETE);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "isLoading", {
          get: function () {
            return this._hasFlag(t.STATUS_FLAGS.LOADING);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.complete = function () {
          this._clearEvents(), this._finish();
        }),
        (t.prototype.abort = function (e) {
          if (!this.error) {
            if (((this.error = new Error(e)), this._clearEvents(), this.xhr))
              this.xhr.abort();
            else if (this.xdr) this.xdr.abort();
            else if (this.data)
              if (this.data.src) this.data.src = t.EMPTY_GIF;
              else
                for (; this.data.firstChild; )
                  this.data.removeChild(this.data.firstChild);
            this._finish();
          }
        }),
        (t.prototype.load = function (e) {
          var n = this;
          if (!this.isLoading)
            if (this.isComplete)
              e &&
                setTimeout(function () {
                  return e(n);
                }, 1);
            else
              switch (
                (e && this.onComplete.once(e),
                this._setFlag(t.STATUS_FLAGS.LOADING, !0),
                this.onStart.dispatch(this),
                (!1 !== this.crossOrigin &&
                  "string" == typeof this.crossOrigin) ||
                  (this.crossOrigin = this._determineCrossOrigin(this.url)),
                this.loadType)
              ) {
                case t.LOAD_TYPE.IMAGE:
                  (this.type = t.TYPE.IMAGE), this._loadElement("image");
                  break;
                case t.LOAD_TYPE.AUDIO:
                  (this.type = t.TYPE.AUDIO), this._loadSourceElement("audio");
                  break;
                case t.LOAD_TYPE.VIDEO:
                  (this.type = t.TYPE.VIDEO), this._loadSourceElement("video");
                  break;
                case t.LOAD_TYPE.XHR:
                default:
                  void 0 === ny &&
                    (ny = !(
                      !globalThis.XDomainRequest ||
                      "withCredentials" in new XMLHttpRequest()
                    )),
                    ny && this.crossOrigin ? this._loadXdr() : this._loadXhr();
              }
        }),
        (t.prototype._hasFlag = function (t) {
          return 0 != (this._flags & t);
        }),
        (t.prototype._setFlag = function (t, e) {
          this._flags = e ? this._flags | t : this._flags & ~t;
        }),
        (t.prototype._clearEvents = function () {
          clearTimeout(this._elementTimer),
            this.data &&
              this.data.removeEventListener &&
              (this.data.removeEventListener("error", this._boundOnError, !1),
              this.data.removeEventListener("load", this._boundComplete, !1),
              this.data.removeEventListener(
                "progress",
                this._boundOnProgress,
                !1
              ),
              this.data.removeEventListener(
                "canplaythrough",
                this._boundComplete,
                !1
              )),
            this.xhr &&
              (this.xhr.removeEventListener
                ? (this.xhr.removeEventListener(
                    "error",
                    this._boundXhrOnError,
                    !1
                  ),
                  this.xhr.removeEventListener(
                    "timeout",
                    this._boundXhrOnTimeout,
                    !1
                  ),
                  this.xhr.removeEventListener(
                    "abort",
                    this._boundXhrOnAbort,
                    !1
                  ),
                  this.xhr.removeEventListener(
                    "progress",
                    this._boundOnProgress,
                    !1
                  ),
                  this.xhr.removeEventListener(
                    "load",
                    this._boundXhrOnLoad,
                    !1
                  ))
                : ((this.xhr.onerror = null),
                  (this.xhr.ontimeout = null),
                  (this.xhr.onprogress = null),
                  (this.xhr.onload = null)));
        }),
        (t.prototype._finish = function () {
          if (this.isComplete)
            throw new Error(
              "Complete called again for an already completed resource."
            );
          this._setFlag(t.STATUS_FLAGS.COMPLETE, !0),
            this._setFlag(t.STATUS_FLAGS.LOADING, !1),
            this.onComplete.dispatch(this);
        }),
        (t.prototype._loadElement = function (t) {
          this.metadata.loadElement
            ? (this.data = this.metadata.loadElement)
            : "image" === t && void 0 !== globalThis.Image
            ? (this.data = new Image())
            : (this.data = document.createElement(t)),
            this.crossOrigin && (this.data.crossOrigin = this.crossOrigin),
            this.metadata.skipSource || (this.data.src = this.url),
            this.data.addEventListener("error", this._boundOnError, !1),
            this.data.addEventListener("load", this._boundComplete, !1),
            this.data.addEventListener("progress", this._boundOnProgress, !1),
            this.timeout &&
              (this._elementTimer = setTimeout(
                this._boundOnTimeout,
                this.timeout
              ));
        }),
        (t.prototype._loadSourceElement = function (t) {
          if (
            (this.metadata.loadElement
              ? (this.data = this.metadata.loadElement)
              : "audio" === t && void 0 !== globalThis.Audio
              ? (this.data = new Audio())
              : (this.data = document.createElement(t)),
            null !== this.data)
          ) {
            if (
              (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin),
              !this.metadata.skipSource)
            )
              if (navigator.isCocoonJS)
                this.data.src = Array.isArray(this.url)
                  ? this.url[0]
                  : this.url;
              else if (Array.isArray(this.url))
                for (
                  var e = this.metadata.mimeType, n = 0;
                  n < this.url.length;
                  ++n
                )
                  this.data.appendChild(
                    this._createSource(
                      t,
                      this.url[n],
                      Array.isArray(e) ? e[n] : e
                    )
                  );
              else {
                e = this.metadata.mimeType;
                this.data.appendChild(
                  this._createSource(t, this.url, Array.isArray(e) ? e[0] : e)
                );
              }
            this.data.addEventListener("error", this._boundOnError, !1),
              this.data.addEventListener("load", this._boundComplete, !1),
              this.data.addEventListener("progress", this._boundOnProgress, !1),
              this.data.addEventListener(
                "canplaythrough",
                this._boundComplete,
                !1
              ),
              this.data.load(),
              this.timeout &&
                (this._elementTimer = setTimeout(
                  this._boundOnTimeout,
                  this.timeout
                ));
          } else this.abort("Unsupported element: " + t);
        }),
        (t.prototype._loadXhr = function () {
          "string" != typeof this.xhrType &&
            (this.xhrType = this._determineXhrType());
          var e = (this.xhr = new XMLHttpRequest());
          "use-credentials" === this.crossOrigin && (e.withCredentials = !0),
            e.open("GET", this.url, !0),
            (e.timeout = this.timeout),
            this.xhrType === t.XHR_RESPONSE_TYPE.JSON ||
            this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT
              ? (e.responseType = t.XHR_RESPONSE_TYPE.TEXT)
              : (e.responseType = this.xhrType),
            e.addEventListener("error", this._boundXhrOnError, !1),
            e.addEventListener("timeout", this._boundXhrOnTimeout, !1),
            e.addEventListener("abort", this._boundXhrOnAbort, !1),
            e.addEventListener("progress", this._boundOnProgress, !1),
            e.addEventListener("load", this._boundXhrOnLoad, !1),
            e.send();
        }),
        (t.prototype._loadXdr = function () {
          "string" != typeof this.xhrType &&
            (this.xhrType = this._determineXhrType());
          var t = (this.xhr = new globalThis.XDomainRequest());
          (t.timeout = this.timeout || 5e3),
            (t.onerror = this._boundXhrOnError),
            (t.ontimeout = this._boundXhrOnTimeout),
            (t.onprogress = this._boundOnProgress),
            (t.onload = this._boundXhrOnLoad),
            t.open("GET", this.url, !0),
            setTimeout(function () {
              return t.send();
            }, 1);
        }),
        (t.prototype._createSource = function (t, e, n) {
          n || (n = t + "/" + this._getExtension(e));
          var i = document.createElement("source");
          return (i.src = e), (i.type = n), i;
        }),
        (t.prototype._onError = function (t) {
          this.abort("Failed to load element using: " + t.target.nodeName);
        }),
        (t.prototype._onProgress = function (t) {
          t &&
            t.lengthComputable &&
            this.onProgress.dispatch(this, t.loaded / t.total);
        }),
        (t.prototype._onTimeout = function () {
          this.abort("Load timed out.");
        }),
        (t.prototype._xhrOnError = function () {
          var t = this.xhr;
          this.abort(
            ly(t) +
              " Request failed. Status: " +
              t.status +
              ', text: "' +
              t.statusText +
              '"'
          );
        }),
        (t.prototype._xhrOnTimeout = function () {
          var t = this.xhr;
          this.abort(ly(t) + " Request timed out.");
        }),
        (t.prototype._xhrOnAbort = function () {
          var t = this.xhr;
          this.abort(ly(t) + " Request was aborted by the user.");
        }),
        (t.prototype._xhrOnLoad = function () {
          var e = this.xhr,
            n = "",
            i = void 0 === e.status ? 200 : e.status;
          if (
            (("" !== e.responseType &&
              "text" !== e.responseType &&
              void 0 !== e.responseType) ||
              (n = e.responseText),
            0 === i &&
            (n.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER)
              ? (i = 200)
              : 1223 === i && (i = 204),
            2 === ((i / 100) | 0))
          ) {
            if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT)
              (this.data = n), (this.type = t.TYPE.TEXT);
            else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON)
              try {
                (this.data = JSON.parse(n)), (this.type = t.TYPE.JSON);
              } catch (o) {
                return void this.abort(
                  "Error trying to parse loaded json: " + o
                );
              }
            else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT)
              try {
                if (globalThis.DOMParser) {
                  var r = new DOMParser();
                  this.data = r.parseFromString(n, "text/xml");
                } else {
                  var s = document.createElement("div");
                  (s.innerHTML = n), (this.data = s);
                }
                this.type = t.TYPE.XML;
              } catch (a) {
                return void this.abort(
                  "Error trying to parse loaded xml: " + a
                );
              }
            else this.data = e.response || n;
            this.complete();
          } else
            this.abort(
              "[" + e.status + "] " + e.statusText + ": " + e.responseURL
            );
        }),
        (t.prototype._determineCrossOrigin = function (t, e) {
          if (0 === t.indexOf("data:")) return "";
          if (globalThis.origin !== globalThis.location.origin)
            return "anonymous";
          (e = e || globalThis.location),
            sy || (sy = document.createElement("a")),
            (sy.href = t);
          var n = ry(sy.href, { strictMode: !0 }),
            i = (!n.port && "" === e.port) || n.port === e.port,
            r = n.protocol ? n.protocol + ":" : "";
          return n.host === e.hostname && i && r === e.protocol
            ? ""
            : "anonymous";
        }),
        (t.prototype._determineXhrType = function () {
          return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT;
        }),
        (t.prototype._determineLoadType = function () {
          return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR;
        }),
        (t.prototype._getExtension = function (t) {
          void 0 === t && (t = this.url);
          var e = "";
          if (this.isDataUrl) {
            var n = t.indexOf("/");
            e = t.substring(n + 1, t.indexOf(";", n));
          } else {
            var i = t.indexOf("?"),
              r = t.indexOf("#"),
              s = Math.min(i > -1 ? i : t.length, r > -1 ? r : t.length);
            e = (t = t.substring(0, s)).substring(t.lastIndexOf(".") + 1);
          }
          return e.toLowerCase();
        }),
        (t.prototype._getMimeFromXhrType = function (e) {
          switch (e) {
            case t.XHR_RESPONSE_TYPE.BUFFER:
              return "application/octet-binary";
            case t.XHR_RESPONSE_TYPE.BLOB:
              return "application/blob";
            case t.XHR_RESPONSE_TYPE.DOCUMENT:
              return "application/xml";
            case t.XHR_RESPONSE_TYPE.JSON:
              return "application/json";
            case t.XHR_RESPONSE_TYPE.DEFAULT:
            case t.XHR_RESPONSE_TYPE.TEXT:
            default:
              return "text/plain";
          }
        }),
        t
      );
    })();
  function my() {}
  function _y(t) {
    return function () {
      for (var e = arguments, n = [], i = 0; i < arguments.length; i++)
        n[i] = e[i];
      if (null === t) throw new Error("Callback was already called.");
      var r = t;
      (t = null), r.apply(this, n);
    };
  }
  (hy = fy || (fy = {})),
    ((uy = hy.STATUS_FLAGS || (hy.STATUS_FLAGS = {}))[(uy.NONE = 0)] = "NONE"),
    (uy[(uy.DATA_URL = 1)] = "DATA_URL"),
    (uy[(uy.COMPLETE = 2)] = "COMPLETE"),
    (uy[(uy.LOADING = 4)] = "LOADING"),
    ((cy = hy.TYPE || (hy.TYPE = {}))[(cy.UNKNOWN = 0)] = "UNKNOWN"),
    (cy[(cy.JSON = 1)] = "JSON"),
    (cy[(cy.XML = 2)] = "XML"),
    (cy[(cy.IMAGE = 3)] = "IMAGE"),
    (cy[(cy.AUDIO = 4)] = "AUDIO"),
    (cy[(cy.VIDEO = 5)] = "VIDEO"),
    (cy[(cy.TEXT = 6)] = "TEXT"),
    ((dy = hy.LOAD_TYPE || (hy.LOAD_TYPE = {}))[(dy.XHR = 1)] = "XHR"),
    (dy[(dy.IMAGE = 2)] = "IMAGE"),
    (dy[(dy.AUDIO = 3)] = "AUDIO"),
    (dy[(dy.VIDEO = 4)] = "VIDEO"),
    ((py = hy.XHR_RESPONSE_TYPE || (hy.XHR_RESPONSE_TYPE = {})).DEFAULT =
      "text"),
    (py.BUFFER = "arraybuffer"),
    (py.BLOB = "blob"),
    (py.DOCUMENT = "document"),
    (py.JSON = "json"),
    (py.TEXT = "text"),
    (hy._loadTypeMap = {
      gif: hy.LOAD_TYPE.IMAGE,
      png: hy.LOAD_TYPE.IMAGE,
      bmp: hy.LOAD_TYPE.IMAGE,
      jpg: hy.LOAD_TYPE.IMAGE,
      jpeg: hy.LOAD_TYPE.IMAGE,
      tif: hy.LOAD_TYPE.IMAGE,
      tiff: hy.LOAD_TYPE.IMAGE,
      webp: hy.LOAD_TYPE.IMAGE,
      tga: hy.LOAD_TYPE.IMAGE,
      svg: hy.LOAD_TYPE.IMAGE,
      "svg+xml": hy.LOAD_TYPE.IMAGE,
      mp3: hy.LOAD_TYPE.AUDIO,
      ogg: hy.LOAD_TYPE.AUDIO,
      wav: hy.LOAD_TYPE.AUDIO,
      mp4: hy.LOAD_TYPE.VIDEO,
      webm: hy.LOAD_TYPE.VIDEO,
    }),
    (hy._xhrTypeMap = {
      xhtml: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      html: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      htm: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      xml: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      tmx: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      svg: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      tsx: hy.XHR_RESPONSE_TYPE.DOCUMENT,
      gif: hy.XHR_RESPONSE_TYPE.BLOB,
      png: hy.XHR_RESPONSE_TYPE.BLOB,
      bmp: hy.XHR_RESPONSE_TYPE.BLOB,
      jpg: hy.XHR_RESPONSE_TYPE.BLOB,
      jpeg: hy.XHR_RESPONSE_TYPE.BLOB,
      tif: hy.XHR_RESPONSE_TYPE.BLOB,
      tiff: hy.XHR_RESPONSE_TYPE.BLOB,
      webp: hy.XHR_RESPONSE_TYPE.BLOB,
      tga: hy.XHR_RESPONSE_TYPE.BLOB,
      json: hy.XHR_RESPONSE_TYPE.JSON,
      text: hy.XHR_RESPONSE_TYPE.TEXT,
      txt: hy.XHR_RESPONSE_TYPE.TEXT,
      ttf: hy.XHR_RESPONSE_TYPE.BUFFER,
      otf: hy.XHR_RESPONSE_TYPE.BUFFER,
    }),
    (hy.EMPTY_GIF =
      "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==");
  var gy = function (t, e) {
      (this.data = t), (this.callback = e);
    },
    vy = (function () {
      function t(t, e) {
        var n = this;
        if (
          (void 0 === e && (e = 1),
          (this.workers = 0),
          (this.saturated = my),
          (this.unsaturated = my),
          (this.empty = my),
          (this.drain = my),
          (this.error = my),
          (this.started = !1),
          (this.paused = !1),
          (this._tasks = []),
          (this._insert = function (t, e, i) {
            if (i && "function" != typeof i)
              throw new Error("task callback must be a function");
            if (((n.started = !0), null == t && n.idle()))
              setTimeout(function () {
                return n.drain();
              }, 1);
            else {
              var r = new gy(t, "function" == typeof i ? i : my);
              e ? n._tasks.unshift(r) : n._tasks.push(r),
                setTimeout(n.process, 1);
            }
          }),
          (this.process = function () {
            for (
              ;
              !n.paused && n.workers < n.concurrency && n._tasks.length;

            ) {
              var t = n._tasks.shift();
              0 === n._tasks.length && n.empty(),
                (n.workers += 1),
                n.workers === n.concurrency && n.saturated(),
                n._worker(t.data, _y(n._next(t)));
            }
          }),
          (this._worker = t),
          0 === e)
        )
          throw new Error("Concurrency must not be zero");
        (this.concurrency = e), (this.buffer = e / 4);
      }
      return (
        (t.prototype._next = function (t) {
          var e = this;
          return function () {
            for (var n = arguments, i = [], r = 0; r < arguments.length; r++)
              i[r] = n[r];
            (e.workers -= 1),
              t.callback.apply(t, i),
              null != i[0] && e.error(i[0], t.data),
              e.workers <= e.concurrency - e.buffer && e.unsaturated(),
              e.idle() && e.drain(),
              e.process();
          };
        }),
        (t.prototype.push = function (t, e) {
          this._insert(t, !1, e);
        }),
        (t.prototype.kill = function () {
          (this.workers = 0),
            (this.drain = my),
            (this.started = !1),
            (this._tasks = []);
        }),
        (t.prototype.unshift = function (t, e) {
          this._insert(t, !0, e);
        }),
        (t.prototype.length = function () {
          return this._tasks.length;
        }),
        (t.prototype.running = function () {
          return this.workers;
        }),
        (t.prototype.idle = function () {
          return this._tasks.length + this.workers === 0;
        }),
        (t.prototype.pause = function () {
          !0 !== this.paused && (this.paused = !0);
        }),
        (t.prototype.resume = function () {
          if (!1 !== this.paused) {
            this.paused = !1;
            for (var t = 1; t <= this.concurrency; t++) this.process();
          }
        }),
        (t.eachSeries = function (t, e, n, i) {
          var r = 0,
            s = t.length;
          !(function o(a) {
            a || r === s
              ? n && n(a)
              : i
              ? setTimeout(function () {
                  e(t[r++], o);
                }, 1)
              : e(t[r++], o);
          })();
        }),
        (t.queue = function (e, n) {
          return new t(e, n);
        }),
        t
      );
    })(),
    yy = /(#[\w-]+)?$/,
    xy = (function () {
      function t(e, n) {
        var i = this;
        void 0 === e && (e = ""),
          void 0 === n && (n = 10),
          (this.progress = 0),
          (this.loading = !1),
          (this.defaultQueryString = ""),
          (this._beforeMiddleware = []),
          (this._afterMiddleware = []),
          (this._resourcesParsing = []),
          (this._boundLoadResource = function (t, e) {
            return i._loadResource(t, e);
          }),
          (this.resources = {}),
          (this.baseUrl = e),
          (this._beforeMiddleware = []),
          (this._afterMiddleware = []),
          (this._resourcesParsing = []),
          (this._boundLoadResource = function (t, e) {
            return i._loadResource(t, e);
          }),
          (this._queue = vy.queue(this._boundLoadResource, n)),
          this._queue.pause(),
          (this.resources = {}),
          (this.onProgress = new iy()),
          (this.onError = new iy()),
          (this.onLoad = new iy()),
          (this.onStart = new iy()),
          (this.onComplete = new iy());
        for (var r = 0; r < t._plugins.length; ++r) {
          var s = t._plugins[r],
            o = s.pre,
            a = s.use;
          o && this.pre(o), a && this.use(a);
        }
        this._protected = !1;
      }
      return (
        (t.prototype._add = function (t, e, n, i) {
          if (this.loading && (!n || !n.parentResource))
            throw new Error(
              "Cannot add resources while the loader is running."
            );
          if (this.resources[t])
            throw new Error('Resource named "' + t + '" already exists.');
          if (
            ((e = this._prepareUrl(e)),
            (this.resources[t] = new fy(t, e, n)),
            "function" == typeof i &&
              this.resources[t].onAfterMiddleware.once(i),
            this.loading)
          ) {
            for (
              var r = n.parentResource, s = [], o = 0;
              o < r.children.length;
              ++o
            )
              r.children[o].isComplete || s.push(r.children[o]);
            var a = (r.progressChunk * (s.length + 1)) / (s.length + 2);
            r.children.push(this.resources[t]), (r.progressChunk = a);
            for (o = 0; o < s.length; ++o) s[o].progressChunk = a;
            this.resources[t].progressChunk = a;
          }
          return this._queue.push(this.resources[t]), this;
        }),
        (t.prototype.pre = function (t) {
          return this._beforeMiddleware.push(t), this;
        }),
        (t.prototype.use = function (t) {
          return this._afterMiddleware.push(t), this;
        }),
        (t.prototype.reset = function () {
          for (var t in ((this.progress = 0),
          (this.loading = !1),
          this._queue.kill(),
          this._queue.pause(),
          this.resources)) {
            var e = this.resources[t];
            e._onLoadBinding && e._onLoadBinding.detach(),
              e.isLoading && e.abort("loader reset");
          }
          return (this.resources = {}), this;
        }),
        (t.prototype.load = function (t) {
          if (
            (gm(
              "6.5.0",
              "@pixi/loaders is being replaced with @pixi/assets in the next major release."
            ),
            "function" == typeof t && this.onComplete.once(t),
            this.loading)
          )
            return this;
          if (this._queue.idle()) this._onStart(), this._onComplete();
          else {
            for (
              var e = 100 / this._queue._tasks.length, n = 0;
              n < this._queue._tasks.length;
              ++n
            )
              this._queue._tasks[n].data.progressChunk = e;
            this._onStart(), this._queue.resume();
          }
          return this;
        }),
        Object.defineProperty(t.prototype, "concurrency", {
          get: function () {
            return this._queue.concurrency;
          },
          set: function (t) {
            this._queue.concurrency = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._prepareUrl = function (t) {
          var e,
            n = ry(t, { strictMode: !0 });
          if (
            ((e =
              n.protocol || !n.path || 0 === t.indexOf("//")
                ? t
                : this.baseUrl.length &&
                  this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 &&
                  "/" !== t.charAt(0)
                ? this.baseUrl + "/" + t
                : this.baseUrl + t),
            this.defaultQueryString)
          ) {
            var i = yy.exec(e)[0];
            -1 !== (e = e.slice(0, e.length - i.length)).indexOf("?")
              ? (e += "&" + this.defaultQueryString)
              : (e += "?" + this.defaultQueryString),
              (e += i);
          }
          return e;
        }),
        (t.prototype._loadResource = function (t, e) {
          var n = this;
          (t._dequeue = e),
            vy.eachSeries(
              this._beforeMiddleware,
              function (e, i) {
                e.call(n, t, function () {
                  i(t.isComplete ? {} : null);
                });
              },
              function () {
                t.isComplete
                  ? n._onLoad(t)
                  : ((t._onLoadBinding = t.onComplete.once(n._onLoad, n)),
                    t.load());
              },
              !0
            );
        }),
        (t.prototype._onStart = function () {
          (this.progress = 0), (this.loading = !0), this.onStart.dispatch(this);
        }),
        (t.prototype._onComplete = function () {
          (this.progress = 100),
            (this.loading = !1),
            this.onComplete.dispatch(this, this.resources);
        }),
        (t.prototype._onLoad = function (t) {
          var e = this;
          (t._onLoadBinding = null),
            this._resourcesParsing.push(t),
            t._dequeue(),
            vy.eachSeries(
              this._afterMiddleware,
              function (n, i) {
                n.call(e, t, i);
              },
              function () {
                t.onAfterMiddleware.dispatch(t),
                  (e.progress = Math.min(100, e.progress + t.progressChunk)),
                  e.onProgress.dispatch(e, t),
                  t.error
                    ? e.onError.dispatch(t.error, e, t)
                    : e.onLoad.dispatch(e, t),
                  e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1),
                  e._queue.idle() &&
                    0 === e._resourcesParsing.length &&
                    e._onComplete();
              },
              !0
            );
        }),
        (t.prototype.destroy = function () {
          this._protected || this.reset();
        }),
        Object.defineProperty(t, "shared", {
          get: function () {
            var e = t._shared;
            return e || (((e = new t())._protected = !0), (t._shared = e)), e;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.registerPlugin = function (e) {
          return (
            gm(
              "6.5.0",
              "Loader.registerPlugin() is deprecated, use extensions.add() instead."
            ),
            M_.add({ type: x_.Loader, ref: e }),
            t
          );
        }),
        (t._plugins = []),
        t
      );
    })();
  M_.handleByList(x_.Loader, xy._plugins),
    (xy.prototype.add = function (t, e, n, i) {
      if (Array.isArray(t)) {
        for (var r = 0; r < t.length; ++r) this.add(t[r]);
        return this;
      }
      if (
        ("object" == typeof t &&
          ((n = t),
          (i = e || n.callback || n.onComplete),
          (e = n.url),
          (t = n.name || n.key || n.url)),
        "string" != typeof e && ((i = n), (n = e), (e = t)),
        "string" != typeof e)
      )
        throw new Error("No url passed to add resource to loader.");
      return (
        "function" == typeof n && ((i = n), (n = null)), this._add(t, e, n, i)
      );
    });
  var by = (function () {
      function t() {}
      return (
        (t.init = function (t) {
          (t = Object.assign({ sharedLoader: !1 }, t)),
            (this.loader = t.sharedLoader ? xy.shared : new xy());
        }),
        (t.destroy = function () {
          this.loader && (this.loader.destroy(), (this.loader = null));
        }),
        (t.extension = x_.Application),
        t
      );
    })(),
    Ty = (function () {
      function t() {}
      return (
        (t.add = function () {
          fy.setExtensionLoadType("svg", fy.LOAD_TYPE.XHR),
            fy.setExtensionXhrType("svg", fy.XHR_RESPONSE_TYPE.TEXT);
        }),
        (t.use = function (t, e) {
          if (!t.data || (t.type !== fy.TYPE.IMAGE && "svg" !== t.extension))
            e();
          else {
            var n = t.data,
              i = t.url,
              r = t.name,
              s = t.metadata;
            eg.fromLoader(n, i, r, s)
              .then(function (n) {
                (t.texture = n), e();
              })
              .catch(e);
          }
        }),
        (t.extension = x_.Loader),
        t
      );
    })();
  function Ey(t, e) {
    if (t.data) {
      if (t.xhr && t.xhrType === fy.XHR_RESPONSE_TYPE.BLOB)
        if (self.Blob && "string" != typeof t.data) {
          if (0 === t.data.type.indexOf("image")) {
            var n = globalThis.URL || globalThis.webkitURL,
              i = n.createObjectURL(t.data);
            return (
              (t.blob = t.data),
              (t.data = new Image()),
              (t.data.src = i),
              (t.type = fy.TYPE.IMAGE),
              void (t.data.onload = function () {
                n.revokeObjectURL(i), (t.data.onload = null), e();
              })
            );
          }
        } else {
          var r = t.xhr.getResponseHeader("content-type");
          if (r && 0 === r.indexOf("image"))
            return (
              (t.data = new Image()),
              (t.data.src =
                "data:" +
                r +
                ";base64," +
                (function (t) {
                  for (var e = "", n = 0; n < t.length; ) {
                    for (
                      var i = [0, 0, 0], r = [0, 0, 0, 0], s = 0;
                      s < i.length;
                      ++s
                    )
                      n < t.length
                        ? (i[s] = 255 & t.charCodeAt(n++))
                        : (i[s] = 0);
                    switch (
                      ((r[0] = i[0] >> 2),
                      (r[1] = ((3 & i[0]) << 4) | (i[1] >> 4)),
                      (r[2] = ((15 & i[1]) << 2) | (i[2] >> 6)),
                      (r[3] = 63 & i[2]),
                      n - (t.length - 1))
                    ) {
                      case 2:
                        (r[3] = 64), (r[2] = 64);
                        break;
                      case 1:
                        r[3] = 64;
                    }
                    for (s = 0; s < r.length; ++s)
                      e +=
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(
                          r[s]
                        );
                  }
                  return e;
                })(t.xhr.responseText)),
              (t.type = fy.TYPE.IMAGE),
              void (t.data.onload = function () {
                (t.data.onload = null), e();
              })
            );
        }
      e();
    } else e();
  }
  var Sy,
    wy,
    My,
    Ay = (function () {
      function t() {}
      return (t.extension = x_.Loader), (t.use = Ey), t;
    })();
  M_.add(Ty, Ay),
    ((My = wy || (wy = {}))[(My.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776)] =
      "COMPRESSED_RGB_S3TC_DXT1_EXT"),
    (My[(My.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777)] =
      "COMPRESSED_RGBA_S3TC_DXT1_EXT"),
    (My[(My.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778)] =
      "COMPRESSED_RGBA_S3TC_DXT3_EXT"),
    (My[(My.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779)] =
      "COMPRESSED_RGBA_S3TC_DXT5_EXT"),
    (My[(My.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"),
    (My[(My.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"),
    (My[(My.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"),
    (My[(My.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916)] =
      "COMPRESSED_SRGB_S3TC_DXT1_EXT"),
    (My[(My.COMPRESSED_R11_EAC = 37488)] = "COMPRESSED_R11_EAC"),
    (My[(My.COMPRESSED_SIGNED_R11_EAC = 37489)] = "COMPRESSED_SIGNED_R11_EAC"),
    (My[(My.COMPRESSED_RG11_EAC = 37490)] = "COMPRESSED_RG11_EAC"),
    (My[(My.COMPRESSED_SIGNED_RG11_EAC = 37491)] =
      "COMPRESSED_SIGNED_RG11_EAC"),
    (My[(My.COMPRESSED_RGB8_ETC2 = 37492)] = "COMPRESSED_RGB8_ETC2"),
    (My[(My.COMPRESSED_RGBA8_ETC2_EAC = 37496)] = "COMPRESSED_RGBA8_ETC2_EAC"),
    (My[(My.COMPRESSED_SRGB8_ETC2 = 37493)] = "COMPRESSED_SRGB8_ETC2"),
    (My[(My.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497)] =
      "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"),
    (My[(My.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494)] =
      "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
    (My[(My.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495)] =
      "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
    (My[(My.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840)] =
      "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"),
    (My[(My.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842)] =
      "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"),
    (My[(My.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841)] =
      "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"),
    (My[(My.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843)] =
      "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"),
    (My[(My.COMPRESSED_RGB_ETC1_WEBGL = 36196)] = "COMPRESSED_RGB_ETC1_WEBGL"),
    (My[(My.COMPRESSED_RGB_ATC_WEBGL = 35986)] = "COMPRESSED_RGB_ATC_WEBGL"),
    (My[(My.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986)] =
      "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"),
    (My[(My.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798)] =
      "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL");
  var Ry =
      (((Sy = {})[wy.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5),
      (Sy[wy.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5),
      (Sy[wy.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1),
      (Sy[wy.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1),
      (Sy[wy.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5),
      (Sy[wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5),
      (Sy[wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1),
      (Sy[wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1),
      (Sy[wy.COMPRESSED_R11_EAC] = 0.5),
      (Sy[wy.COMPRESSED_SIGNED_R11_EAC] = 0.5),
      (Sy[wy.COMPRESSED_RG11_EAC] = 1),
      (Sy[wy.COMPRESSED_SIGNED_RG11_EAC] = 1),
      (Sy[wy.COMPRESSED_RGB8_ETC2] = 0.5),
      (Sy[wy.COMPRESSED_RGBA8_ETC2_EAC] = 1),
      (Sy[wy.COMPRESSED_SRGB8_ETC2] = 0.5),
      (Sy[wy.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1),
      (Sy[wy.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5),
      (Sy[wy.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5),
      (Sy[wy.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5),
      (Sy[wy.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5),
      (Sy[wy.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25),
      (Sy[wy.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25),
      (Sy[wy.COMPRESSED_RGB_ETC1_WEBGL] = 0.5),
      (Sy[wy.COMPRESSED_RGB_ATC_WEBGL] = 0.5),
      (Sy[wy.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1),
      (Sy[wy.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1),
      Sy),
    Cy = function (t, e) {
      return (Cy =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function Iy(t, e) {
    function n() {
      this.constructor = t;
    }
    Cy(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  function Py(t, e, n, i) {
    return new (n || (n = Promise))(function (r, s) {
      function o(t) {
        try {
          l(i.next(t));
        } catch (e) {
          s(e);
        }
      }
      function a(t) {
        try {
          l(i.throw(t));
        } catch (e) {
          s(e);
        }
      }
      function l(t) {
        var e;
        t.done
          ? r(t.value)
          : ((e = t.value),
            e instanceof n
              ? e
              : new n(function (t) {
                  t(e);
                })).then(o, a);
      }
      l((i = i.apply(t, e || [])).next());
    });
  }
  function Oy(t, e) {
    var n,
      i,
      r,
      s,
      o = {
        label: 0,
        sent: function () {
          if (1 & r[0]) throw r[1];
          return r[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (s = { next: a(0), throw: a(1), return: a(2) }),
      "function" == typeof Symbol &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function a(s) {
      return function (a) {
        return (function (s) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; o; )
            try {
              if (
                ((n = 1),
                i &&
                  (r =
                    2 & s[0]
                      ? i.return
                      : s[0]
                      ? i.throw || ((r = i.return) && r.call(i), 0)
                      : i.next) &&
                  !(r = r.call(i, s[1])).done)
              )
                return r;
              switch (((i = 0), r && (s = [2 & s[0], r.value]), s[0])) {
                case 0:
                case 1:
                  r = s;
                  break;
                case 4:
                  return o.label++, { value: s[1], done: !1 };
                case 5:
                  o.label++, (i = s[1]), (s = [0]);
                  continue;
                case 7:
                  (s = o.ops.pop()), o.trys.pop();
                  continue;
                default:
                  if (
                    !((r = o.trys),
                    (r = r.length > 0 && r[r.length - 1]) ||
                      (6 !== s[0] && 2 !== s[0]))
                  ) {
                    o = 0;
                    continue;
                  }
                  if (3 === s[0] && (!r || (s[1] > r[0] && s[1] < r[3]))) {
                    o.label = s[1];
                    break;
                  }
                  if (6 === s[0] && o.label < r[1]) {
                    (o.label = r[1]), (r = s);
                    break;
                  }
                  if (r && o.label < r[2]) {
                    (o.label = r[2]), o.ops.push(s);
                    break;
                  }
                  r[2] && o.ops.pop(), o.trys.pop();
                  continue;
              }
              s = e.call(t, o);
            } catch (a) {
              (s = [6, a]), (i = 0);
            } finally {
              n = r = 0;
            }
          if (5 & s[0]) throw s[1];
          return { value: s[0] ? s[1] : void 0, done: !0 };
        })([s, a]);
      };
    }
  }
  var Ny,
    Dy,
    Ly = (function (t) {
      function e(n, i) {
        var r = t.call(this, n, i) || this;
        return (
          (r.format = i.format),
          (r.levels = i.levels || 1),
          (r._width = i.width),
          (r._height = i.height),
          (r._extension = e._formatToExtension(r.format)),
          (i.levelBuffers || r.buffer) &&
            (r._levelBuffers =
              i.levelBuffers ||
              e._createLevelBuffers(
                n instanceof Uint8Array ? n : r.buffer.uint8View,
                r.format,
                r.levels,
                4,
                4,
                r.width,
                r.height
              )),
          r
        );
      }
      return (
        Iy(e, t),
        (e.prototype.upload = function (t, e, n) {
          var i = t.gl;
          if (!t.context.extensions[this._extension])
            throw new Error(
              this._extension +
                " textures are not supported on the current machine"
            );
          if (!this._levelBuffers) return !1;
          for (var r = 0, s = this.levels; r < s; r++) {
            var o = this._levelBuffers[r],
              a = o.levelID,
              l = o.levelWidth,
              h = o.levelHeight,
              u = o.levelBuffer;
            i.compressedTexImage2D(i.TEXTURE_2D, a, this.format, l, h, 0, u);
          }
          return !0;
        }),
        (e.prototype.onBlobLoaded = function () {
          this._levelBuffers = e._createLevelBuffers(
            this.buffer.uint8View,
            this.format,
            this.levels,
            4,
            4,
            this.width,
            this.height
          );
        }),
        (e._formatToExtension = function (t) {
          if (t >= 33776 && t <= 33779) return "s3tc";
          if (t >= 37488 && t <= 37497) return "etc";
          if (t >= 35840 && t <= 35843) return "pvrtc";
          if (t >= 36196) return "etc1";
          if (t >= 35986 && t <= 34798) return "atc";
          throw new Error("Invalid (compressed) texture format given!");
        }),
        (e._createLevelBuffers = function (t, e, n, i, r, s, o) {
          for (
            var a = new Array(n),
              l = t.byteOffset,
              h = s,
              u = o,
              c = (h + i - 1) & ~(i - 1),
              d = (u + r - 1) & ~(r - 1),
              p = c * d * Ry[e],
              f = 0;
            f < n;
            f++
          )
            (a[f] = {
              levelID: f,
              levelWidth: n > 1 ? h : c,
              levelHeight: n > 1 ? u : d,
              levelBuffer: new Uint8Array(t.buffer, l, p),
            }),
              (l += p),
              (p =
                (c = ((h = h >> 1 || 1) + i - 1) & ~(i - 1)) *
                (d = ((u = u >> 1 || 1) + r - 1) & ~(r - 1)) *
                Ry[e]);
          return a;
        }),
        e
      );
    })(
      (function (t) {
        function e(e, n) {
          void 0 === n && (n = { width: 1, height: 1, autoLoad: !0 });
          var i,
            r,
            s = this;
          return (
            "string" == typeof e
              ? ((i = e), (r = new Uint8Array()))
              : ((i = null), (r = e)),
            ((s = t.call(this, r, n) || this).origin = i),
            (s.buffer = r ? new Fv(r) : null),
            s.origin && !1 !== n.autoLoad && s.load(),
            r &&
              r.length &&
              ((s.loaded = !0), s.onBlobLoaded(s.buffer.rawBinaryData)),
            s
          );
        }
        return (
          Iy(e, t),
          (e.prototype.onBlobLoaded = function (t) {}),
          (e.prototype.load = function () {
            return Py(this, void 0, Promise, function () {
              var t;
              return Oy(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, fetch(this.origin)];
                  case 1:
                    return [4, e.sent().blob()];
                  case 2:
                    return [4, e.sent().arrayBuffer()];
                  case 3:
                    return (
                      (t = e.sent()),
                      (this.data = new Uint32Array(t)),
                      (this.buffer = new Fv(t)),
                      (this.loaded = !0),
                      this.onBlobLoaded(t),
                      this.update(),
                      [2, this]
                    );
                }
              });
            });
          }),
          e
        );
      })(U_)
    ),
    Fy = (function () {
      function t() {}
      return (
        (t.use = function (e, n) {
          var i = e.data;
          if (e.type === fy.TYPE.JSON && i && i.cacheID && i.textures) {
            for (
              var r = i.textures, s = void 0, o = void 0, a = 0, l = r.length;
              a < l;
              a++
            ) {
              var h = r[a],
                u = h.src,
                c = h.format;
              if ((c || (o = u), t.textureFormats[c])) {
                s = u;
                break;
              }
            }
            if (!(s = s || o))
              return void n(
                new Error(
                  "Cannot load compressed-textures in " +
                    e.url +
                    ", make sure you provide a fallback"
                )
              );
            if (s === e.url)
              return void n(
                new Error(
                  "URL of compressed texture cannot be the same as the manifest's URL"
                )
              );
            var d = {
                crossOrigin: e.crossOrigin,
                metadata: e.metadata.imageMetadata,
                parentResource: e,
              },
              p = Jf.resolve(e.url.replace(this.baseUrl, ""), s),
              f = i.cacheID;
            this.add(f, p, d, function (t) {
              if (t.error) n(t.error);
              else {
                var i = t.texture,
                  r = void 0 === i ? null : i,
                  s = t.textures,
                  o = void 0 === s ? {} : s;
                Object.assign(e, { texture: r, textures: o }), n();
              }
            });
          } else n();
        }),
        Object.defineProperty(t, "textureExtensions", {
          get: function () {
            if (!t._textureExtensions) {
              var e = document.createElement("canvas").getContext("webgl");
              if (!e)
                return (
                  console.warn(
                    "WebGL not available for compressed textures. Silently failing."
                  ),
                  {}
                );
              var n = {
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc:
                  e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
              };
              t._textureExtensions = n;
            }
            return t._textureExtensions;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t, "textureFormats", {
          get: function () {
            if (!t._textureFormats) {
              var e = t.textureExtensions;
              for (var n in ((t._textureFormats = {}), e)) {
                var i = e[n];
                i && Object.assign(t._textureFormats, Object.getPrototypeOf(i));
              }
            }
            return t._textureFormats;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.extension = x_.Loader),
        t
      );
    })();
  function Uy(t, e, n) {
    var i = { textures: {}, texture: null };
    return e
      ? (e
          .map(function (t) {
            return new eg(
              new k_(
                t,
                Object.assign(
                  { mipmap: Rf.OFF, alphaMode: Cf.NO_PREMULTIPLIED_ALPHA },
                  n
                )
              )
            );
          })
          .forEach(function (e, n) {
            var r = e.baseTexture,
              s = t + "-" + (n + 1);
            k_.addToCache(r, s),
              eg.addToCache(e, s),
              0 === n &&
                (k_.addToCache(r, t), eg.addToCache(e, t), (i.texture = e)),
              (i.textures[s] = e);
          }),
        i)
      : i;
  }
  var By,
    ky,
    Gy,
    Hy,
    zy = 124,
    Vy = 3,
    Xy = 4,
    Wy = 7,
    jy = 19,
    Yy = 2,
    qy = 0,
    Ky = 1,
    Zy = 2,
    Jy = 3;
  ((ky = By || (By = {}))[(ky.DXGI_FORMAT_UNKNOWN = 0)] =
    "DXGI_FORMAT_UNKNOWN"),
    (ky[(ky.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1)] =
      "DXGI_FORMAT_R32G32B32A32_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R32G32B32A32_FLOAT = 2)] =
      "DXGI_FORMAT_R32G32B32A32_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R32G32B32A32_UINT = 3)] =
      "DXGI_FORMAT_R32G32B32A32_UINT"),
    (ky[(ky.DXGI_FORMAT_R32G32B32A32_SINT = 4)] =
      "DXGI_FORMAT_R32G32B32A32_SINT"),
    (ky[(ky.DXGI_FORMAT_R32G32B32_TYPELESS = 5)] =
      "DXGI_FORMAT_R32G32B32_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R32G32B32_FLOAT = 6)] = "DXGI_FORMAT_R32G32B32_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R32G32B32_UINT = 7)] = "DXGI_FORMAT_R32G32B32_UINT"),
    (ky[(ky.DXGI_FORMAT_R32G32B32_SINT = 8)] = "DXGI_FORMAT_R32G32B32_SINT"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9)] =
      "DXGI_FORMAT_R16G16B16A16_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_FLOAT = 10)] =
      "DXGI_FORMAT_R16G16B16A16_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_UNORM = 11)] =
      "DXGI_FORMAT_R16G16B16A16_UNORM"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_UINT = 12)] =
      "DXGI_FORMAT_R16G16B16A16_UINT"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_SNORM = 13)] =
      "DXGI_FORMAT_R16G16B16A16_SNORM"),
    (ky[(ky.DXGI_FORMAT_R16G16B16A16_SINT = 14)] =
      "DXGI_FORMAT_R16G16B16A16_SINT"),
    (ky[(ky.DXGI_FORMAT_R32G32_TYPELESS = 15)] = "DXGI_FORMAT_R32G32_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R32G32_FLOAT = 16)] = "DXGI_FORMAT_R32G32_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R32G32_UINT = 17)] = "DXGI_FORMAT_R32G32_UINT"),
    (ky[(ky.DXGI_FORMAT_R32G32_SINT = 18)] = "DXGI_FORMAT_R32G32_SINT"),
    (ky[(ky.DXGI_FORMAT_R32G8X24_TYPELESS = 19)] =
      "DXGI_FORMAT_R32G8X24_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20)] =
      "DXGI_FORMAT_D32_FLOAT_S8X24_UINT"),
    (ky[(ky.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21)] =
      "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22)] =
      "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"),
    (ky[(ky.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23)] =
      "DXGI_FORMAT_R10G10B10A2_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R10G10B10A2_UNORM = 24)] =
      "DXGI_FORMAT_R10G10B10A2_UNORM"),
    (ky[(ky.DXGI_FORMAT_R10G10B10A2_UINT = 25)] =
      "DXGI_FORMAT_R10G10B10A2_UINT"),
    (ky[(ky.DXGI_FORMAT_R11G11B10_FLOAT = 26)] = "DXGI_FORMAT_R11G11B10_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27)] =
      "DXGI_FORMAT_R8G8B8A8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_UNORM = 28)] = "DXGI_FORMAT_R8G8B8A8_UNORM"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29)] =
      "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_UINT = 30)] = "DXGI_FORMAT_R8G8B8A8_UINT"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_SNORM = 31)] = "DXGI_FORMAT_R8G8B8A8_SNORM"),
    (ky[(ky.DXGI_FORMAT_R8G8B8A8_SINT = 32)] = "DXGI_FORMAT_R8G8B8A8_SINT"),
    (ky[(ky.DXGI_FORMAT_R16G16_TYPELESS = 33)] = "DXGI_FORMAT_R16G16_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R16G16_FLOAT = 34)] = "DXGI_FORMAT_R16G16_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R16G16_UNORM = 35)] = "DXGI_FORMAT_R16G16_UNORM"),
    (ky[(ky.DXGI_FORMAT_R16G16_UINT = 36)] = "DXGI_FORMAT_R16G16_UINT"),
    (ky[(ky.DXGI_FORMAT_R16G16_SNORM = 37)] = "DXGI_FORMAT_R16G16_SNORM"),
    (ky[(ky.DXGI_FORMAT_R16G16_SINT = 38)] = "DXGI_FORMAT_R16G16_SINT"),
    (ky[(ky.DXGI_FORMAT_R32_TYPELESS = 39)] = "DXGI_FORMAT_R32_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_D32_FLOAT = 40)] = "DXGI_FORMAT_D32_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R32_FLOAT = 41)] = "DXGI_FORMAT_R32_FLOAT"),
    (ky[(ky.DXGI_FORMAT_R32_UINT = 42)] = "DXGI_FORMAT_R32_UINT"),
    (ky[(ky.DXGI_FORMAT_R32_SINT = 43)] = "DXGI_FORMAT_R32_SINT"),
    (ky[(ky.DXGI_FORMAT_R24G8_TYPELESS = 44)] = "DXGI_FORMAT_R24G8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_D24_UNORM_S8_UINT = 45)] =
      "DXGI_FORMAT_D24_UNORM_S8_UINT"),
    (ky[(ky.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46)] =
      "DXGI_FORMAT_R24_UNORM_X8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47)] =
      "DXGI_FORMAT_X24_TYPELESS_G8_UINT"),
    (ky[(ky.DXGI_FORMAT_R8G8_TYPELESS = 48)] = "DXGI_FORMAT_R8G8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R8G8_UNORM = 49)] = "DXGI_FORMAT_R8G8_UNORM"),
    (ky[(ky.DXGI_FORMAT_R8G8_UINT = 50)] = "DXGI_FORMAT_R8G8_UINT"),
    (ky[(ky.DXGI_FORMAT_R8G8_SNORM = 51)] = "DXGI_FORMAT_R8G8_SNORM"),
    (ky[(ky.DXGI_FORMAT_R8G8_SINT = 52)] = "DXGI_FORMAT_R8G8_SINT"),
    (ky[(ky.DXGI_FORMAT_R16_TYPELESS = 53)] = "DXGI_FORMAT_R16_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R16_FLOAT = 54)] = "DXGI_FORMAT_R16_FLOAT"),
    (ky[(ky.DXGI_FORMAT_D16_UNORM = 55)] = "DXGI_FORMAT_D16_UNORM"),
    (ky[(ky.DXGI_FORMAT_R16_UNORM = 56)] = "DXGI_FORMAT_R16_UNORM"),
    (ky[(ky.DXGI_FORMAT_R16_UINT = 57)] = "DXGI_FORMAT_R16_UINT"),
    (ky[(ky.DXGI_FORMAT_R16_SNORM = 58)] = "DXGI_FORMAT_R16_SNORM"),
    (ky[(ky.DXGI_FORMAT_R16_SINT = 59)] = "DXGI_FORMAT_R16_SINT"),
    (ky[(ky.DXGI_FORMAT_R8_TYPELESS = 60)] = "DXGI_FORMAT_R8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_R8_UNORM = 61)] = "DXGI_FORMAT_R8_UNORM"),
    (ky[(ky.DXGI_FORMAT_R8_UINT = 62)] = "DXGI_FORMAT_R8_UINT"),
    (ky[(ky.DXGI_FORMAT_R8_SNORM = 63)] = "DXGI_FORMAT_R8_SNORM"),
    (ky[(ky.DXGI_FORMAT_R8_SINT = 64)] = "DXGI_FORMAT_R8_SINT"),
    (ky[(ky.DXGI_FORMAT_A8_UNORM = 65)] = "DXGI_FORMAT_A8_UNORM"),
    (ky[(ky.DXGI_FORMAT_R1_UNORM = 66)] = "DXGI_FORMAT_R1_UNORM"),
    (ky[(ky.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67)] =
      "DXGI_FORMAT_R9G9B9E5_SHAREDEXP"),
    (ky[(ky.DXGI_FORMAT_R8G8_B8G8_UNORM = 68)] = "DXGI_FORMAT_R8G8_B8G8_UNORM"),
    (ky[(ky.DXGI_FORMAT_G8R8_G8B8_UNORM = 69)] = "DXGI_FORMAT_G8R8_G8B8_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC1_TYPELESS = 70)] = "DXGI_FORMAT_BC1_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC1_UNORM = 71)] = "DXGI_FORMAT_BC1_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC1_UNORM_SRGB = 72)] = "DXGI_FORMAT_BC1_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_BC2_TYPELESS = 73)] = "DXGI_FORMAT_BC2_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC2_UNORM = 74)] = "DXGI_FORMAT_BC2_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC2_UNORM_SRGB = 75)] = "DXGI_FORMAT_BC2_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_BC3_TYPELESS = 76)] = "DXGI_FORMAT_BC3_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC3_UNORM = 77)] = "DXGI_FORMAT_BC3_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC3_UNORM_SRGB = 78)] = "DXGI_FORMAT_BC3_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_BC4_TYPELESS = 79)] = "DXGI_FORMAT_BC4_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC4_UNORM = 80)] = "DXGI_FORMAT_BC4_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC4_SNORM = 81)] = "DXGI_FORMAT_BC4_SNORM"),
    (ky[(ky.DXGI_FORMAT_BC5_TYPELESS = 82)] = "DXGI_FORMAT_BC5_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC5_UNORM = 83)] = "DXGI_FORMAT_BC5_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC5_SNORM = 84)] = "DXGI_FORMAT_BC5_SNORM"),
    (ky[(ky.DXGI_FORMAT_B5G6R5_UNORM = 85)] = "DXGI_FORMAT_B5G6R5_UNORM"),
    (ky[(ky.DXGI_FORMAT_B5G5R5A1_UNORM = 86)] = "DXGI_FORMAT_B5G5R5A1_UNORM"),
    (ky[(ky.DXGI_FORMAT_B8G8R8A8_UNORM = 87)] = "DXGI_FORMAT_B8G8R8A8_UNORM"),
    (ky[(ky.DXGI_FORMAT_B8G8R8X8_UNORM = 88)] = "DXGI_FORMAT_B8G8R8X8_UNORM"),
    (ky[(ky.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89)] =
      "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"),
    (ky[(ky.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90)] =
      "DXGI_FORMAT_B8G8R8A8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91)] =
      "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92)] =
      "DXGI_FORMAT_B8G8R8X8_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93)] =
      "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_BC6H_TYPELESS = 94)] = "DXGI_FORMAT_BC6H_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC6H_UF16 = 95)] = "DXGI_FORMAT_BC6H_UF16"),
    (ky[(ky.DXGI_FORMAT_BC6H_SF16 = 96)] = "DXGI_FORMAT_BC6H_SF16"),
    (ky[(ky.DXGI_FORMAT_BC7_TYPELESS = 97)] = "DXGI_FORMAT_BC7_TYPELESS"),
    (ky[(ky.DXGI_FORMAT_BC7_UNORM = 98)] = "DXGI_FORMAT_BC7_UNORM"),
    (ky[(ky.DXGI_FORMAT_BC7_UNORM_SRGB = 99)] = "DXGI_FORMAT_BC7_UNORM_SRGB"),
    (ky[(ky.DXGI_FORMAT_AYUV = 100)] = "DXGI_FORMAT_AYUV"),
    (ky[(ky.DXGI_FORMAT_Y410 = 101)] = "DXGI_FORMAT_Y410"),
    (ky[(ky.DXGI_FORMAT_Y416 = 102)] = "DXGI_FORMAT_Y416"),
    (ky[(ky.DXGI_FORMAT_NV12 = 103)] = "DXGI_FORMAT_NV12"),
    (ky[(ky.DXGI_FORMAT_P010 = 104)] = "DXGI_FORMAT_P010"),
    (ky[(ky.DXGI_FORMAT_P016 = 105)] = "DXGI_FORMAT_P016"),
    (ky[(ky.DXGI_FORMAT_420_OPAQUE = 106)] = "DXGI_FORMAT_420_OPAQUE"),
    (ky[(ky.DXGI_FORMAT_YUY2 = 107)] = "DXGI_FORMAT_YUY2"),
    (ky[(ky.DXGI_FORMAT_Y210 = 108)] = "DXGI_FORMAT_Y210"),
    (ky[(ky.DXGI_FORMAT_Y216 = 109)] = "DXGI_FORMAT_Y216"),
    (ky[(ky.DXGI_FORMAT_NV11 = 110)] = "DXGI_FORMAT_NV11"),
    (ky[(ky.DXGI_FORMAT_AI44 = 111)] = "DXGI_FORMAT_AI44"),
    (ky[(ky.DXGI_FORMAT_IA44 = 112)] = "DXGI_FORMAT_IA44"),
    (ky[(ky.DXGI_FORMAT_P8 = 113)] = "DXGI_FORMAT_P8"),
    (ky[(ky.DXGI_FORMAT_A8P8 = 114)] = "DXGI_FORMAT_A8P8"),
    (ky[(ky.DXGI_FORMAT_B4G4R4A4_UNORM = 115)] = "DXGI_FORMAT_B4G4R4A4_UNORM"),
    (ky[(ky.DXGI_FORMAT_P208 = 116)] = "DXGI_FORMAT_P208"),
    (ky[(ky.DXGI_FORMAT_V208 = 117)] = "DXGI_FORMAT_V208"),
    (ky[(ky.DXGI_FORMAT_V408 = 118)] = "DXGI_FORMAT_V408"),
    (ky[(ky.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119)] =
      "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"),
    (ky[(ky.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120)] =
      "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"),
    (ky[(ky.DXGI_FORMAT_FORCE_UINT = 121)] = "DXGI_FORMAT_FORCE_UINT"),
    ((Hy = Gy || (Gy = {}))[(Hy.DDS_DIMENSION_TEXTURE1D = 2)] =
      "DDS_DIMENSION_TEXTURE1D"),
    (Hy[(Hy.DDS_DIMENSION_TEXTURE2D = 3)] = "DDS_DIMENSION_TEXTURE2D"),
    (Hy[(Hy.DDS_DIMENSION_TEXTURE3D = 6)] = "DDS_DIMENSION_TEXTURE3D");
  var $y,
    Qy,
    tx,
    ex =
      (((Ny = {})[827611204] = wy.COMPRESSED_RGBA_S3TC_DXT1_EXT),
      (Ny[861165636] = wy.COMPRESSED_RGBA_S3TC_DXT3_EXT),
      (Ny[894720068] = wy.COMPRESSED_RGBA_S3TC_DXT5_EXT),
      Ny),
    nx =
      (((Dy = {})[By.DXGI_FORMAT_BC1_TYPELESS] =
        wy.COMPRESSED_RGBA_S3TC_DXT1_EXT),
      (Dy[By.DXGI_FORMAT_BC1_UNORM] = wy.COMPRESSED_RGBA_S3TC_DXT1_EXT),
      (Dy[By.DXGI_FORMAT_BC2_TYPELESS] = wy.COMPRESSED_RGBA_S3TC_DXT3_EXT),
      (Dy[By.DXGI_FORMAT_BC2_UNORM] = wy.COMPRESSED_RGBA_S3TC_DXT3_EXT),
      (Dy[By.DXGI_FORMAT_BC3_TYPELESS] = wy.COMPRESSED_RGBA_S3TC_DXT5_EXT),
      (Dy[By.DXGI_FORMAT_BC3_UNORM] = wy.COMPRESSED_RGBA_S3TC_DXT5_EXT),
      (Dy[By.DXGI_FORMAT_BC1_UNORM_SRGB] =
        wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT),
      (Dy[By.DXGI_FORMAT_BC2_UNORM_SRGB] =
        wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT),
      (Dy[By.DXGI_FORMAT_BC3_UNORM_SRGB] =
        wy.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),
      Dy);
  var ix = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    rx = 12,
    sx = 16,
    ox = 24,
    ax = 28,
    lx = 36,
    hx = 40,
    ux = 44,
    cx = 48,
    dx = 52,
    px = 56,
    fx = 60,
    mx =
      ((($y = {})[Sf.UNSIGNED_BYTE] = 1),
      ($y[Sf.UNSIGNED_SHORT] = 2),
      ($y[Sf.INT] = 4),
      ($y[Sf.UNSIGNED_INT] = 4),
      ($y[Sf.FLOAT] = 4),
      ($y[Sf.HALF_FLOAT] = 8),
      $y),
    _x =
      (((Qy = {})[Tf.RGBA] = 4),
      (Qy[Tf.RGB] = 3),
      (Qy[Tf.RG] = 2),
      (Qy[Tf.RED] = 1),
      (Qy[Tf.LUMINANCE] = 1),
      (Qy[Tf.LUMINANCE_ALPHA] = 2),
      (Qy[Tf.ALPHA] = 1),
      Qy),
    gx =
      (((tx = {})[Sf.UNSIGNED_SHORT_4_4_4_4] = 2),
      (tx[Sf.UNSIGNED_SHORT_5_5_5_1] = 2),
      (tx[Sf.UNSIGNED_SHORT_5_6_5] = 2),
      tx);
  function vx(t, e, n) {
    void 0 === n && (n = !1);
    var i = new DataView(e);
    if (
      !(function (t, e) {
        for (var n = 0; n < ix.length; n++)
          if (e.getUint8(n) !== ix[n])
            return console.error(t + " is not a valid *.ktx file!"), !1;
        return !0;
      })(t, i)
    )
      return null;
    var r = 67305985 === i.getUint32(rx, !0),
      s = i.getUint32(sx, r),
      o = i.getUint32(ox, r),
      a = i.getUint32(ax, r),
      l = i.getUint32(lx, r),
      h = i.getUint32(hx, r) || 1,
      u = i.getUint32(ux, r) || 1,
      c = i.getUint32(cx, r) || 1,
      d = i.getUint32(dx, r),
      p = i.getUint32(px, r),
      f = i.getUint32(fx, r);
    if (0 === h || 1 !== u) throw new Error("Only 2D textures are supported");
    if (1 !== d)
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (1 !== c) throw new Error("WebGL does not support array textures");
    var m,
      _ = (l + 3) & -4,
      g = (h + 3) & -4,
      v = new Array(c),
      y = l * h;
    if (
      (0 === s && (y = _ * g),
      void 0 === (m = 0 !== s ? (mx[s] ? mx[s] * _x[o] : gx[s]) : Ry[a]))
    )
      throw new Error(
        "Unable to resolve the pixel format stored in the *.ktx file!"
      );
    for (
      var x = n
          ? (function (t, e, n) {
              var i = new Map(),
                r = 0;
              for (; r < e; ) {
                var s = t.getUint32(64 + r, n),
                  o = 64 + r + 4,
                  a = 3 - ((s + 3) % 4);
                if (0 === s || s > e - r) {
                  console.error("KTXLoader: keyAndValueByteSize out of bounds");
                  break;
                }
                for (var l = 0; l < s && 0 !== t.getUint8(o + l); l++);
                if (-1 === l) {
                  console.error(
                    "KTXLoader: Failed to find null byte terminating kvData key"
                  );
                  break;
                }
                var h = new TextDecoder().decode(
                    new Uint8Array(t.buffer, o, l)
                  ),
                  u = new DataView(t.buffer, o + l + 1, s - l - 1);
                i.set(h, u), (r += 4 + s + a);
              }
              return i;
            })(i, f, r)
          : null,
        b = y * m,
        T = l,
        E = h,
        S = _,
        w = g,
        M = 64 + f,
        A = 0;
      A < p;
      A++
    ) {
      for (var R = i.getUint32(M, r), C = M + 4, I = 0; I < c; I++) {
        var P = v[I];
        P || (P = v[I] = new Array(p)),
          (P[A] = {
            levelID: A,
            levelWidth: p > 1 || 0 !== s ? T : S,
            levelHeight: p > 1 || 0 !== s ? E : w,
            levelBuffer: new Uint8Array(e, C, b),
          }),
          (C += b);
      }
      (M = (M += R + 4) % 4 != 0 ? M + 4 - (M % 4) : M),
        (b =
          (S = ((T = T >> 1 || 1) + 4 - 1) & -4) *
          (w = ((E = E >> 1 || 1) + 4 - 1) & -4) *
          m);
    }
    return 0 !== s
      ? {
          uncompressed: v.map(function (t) {
            var e = t[0].levelBuffer,
              n = !1;
            return (
              s === Sf.FLOAT
                ? (e = new Float32Array(
                    t[0].levelBuffer.buffer,
                    t[0].levelBuffer.byteOffset,
                    t[0].levelBuffer.byteLength / 4
                  ))
                : s === Sf.UNSIGNED_INT
                ? ((n = !0),
                  (e = new Uint32Array(
                    t[0].levelBuffer.buffer,
                    t[0].levelBuffer.byteOffset,
                    t[0].levelBuffer.byteLength / 4
                  )))
                : s === Sf.INT &&
                  ((n = !0),
                  (e = new Int32Array(
                    t[0].levelBuffer.buffer,
                    t[0].levelBuffer.byteOffset,
                    t[0].levelBuffer.byteLength / 4
                  ))),
              {
                resource: new U_(e, {
                  width: t[0].levelWidth,
                  height: t[0].levelHeight,
                }),
                type: s,
                format: n ? yx(o) : o,
              }
            );
          }),
          kvData: x,
        }
      : {
          compressed: v.map(function (t) {
            return new Ly(null, {
              format: a,
              width: l,
              height: h,
              levels: p,
              levelBuffers: t,
            });
          }),
          kvData: x,
        };
  }
  function yx(t) {
    switch (t) {
      case Tf.RGBA:
        return Tf.RGBA_INTEGER;
      case Tf.RGB:
        return Tf.RGB_INTEGER;
      case Tf.RG:
        return Tf.RG_INTEGER;
      case Tf.RED:
        return Tf.RED_INTEGER;
      default:
        return t;
    }
  }
  fy.setExtensionXhrType("dds", fy.XHR_RESPONSE_TYPE.BUFFER);
  var xx = (function () {
    function t() {}
    return (
      (t.use = function (t, e) {
        if ("dds" === t.extension && t.data)
          try {
            Object.assign(
              t,
              Uy(
                t.name || t.url,
                (function (t) {
                  var e = new Uint32Array(t);
                  if (542327876 !== e[0])
                    throw new Error("Invalid DDS file magic word");
                  var n = new Uint32Array(
                      t,
                      0,
                      zy / Uint32Array.BYTES_PER_ELEMENT
                    ),
                    i = n[Vy],
                    r = n[Xy],
                    s = n[Wy],
                    o = new Uint32Array(
                      t,
                      jy * Uint32Array.BYTES_PER_ELEMENT,
                      32 / Uint32Array.BYTES_PER_ELEMENT
                    ),
                    a = o[1];
                  if (4 & a) {
                    var l = o[Yy];
                    if (808540228 !== l) {
                      var h = ex[l],
                        u = new Uint8Array(t, 128);
                      return [
                        new Ly(u, {
                          format: h,
                          width: r,
                          height: i,
                          levels: s,
                        }),
                      ];
                    }
                    var c = new Uint32Array(
                        e.buffer,
                        128,
                        20 / Uint32Array.BYTES_PER_ELEMENT
                      ),
                      d = c[qy],
                      p = c[Ky],
                      f = c[Zy],
                      m = c[Jy],
                      _ = nx[d];
                    if (void 0 === _)
                      throw new Error(
                        "DDSParser cannot parse texture data with DXGI format " +
                          d
                      );
                    if (4 === f)
                      throw new Error(
                        "DDSParser does not support cubemap textures"
                      );
                    if (p === Gy.DDS_DIMENSION_TEXTURE3D)
                      throw new Error(
                        "DDSParser does not supported 3D texture data"
                      );
                    var g = new Array();
                    if (1 === m) g.push(new Uint8Array(t, 148));
                    else {
                      for (
                        var v = Ry[_], y = 0, x = r, b = i, T = 0;
                        T < s;
                        T++
                      )
                        (y +=
                          Math.max(1, (x + 3) & -4) *
                          Math.max(1, (b + 3) & -4) *
                          v),
                          (x >>>= 1),
                          (b >>>= 1);
                      var E = 148;
                      for (T = 0; T < m; T++)
                        g.push(new Uint8Array(t, E, y)), (E += y);
                    }
                    return g.map(function (t) {
                      return new Ly(t, {
                        format: _,
                        width: r,
                        height: i,
                        levels: s,
                      });
                    });
                  }
                  if (64 & a)
                    throw new Error(
                      "DDSParser does not support uncompressed texture data."
                    );
                  if (512 & a)
                    throw new Error(
                      "DDSParser does not supported YUV uncompressed texture data."
                    );
                  if (131072 & a)
                    throw new Error(
                      "DDSParser does not support single-channel (lumninance) texture data!"
                    );
                  if (2 & a)
                    throw new Error(
                      "DDSParser does not support single-channel (alpha) texture data!"
                    );
                  throw new Error(
                    "DDSParser failed to load a texture file due to an unknown reason!"
                  );
                })(t.data),
                t.metadata
              )
            );
          } catch (n) {
            return void e(n);
          }
        e();
      }),
      (t.extension = x_.Loader),
      t
    );
  })();
  fy.setExtensionXhrType("ktx", fy.XHR_RESPONSE_TYPE.BUFFER);
  var bx = (function () {
      function t() {}
      return (
        (t.use = function (t, e) {
          if ("ktx" === t.extension && t.data)
            try {
              var n = t.name || t.url,
                i = vx(n, t.data, this.loadKeyValueData),
                r = i.compressed,
                s = i.uncompressed,
                o = i.kvData;
              if (r) {
                var a = Uy(n, r, t.metadata);
                if (o && a.textures)
                  for (var l in a.textures)
                    a.textures[l].baseTexture.ktxKeyValueData = o;
                Object.assign(t, a);
              } else if (s) {
                var h = {};
                s.forEach(function (t, e) {
                  var i = new eg(
                      new k_(t.resource, {
                        mipmap: Rf.OFF,
                        alphaMode: Cf.NO_PREMULTIPLIED_ALPHA,
                        type: t.type,
                        format: t.format,
                      })
                    ),
                    r = n + "-" + (e + 1);
                  o && (i.baseTexture.ktxKeyValueData = o),
                    k_.addToCache(i.baseTexture, r),
                    eg.addToCache(i, r),
                    0 === e &&
                      ((h[n] = i),
                      k_.addToCache(i.baseTexture, n),
                      eg.addToCache(i, n)),
                    (h[r] = i);
                }),
                  Object.assign(t, { textures: h });
              }
            } catch (u) {
              return void e(u);
            }
          e();
        }),
        (t.extension = x_.Loader),
        (t.loadKeyValueData = !1),
        t
      );
    })(),
    Tx = function (t, e) {
      return (Tx =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function Ex(t, e) {
    function n() {
      this.constructor = t;
    }
    Tx(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  !(function (t) {
    function e(e, n, i, r) {
      void 0 === e && (e = 1500),
        void 0 === i && (i = 16384),
        void 0 === r && (r = !1);
      var s = t.call(this) || this;
      return (
        i > 16384 && (i = 16384),
        (s._properties = [!1, !0, !1, !1, !1]),
        (s._maxSize = e),
        (s._batchSize = i),
        (s._buffers = null),
        (s._bufferUpdateIDs = []),
        (s._updateID = 0),
        (s.interactiveChildren = !1),
        (s.blendMode = xf.NORMAL),
        (s.autoResize = r),
        (s.roundPixels = !0),
        (s.baseTexture = null),
        s.setProperties(n),
        (s._tint = 0),
        (s.tintRgb = new Float32Array(4)),
        (s.tint = 16777215),
        s
      );
    }
    Ex(e, t),
      (e.prototype.setProperties = function (t) {
        t &&
          ((this._properties[0] =
            "vertices" in t || "scale" in t
              ? !!t.vertices || !!t.scale
              : this._properties[0]),
          (this._properties[1] =
            "position" in t ? !!t.position : this._properties[1]),
          (this._properties[2] =
            "rotation" in t ? !!t.rotation : this._properties[2]),
          (this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3]),
          (this._properties[4] =
            "tint" in t || "alpha" in t
              ? !!t.tint || !!t.alpha
              : this._properties[4]));
      }),
      (e.prototype.updateTransform = function () {
        this.displayObjectUpdateTransform();
      }),
      Object.defineProperty(e.prototype, "tint", {
        get: function () {
          return this._tint;
        },
        set: function (t) {
          (this._tint = t), em(t, this.tintRgb);
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.render = function (t) {
        var e = this;
        this.visible &&
          !(this.worldAlpha <= 0) &&
          this.children.length &&
          this.renderable &&
          (this.baseTexture ||
            ((this.baseTexture = this.children[0]._texture.baseTexture),
            this.baseTexture.valid ||
              this.baseTexture.once("update", function () {
                return e.onChildrenChange(0);
              })),
          t.batch.setObjectRenderer(t.plugins.particle),
          t.plugins.particle.render(this));
      }),
      (e.prototype.onChildrenChange = function (t) {
        for (
          var e = Math.floor(t / this._batchSize);
          this._bufferUpdateIDs.length < e;

        )
          this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[e] = ++this._updateID;
      }),
      (e.prototype.dispose = function () {
        if (this._buffers) {
          for (var t = 0; t < this._buffers.length; ++t)
            this._buffers[t].destroy();
          this._buffers = null;
        }
      }),
      (e.prototype.destroy = function (e) {
        t.prototype.destroy.call(this, e),
          this.dispose(),
          (this._properties = null),
          (this._buffers = null),
          (this._bufferUpdateIDs = null);
      });
  })(y_);
  var Sx,
    wx,
    Mx,
    Ax,
    Rx = (function () {
      function t(t, e, n) {
        (this.geometry = new cg()),
          (this.indexBuffer = null),
          (this.size = n),
          (this.dynamicProperties = []),
          (this.staticProperties = []);
        for (var i = 0; i < t.length; ++i) {
          var r = t[i];
          (r = {
            attributeName: r.attributeName,
            size: r.size,
            uploadFunction: r.uploadFunction,
            type: r.type || Sf.FLOAT,
            offset: r.offset,
          }),
            e[i]
              ? this.dynamicProperties.push(r)
              : this.staticProperties.push(r);
        }
        (this.staticStride = 0),
          (this.staticBuffer = null),
          (this.staticData = null),
          (this.staticDataUint32 = null),
          (this.dynamicStride = 0),
          (this.dynamicBuffer = null),
          (this.dynamicData = null),
          (this.dynamicDataUint32 = null),
          (this._updateID = 0),
          this.initBuffers();
      }
      return (
        (t.prototype.initBuffers = function () {
          var t = this.geometry,
            e = 0;
          (this.indexBuffer = new og(
            (function (t, e) {
              void 0 === e && (e = null);
              var n = 6 * t;
              if ((e = e || new Uint16Array(n)).length !== n)
                throw new Error(
                  "Out buffer length is incorrect, got " +
                    e.length +
                    " and expected " +
                    n
                );
              for (var i = 0, r = 0; i < n; i += 6, r += 4)
                (e[i + 0] = r + 0),
                  (e[i + 1] = r + 1),
                  (e[i + 2] = r + 2),
                  (e[i + 3] = r + 0),
                  (e[i + 4] = r + 2),
                  (e[i + 5] = r + 3);
              return e;
            })(this.size),
            !0,
            !0
          )),
            t.addIndex(this.indexBuffer),
            (this.dynamicStride = 0);
          for (var n = 0; n < this.dynamicProperties.length; ++n) {
            ((o = this.dynamicProperties[n]).offset = e),
              (e += o.size),
              (this.dynamicStride += o.size);
          }
          var i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
          (this.dynamicData = new Float32Array(i)),
            (this.dynamicDataUint32 = new Uint32Array(i)),
            (this.dynamicBuffer = new og(this.dynamicData, !1, !1));
          var r = 0;
          this.staticStride = 0;
          for (n = 0; n < this.staticProperties.length; ++n) {
            ((o = this.staticProperties[n]).offset = r),
              (r += o.size),
              (this.staticStride += o.size);
          }
          var s = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
          (this.staticData = new Float32Array(s)),
            (this.staticDataUint32 = new Uint32Array(s)),
            (this.staticBuffer = new og(this.staticData, !0, !1));
          for (n = 0; n < this.dynamicProperties.length; ++n) {
            var o = this.dynamicProperties[n];
            t.addAttribute(
              o.attributeName,
              this.dynamicBuffer,
              0,
              o.type === Sf.UNSIGNED_BYTE,
              o.type,
              4 * this.dynamicStride,
              4 * o.offset
            );
          }
          for (n = 0; n < this.staticProperties.length; ++n) {
            o = this.staticProperties[n];
            t.addAttribute(
              o.attributeName,
              this.staticBuffer,
              0,
              o.type === Sf.UNSIGNED_BYTE,
              o.type,
              4 * this.staticStride,
              4 * o.offset
            );
          }
        }),
        (t.prototype.uploadDynamic = function (t, e, n) {
          for (var i = 0; i < this.dynamicProperties.length; i++) {
            var r = this.dynamicProperties[i];
            r.uploadFunction(
              t,
              e,
              n,
              r.type === Sf.UNSIGNED_BYTE
                ? this.dynamicDataUint32
                : this.dynamicData,
              this.dynamicStride,
              r.offset
            );
          }
          this.dynamicBuffer._updateID++;
        }),
        (t.prototype.uploadStatic = function (t, e, n) {
          for (var i = 0; i < this.staticProperties.length; i++) {
            var r = this.staticProperties[i];
            r.uploadFunction(
              t,
              e,
              n,
              r.type === Sf.UNSIGNED_BYTE
                ? this.staticDataUint32
                : this.staticData,
              this.staticStride,
              r.offset
            );
          }
          this.staticBuffer._updateID++;
        }),
        (t.prototype.destroy = function () {
          (this.indexBuffer = null),
            (this.dynamicProperties = null),
            (this.dynamicBuffer = null),
            (this.dynamicData = null),
            (this.dynamicDataUint32 = null),
            (this.staticProperties = null),
            (this.staticBuffer = null),
            (this.staticData = null),
            (this.staticDataUint32 = null),
            this.geometry.destroy();
        }),
        t
      );
    })(),
    Cx = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.shader = null),
          (n.properties = null),
          (n.tempMatrix = new Um()),
          (n.properties = [
            {
              attributeName: "aVertexPosition",
              size: 2,
              uploadFunction: n.uploadVertices,
              offset: 0,
            },
            {
              attributeName: "aPositionCoord",
              size: 2,
              uploadFunction: n.uploadPosition,
              offset: 0,
            },
            {
              attributeName: "aRotation",
              size: 1,
              uploadFunction: n.uploadRotation,
              offset: 0,
            },
            {
              attributeName: "aTextureCoord",
              size: 2,
              uploadFunction: n.uploadUvs,
              offset: 0,
            },
            {
              attributeName: "aColor",
              size: 1,
              type: Sf.UNSIGNED_BYTE,
              uploadFunction: n.uploadTint,
              offset: 0,
            },
          ]),
          (n.shader = Qg.from(
            "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n",
            "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}",
            {}
          )),
          (n.state = tv.for2d()),
          n
        );
      }
      return (
        Ex(e, t),
        (e.prototype.render = function (t) {
          var e = t.children,
            n = t._maxSize,
            i = t._batchSize,
            r = this.renderer,
            s = e.length;
          if (0 !== s) {
            s > n && !t.autoResize && (s = n);
            var o = t._buffers;
            o || (o = t._buffers = this.generateBuffers(t));
            var a = e[0]._texture.baseTexture,
              l = a.alphaMode > 0;
            (this.state.blendMode = sm(t.blendMode, l)),
              r.state.set(this.state);
            var h,
              u,
              c,
              d,
              p = r.gl,
              f = t.worldTransform.copyTo(this.tempMatrix);
            f.prepend(r.globalUniforms.uniforms.projectionMatrix),
              (this.shader.uniforms.translationMatrix = f.toArray(!0)),
              (this.shader.uniforms.uColor =
                ((h = t.tintRgb),
                (u = t.worldAlpha),
                (c = this.shader.uniforms.uColor),
                (d = l),
                (c = c || new Float32Array(4)),
                d || void 0 === d
                  ? ((c[0] = h[0] * u), (c[1] = h[1] * u), (c[2] = h[2] * u))
                  : ((c[0] = h[0]), (c[1] = h[1]), (c[2] = h[2])),
                (c[3] = u),
                c)),
              (this.shader.uniforms.uSampler = a),
              this.renderer.shader.bind(this.shader);
            for (var m = !1, _ = 0, g = 0; _ < s; _ += i, g += 1) {
              var v = s - _;
              v > i && (v = i),
                g >= o.length && o.push(this._generateOneMoreBuffer(t));
              var y = o[g];
              y.uploadDynamic(e, _, v);
              var x = t._bufferUpdateIDs[g] || 0;
              (m = m || y._updateID < x) &&
                ((y._updateID = t._updateID), y.uploadStatic(e, _, v)),
                r.geometry.bind(y.geometry),
                p.drawElements(p.TRIANGLES, 6 * v, p.UNSIGNED_SHORT, 0);
            }
          }
        }),
        (e.prototype.generateBuffers = function (t) {
          for (
            var e = [],
              n = t._maxSize,
              i = t._batchSize,
              r = t._properties,
              s = 0;
            s < n;
            s += i
          )
            e.push(new Rx(this.properties, r, i));
          return e;
        }),
        (e.prototype._generateOneMoreBuffer = function (t) {
          var e = t._batchSize,
            n = t._properties;
          return new Rx(this.properties, n, e);
        }),
        (e.prototype.uploadVertices = function (t, e, n, i, r, s) {
          for (var o = 0, a = 0, l = 0, h = 0, u = 0; u < n; ++u) {
            var c = t[e + u],
              d = c._texture,
              p = c.scale.x,
              f = c.scale.y,
              m = d.trim,
              _ = d.orig;
            m
              ? ((o = (a = m.x - c.anchor.x * _.width) + m.width),
                (l = (h = m.y - c.anchor.y * _.height) + m.height))
              : ((o = _.width * (1 - c.anchor.x)),
                (a = _.width * -c.anchor.x),
                (l = _.height * (1 - c.anchor.y)),
                (h = _.height * -c.anchor.y)),
              (i[s] = a * p),
              (i[s + 1] = h * f),
              (i[s + r] = o * p),
              (i[s + r + 1] = h * f),
              (i[s + 2 * r] = o * p),
              (i[s + 2 * r + 1] = l * f),
              (i[s + 3 * r] = a * p),
              (i[s + 3 * r + 1] = l * f),
              (s += 4 * r);
          }
        }),
        (e.prototype.uploadPosition = function (t, e, n, i, r, s) {
          for (var o = 0; o < n; o++) {
            var a = t[e + o].position;
            (i[s] = a.x),
              (i[s + 1] = a.y),
              (i[s + r] = a.x),
              (i[s + r + 1] = a.y),
              (i[s + 2 * r] = a.x),
              (i[s + 2 * r + 1] = a.y),
              (i[s + 3 * r] = a.x),
              (i[s + 3 * r + 1] = a.y),
              (s += 4 * r);
          }
        }),
        (e.prototype.uploadRotation = function (t, e, n, i, r, s) {
          for (var o = 0; o < n; o++) {
            var a = t[e + o].rotation;
            (i[s] = a),
              (i[s + r] = a),
              (i[s + 2 * r] = a),
              (i[s + 3 * r] = a),
              (s += 4 * r);
          }
        }),
        (e.prototype.uploadUvs = function (t, e, n, i, r, s) {
          for (var o = 0; o < n; ++o) {
            var a = t[e + o]._texture._uvs;
            a
              ? ((i[s] = a.x0),
                (i[s + 1] = a.y0),
                (i[s + r] = a.x1),
                (i[s + r + 1] = a.y1),
                (i[s + 2 * r] = a.x2),
                (i[s + 2 * r + 1] = a.y2),
                (i[s + 3 * r] = a.x3),
                (i[s + 3 * r + 1] = a.y3),
                (s += 4 * r))
              : ((i[s] = 0),
                (i[s + 1] = 0),
                (i[s + r] = 0),
                (i[s + r + 1] = 0),
                (i[s + 2 * r] = 0),
                (i[s + 2 * r + 1] = 0),
                (i[s + 3 * r] = 0),
                (i[s + 3 * r + 1] = 0),
                (s += 4 * r));
          }
        }),
        (e.prototype.uploadTint = function (t, e, n, i, r, s) {
          for (var o = 0; o < n; ++o) {
            var a = t[e + o],
              l = a._texture.baseTexture.alphaMode > 0,
              h = a.alpha,
              u =
                h < 1 && l ? om(a._tintRGB, h) : a._tintRGB + ((255 * h) << 24);
            (i[s] = u),
              (i[s + r] = u),
              (i[s + 2 * r] = u),
              (i[s + 3 * r] = u),
              (s += 4 * r);
          }
        }),
        (e.prototype.destroy = function () {
          t.prototype.destroy.call(this),
            this.shader && (this.shader.destroy(), (this.shader = null)),
            (this.tempMatrix = null);
        }),
        (e.extension = { name: "particle", type: x_.RendererPlugin }),
        e
      );
    })(xg);
  ((wx = Sx || (Sx = {})).MITER = "miter"),
    (wx.BEVEL = "bevel"),
    (wx.ROUND = "round"),
    ((Ax = Mx || (Mx = {})).BUTT = "butt"),
    (Ax.ROUND = "round"),
    (Ax.SQUARE = "square");
  var Ix = {
      adaptive: !0,
      maxLength: 10,
      minSegments: 8,
      maxSegments: 2048,
      epsilon: 1e-4,
      _segmentsCount: function (t, e) {
        if ((void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)))
          return e;
        var n = Math.ceil(t / this.maxLength);
        return (
          n < this.minSegments
            ? (n = this.minSegments)
            : n > this.maxSegments && (n = this.maxSegments),
          n
        );
      },
    },
    Px = (function () {
      function t() {
        (this.color = 16777215),
          (this.alpha = 1),
          (this.texture = eg.WHITE),
          (this.matrix = null),
          (this.visible = !1),
          this.reset();
      }
      return (
        (t.prototype.clone = function () {
          var e = new t();
          return (
            (e.color = this.color),
            (e.alpha = this.alpha),
            (e.texture = this.texture),
            (e.matrix = this.matrix),
            (e.visible = this.visible),
            e
          );
        }),
        (t.prototype.reset = function () {
          (this.color = 16777215),
            (this.alpha = 1),
            (this.texture = eg.WHITE),
            (this.matrix = null),
            (this.visible = !1);
        }),
        (t.prototype.destroy = function () {
          (this.texture = null), (this.matrix = null);
        }),
        t
      );
    })(),
    Ox = function (t, e) {
      return (Ox =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function Nx(t, e) {
    function n() {
      this.constructor = t;
    }
    Ox(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  function Dx(t, e) {
    var n, i;
    void 0 === e && (e = !1);
    var r = t.length;
    if (!(r < 6)) {
      for (var s = 0, o = 0, a = t[r - 2], l = t[r - 1]; o < r; o += 2) {
        var h = t[o],
          u = t[o + 1];
        (s += (h - a) * (u + l)), (a = h), (l = u);
      }
      if ((!e && s > 0) || (e && s <= 0)) {
        var c = r / 2;
        for (o = c + (c % 2); o < r; o += 2) {
          var d = r - o - 2,
            p = r - o - 1,
            f = o,
            m = o + 1;
          (n = [t[f], t[d]]),
            (t[d] = n[0]),
            (t[f] = n[1]),
            (i = [t[m], t[p]]),
            (t[p] = i[0]),
            (t[m] = i[1]);
        }
      }
    }
  }
  var Lx = {
      build: function (t) {
        t.points = t.shape.points.slice();
      },
      triangulate: function (t, e) {
        var n = t.points,
          i = t.holes,
          r = e.points,
          s = e.indices;
        if (n.length >= 6) {
          Dx(n, !1);
          for (var o = [], a = 0; a < i.length; a++) {
            var l = i[a];
            Dx(l.points, !0), o.push(n.length / 2), (n = n.concat(l.points));
          }
          var h = Pp.exports(n, o, 2);
          if (!h) return;
          var u = r.length / 2;
          for (a = 0; a < h.length; a += 3)
            s.push(h[a] + u), s.push(h[a + 1] + u), s.push(h[a + 2] + u);
          for (a = 0; a < n.length; a++) r.push(n[a]);
        }
      },
    },
    Fx = {
      build: function (t) {
        var e,
          n,
          i,
          r,
          s,
          o,
          a = t.points;
        if (t.type === Sm.CIRC) {
          var l = t.shape;
          (e = l.x), (n = l.y), (s = o = l.radius), (i = r = 0);
        } else if (t.type === Sm.ELIP) {
          var h = t.shape;
          (e = h.x), (n = h.y), (s = h.width), (o = h.height), (i = r = 0);
        } else {
          var u = t.shape,
            c = u.width / 2,
            d = u.height / 2;
          (e = u.x + c),
            (n = u.y + d),
            (i = c - (s = o = Math.max(0, Math.min(u.radius, Math.min(c, d))))),
            (r = d - o);
        }
        if (s >= 0 && o >= 0 && i >= 0 && r >= 0) {
          var p = Math.ceil(2.3 * Math.sqrt(s + o)),
            f = 8 * p + (i ? 4 : 0) + (r ? 4 : 0);
          if (((a.length = f), 0 !== f)) {
            if (0 === p)
              return (
                (a.length = 8),
                (a[0] = a[6] = e + i),
                (a[1] = a[3] = n + r),
                (a[2] = a[4] = e - i),
                void (a[5] = a[7] = n - r)
              );
            var m = 0,
              _ = 4 * p + (i ? 2 : 0) + 2,
              g = _,
              v = f,
              y = e + (w = i + s),
              x = e - w,
              b = n + (M = r);
            if (((a[m++] = y), (a[m++] = b), (a[--_] = b), (a[--_] = x), r)) {
              var T = n - M;
              (a[g++] = x), (a[g++] = T), (a[--v] = T), (a[--v] = y);
            }
            for (var E = 1; E < p; E++) {
              var S = (Math.PI / 2) * (E / p);
              (y = e + (w = i + Math.cos(S) * s)),
                (x = e - w),
                (b = n + (M = r + Math.sin(S) * o)),
                (T = n - M);
              (a[m++] = y),
                (a[m++] = b),
                (a[--_] = b),
                (a[--_] = x),
                (a[g++] = x),
                (a[g++] = T),
                (a[--v] = T),
                (a[--v] = y);
            }
            var w, M;
            (y = e + (w = i)), (x = e - w), (b = n + (M = r + o)), (T = n - M);
            (a[m++] = y),
              (a[m++] = b),
              (a[--v] = T),
              (a[--v] = y),
              i && ((a[m++] = x), (a[m++] = b), (a[--v] = T), (a[--v] = x));
          }
        } else a.length = 0;
      },
      triangulate: function (t, e) {
        var n = t.points,
          i = e.points,
          r = e.indices;
        if (0 !== n.length) {
          var s,
            o,
            a = i.length / 2,
            l = a;
          if (t.type !== Sm.RREC) {
            var h = t.shape;
            (s = h.x), (o = h.y);
          } else {
            var u = t.shape;
            (s = u.x + u.width / 2), (o = u.y + u.height / 2);
          }
          var c = t.matrix;
          i.push(
            t.matrix ? c.a * s + c.c * o + c.tx : s,
            t.matrix ? c.b * s + c.d * o + c.ty : o
          ),
            a++,
            i.push(n[0], n[1]);
          for (var d = 2; d < n.length; d += 2)
            i.push(n[d], n[d + 1]), r.push(a++, l, a);
          r.push(l + 1, l, a);
        }
      },
    };
  function Ux(t, e, n) {
    return t + (e - t) * n;
  }
  function Bx(t, e, n, i, r, s, o) {
    void 0 === o && (o = []);
    for (
      var a = o, l = 0, h = 0, u = 0, c = 0, d = 0, p = 0, f = 0, m = 0;
      f <= 20;
      ++f
    )
      (l = Ux(t, n, (m = f / 20))),
        (h = Ux(e, i, m)),
        (u = Ux(n, r, m)),
        (c = Ux(i, s, m)),
        (d = Ux(l, u, m)),
        (p = Ux(h, c, m)),
        (0 === f && a[a.length - 2] === d && a[a.length - 1] === p) ||
          a.push(d, p);
    return a;
  }
  var kx = {
    build: function (t) {
      if (ib.nextRoundedRectBehavior) Fx.build(t);
      else {
        var e = t.shape,
          n = t.points,
          i = e.x,
          r = e.y,
          s = e.width,
          o = e.height,
          a = Math.max(0, Math.min(e.radius, Math.min(s, o) / 2));
        (n.length = 0),
          a
            ? (Bx(i, r + a, i, r, i + a, r, n),
              Bx(i + s - a, r, i + s, r, i + s, r + a, n),
              Bx(i + s, r + o - a, i + s, r + o, i + s - a, r + o, n),
              Bx(i + a, r + o, i, r + o, i, r + o - a, n))
            : n.push(i, r, i + s, r, i + s, r + o, i, r + o);
      }
    },
    triangulate: function (t, e) {
      if (ib.nextRoundedRectBehavior) Fx.triangulate(t, e);
      else {
        for (
          var n = t.points,
            i = e.points,
            r = e.indices,
            s = i.length / 2,
            o = Pp.exports(n, null, 2),
            a = 0,
            l = o.length;
          a < l;
          a += 3
        )
          r.push(o[a] + s), r.push(o[a + 1] + s), r.push(o[a + 2] + s);
        for (a = 0, l = n.length; a < l; a++) i.push(n[a], n[++a]);
      }
    },
  };
  function Gx(t, e, n, i, r, s, o, a) {
    var l, h;
    o ? ((l = i), (h = -n)) : ((l = -i), (h = n));
    var u = t - n * r + l,
      c = e - i * r + h,
      d = t + n * s + l,
      p = e + i * s + h;
    return a.push(u, c), a.push(d, p), 2;
  }
  function Hx(t, e, n, i, r, s, o, a) {
    var l = n - t,
      h = i - e,
      u = Math.atan2(l, h),
      c = Math.atan2(r - t, s - e);
    a && u < c ? (u += 2 * Math.PI) : !a && u > c && (c += 2 * Math.PI);
    var d = u,
      p = c - u,
      f = Math.abs(p),
      m = Math.sqrt(l * l + h * h),
      _ = 1 + (((15 * f * Math.sqrt(m)) / Math.PI) >> 0),
      g = p / _;
    if (((d += g), a)) {
      o.push(t, e), o.push(n, i);
      for (var v = 1, y = d; v < _; v++, y += g)
        o.push(t, e), o.push(t + Math.sin(y) * m, e + Math.cos(y) * m);
      o.push(t, e), o.push(r, s);
    } else {
      o.push(n, i), o.push(t, e);
      for (v = 1, y = d; v < _; v++, y += g)
        o.push(t + Math.sin(y) * m, e + Math.cos(y) * m), o.push(t, e);
      o.push(r, s), o.push(t, e);
    }
    return 2 * _;
  }
  function zx(t, e) {
    t.lineStyle.native
      ? (function (t, e) {
          var n = 0,
            i = t.shape,
            r = t.points || i.points,
            s = i.type !== Sm.POLY || i.closeStroke;
          if (0 !== r.length) {
            var o = e.points,
              a = e.indices,
              l = r.length / 2,
              h = o.length / 2,
              u = h;
            for (o.push(r[0], r[1]), n = 1; n < l; n++)
              o.push(r[2 * n], r[2 * n + 1]), a.push(u, u + 1), u++;
            s && a.push(u, h);
          }
        })(t, e)
      : (function (t, e) {
          var n = t.shape,
            i = t.points || n.points.slice(),
            r = e.closePointEps;
          if (0 !== i.length) {
            var s = t.lineStyle,
              o = new Cm(i[0], i[1]),
              a = new Cm(i[i.length - 2], i[i.length - 1]),
              l = n.type !== Sm.POLY || n.closeStroke,
              h = Math.abs(o.x - a.x) < r && Math.abs(o.y - a.y) < r;
            if (l) {
              (i = i.slice()),
                h &&
                  (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1]));
              var u = 0.5 * (o.x + a.x),
                c = 0.5 * (a.y + o.y);
              i.unshift(u, c), i.push(u, c);
            }
            var d = e.points,
              p = i.length / 2,
              f = i.length,
              m = d.length / 2,
              _ = s.width / 2,
              g = _ * _,
              v = s.miterLimit * s.miterLimit,
              y = i[0],
              x = i[1],
              b = i[2],
              T = i[3],
              E = 0,
              S = 0,
              w = -(x - T),
              M = y - b,
              A = 0,
              R = 0,
              C = Math.sqrt(w * w + M * M);
            (w /= C), (M /= C), (w *= _), (M *= _);
            var I = s.alignment,
              P = 2 * (1 - I),
              O = 2 * I;
            l ||
              (s.cap === Mx.ROUND
                ? (f +=
                    Hx(
                      y - w * (P - O) * 0.5,
                      x - M * (P - O) * 0.5,
                      y - w * P,
                      x - M * P,
                      y + w * O,
                      x + M * O,
                      d,
                      !0
                    ) + 2)
                : s.cap === Mx.SQUARE && (f += Gx(y, x, w, M, P, O, !0, d))),
              d.push(y - w * P, x - M * P),
              d.push(y + w * O, x + M * O);
            for (var N = 1; N < p - 1; ++N) {
              (y = i[2 * (N - 1)]),
                (x = i[2 * (N - 1) + 1]),
                (b = i[2 * N]),
                (T = i[2 * N + 1]),
                (E = i[2 * (N + 1)]),
                (S = i[2 * (N + 1) + 1]),
                (w = -(x - T)),
                (M = y - b),
                (w /= C = Math.sqrt(w * w + M * M)),
                (M /= C),
                (w *= _),
                (M *= _),
                (A = -(T - S)),
                (R = b - E),
                (A /= C = Math.sqrt(A * A + R * R)),
                (R /= C),
                (A *= _),
                (R *= _);
              var D = b - y,
                L = x - T,
                F = b - E,
                U = S - T,
                B = L * F - U * D,
                k = B < 0;
              if (Math.abs(B) < 0.1)
                d.push(b - w * P, T - M * P), d.push(b + w * O, T + M * O);
              else {
                var G = (-w + y) * (-M + T) - (-w + b) * (-M + x),
                  H = (-A + E) * (-R + T) - (-A + b) * (-R + S),
                  z = (D * H - F * G) / B,
                  V = (U * G - L * H) / B,
                  X = (z - b) * (z - b) + (V - T) * (V - T),
                  W = b + (z - b) * P,
                  j = T + (V - T) * P,
                  Y = b - (z - b) * O,
                  q = T - (V - T) * O,
                  K = k ? P : O;
                X <= Math.min(D * D + L * L, F * F + U * U) + K * K * g
                  ? s.join === Sx.BEVEL || X / g > v
                    ? (k
                        ? (d.push(W, j),
                          d.push(b + w * O, T + M * O),
                          d.push(W, j),
                          d.push(b + A * O, T + R * O))
                        : (d.push(b - w * P, T - M * P),
                          d.push(Y, q),
                          d.push(b - A * P, T - R * P),
                          d.push(Y, q)),
                      (f += 2))
                    : s.join === Sx.ROUND
                    ? k
                      ? (d.push(W, j),
                        d.push(b + w * O, T + M * O),
                        (f +=
                          Hx(
                            b,
                            T,
                            b + w * O,
                            T + M * O,
                            b + A * O,
                            T + R * O,
                            d,
                            !0
                          ) + 4),
                        d.push(W, j),
                        d.push(b + A * O, T + R * O))
                      : (d.push(b - w * P, T - M * P),
                        d.push(Y, q),
                        (f +=
                          Hx(
                            b,
                            T,
                            b - w * P,
                            T - M * P,
                            b - A * P,
                            T - R * P,
                            d,
                            !1
                          ) + 4),
                        d.push(b - A * P, T - R * P),
                        d.push(Y, q))
                    : (d.push(W, j), d.push(Y, q))
                  : (d.push(b - w * P, T - M * P),
                    d.push(b + w * O, T + M * O),
                    s.join === Sx.ROUND
                      ? (f += k
                          ? Hx(
                              b,
                              T,
                              b + w * O,
                              T + M * O,
                              b + A * O,
                              T + R * O,
                              d,
                              !0
                            ) + 2
                          : Hx(
                              b,
                              T,
                              b - w * P,
                              T - M * P,
                              b - A * P,
                              T - R * P,
                              d,
                              !1
                            ) + 2)
                      : s.join === Sx.MITER &&
                        X / g <= v &&
                        (k
                          ? (d.push(Y, q), d.push(Y, q))
                          : (d.push(W, j), d.push(W, j)),
                        (f += 2)),
                    d.push(b - A * P, T - R * P),
                    d.push(b + A * O, T + R * O),
                    (f += 2));
              }
            }
            (y = i[2 * (p - 2)]),
              (x = i[2 * (p - 2) + 1]),
              (b = i[2 * (p - 1)]),
              (w = -(x - (T = i[2 * (p - 1) + 1]))),
              (M = y - b),
              (w /= C = Math.sqrt(w * w + M * M)),
              (M /= C),
              (w *= _),
              (M *= _),
              d.push(b - w * P, T - M * P),
              d.push(b + w * O, T + M * O),
              l ||
                (s.cap === Mx.ROUND
                  ? (f +=
                      Hx(
                        b - w * (P - O) * 0.5,
                        T - M * (P - O) * 0.5,
                        b - w * P,
                        T - M * P,
                        b + w * O,
                        T + M * O,
                        d,
                        !1
                      ) + 2)
                  : s.cap === Mx.SQUARE && (f += Gx(b, T, w, M, P, O, !1, d)));
            var Z = e.indices,
              J = Ix.epsilon * Ix.epsilon;
            for (N = m; N < f + m - 2; ++N)
              (y = d[2 * N]),
                (x = d[2 * N + 1]),
                (b = d[2 * (N + 1)]),
                (T = d[2 * (N + 1) + 1]),
                (E = d[2 * (N + 2)]),
                (S = d[2 * (N + 2) + 1]),
                Math.abs(y * (T - S) + b * (S - x) + E * (x - T)) < J ||
                  Z.push(N, N + 1, N + 2);
          }
        })(t, e);
  }
  var Vx,
    Xx = (function () {
      function t() {}
      return (
        (t.curveTo = function (t, e, n, i, r, s) {
          var o = s[s.length - 2],
            a = s[s.length - 1] - e,
            l = o - t,
            h = i - e,
            u = n - t,
            c = Math.abs(a * u - l * h);
          if (c < 1e-8 || 0 === r)
            return (
              (s[s.length - 2] === t && s[s.length - 1] === e) || s.push(t, e),
              null
            );
          var d = a * a + l * l,
            p = h * h + u * u,
            f = a * h + l * u,
            m = (r * Math.sqrt(d)) / c,
            _ = (r * Math.sqrt(p)) / c,
            g = (m * f) / d,
            v = (_ * f) / p,
            y = m * u + _ * l,
            x = m * h + _ * a,
            b = l * (_ + g),
            T = a * (_ + g),
            E = u * (m + v),
            S = h * (m + v);
          return {
            cx: y + t,
            cy: x + e,
            radius: r,
            startAngle: Math.atan2(T - x, b - y),
            endAngle: Math.atan2(S - x, E - y),
            anticlockwise: l * h > u * a,
          };
        }),
        (t.arc = function (t, e, n, i, r, s, o, a, l) {
          for (
            var h = o - s,
              u = Ix._segmentsCount(
                Math.abs(h) * r,
                40 * Math.ceil(Math.abs(h) / Mm)
              ),
              c = h / (2 * u),
              d = 2 * c,
              p = Math.cos(c),
              f = Math.sin(c),
              m = u - 1,
              _ = (m % 1) / m,
              g = 0;
            g <= m;
            ++g
          ) {
            var v = c + s + d * (g + _ * g),
              y = Math.cos(v),
              x = -Math.sin(v);
            l.push((p * y + f * x) * r + n, (p * -x + f * y) * r + i);
          }
        }),
        t
      );
    })(),
    Wx = (function () {
      function t() {}
      return (
        (t.curveLength = function (t, e, n, i, r, s, o, a) {
          for (
            var l = 0,
              h = 0,
              u = 0,
              c = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              _ = 0,
              g = 0,
              v = 0,
              y = t,
              x = e,
              b = 1;
            b <= 10;
            ++b
          )
            (g =
              y -
              (m =
                (f = (p = (d = 1 - (h = b / 10)) * d) * d) * t +
                3 * p * h * n +
                3 * d * (u = h * h) * r +
                (c = u * h) * o)),
              (v = x - (_ = f * e + 3 * p * h * i + 3 * d * u * s + c * a)),
              (y = m),
              (x = _),
              (l += Math.sqrt(g * g + v * v));
          return l;
        }),
        (t.curveTo = function (e, n, i, r, s, o, a) {
          var l = a[a.length - 2],
            h = a[a.length - 1];
          a.length -= 2;
          var u = Ix._segmentsCount(t.curveLength(l, h, e, n, i, r, s, o)),
            c = 0,
            d = 0,
            p = 0,
            f = 0,
            m = 0;
          a.push(l, h);
          for (var _ = 1, g = 0; _ <= u; ++_)
            (p = (d = (c = 1 - (g = _ / u)) * c) * c),
              (m = (f = g * g) * g),
              a.push(
                p * l + 3 * d * g * e + 3 * c * f * i + m * s,
                p * h + 3 * d * g * n + 3 * c * f * r + m * o
              );
        }),
        t
      );
    })(),
    jx = (function () {
      function t() {}
      return (
        (t.curveLength = function (t, e, n, i, r, s) {
          var o = t - 2 * n + r,
            a = e - 2 * i + s,
            l = 2 * n - 2 * t,
            h = 2 * i - 2 * e,
            u = 4 * (o * o + a * a),
            c = 4 * (o * l + a * h),
            d = l * l + h * h,
            p = 2 * Math.sqrt(u + c + d),
            f = Math.sqrt(u),
            m = 2 * u * f,
            _ = 2 * Math.sqrt(d),
            g = c / f;
          return (
            (m * p +
              f * c * (p - _) +
              (4 * d * u - c * c) * Math.log((2 * f + g + p) / (g + _))) /
            (4 * m)
          );
        }),
        (t.curveTo = function (e, n, i, r, s) {
          for (
            var o = s[s.length - 2],
              a = s[s.length - 1],
              l = Ix._segmentsCount(t.curveLength(o, a, e, n, i, r)),
              h = 0,
              u = 0,
              c = 1;
            c <= l;
            ++c
          ) {
            var d = c / l;
            (h = o + (e - o) * d),
              (u = a + (n - a) * d),
              s.push(
                h + (e + (i - e) * d - h) * d,
                u + (n + (r - n) * d - u) * d
              );
          }
        }),
        t
      );
    })(),
    Yx = (function () {
      function t() {
        this.reset();
      }
      return (
        (t.prototype.begin = function (t, e, n) {
          this.reset(),
            (this.style = t),
            (this.start = e),
            (this.attribStart = n);
        }),
        (t.prototype.end = function (t, e) {
          (this.attribSize = e - this.attribStart),
            (this.size = t - this.start);
        }),
        (t.prototype.reset = function () {
          (this.style = null),
            (this.size = 0),
            (this.start = 0),
            (this.attribStart = 0),
            (this.attribSize = 0);
        }),
        t
      );
    })(),
    qx =
      (((Vx = {})[Sm.POLY] = Lx),
      (Vx[Sm.CIRC] = Fx),
      (Vx[Sm.ELIP] = Fx),
      (Vx[Sm.RECT] = {
        build: function (t) {
          var e = t.shape,
            n = e.x,
            i = e.y,
            r = e.width,
            s = e.height,
            o = t.points;
          (o.length = 0), o.push(n, i, n + r, i, n + r, i + s, n, i + s);
        },
        triangulate: function (t, e) {
          var n = t.points,
            i = e.points,
            r = i.length / 2;
          i.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]),
            e.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3);
        },
      }),
      (Vx[Sm.RREC] = kx),
      Vx),
    Kx = [],
    Zx = [],
    Jx = (function () {
      function t(t, e, n, i) {
        void 0 === e && (e = null),
          void 0 === n && (n = null),
          void 0 === i && (i = null),
          (this.points = []),
          (this.holes = []),
          (this.shape = t),
          (this.lineStyle = n),
          (this.fillStyle = e),
          (this.matrix = i),
          (this.type = t.type);
      }
      return (
        (t.prototype.clone = function () {
          return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix);
        }),
        (t.prototype.destroy = function () {
          (this.shape = null),
            (this.holes.length = 0),
            (this.holes = null),
            (this.points.length = 0),
            (this.points = null),
            (this.lineStyle = null),
            (this.fillStyle = null);
        }),
        t
      );
    })(),
    $x = new Cm(),
    Qx = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (
          (e.closePointEps = 1e-4),
          (e.boundsPadding = 0),
          (e.uvsFloat32 = null),
          (e.indicesUint16 = null),
          (e.batchable = !1),
          (e.points = []),
          (e.colors = []),
          (e.uvs = []),
          (e.indices = []),
          (e.textureIds = []),
          (e.graphicsData = []),
          (e.drawCalls = []),
          (e.batchDirty = -1),
          (e.batches = []),
          (e.dirty = 0),
          (e.cacheDirty = -1),
          (e.clearDirty = 0),
          (e.shapeIndex = 0),
          (e._bounds = new Ym()),
          (e.boundsDirty = -1),
          e
        );
      }
      return (
        Nx(e, t),
        Object.defineProperty(e.prototype, "bounds", {
          get: function () {
            return (
              this.updateBatches(),
              this.boundsDirty !== this.dirty &&
                ((this.boundsDirty = this.dirty), this.calculateBounds()),
              this._bounds
            );
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.invalidate = function () {
          (this.boundsDirty = -1),
            this.dirty++,
            this.batchDirty++,
            (this.shapeIndex = 0),
            (this.points.length = 0),
            (this.colors.length = 0),
            (this.uvs.length = 0),
            (this.indices.length = 0),
            (this.textureIds.length = 0);
          for (var t = 0; t < this.drawCalls.length; t++)
            this.drawCalls[t].texArray.clear(), Zx.push(this.drawCalls[t]);
          this.drawCalls.length = 0;
          for (t = 0; t < this.batches.length; t++) {
            var e = this.batches[t];
            e.reset(), Kx.push(e);
          }
          this.batches.length = 0;
        }),
        (e.prototype.clear = function () {
          return (
            this.graphicsData.length > 0 &&
              (this.invalidate(),
              this.clearDirty++,
              (this.graphicsData.length = 0)),
            this
          );
        }),
        (e.prototype.drawShape = function (t, e, n, i) {
          void 0 === e && (e = null),
            void 0 === n && (n = null),
            void 0 === i && (i = null);
          var r = new Jx(t, e, n, i);
          return this.graphicsData.push(r), this.dirty++, this;
        }),
        (e.prototype.drawHole = function (t, e) {
          if ((void 0 === e && (e = null), !this.graphicsData.length))
            return null;
          var n = new Jx(t, null, null, e),
            i = this.graphicsData[this.graphicsData.length - 1];
          return (
            (n.lineStyle = i.lineStyle), i.holes.push(n), this.dirty++, this
          );
        }),
        (e.prototype.destroy = function () {
          t.prototype.destroy.call(this);
          for (var e = 0; e < this.graphicsData.length; ++e)
            this.graphicsData[e].destroy();
          (this.points.length = 0),
            (this.points = null),
            (this.colors.length = 0),
            (this.colors = null),
            (this.uvs.length = 0),
            (this.uvs = null),
            (this.indices.length = 0),
            (this.indices = null),
            this.indexBuffer.destroy(),
            (this.indexBuffer = null),
            (this.graphicsData.length = 0),
            (this.graphicsData = null),
            (this.drawCalls.length = 0),
            (this.drawCalls = null),
            (this.batches.length = 0),
            (this.batches = null),
            (this._bounds = null);
        }),
        (e.prototype.containsPoint = function (t) {
          for (var e = this.graphicsData, n = 0; n < e.length; ++n) {
            var i = e[n];
            if (
              i.fillStyle.visible &&
              i.shape &&
              (i.matrix ? i.matrix.applyInverse(t, $x) : $x.copyFrom(t),
              i.shape.contains($x.x, $x.y))
            ) {
              var r = !1;
              if (i.holes)
                for (var s = 0; s < i.holes.length; s++) {
                  if (i.holes[s].shape.contains($x.x, $x.y)) {
                    r = !0;
                    break;
                  }
                }
              if (!r) return !0;
            }
          }
          return !1;
        }),
        (e.prototype.updateBatches = function () {
          if (this.graphicsData.length) {
            if (this.validateBatching()) {
              this.cacheDirty = this.dirty;
              var t = this.uvs,
                e = this.graphicsData,
                n = null,
                i = null;
              this.batches.length > 0 &&
                (i = (n = this.batches[this.batches.length - 1]).style);
              for (var r = this.shapeIndex; r < e.length; r++) {
                this.shapeIndex++;
                var s = e[r],
                  o = s.fillStyle,
                  a = s.lineStyle;
                qx[s.type].build(s),
                  s.matrix && this.transformPoints(s.points, s.matrix),
                  (o.visible || a.visible) && this.processHoles(s.holes);
                for (var l = 0; l < 2; l++) {
                  var h = 0 === l ? o : a;
                  if (h.visible) {
                    var u = h.texture.baseTexture,
                      c = this.indices.length,
                      d = this.points.length / 2;
                    (u.wrapMode = Af.REPEAT),
                      0 === l ? this.processFill(s) : this.processLine(s);
                    var p = this.points.length / 2 - d;
                    0 !== p &&
                      (n &&
                        !this._compareStyles(i, h) &&
                        (n.end(c, d), (n = null)),
                      n ||
                        ((n = Kx.pop() || new Yx()).begin(h, c, d),
                        this.batches.push(n),
                        (i = h)),
                      this.addUvs(this.points, t, h.texture, d, p, h.matrix));
                  }
                }
              }
              var f = this.indices.length,
                m = this.points.length / 2;
              if ((n && n.end(f, m), 0 !== this.batches.length)) {
                var _ = m > 65535;
                this.indicesUint16 &&
                this.indices.length === this.indicesUint16.length &&
                _ === this.indicesUint16.BYTES_PER_ELEMENT > 2
                  ? this.indicesUint16.set(this.indices)
                  : (this.indicesUint16 = _
                      ? new Uint32Array(this.indices)
                      : new Uint16Array(this.indices)),
                  (this.batchable = this.isBatchable()),
                  this.batchable ? this.packBatches() : this.buildDrawCalls();
              } else this.batchable = !0;
            }
          } else this.batchable = !0;
        }),
        (e.prototype._compareStyles = function (t, e) {
          return (
            !(!t || !e) &&
            t.texture.baseTexture === e.texture.baseTexture &&
            t.color + t.alpha === e.color + e.alpha &&
            !!t.native == !!e.native
          );
        }),
        (e.prototype.validateBatching = function () {
          if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return !1;
          for (var t = 0, e = this.graphicsData.length; t < e; t++) {
            var n = this.graphicsData[t],
              i = n.fillStyle,
              r = n.lineStyle;
            if (i && !i.texture.baseTexture.valid) return !1;
            if (r && !r.texture.baseTexture.valid) return !1;
          }
          return !0;
        }),
        (e.prototype.packBatches = function () {
          this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs));
          for (var t = this.batches, e = 0, n = t.length; e < n; e++)
            for (var i = t[e], r = 0; r < i.size; r++) {
              var s = i.start + r;
              this.indicesUint16[s] = this.indicesUint16[s] - i.attribStart;
            }
        }),
        (e.prototype.isBatchable = function () {
          if (this.points.length > 131070) return !1;
          for (var t = this.batches, n = 0; n < t.length; n++)
            if (t[n].style.native) return !1;
          return this.points.length < 2 * e.BATCHABLE_SIZE;
        }),
        (e.prototype.buildDrawCalls = function () {
          for (var t = ++k_._globalBatch, e = 0; e < this.drawCalls.length; e++)
            this.drawCalls[e].texArray.clear(), Zx.push(this.drawCalls[e]);
          this.drawCalls.length = 0;
          var n = this.colors,
            i = this.textureIds,
            r = Zx.pop();
          r || ((r = new Dv()).texArray = new Lv()),
            (r.texArray.count = 0),
            (r.start = 0),
            (r.size = 0),
            (r.type = bf.TRIANGLES);
          var s = 0,
            o = null,
            a = 0,
            l = !1,
            h = bf.TRIANGLES,
            u = 0;
          this.drawCalls.push(r);
          for (e = 0; e < this.batches.length; e++) {
            var c = this.batches[e],
              d = c.style,
              p = d.texture.baseTexture;
            l !== !!d.native &&
              ((h = (l = !!d.native) ? bf.LINES : bf.TRIANGLES),
              (o = null),
              (s = 8),
              t++),
              o !== p &&
                ((o = p),
                p._batchEnabled !== t &&
                  (8 === s &&
                    (t++,
                    (s = 0),
                    r.size > 0 &&
                      ((r = Zx.pop()) || ((r = new Dv()).texArray = new Lv()),
                      this.drawCalls.push(r)),
                    (r.start = u),
                    (r.size = 0),
                    (r.texArray.count = 0),
                    (r.type = h)),
                  (p.touched = 1),
                  (p._batchEnabled = t),
                  (p._batchLocation = s),
                  (p.wrapMode = Af.REPEAT),
                  (r.texArray.elements[r.texArray.count++] = p),
                  s++)),
              (r.size += c.size),
              (u += c.size),
              (a = p._batchLocation),
              this.addColors(n, d.color, d.alpha, c.attribSize, c.attribStart),
              this.addTextureIds(i, a, c.attribSize, c.attribStart);
          }
          (k_._globalBatch = t), this.packAttributes();
        }),
        (e.prototype.packAttributes = function () {
          for (
            var t = this.points,
              e = this.uvs,
              n = this.colors,
              i = this.textureIds,
              r = new ArrayBuffer(3 * t.length * 4),
              s = new Float32Array(r),
              o = new Uint32Array(r),
              a = 0,
              l = 0;
            l < t.length / 2;
            l++
          )
            (s[a++] = t[2 * l]),
              (s[a++] = t[2 * l + 1]),
              (s[a++] = e[2 * l]),
              (s[a++] = e[2 * l + 1]),
              (o[a++] = n[l]),
              (s[a++] = i[l]);
          this._buffer.update(r), this._indexBuffer.update(this.indicesUint16);
        }),
        (e.prototype.processFill = function (t) {
          t.holes.length
            ? Lx.triangulate(t, this)
            : qx[t.type].triangulate(t, this);
        }),
        (e.prototype.processLine = function (t) {
          zx(t, this);
          for (var e = 0; e < t.holes.length; e++) zx(t.holes[e], this);
        }),
        (e.prototype.processHoles = function (t) {
          for (var e = 0; e < t.length; e++) {
            var n = t[e];
            qx[n.type].build(n),
              n.matrix && this.transformPoints(n.points, n.matrix);
          }
        }),
        (e.prototype.calculateBounds = function () {
          var t = this._bounds;
          t.clear(),
            t.addVertexData(this.points, 0, this.points.length),
            t.pad(this.boundsPadding, this.boundsPadding);
        }),
        (e.prototype.transformPoints = function (t, e) {
          for (var n = 0; n < t.length / 2; n++) {
            var i = t[2 * n],
              r = t[2 * n + 1];
            (t[2 * n] = e.a * i + e.c * r + e.tx),
              (t[2 * n + 1] = e.b * i + e.d * r + e.ty);
          }
        }),
        (e.prototype.addColors = function (t, e, n, i, r) {
          void 0 === r && (r = 0);
          var s = om((e >> 16) + (65280 & e) + ((255 & e) << 16), n);
          t.length = Math.max(t.length, r + i);
          for (var o = 0; o < i; o++) t[r + o] = s;
        }),
        (e.prototype.addTextureIds = function (t, e, n, i) {
          void 0 === i && (i = 0), (t.length = Math.max(t.length, i + n));
          for (var r = 0; r < n; r++) t[i + r] = e;
        }),
        (e.prototype.addUvs = function (t, e, n, i, r, s) {
          void 0 === s && (s = null);
          for (var o = 0, a = e.length, l = n.frame; o < r; ) {
            var h = t[2 * (i + o)],
              u = t[2 * (i + o) + 1];
            if (s) {
              var c = s.a * h + s.c * u + s.tx;
              (u = s.b * h + s.d * u + s.ty), (h = c);
            }
            o++, e.push(h / l.width, u / l.height);
          }
          var d = n.baseTexture;
          (l.width < d.width || l.height < d.height) &&
            this.adjustUvs(e, n, a, r);
        }),
        (e.prototype.adjustUvs = function (t, e, n, i) {
          for (
            var r = e.baseTexture,
              s = 1e-6,
              o = n + 2 * i,
              a = e.frame,
              l = a.width / r.width,
              h = a.height / r.height,
              u = a.x / a.width,
              c = a.y / a.height,
              d = Math.floor(t[n] + s),
              p = Math.floor(t[n + 1] + s),
              f = n + 2;
            f < o;
            f += 2
          )
            (d = Math.min(d, Math.floor(t[f] + s))),
              (p = Math.min(p, Math.floor(t[f + 1] + s)));
          (u -= d), (c -= p);
          for (f = n; f < o; f += 2)
            (t[f] = (t[f] + u) * l), (t[f + 1] = (t[f + 1] + c) * h);
        }),
        (e.BATCHABLE_SIZE = 100),
        e
      );
    })(kv),
    tb = (function (t) {
      function e() {
        var e = (null !== t && t.apply(this, arguments)) || this;
        return (
          (e.width = 0),
          (e.alignment = 0.5),
          (e.native = !1),
          (e.cap = Mx.BUTT),
          (e.join = Sx.MITER),
          (e.miterLimit = 10),
          e
        );
      }
      return (
        Nx(e, t),
        (e.prototype.clone = function () {
          var t = new e();
          return (
            (t.color = this.color),
            (t.alpha = this.alpha),
            (t.texture = this.texture),
            (t.matrix = this.matrix),
            (t.visible = this.visible),
            (t.width = this.width),
            (t.alignment = this.alignment),
            (t.native = this.native),
            (t.cap = this.cap),
            (t.join = this.join),
            (t.miterLimit = this.miterLimit),
            t
          );
        }),
        (e.prototype.reset = function () {
          t.prototype.reset.call(this),
            (this.color = 0),
            (this.alignment = 0.5),
            (this.width = 0),
            (this.native = !1);
        }),
        e
      );
    })(Px),
    eb = new Float32Array(3),
    nb = {},
    ib = (function (t) {
      function e(e) {
        void 0 === e && (e = null);
        var n = t.call(this) || this;
        return (
          (n.shader = null),
          (n.pluginName = "batch"),
          (n.currentPath = null),
          (n.batches = []),
          (n.batchTint = -1),
          (n.batchDirty = -1),
          (n.vertexData = null),
          (n._fillStyle = new Px()),
          (n._lineStyle = new tb()),
          (n._matrix = null),
          (n._holeMode = !1),
          (n.state = tv.for2d()),
          (n._geometry = e || new Qx()),
          n._geometry.refCount++,
          (n._transformID = -1),
          (n.tint = 16777215),
          (n.blendMode = xf.NORMAL),
          n
        );
      }
      return (
        Nx(e, t),
        Object.defineProperty(e.prototype, "geometry", {
          get: function () {
            return this._geometry;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.clone = function () {
          return this.finishPoly(), new e(this._geometry);
        }),
        Object.defineProperty(e.prototype, "blendMode", {
          get: function () {
            return this.state.blendMode;
          },
          set: function (t) {
            this.state.blendMode = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "tint", {
          get: function () {
            return this._tint;
          },
          set: function (t) {
            this._tint = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "fill", {
          get: function () {
            return this._fillStyle;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "line", {
          get: function () {
            return this._lineStyle;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.lineStyle = function (t, e, n, i, r) {
          return (
            void 0 === t && (t = null),
            void 0 === e && (e = 0),
            void 0 === n && (n = 1),
            void 0 === i && (i = 0.5),
            void 0 === r && (r = !1),
            "number" == typeof t &&
              (t = { width: t, color: e, alpha: n, alignment: i, native: r }),
            this.lineTextureStyle(t)
          );
        }),
        (e.prototype.lineTextureStyle = function (t) {
          (t = Object.assign(
            {
              width: 0,
              texture: eg.WHITE,
              color: t && t.texture ? 16777215 : 0,
              alpha: 1,
              matrix: null,
              alignment: 0.5,
              native: !1,
              cap: Mx.BUTT,
              join: Sx.MITER,
              miterLimit: 10,
            },
            t
          )),
            this.currentPath && this.startPoly();
          var e = t.width > 0 && t.alpha > 0;
          return (
            e
              ? (t.matrix && ((t.matrix = t.matrix.clone()), t.matrix.invert()),
                Object.assign(this._lineStyle, { visible: e }, t))
              : this._lineStyle.reset(),
            this
          );
        }),
        (e.prototype.startPoly = function () {
          if (this.currentPath) {
            var t = this.currentPath.points,
              e = this.currentPath.points.length;
            e > 2 &&
              (this.drawShape(this.currentPath),
              (this.currentPath = new Dm()),
              (this.currentPath.closeStroke = !1),
              this.currentPath.points.push(t[e - 2], t[e - 1]));
          } else
            (this.currentPath = new Dm()), (this.currentPath.closeStroke = !1);
        }),
        (e.prototype.finishPoly = function () {
          this.currentPath &&
            (this.currentPath.points.length > 2
              ? (this.drawShape(this.currentPath), (this.currentPath = null))
              : (this.currentPath.points.length = 0));
        }),
        (e.prototype.moveTo = function (t, e) {
          return (
            this.startPoly(),
            (this.currentPath.points[0] = t),
            (this.currentPath.points[1] = e),
            this
          );
        }),
        (e.prototype.lineTo = function (t, e) {
          this.currentPath || this.moveTo(0, 0);
          var n = this.currentPath.points,
            i = n[n.length - 2],
            r = n[n.length - 1];
          return (i === t && r === e) || n.push(t, e), this;
        }),
        (e.prototype._initCurve = function (t, e) {
          void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            this.currentPath
              ? 0 === this.currentPath.points.length &&
                (this.currentPath.points = [t, e])
              : this.moveTo(t, e);
        }),
        (e.prototype.quadraticCurveTo = function (t, e, n, i) {
          this._initCurve();
          var r = this.currentPath.points;
          return (
            0 === r.length && this.moveTo(0, 0), jx.curveTo(t, e, n, i, r), this
          );
        }),
        (e.prototype.bezierCurveTo = function (t, e, n, i, r, s) {
          return (
            this._initCurve(),
            Wx.curveTo(t, e, n, i, r, s, this.currentPath.points),
            this
          );
        }),
        (e.prototype.arcTo = function (t, e, n, i, r) {
          this._initCurve(t, e);
          var s = this.currentPath.points,
            o = Xx.curveTo(t, e, n, i, r, s);
          if (o) {
            var a = o.cx,
              l = o.cy,
              h = o.radius,
              u = o.startAngle,
              c = o.endAngle,
              d = o.anticlockwise;
            this.arc(a, l, h, u, c, d);
          }
          return this;
        }),
        (e.prototype.arc = function (t, e, n, i, r, s) {
          if ((void 0 === s && (s = !1), i === r)) return this;
          if (
            (!s && r <= i ? (r += Mm) : s && i <= r && (i += Mm), 0 === r - i)
          )
            return this;
          var o = t + Math.cos(i) * n,
            a = e + Math.sin(i) * n,
            l = this._geometry.closePointEps,
            h = this.currentPath ? this.currentPath.points : null;
          if (h) {
            var u = Math.abs(h[h.length - 2] - o),
              c = Math.abs(h[h.length - 1] - a);
            (u < l && c < l) || h.push(o, a);
          } else this.moveTo(o, a), (h = this.currentPath.points);
          return Xx.arc(o, a, t, e, n, i, r, s, h), this;
        }),
        (e.prototype.beginFill = function (t, e) {
          return (
            void 0 === t && (t = 0),
            void 0 === e && (e = 1),
            this.beginTextureFill({ texture: eg.WHITE, color: t, alpha: e })
          );
        }),
        (e.prototype.beginTextureFill = function (t) {
          (t = Object.assign(
            { texture: eg.WHITE, color: 16777215, alpha: 1, matrix: null },
            t
          )),
            this.currentPath && this.startPoly();
          var e = t.alpha > 0;
          return (
            e
              ? (t.matrix && ((t.matrix = t.matrix.clone()), t.matrix.invert()),
                Object.assign(this._fillStyle, { visible: e }, t))
              : this._fillStyle.reset(),
            this
          );
        }),
        (e.prototype.endFill = function () {
          return this.finishPoly(), this._fillStyle.reset(), this;
        }),
        (e.prototype.drawRect = function (t, e, n, i) {
          return this.drawShape(new Pm(t, e, n, i));
        }),
        (e.prototype.drawRoundedRect = function (t, e, n, i, r) {
          return this.drawShape(new Lm(t, e, n, i, r));
        }),
        (e.prototype.drawCircle = function (t, e, n) {
          return this.drawShape(new Om(t, e, n));
        }),
        (e.prototype.drawEllipse = function (t, e, n, i) {
          return this.drawShape(new Nm(t, e, n, i));
        }),
        (e.prototype.drawPolygon = function () {
          for (var t, e = arguments, n = [], i = 0; i < arguments.length; i++)
            n[i] = e[i];
          var r = !0,
            s = n[0];
          s.points
            ? ((r = s.closeStroke), (t = s.points))
            : (t = Array.isArray(n[0]) ? n[0] : n);
          var o = new Dm(t);
          return (o.closeStroke = r), this.drawShape(o), this;
        }),
        (e.prototype.drawShape = function (t) {
          return (
            this._holeMode
              ? this._geometry.drawHole(t, this._matrix)
              : this._geometry.drawShape(
                  t,
                  this._fillStyle.clone(),
                  this._lineStyle.clone(),
                  this._matrix
                ),
            this
          );
        }),
        (e.prototype.clear = function () {
          return (
            this._geometry.clear(),
            this._lineStyle.reset(),
            this._fillStyle.reset(),
            this._boundsID++,
            (this._matrix = null),
            (this._holeMode = !1),
            (this.currentPath = null),
            this
          );
        }),
        (e.prototype.isFastRect = function () {
          var t = this._geometry.graphicsData;
          return !(
            1 !== t.length ||
            t[0].shape.type !== Sm.RECT ||
            t[0].matrix ||
            t[0].holes.length ||
            (t[0].lineStyle.visible && t[0].lineStyle.width)
          );
        }),
        (e.prototype._render = function (t) {
          this.finishPoly();
          var e = this._geometry;
          e.updateBatches(),
            e.batchable
              ? (this.batchDirty !== e.batchDirty && this._populateBatches(),
                this._renderBatched(t))
              : (t.batch.flush(), this._renderDirect(t));
        }),
        (e.prototype._populateBatches = function () {
          var t = this._geometry,
            e = this.blendMode,
            n = t.batches.length;
          (this.batchTint = -1),
            (this._transformID = -1),
            (this.batchDirty = t.batchDirty),
            (this.batches.length = n),
            (this.vertexData = new Float32Array(t.points));
          for (var i = 0; i < n; i++) {
            var r = t.batches[i],
              s = r.style.color,
              o = new Float32Array(
                this.vertexData.buffer,
                4 * r.attribStart * 2,
                2 * r.attribSize
              ),
              a = new Float32Array(
                t.uvsFloat32.buffer,
                4 * r.attribStart * 2,
                2 * r.attribSize
              ),
              l = {
                vertexData: o,
                blendMode: e,
                indices: new Uint16Array(
                  t.indicesUint16.buffer,
                  2 * r.start,
                  r.size
                ),
                uvs: a,
                _batchRGB: em(s),
                _tintRGB: s,
                _texture: r.style.texture,
                alpha: r.style.alpha,
                worldAlpha: 1,
              };
            this.batches[i] = l;
          }
        }),
        (e.prototype._renderBatched = function (t) {
          if (this.batches.length) {
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
              this.calculateVertices(),
              this.calculateTints();
            for (var e = 0, n = this.batches.length; e < n; e++) {
              var i = this.batches[e];
              (i.worldAlpha = this.worldAlpha * i.alpha),
                t.plugins[this.pluginName].render(i);
            }
          }
        }),
        (e.prototype._renderDirect = function (t) {
          var e = this._resolveDirectShader(t),
            n = this._geometry,
            i = this.tint,
            r = this.worldAlpha,
            s = e.uniforms,
            o = n.drawCalls;
          (s.translationMatrix = this.transform.worldTransform),
            (s.tint[0] = (((i >> 16) & 255) / 255) * r),
            (s.tint[1] = (((i >> 8) & 255) / 255) * r),
            (s.tint[2] = ((255 & i) / 255) * r),
            (s.tint[3] = r),
            t.shader.bind(e),
            t.geometry.bind(n, e),
            t.state.set(this.state);
          for (var a = 0, l = o.length; a < l; a++)
            this._renderDrawCallDirect(t, n.drawCalls[a]);
        }),
        (e.prototype._renderDrawCallDirect = function (t, e) {
          for (
            var n = e.texArray,
              i = e.type,
              r = e.size,
              s = e.start,
              o = n.count,
              a = 0;
            a < o;
            a++
          )
            t.texture.bind(n.elements[a], a);
          t.geometry.draw(i, r, s);
        }),
        (e.prototype._resolveDirectShader = function (t) {
          var e = this.shader,
            n = this.pluginName;
          if (!e) {
            if (!nb[n]) {
              for (
                var i = t.plugins[n].MAX_TEXTURES, r = new Int32Array(i), s = 0;
                s < i;
                s++
              )
                r[s] = s;
              var o = {
                  tint: new Float32Array([1, 1, 1, 1]),
                  translationMatrix: new Um(),
                  default: mg.from({ uSamplers: r }, !0),
                },
                a = t.plugins[n]._shader.program;
              nb[n] = new Qg(a, o);
            }
            e = nb[n];
          }
          return e;
        }),
        (e.prototype._calculateBounds = function () {
          this.finishPoly();
          var t = this._geometry;
          if (t.graphicsData.length) {
            var e = t.bounds,
              n = e.minX,
              i = e.minY,
              r = e.maxX,
              s = e.maxY;
            this._bounds.addFrame(this.transform, n, i, r, s);
          }
        }),
        (e.prototype.containsPoint = function (t) {
          return (
            this.worldTransform.applyInverse(t, e._TEMP_POINT),
            this._geometry.containsPoint(e._TEMP_POINT)
          );
        }),
        (e.prototype.calculateTints = function () {
          if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            for (
              var t = em(this.tint, eb), e = 0;
              e < this.batches.length;
              e++
            ) {
              var n = this.batches[e],
                i = n._batchRGB,
                r =
                  ((t[0] * i[0] * 255) << 16) +
                  ((t[1] * i[1] * 255) << 8) +
                  (0 | (t[2] * i[2] * 255));
              n._tintRGB = (r >> 16) + (65280 & r) + ((255 & r) << 16);
            }
          }
        }),
        (e.prototype.calculateVertices = function () {
          var t = this.transform._worldID;
          if (this._transformID !== t) {
            this._transformID = t;
            for (
              var e = this.transform.worldTransform,
                n = e.a,
                i = e.b,
                r = e.c,
                s = e.d,
                o = e.tx,
                a = e.ty,
                l = this._geometry.points,
                h = this.vertexData,
                u = 0,
                c = 0;
              c < l.length;
              c += 2
            ) {
              var d = l[c],
                p = l[c + 1];
              (h[u++] = n * d + r * p + o), (h[u++] = s * p + i * d + a);
            }
          }
        }),
        (e.prototype.closePath = function () {
          var t = this.currentPath;
          return t && ((t.closeStroke = !0), this.finishPoly()), this;
        }),
        (e.prototype.setMatrix = function (t) {
          return (this._matrix = t), this;
        }),
        (e.prototype.beginHole = function () {
          return this.finishPoly(), (this._holeMode = !0), this;
        }),
        (e.prototype.endHole = function () {
          return this.finishPoly(), (this._holeMode = !1), this;
        }),
        (e.prototype.destroy = function (e) {
          this._geometry.refCount--,
            0 === this._geometry.refCount && this._geometry.dispose(),
            (this._matrix = null),
            (this.currentPath = null),
            this._lineStyle.destroy(),
            (this._lineStyle = null),
            this._fillStyle.destroy(),
            (this._fillStyle = null),
            (this._geometry = null),
            (this.shader = null),
            (this.vertexData = null),
            (this.batches.length = 0),
            (this.batches = null),
            t.prototype.destroy.call(this, e);
        }),
        (e.nextRoundedRectBehavior = !1),
        (e._TEMP_POINT = new Cm()),
        e
      );
    })(y_),
    rb = function (t, e) {
      return (rb =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  var sb,
    ob,
    ab = new Cm(),
    lb = new Uint16Array([0, 1, 2, 0, 2, 3]),
    hb = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n._anchor = new Fm(
            n._onAnchorUpdate,
            n,
            e ? e.defaultAnchor.x : 0,
            e ? e.defaultAnchor.y : 0
          )),
          (n._texture = null),
          (n._width = 0),
          (n._height = 0),
          (n._tint = null),
          (n._tintRGB = null),
          (n.tint = 16777215),
          (n.blendMode = xf.NORMAL),
          (n._cachedTint = 16777215),
          (n.uvs = null),
          (n.texture = e || eg.EMPTY),
          (n.vertexData = new Float32Array(8)),
          (n.vertexTrimmedData = null),
          (n._transformID = -1),
          (n._textureID = -1),
          (n._transformTrimmedID = -1),
          (n._textureTrimmedID = -1),
          (n.indices = lb),
          (n.pluginName = "batch"),
          (n.isSprite = !0),
          (n._roundPixels = Rp.ROUND_PIXELS),
          n
        );
      }
      return (
        (function (t, e) {
          function n() {
            this.constructor = t;
          }
          rb(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        })(e, t),
        (e.prototype._onTextureUpdate = function () {
          (this._textureID = -1),
            (this._textureTrimmedID = -1),
            (this._cachedTint = 16777215),
            this._width &&
              (this.scale.x =
                (pm(this.scale.x) * this._width) / this._texture.orig.width),
            this._height &&
              (this.scale.y =
                (pm(this.scale.y) * this._height) / this._texture.orig.height);
        }),
        (e.prototype._onAnchorUpdate = function () {
          (this._transformID = -1), (this._transformTrimmedID = -1);
        }),
        (e.prototype.calculateVertices = function () {
          var t = this._texture;
          if (
            this._transformID !== this.transform._worldID ||
            this._textureID !== t._updateID
          ) {
            this._textureID !== t._updateID &&
              (this.uvs = this._texture._uvs.uvsFloat32),
              (this._transformID = this.transform._worldID),
              (this._textureID = t._updateID);
            var e = this.transform.worldTransform,
              n = e.a,
              i = e.b,
              r = e.c,
              s = e.d,
              o = e.tx,
              a = e.ty,
              l = this.vertexData,
              h = t.trim,
              u = t.orig,
              c = this._anchor,
              d = 0,
              p = 0,
              f = 0,
              m = 0;
            if (
              (h
                ? ((d = (p = h.x - c._x * u.width) + h.width),
                  (f = (m = h.y - c._y * u.height) + h.height))
                : ((d = (p = -c._x * u.width) + u.width),
                  (f = (m = -c._y * u.height) + u.height)),
              (l[0] = n * p + r * m + o),
              (l[1] = s * m + i * p + a),
              (l[2] = n * d + r * m + o),
              (l[3] = s * m + i * d + a),
              (l[4] = n * d + r * f + o),
              (l[5] = s * f + i * d + a),
              (l[6] = n * p + r * f + o),
              (l[7] = s * f + i * p + a),
              this._roundPixels)
            )
              for (var _ = Rp.RESOLUTION, g = 0; g < l.length; ++g)
                l[g] = Math.round(((l[g] * _) | 0) / _);
          }
        }),
        (e.prototype.calculateTrimmedVertices = function () {
          if (this.vertexTrimmedData) {
            if (
              this._transformTrimmedID === this.transform._worldID &&
              this._textureTrimmedID === this._texture._updateID
            )
              return;
          } else this.vertexTrimmedData = new Float32Array(8);
          (this._transformTrimmedID = this.transform._worldID),
            (this._textureTrimmedID = this._texture._updateID);
          var t = this._texture,
            e = this.vertexTrimmedData,
            n = t.orig,
            i = this._anchor,
            r = this.transform.worldTransform,
            s = r.a,
            o = r.b,
            a = r.c,
            l = r.d,
            h = r.tx,
            u = r.ty,
            c = -i._x * n.width,
            d = c + n.width,
            p = -i._y * n.height,
            f = p + n.height;
          (e[0] = s * c + a * p + h),
            (e[1] = l * p + o * c + u),
            (e[2] = s * d + a * p + h),
            (e[3] = l * p + o * d + u),
            (e[4] = s * d + a * f + h),
            (e[5] = l * f + o * d + u),
            (e[6] = s * c + a * f + h),
            (e[7] = l * f + o * c + u);
        }),
        (e.prototype._render = function (t) {
          this.calculateVertices(),
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
            t.plugins[this.pluginName].render(this);
        }),
        (e.prototype._calculateBounds = function () {
          var t = this._texture.trim,
            e = this._texture.orig;
          !t || (t.width === e.width && t.height === e.height)
            ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData))
            : (this.calculateTrimmedVertices(),
              this._bounds.addQuad(this.vertexTrimmedData));
        }),
        (e.prototype.getLocalBounds = function (e) {
          return 0 === this.children.length
            ? (this._localBounds || (this._localBounds = new Ym()),
              (this._localBounds.minX =
                this._texture.orig.width * -this._anchor._x),
              (this._localBounds.minY =
                this._texture.orig.height * -this._anchor._y),
              (this._localBounds.maxX =
                this._texture.orig.width * (1 - this._anchor._x)),
              (this._localBounds.maxY =
                this._texture.orig.height * (1 - this._anchor._y)),
              e ||
                (this._localBoundsRect || (this._localBoundsRect = new Pm()),
                (e = this._localBoundsRect)),
              this._localBounds.getRectangle(e))
            : t.prototype.getLocalBounds.call(this, e);
        }),
        (e.prototype.containsPoint = function (t) {
          this.worldTransform.applyInverse(t, ab);
          var e = this._texture.orig.width,
            n = this._texture.orig.height,
            i = -e * this.anchor.x,
            r = 0;
          return (
            ab.x >= i &&
            ab.x < i + e &&
            ((r = -n * this.anchor.y), ab.y >= r && ab.y < r + n)
          );
        }),
        (e.prototype.destroy = function (e) {
          if (
            (t.prototype.destroy.call(this, e),
            this._texture.off("update", this._onTextureUpdate, this),
            (this._anchor = null),
            "boolean" == typeof e ? e : e && e.texture)
          ) {
            var n = "boolean" == typeof e ? e : e && e.baseTexture;
            this._texture.destroy(!!n);
          }
          this._texture = null;
        }),
        (e.from = function (t, n) {
          return new e(t instanceof eg ? t : eg.from(t, n));
        }),
        Object.defineProperty(e.prototype, "roundPixels", {
          get: function () {
            return this._roundPixels;
          },
          set: function (t) {
            this._roundPixels !== t && (this._transformID = -1),
              (this._roundPixels = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "width", {
          get: function () {
            return Math.abs(this.scale.x) * this._texture.orig.width;
          },
          set: function (t) {
            var e = pm(this.scale.x) || 1;
            (this.scale.x = (e * t) / this._texture.orig.width),
              (this._width = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "height", {
          get: function () {
            return Math.abs(this.scale.y) * this._texture.orig.height;
          },
          set: function (t) {
            var e = pm(this.scale.y) || 1;
            (this.scale.y = (e * t) / this._texture.orig.height),
              (this._height = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "anchor", {
          get: function () {
            return this._anchor;
          },
          set: function (t) {
            this._anchor.copyFrom(t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "tint", {
          get: function () {
            return this._tint;
          },
          set: function (t) {
            (this._tint = t),
              (this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "texture", {
          get: function () {
            return this._texture;
          },
          set: function (t) {
            this._texture !== t &&
              (this._texture &&
                this._texture.off("update", this._onTextureUpdate, this),
              (this._texture = t || eg.EMPTY),
              (this._cachedTint = 16777215),
              (this._textureID = -1),
              (this._textureTrimmedID = -1),
              t &&
                (t.baseTexture.valid
                  ? this._onTextureUpdate()
                  : t.once("update", this._onTextureUpdate, this)));
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(y_),
    ub = function (t, e) {
      return (ub =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  ((ob = sb || (sb = {}))[(ob.LINEAR_VERTICAL = 0)] = "LINEAR_VERTICAL"),
    (ob[(ob.LINEAR_HORIZONTAL = 1)] = "LINEAR_HORIZONTAL");
  var cb = {
      align: "left",
      breakWords: !1,
      dropShadow: !1,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fillGradientType: sb.LINEAR_VERTICAL,
      fillGradientStops: [],
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      letterSpacing: 0,
      lineHeight: 0,
      lineJoin: "miter",
      miterLimit: 10,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      textBaseline: "alphabetic",
      trim: !1,
      whiteSpace: "pre",
      wordWrap: !1,
      wordWrapWidth: 100,
      leading: 0,
    },
    db = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
    ],
    pb = (function () {
      function t(t) {
        (this.styleID = 0), this.reset(), _b(this, t, t);
      }
      return (
        (t.prototype.clone = function () {
          var e = {};
          return _b(e, this, cb), new t(e);
        }),
        (t.prototype.reset = function () {
          _b(this, cb, cb);
        }),
        Object.defineProperty(t.prototype, "align", {
          get: function () {
            return this._align;
          },
          set: function (t) {
            this._align !== t && ((this._align = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "breakWords", {
          get: function () {
            return this._breakWords;
          },
          set: function (t) {
            this._breakWords !== t && ((this._breakWords = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadow", {
          get: function () {
            return this._dropShadow;
          },
          set: function (t) {
            this._dropShadow !== t && ((this._dropShadow = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadowAlpha", {
          get: function () {
            return this._dropShadowAlpha;
          },
          set: function (t) {
            this._dropShadowAlpha !== t &&
              ((this._dropShadowAlpha = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadowAngle", {
          get: function () {
            return this._dropShadowAngle;
          },
          set: function (t) {
            this._dropShadowAngle !== t &&
              ((this._dropShadowAngle = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadowBlur", {
          get: function () {
            return this._dropShadowBlur;
          },
          set: function (t) {
            this._dropShadowBlur !== t &&
              ((this._dropShadowBlur = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadowColor", {
          get: function () {
            return this._dropShadowColor;
          },
          set: function (t) {
            var e = mb(t);
            this._dropShadowColor !== e &&
              ((this._dropShadowColor = e), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "dropShadowDistance", {
          get: function () {
            return this._dropShadowDistance;
          },
          set: function (t) {
            this._dropShadowDistance !== t &&
              ((this._dropShadowDistance = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fill", {
          get: function () {
            return this._fill;
          },
          set: function (t) {
            var e = mb(t);
            this._fill !== e && ((this._fill = e), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fillGradientType", {
          get: function () {
            return this._fillGradientType;
          },
          set: function (t) {
            this._fillGradientType !== t &&
              ((this._fillGradientType = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fillGradientStops", {
          get: function () {
            return this._fillGradientStops;
          },
          set: function (t) {
            (function (t, e) {
              if (!Array.isArray(t) || !Array.isArray(e)) return !1;
              if (t.length !== e.length) return !1;
              for (var n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;
              return !0;
            })(this._fillGradientStops, t) ||
              ((this._fillGradientStops = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fontFamily", {
          get: function () {
            return this._fontFamily;
          },
          set: function (t) {
            this.fontFamily !== t && ((this._fontFamily = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fontSize", {
          get: function () {
            return this._fontSize;
          },
          set: function (t) {
            this._fontSize !== t && ((this._fontSize = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fontStyle", {
          get: function () {
            return this._fontStyle;
          },
          set: function (t) {
            this._fontStyle !== t && ((this._fontStyle = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fontVariant", {
          get: function () {
            return this._fontVariant;
          },
          set: function (t) {
            this._fontVariant !== t &&
              ((this._fontVariant = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "fontWeight", {
          get: function () {
            return this._fontWeight;
          },
          set: function (t) {
            this._fontWeight !== t && ((this._fontWeight = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "letterSpacing", {
          get: function () {
            return this._letterSpacing;
          },
          set: function (t) {
            this._letterSpacing !== t &&
              ((this._letterSpacing = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "lineHeight", {
          get: function () {
            return this._lineHeight;
          },
          set: function (t) {
            this._lineHeight !== t && ((this._lineHeight = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "leading", {
          get: function () {
            return this._leading;
          },
          set: function (t) {
            this._leading !== t && ((this._leading = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "lineJoin", {
          get: function () {
            return this._lineJoin;
          },
          set: function (t) {
            this._lineJoin !== t && ((this._lineJoin = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "miterLimit", {
          get: function () {
            return this._miterLimit;
          },
          set: function (t) {
            this._miterLimit !== t && ((this._miterLimit = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "padding", {
          get: function () {
            return this._padding;
          },
          set: function (t) {
            this._padding !== t && ((this._padding = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "stroke", {
          get: function () {
            return this._stroke;
          },
          set: function (t) {
            var e = mb(t);
            this._stroke !== e && ((this._stroke = e), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "strokeThickness", {
          get: function () {
            return this._strokeThickness;
          },
          set: function (t) {
            this._strokeThickness !== t &&
              ((this._strokeThickness = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "textBaseline", {
          get: function () {
            return this._textBaseline;
          },
          set: function (t) {
            this._textBaseline !== t &&
              ((this._textBaseline = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "trim", {
          get: function () {
            return this._trim;
          },
          set: function (t) {
            this._trim !== t && ((this._trim = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "whiteSpace", {
          get: function () {
            return this._whiteSpace;
          },
          set: function (t) {
            this._whiteSpace !== t && ((this._whiteSpace = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "wordWrap", {
          get: function () {
            return this._wordWrap;
          },
          set: function (t) {
            this._wordWrap !== t && ((this._wordWrap = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "wordWrapWidth", {
          get: function () {
            return this._wordWrapWidth;
          },
          set: function (t) {
            this._wordWrapWidth !== t &&
              ((this._wordWrapWidth = t), this.styleID++);
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.toFontString = function () {
          var t =
              "number" == typeof this.fontSize
                ? this.fontSize + "px"
                : this.fontSize,
            e = this.fontFamily;
          Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
          for (var n = e.length - 1; n >= 0; n--) {
            var i = e[n].trim();
            !/([\"\'])[^\'\"]+\1/.test(i) &&
              db.indexOf(i) < 0 &&
              (i = '"' + i + '"'),
              (e[n] = i);
          }
          return (
            this.fontStyle +
            " " +
            this.fontVariant +
            " " +
            this.fontWeight +
            " " +
            t +
            " " +
            e.join(",")
          );
        }),
        t
      );
    })();
  function fb(t) {
    return "number" == typeof t
      ? nm(t)
      : ("string" == typeof t &&
          0 === t.indexOf("0x") &&
          (t = t.replace("0x", "#")),
        t);
  }
  function mb(t) {
    if (Array.isArray(t)) {
      for (var e = 0; e < t.length; ++e) t[e] = fb(t[e]);
      return t;
    }
    return fb(t);
  }
  function _b(t, e, n) {
    for (var i in n)
      Array.isArray(e[i]) ? (t[i] = e[i].slice()) : (t[i] = e[i]);
  }
  var gb = (function () {
    function t(t, e, n, i, r, s, o, a, l) {
      (this.text = t),
        (this.style = e),
        (this.width = n),
        (this.height = i),
        (this.lines = r),
        (this.lineWidths = s),
        (this.lineHeight = o),
        (this.maxLineWidth = a),
        (this.fontProperties = l);
    }
    return (
      (t.measureText = function (e, n, i, r) {
        void 0 === r && (r = t._canvas), (i = null == i ? n.wordWrap : i);
        var s = n.toFontString(),
          o = t.measureFont(s);
        0 === o.fontSize &&
          ((o.fontSize = n.fontSize), (o.ascent = n.fontSize));
        var a = r.getContext("2d");
        a.font = s;
        for (
          var l = (i ? t.wordWrap(e, n, r) : e).split(/(?:\r\n|\r|\n)/),
            h = new Array(l.length),
            u = 0,
            c = 0;
          c < l.length;
          c++
        ) {
          var d =
            a.measureText(l[c]).width + (l[c].length - 1) * n.letterSpacing;
          (h[c] = d), (u = Math.max(u, d));
        }
        var p = u + n.strokeThickness;
        n.dropShadow && (p += n.dropShadowDistance);
        var f = n.lineHeight || o.fontSize + n.strokeThickness,
          m =
            Math.max(f, o.fontSize + n.strokeThickness) +
            (l.length - 1) * (f + n.leading);
        return (
          n.dropShadow && (m += n.dropShadowDistance),
          new t(e, n, p, m, l, h, f + n.leading, u, o)
        );
      }),
      (t.wordWrap = function (e, n, i) {
        void 0 === i && (i = t._canvas);
        for (
          var r = i.getContext("2d"),
            s = 0,
            o = "",
            a = "",
            l = Object.create(null),
            h = n.letterSpacing,
            u = n.whiteSpace,
            c = t.collapseSpaces(u),
            d = t.collapseNewlines(u),
            p = !c,
            f = n.wordWrapWidth + h,
            m = t.tokenize(e),
            _ = 0;
          _ < m.length;
          _++
        ) {
          var g = m[_];
          if (t.isNewline(g)) {
            if (!d) {
              (a += t.addLine(o)), (p = !c), (o = ""), (s = 0);
              continue;
            }
            g = " ";
          }
          if (c) {
            var v = t.isBreakingSpace(g),
              y = t.isBreakingSpace(o[o.length - 1]);
            if (v && y) continue;
          }
          var x = t.getFromCache(g, h, l, r);
          if (x > f)
            if (
              ("" !== o && ((a += t.addLine(o)), (o = ""), (s = 0)),
              t.canBreakWords(g, n.breakWords))
            )
              for (var b = t.wordWrapSplit(g), T = 0; T < b.length; T++) {
                for (var E = b[T], S = 1; b[T + S]; ) {
                  var w = b[T + S],
                    M = E[E.length - 1];
                  if (t.canBreakChars(M, w, g, T, n.breakWords)) break;
                  (E += w), S++;
                }
                T += E.length - 1;
                var A = t.getFromCache(E, h, l, r);
                A + s > f && ((a += t.addLine(o)), (p = !1), (o = ""), (s = 0)),
                  (o += E),
                  (s += A);
              }
            else {
              o.length > 0 && ((a += t.addLine(o)), (o = ""), (s = 0));
              var R = _ === m.length - 1;
              (a += t.addLine(g, !R)), (p = !1), (o = ""), (s = 0);
            }
          else
            x + s > f && ((p = !1), (a += t.addLine(o)), (o = ""), (s = 0)),
              (o.length > 0 || !t.isBreakingSpace(g) || p) &&
                ((o += g), (s += x));
        }
        return (a += t.addLine(o, !1));
      }),
      (t.addLine = function (e, n) {
        return (
          void 0 === n && (n = !0), (e = t.trimRight(e)), (e = n ? e + "\n" : e)
        );
      }),
      (t.getFromCache = function (t, e, n, i) {
        var r = n[t];
        if ("number" != typeof r) {
          var s = t.length * e;
          (r = i.measureText(t).width + s), (n[t] = r);
        }
        return r;
      }),
      (t.collapseSpaces = function (t) {
        return "normal" === t || "pre-line" === t;
      }),
      (t.collapseNewlines = function (t) {
        return "normal" === t;
      }),
      (t.trimRight = function (e) {
        if ("string" != typeof e) return "";
        for (var n = e.length - 1; n >= 0; n--) {
          var i = e[n];
          if (!t.isBreakingSpace(i)) break;
          e = e.slice(0, -1);
        }
        return e;
      }),
      (t.isNewline = function (e) {
        return (
          "string" == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0
        );
      }),
      (t.isBreakingSpace = function (e, n) {
        return (
          "string" == typeof e &&
          t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0
        );
      }),
      (t.tokenize = function (e) {
        var n = [],
          i = "";
        if ("string" != typeof e) return n;
        for (var r = 0; r < e.length; r++) {
          var s = e[r],
            o = e[r + 1];
          t.isBreakingSpace(s, o) || t.isNewline(s)
            ? ("" !== i && (n.push(i), (i = "")), n.push(s))
            : (i += s);
        }
        return "" !== i && n.push(i), n;
      }),
      (t.canBreakWords = function (t, e) {
        return e;
      }),
      (t.canBreakChars = function (t, e, n, i, r) {
        return !0;
      }),
      (t.wordWrapSplit = function (t) {
        return t.split("");
      }),
      (t.measureFont = function (e) {
        if (t._fonts[e]) return t._fonts[e];
        var n = { ascent: 0, descent: 0, fontSize: 0 },
          i = t._canvas,
          r = t._context;
        r.font = e;
        var s = t.METRICS_STRING + t.BASELINE_SYMBOL,
          o = Math.ceil(r.measureText(s).width),
          a = Math.ceil(r.measureText(t.BASELINE_SYMBOL).width),
          l = Math.ceil(t.HEIGHT_MULTIPLIER * a);
        (a = (a * t.BASELINE_MULTIPLIER) | 0),
          (i.width = o),
          (i.height = l),
          (r.fillStyle = "#f00"),
          r.fillRect(0, 0, o, l),
          (r.font = e),
          (r.textBaseline = "alphabetic"),
          (r.fillStyle = "#000"),
          r.fillText(s, 0, a);
        var h = r.getImageData(0, 0, o, l).data,
          u = h.length,
          c = 4 * o,
          d = 0,
          p = 0,
          f = !1;
        for (d = 0; d < a; ++d) {
          for (var m = 0; m < c; m += 4)
            if (255 !== h[p + m]) {
              f = !0;
              break;
            }
          if (f) break;
          p += c;
        }
        for (n.ascent = a - d, p = u - c, f = !1, d = l; d > a; --d) {
          for (m = 0; m < c; m += 4)
            if (255 !== h[p + m]) {
              f = !0;
              break;
            }
          if (f) break;
          p -= c;
        }
        return (
          (n.descent = d - a),
          (n.fontSize = n.ascent + n.descent),
          (t._fonts[e] = n),
          n
        );
      }),
      (t.clearMetrics = function (e) {
        void 0 === e && (e = ""), e ? delete t._fonts[e] : (t._fonts = {});
      }),
      Object.defineProperty(t, "_canvas", {
        get: function () {
          if (!t.__canvas) {
            var e = void 0;
            try {
              var n = new OffscreenCanvas(0, 0),
                i = n.getContext("2d");
              if (i && i.measureText) return (t.__canvas = n), n;
              e = Rp.ADAPTER.createCanvas();
            } catch (r) {
              e = Rp.ADAPTER.createCanvas();
            }
            (e.width = e.height = 10), (t.__canvas = e);
          }
          return t.__canvas;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t, "_context", {
        get: function () {
          return (
            t.__context || (t.__context = t._canvas.getContext("2d")),
            t.__context
          );
        },
        enumerable: !1,
        configurable: !0,
      }),
      t
    );
  })();
  (gb._fonts = {}),
    (gb.METRICS_STRING = "|q"),
    (gb.BASELINE_SYMBOL = "M"),
    (gb.BASELINE_MULTIPLIER = 1.4),
    (gb.HEIGHT_MULTIPLIER = 2),
    (gb._newlines = [10, 13]),
    (gb._breakingSpaces = [
      9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
      12288,
    ]);
  var vb = { texture: !0, children: !1, baseTexture: !0 },
    yb = (function (t) {
      function e(e, n, i) {
        var r = this,
          s = !1;
        i || ((i = Rp.ADAPTER.createCanvas()), (s = !0)),
          (i.width = 3),
          (i.height = 3);
        var o = eg.from(i);
        return (
          (o.orig = new Pm()),
          (o.trim = new Pm()),
          ((r = t.call(this, o) || this)._ownCanvas = s),
          (r.canvas = i),
          (r.context = i.getContext("2d")),
          (r._resolution = Rp.RESOLUTION),
          (r._autoResolution = !0),
          (r._text = null),
          (r._style = null),
          (r._styleListener = null),
          (r._font = ""),
          (r.text = e),
          (r.style = n),
          (r.localStyleID = -1),
          r
        );
      }
      return (
        (function (t, e) {
          function n() {
            this.constructor = t;
          }
          ub(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        })(e, t),
        (e.prototype.updateText = function (t) {
          var n = this._style;
          if (
            (this.localStyleID !== n.styleID &&
              ((this.dirty = !0), (this.localStyleID = n.styleID)),
            this.dirty || !t)
          ) {
            this._font = this._style.toFontString();
            var i,
              r,
              s = this.context,
              o = gb.measureText(
                this._text || " ",
                this._style,
                this._style.wordWrap,
                this.canvas
              ),
              a = o.width,
              l = o.height,
              h = o.lines,
              u = o.lineHeight,
              c = o.lineWidths,
              d = o.maxLineWidth,
              p = o.fontProperties;
            (this.canvas.width = Math.ceil(
              Math.ceil(Math.max(1, a) + 2 * n.padding) * this._resolution
            )),
              (this.canvas.height = Math.ceil(
                Math.ceil(Math.max(1, l) + 2 * n.padding) * this._resolution
              )),
              s.scale(this._resolution, this._resolution),
              s.clearRect(0, 0, this.canvas.width, this.canvas.height),
              (s.font = this._font),
              (s.lineWidth = n.strokeThickness),
              (s.textBaseline = n.textBaseline),
              (s.lineJoin = n.lineJoin),
              (s.miterLimit = n.miterLimit);
            for (var f = n.dropShadow ? 2 : 1, m = 0; m < f; ++m) {
              var _ = n.dropShadow && 0 === m,
                g = _ ? Math.ceil(Math.max(1, l) + 2 * n.padding) : 0,
                v = g * this._resolution;
              if (_) {
                (s.fillStyle = "black"), (s.strokeStyle = "black");
                var y = n.dropShadowColor,
                  x = em("number" == typeof y ? y : im(y)),
                  b = n.dropShadowBlur * this._resolution,
                  T = n.dropShadowDistance * this._resolution;
                (s.shadowColor =
                  "rgba(" +
                  255 * x[0] +
                  "," +
                  255 * x[1] +
                  "," +
                  255 * x[2] +
                  "," +
                  n.dropShadowAlpha +
                  ")"),
                  (s.shadowBlur = b),
                  (s.shadowOffsetX = Math.cos(n.dropShadowAngle) * T),
                  (s.shadowOffsetY = Math.sin(n.dropShadowAngle) * T + v);
              } else
                (s.fillStyle = this._generateFillStyle(n, h, o)),
                  (s.strokeStyle = n.stroke),
                  (s.shadowColor = "black"),
                  (s.shadowBlur = 0),
                  (s.shadowOffsetX = 0),
                  (s.shadowOffsetY = 0);
              var E = (u - p.fontSize) / 2;
              (!e.nextLineHeightBehavior || u - p.fontSize < 0) && (E = 0);
              for (var S = 0; S < h.length; S++)
                (i = n.strokeThickness / 2),
                  (r = n.strokeThickness / 2 + S * u + p.ascent + E),
                  "right" === n.align
                    ? (i += d - c[S])
                    : "center" === n.align && (i += (d - c[S]) / 2),
                  n.stroke &&
                    n.strokeThickness &&
                    this.drawLetterSpacing(
                      h[S],
                      i + n.padding,
                      r + n.padding - g,
                      !0
                    ),
                  n.fill &&
                    this.drawLetterSpacing(
                      h[S],
                      i + n.padding,
                      r + n.padding - g
                    );
            }
            this.updateTexture();
          }
        }),
        (e.prototype.drawLetterSpacing = function (t, n, i, r) {
          void 0 === r && (r = !1);
          var s = this._style.letterSpacing,
            o =
              e.experimentalLetterSpacing &&
              ("letterSpacing" in CanvasRenderingContext2D.prototype ||
                "textLetterSpacing" in CanvasRenderingContext2D.prototype);
          if (0 === s || o)
            return (
              o &&
                ((this.context.letterSpacing = s),
                (this.context.textLetterSpacing = s)),
              void (r
                ? this.context.strokeText(t, n, i)
                : this.context.fillText(t, n, i))
            );
          for (
            var a = n,
              l = Array.from ? Array.from(t) : t.split(""),
              h = this.context.measureText(t).width,
              u = 0,
              c = 0;
            c < l.length;
            ++c
          ) {
            var d = l[c];
            r
              ? this.context.strokeText(d, a, i)
              : this.context.fillText(d, a, i);
            for (var p = "", f = c + 1; f < l.length; ++f) p += l[f];
            (a += h - (u = this.context.measureText(p).width) + s), (h = u);
          }
        }),
        (e.prototype.updateTexture = function () {
          var t = this.canvas;
          if (this._style.trim) {
            var e = (function (t) {
              var e,
                n,
                i,
                r = t.width,
                s = t.height,
                o = t.getContext("2d"),
                a = o.getImageData(0, 0, r, s).data,
                l = a.length,
                h = { top: null, left: null, right: null, bottom: null },
                u = null;
              for (e = 0; e < l; e += 4)
                0 !== a[e + 3] &&
                  ((n = (e / 4) % r),
                  (i = ~~(e / 4 / r)),
                  null === h.top && (h.top = i),
                  (null === h.left || n < h.left) && (h.left = n),
                  (null === h.right || h.right < n) && (h.right = n + 1),
                  (null === h.bottom || h.bottom < i) && (h.bottom = i));
              return (
                null !== h.top &&
                  ((r = h.right - h.left),
                  (s = h.bottom - h.top + 1),
                  (u = o.getImageData(h.left, h.top, r, s))),
                { height: s, width: r, data: u }
              );
            })(t);
            e.data &&
              ((t.width = e.width),
              (t.height = e.height),
              this.context.putImageData(e.data, 0, 0));
          }
          var n = this._texture,
            i = this._style,
            r = i.trim ? 0 : i.padding,
            s = n.baseTexture;
          (n.trim.width = n._frame.width = t.width / this._resolution),
            (n.trim.height = n._frame.height = t.height / this._resolution),
            (n.trim.x = -r),
            (n.trim.y = -r),
            (n.orig.width = n._frame.width - 2 * r),
            (n.orig.height = n._frame.height - 2 * r),
            this._onTextureUpdate(),
            s.setRealSize(t.width, t.height, this._resolution),
            n.updateUvs(),
            (this.dirty = !1);
        }),
        (e.prototype._render = function (e) {
          this._autoResolution &&
            this._resolution !== e.resolution &&
            ((this._resolution = e.resolution), (this.dirty = !0)),
            this.updateText(!0),
            t.prototype._render.call(this, e);
        }),
        (e.prototype.updateTransform = function () {
          this.updateText(!0), t.prototype.updateTransform.call(this);
        }),
        (e.prototype.getBounds = function (e, n) {
          return (
            this.updateText(!0),
            -1 === this._textureID && (e = !1),
            t.prototype.getBounds.call(this, e, n)
          );
        }),
        (e.prototype.getLocalBounds = function (e) {
          return this.updateText(!0), t.prototype.getLocalBounds.call(this, e);
        }),
        (e.prototype._calculateBounds = function () {
          this.calculateVertices(), this._bounds.addQuad(this.vertexData);
        }),
        (e.prototype._generateFillStyle = function (t, e, n) {
          var i,
            r = t.fill;
          if (!Array.isArray(r)) return r;
          if (1 === r.length) return r[0];
          var s = t.dropShadow ? t.dropShadowDistance : 0,
            o = t.padding || 0,
            a = this.canvas.width / this._resolution - s - 2 * o,
            l = this.canvas.height / this._resolution - s - 2 * o,
            h = r.slice(),
            u = t.fillGradientStops.slice();
          if (!u.length)
            for (var c = h.length + 1, d = 1; d < c; ++d) u.push(d / c);
          if (
            (h.unshift(r[0]),
            u.unshift(0),
            h.push(r[r.length - 1]),
            u.push(1),
            t.fillGradientType === sb.LINEAR_VERTICAL)
          ) {
            i = this.context.createLinearGradient(a / 2, o, a / 2, l + o);
            var p = n.fontProperties.fontSize + t.strokeThickness;
            for (d = 0; d < e.length; d++) {
              var f = n.lineHeight * (d - 1) + p,
                m = n.lineHeight * d,
                _ = m;
              d > 0 && f > m && (_ = (m + f) / 2);
              var g = m + p,
                v = n.lineHeight * (d + 1),
                y = g;
              d + 1 < e.length && v < g && (y = (g + v) / 2);
              for (var x = (y - _) / l, b = 0; b < h.length; b++) {
                var T = 0;
                T = "number" == typeof u[b] ? u[b] : b / h.length;
                var E = Math.min(1, Math.max(0, _ / l + T * x));
                (E = Number(E.toFixed(5))), i.addColorStop(E, h[b]);
              }
            }
          } else {
            i = this.context.createLinearGradient(o, l / 2, a + o, l / 2);
            var S = h.length + 1,
              w = 1;
            for (d = 0; d < h.length; d++) {
              var M = void 0;
              (M = "number" == typeof u[d] ? u[d] : w / S),
                i.addColorStop(M, h[d]),
                w++;
            }
          }
          return i;
        }),
        (e.prototype.destroy = function (e) {
          "boolean" == typeof e && (e = { children: e }),
            (e = Object.assign({}, vb, e)),
            t.prototype.destroy.call(this, e),
            this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
            (this.context = null),
            (this.canvas = null),
            (this._style = null);
        }),
        Object.defineProperty(e.prototype, "width", {
          get: function () {
            return (
              this.updateText(!0),
              Math.abs(this.scale.x) * this._texture.orig.width
            );
          },
          set: function (t) {
            this.updateText(!0);
            var e = pm(this.scale.x) || 1;
            (this.scale.x = (e * t) / this._texture.orig.width),
              (this._width = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "height", {
          get: function () {
            return (
              this.updateText(!0),
              Math.abs(this.scale.y) * this._texture.orig.height
            );
          },
          set: function (t) {
            this.updateText(!0);
            var e = pm(this.scale.y) || 1;
            (this.scale.y = (e * t) / this._texture.orig.height),
              (this._height = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "style", {
          get: function () {
            return this._style;
          },
          set: function (t) {
            (t = t || {}),
              (this._style = t instanceof pb ? t : new pb(t)),
              (this.localStyleID = -1),
              (this.dirty = !0);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "text", {
          get: function () {
            return this._text;
          },
          set: function (t) {
            (t = String(null == t ? "" : t)),
              this._text !== t && ((this._text = t), (this.dirty = !0));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "resolution", {
          get: function () {
            return this._resolution;
          },
          set: function (t) {
            (this._autoResolution = !1),
              this._resolution !== t &&
                ((this._resolution = t), (this.dirty = !0));
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.nextLineHeightBehavior = !1),
        (e.experimentalLetterSpacing = !1),
        e
      );
    })(hb);
  Rp.UPLOADS_PER_FRAME = 4;
  var xb = function (t, e) {
    return (xb =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  var bb = (function () {
    function t(t) {
      (this.maxItemsPerFrame = t), (this.itemsLeft = 0);
    }
    return (
      (t.prototype.beginFrame = function () {
        this.itemsLeft = this.maxItemsPerFrame;
      }),
      (t.prototype.allowedToUpload = function () {
        return this.itemsLeft-- > 0;
      }),
      t
    );
  })();
  function Tb(t, e) {
    var n = !1;
    if (t && t._textures && t._textures.length)
      for (var i = 0; i < t._textures.length; i++)
        if (t._textures[i] instanceof eg) {
          var r = t._textures[i].baseTexture;
          -1 === e.indexOf(r) && (e.push(r), (n = !0));
        }
    return n;
  }
  function Eb(t, e) {
    if (t.baseTexture instanceof k_) {
      var n = t.baseTexture;
      return -1 === e.indexOf(n) && e.push(n), !0;
    }
    return !1;
  }
  function Sb(t, e) {
    if (t._texture && t._texture instanceof eg) {
      var n = t._texture.baseTexture;
      return -1 === e.indexOf(n) && e.push(n), !0;
    }
    return !1;
  }
  function wb(t, e) {
    return e instanceof yb && (e.updateText(!0), !0);
  }
  function Mb(t, e) {
    if (e instanceof pb) {
      var n = e.toFontString();
      return gb.measureFont(n), !0;
    }
    return !1;
  }
  function Ab(t, e) {
    if (t instanceof yb) {
      -1 === e.indexOf(t.style) && e.push(t.style),
        -1 === e.indexOf(t) && e.push(t);
      var n = t._texture.baseTexture;
      return -1 === e.indexOf(n) && e.push(n), !0;
    }
    return !1;
  }
  function Rb(t, e) {
    return t instanceof pb && (-1 === e.indexOf(t) && e.push(t), !0);
  }
  function Cb(t, e) {
    return (
      e instanceof k_ && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
    );
  }
  function Ib(t, e) {
    if (!(e instanceof ib)) return !1;
    var n = e.geometry;
    e.finishPoly(), n.updateBatches();
    for (var i = n.batches, r = 0; r < i.length; r++) {
      var s = i[r].style.texture;
      s && Cb(t, s.baseTexture);
    }
    return n.batchable || t.geometry.bind(n, e._resolveDirectShader(t)), !0;
  }
  function Pb(t, e) {
    return t instanceof ib && (e.push(t), !0);
  }
  var Ob = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.uploadHookHelper = n.renderer),
          n.registerFindHook(Pb),
          n.registerUploadHook(Cb),
          n.registerUploadHook(Ib),
          n
        );
      }
      return (
        (function (t, e) {
          function n() {
            this.constructor = t;
          }
          xb(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        })(e, t),
        (e.extension = { name: "prepare", type: x_.RendererPlugin }),
        e
      );
    })(
      (function () {
        function t(t) {
          var e = this;
          (this.limiter = new bb(Rp.UPLOADS_PER_FRAME)),
            (this.renderer = t),
            (this.uploadHookHelper = null),
            (this.queue = []),
            (this.addHooks = []),
            (this.uploadHooks = []),
            (this.completes = []),
            (this.ticking = !1),
            (this.delayedTick = function () {
              e.queue && e.prepareItems();
            }),
            this.registerFindHook(Ab),
            this.registerFindHook(Rb),
            this.registerFindHook(Tb),
            this.registerFindHook(Eb),
            this.registerFindHook(Sb),
            this.registerUploadHook(wb),
            this.registerUploadHook(Mb);
        }
        return (
          (t.prototype.upload = function (t, e) {
            var n = this;
            return (
              "function" == typeof t && ((e = t), (t = null)),
              e &&
                gm(
                  "6.5.0",
                  "BasePrepare.upload callback is deprecated, use the return Promise instead."
                ),
              new Promise(function (i) {
                t && n.add(t);
                var r = function () {
                  null == e || e(), i();
                };
                n.queue.length
                  ? (n.completes.push(r),
                    n.ticking ||
                      ((n.ticking = !0),
                      C_.system.addOnce(n.tick, n, E_.UTILITY)))
                  : r();
              })
            );
          }),
          (t.prototype.tick = function () {
            setTimeout(this.delayedTick, 0);
          }),
          (t.prototype.prepareItems = function () {
            for (
              this.limiter.beginFrame();
              this.queue.length && this.limiter.allowedToUpload();

            ) {
              var t = this.queue[0],
                e = !1;
              if (t && !t._destroyed)
                for (var n = 0, i = this.uploadHooks.length; n < i; n++)
                  if (this.uploadHooks[n](this.uploadHookHelper, t)) {
                    this.queue.shift(), (e = !0);
                    break;
                  }
              e || this.queue.shift();
            }
            if (this.queue.length)
              C_.system.addOnce(this.tick, this, E_.UTILITY);
            else {
              this.ticking = !1;
              var r = this.completes.slice(0);
              this.completes.length = 0;
              for (n = 0, i = r.length; n < i; n++) r[n]();
            }
          }),
          (t.prototype.registerFindHook = function (t) {
            return t && this.addHooks.push(t), this;
          }),
          (t.prototype.registerUploadHook = function (t) {
            return t && this.uploadHooks.push(t), this;
          }),
          (t.prototype.add = function (t) {
            for (
              var e = 0, n = this.addHooks.length;
              e < n && !this.addHooks[e](t, this.queue);
              e++
            );
            if (t instanceof y_)
              for (e = t.children.length - 1; e >= 0; e--)
                this.add(t.children[e]);
            return this;
          }),
          (t.prototype.destroy = function () {
            this.ticking && C_.system.remove(this.tick, this),
              (this.ticking = !1),
              (this.addHooks = null),
              (this.uploadHooks = null),
              (this.renderer = null),
              (this.completes = null),
              (this.queue = null),
              (this.limiter = null),
              (this.uploadHookHelper = null);
          }),
          t
        );
      })()
    ),
    Nb = (function () {
      function t(t, e, n) {
        void 0 === n && (n = null),
          (this.linkedSheets = []),
          (this._texture = t instanceof eg ? t : null),
          (this.baseTexture = t instanceof k_ ? t : this._texture.baseTexture),
          (this.textures = {}),
          (this.animations = {}),
          (this.data = e);
        var i = this.baseTexture.resource;
        (this.resolution = this._updateResolution(n || (i ? i.url : null))),
          (this._frames = this.data.frames),
          (this._frameKeys = Object.keys(this._frames)),
          (this._batchIndex = 0),
          (this._callback = null);
      }
      return (
        (t.prototype._updateResolution = function (t) {
          void 0 === t && (t = null);
          var e = this.data.meta.scale,
            n = Em(t, null);
          return (
            null === n && (n = void 0 !== e ? parseFloat(e) : 1),
            1 !== n && this.baseTexture.setResolution(n),
            n
          );
        }),
        (t.prototype.parse = function (e) {
          var n = this;
          return (
            e &&
              gm(
                "6.5.0",
                "Spritesheet.parse callback is deprecated, use the return Promise instead."
              ),
            new Promise(function (i) {
              (n._callback = function (t) {
                null == e || e(t), i(t);
              }),
                (n._batchIndex = 0),
                n._frameKeys.length <= t.BATCH_SIZE
                  ? (n._processFrames(0),
                    n._processAnimations(),
                    n._parseComplete())
                  : n._nextBatch();
            })
          );
        }),
        (t.prototype._processFrames = function (e) {
          for (
            var n = e, i = t.BATCH_SIZE;
            n - e < i && n < this._frameKeys.length;

          ) {
            var r = this._frameKeys[n],
              s = this._frames[r],
              o = s.frame;
            if (o) {
              var a = null,
                l = null,
                h = !1 !== s.trimmed && s.sourceSize ? s.sourceSize : s.frame,
                u = new Pm(
                  0,
                  0,
                  Math.floor(h.w) / this.resolution,
                  Math.floor(h.h) / this.resolution
                );
              (a = s.rotated
                ? new Pm(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                    Math.floor(o.w) / this.resolution
                  )
                : new Pm(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution
                  )),
                !1 !== s.trimmed &&
                  s.spriteSourceSize &&
                  (l = new Pm(
                    Math.floor(s.spriteSourceSize.x) / this.resolution,
                    Math.floor(s.spriteSourceSize.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution
                  )),
                (this.textures[r] = new eg(
                  this.baseTexture,
                  a,
                  u,
                  l,
                  s.rotated ? 2 : 0,
                  s.anchor
                )),
                eg.addToCache(this.textures[r], r);
            }
            n++;
          }
        }),
        (t.prototype._processAnimations = function () {
          var t = this.data.animations || {};
          for (var e in t) {
            this.animations[e] = [];
            for (var n = 0; n < t[e].length; n++) {
              var i = t[e][n];
              this.animations[e].push(this.textures[i]);
            }
          }
        }),
        (t.prototype._parseComplete = function () {
          var t = this._callback;
          (this._callback = null),
            (this._batchIndex = 0),
            t.call(this, this.textures);
        }),
        (t.prototype._nextBatch = function () {
          var e = this;
          this._processFrames(this._batchIndex * t.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(function () {
              e._batchIndex * t.BATCH_SIZE < e._frameKeys.length
                ? e._nextBatch()
                : (e._processAnimations(), e._parseComplete());
            }, 0);
        }),
        (t.prototype.destroy = function (t) {
          var e;
          for (var n in (void 0 === t && (t = !1), this.textures))
            this.textures[n].destroy();
          (this._frames = null),
            (this._frameKeys = null),
            (this.data = null),
            (this.textures = null),
            t &&
              (null === (e = this._texture) || void 0 === e || e.destroy(),
              this.baseTexture.destroy()),
            (this._texture = null),
            (this.baseTexture = null),
            (this.linkedSheets = []);
        }),
        (t.BATCH_SIZE = 1e3),
        t
      );
    })(),
    Db = (function () {
      function t() {}
      return (
        (t.use = function (e, n) {
          var i,
            r,
            s = this,
            o = e.name + "_image";
          if (
            e.data &&
            e.type === fy.TYPE.JSON &&
            e.data.frames &&
            !s.resources[o]
          ) {
            var a =
              null ===
                (r = null === (i = e.data) || void 0 === i ? void 0 : i.meta) ||
              void 0 === r
                ? void 0
                : r.related_multi_packs;
            if (Array.isArray(a))
              for (
                var l = function (t) {
                    if ("string" != typeof t) return "continue";
                    var n = t.replace(".json", ""),
                      i = Jf.resolve(e.url.replace(s.baseUrl, ""), t);
                    if (
                      s.resources[n] ||
                      Object.values(s.resources).some(function (t) {
                        return Jf.format(Jf.parse(t.url)) === i;
                      })
                    )
                      return "continue";
                    var r = {
                      crossOrigin: e.crossOrigin,
                      loadType: fy.LOAD_TYPE.XHR,
                      xhrType: fy.XHR_RESPONSE_TYPE.JSON,
                      parentResource: e,
                      metadata: e.metadata,
                    };
                    s.add(n, i, r);
                  },
                  h = 0,
                  u = a;
                h < u.length;
                h++
              ) {
                l(u[h]);
              }
            var c = {
                crossOrigin: e.crossOrigin,
                metadata: e.metadata.imageMetadata,
                parentResource: e,
              },
              d = t.getResourcePath(e, s.baseUrl);
            s.add(o, d, c, function (t) {
              if (t.error) n(t.error);
              else {
                var i = new Nb(t.texture, e.data, e.url);
                i.parse().then(function () {
                  (e.spritesheet = i), (e.textures = i.textures), n();
                });
              }
            });
          } else n();
        }),
        (t.getResourcePath = function (t, e) {
          return t.isDataUrl
            ? t.data.meta.image
            : Jf.resolve(t.url.replace(e, ""), t.data.meta.image);
        }),
        (t.extension = x_.Loader),
        t
      );
    })(),
    Lb = function (t, e) {
      return (Lb =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function Fb(t, e) {
    function n() {
      this.constructor = t;
    }
    Lb(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var Ub = new Cm();
  !(function (t) {
    function e(e, n, i) {
      void 0 === n && (n = 100), void 0 === i && (i = 100);
      var r = t.call(this, e) || this;
      return (
        (r.tileTransform = new jm()),
        (r._width = n),
        (r._height = i),
        (r.uvMatrix = r.texture.uvMatrix || new iv(e)),
        (r.pluginName = "tilingSprite"),
        (r.uvRespectAnchor = !1),
        r
      );
    }
    Fb(e, t),
      Object.defineProperty(e.prototype, "clampMargin", {
        get: function () {
          return this.uvMatrix.clampMargin;
        },
        set: function (t) {
          (this.uvMatrix.clampMargin = t), this.uvMatrix.update(!0);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "tileScale", {
        get: function () {
          return this.tileTransform.scale;
        },
        set: function (t) {
          this.tileTransform.scale.copyFrom(t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "tilePosition", {
        get: function () {
          return this.tileTransform.position;
        },
        set: function (t) {
          this.tileTransform.position.copyFrom(t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._onTextureUpdate = function () {
        this.uvMatrix && (this.uvMatrix.texture = this._texture),
          (this._cachedTint = 16777215);
      }),
      (e.prototype._render = function (t) {
        var e = this._texture;
        e &&
          e.valid &&
          (this.tileTransform.updateLocalTransform(),
          this.uvMatrix.update(),
          t.batch.setObjectRenderer(t.plugins[this.pluginName]),
          t.plugins[this.pluginName].render(this));
      }),
      (e.prototype._calculateBounds = function () {
        var t = this._width * -this._anchor._x,
          e = this._height * -this._anchor._y,
          n = this._width * (1 - this._anchor._x),
          i = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, e, n, i);
      }),
      (e.prototype.getLocalBounds = function (e) {
        return 0 === this.children.length
          ? ((this._bounds.minX = this._width * -this._anchor._x),
            (this._bounds.minY = this._height * -this._anchor._y),
            (this._bounds.maxX = this._width * (1 - this._anchor._x)),
            (this._bounds.maxY = this._height * (1 - this._anchor._y)),
            e ||
              (this._localBoundsRect || (this._localBoundsRect = new Pm()),
              (e = this._localBoundsRect)),
            this._bounds.getRectangle(e))
          : t.prototype.getLocalBounds.call(this, e);
      }),
      (e.prototype.containsPoint = function (t) {
        this.worldTransform.applyInverse(t, Ub);
        var e = this._width,
          n = this._height,
          i = -e * this.anchor._x;
        if (Ub.x >= i && Ub.x < i + e) {
          var r = -n * this.anchor._y;
          if (Ub.y >= r && Ub.y < r + n) return !0;
        }
        return !1;
      }),
      (e.prototype.destroy = function (e) {
        t.prototype.destroy.call(this, e),
          (this.tileTransform = null),
          (this.uvMatrix = null);
      }),
      (e.from = function (t, n) {
        return new e(t instanceof eg ? t : eg.from(t, n), n.width, n.height);
      }),
      Object.defineProperty(e.prototype, "width", {
        get: function () {
          return this._width;
        },
        set: function (t) {
          this._width = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "height", {
        get: function () {
          return this._height;
        },
        set: function (t) {
          this._height = t;
        },
        enumerable: !1,
        configurable: !0,
      });
  })(hb);
  var Bb =
      "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
    kb = new Um(),
    Gb = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          e.runners.contextChange.add(n),
          (n.quad = new pg()),
          (n.state = tv.for2d()),
          n
        );
      }
      return (
        Fb(e, t),
        (e.prototype.contextChange = function () {
          var t = this.renderer,
            e = { globals: t.globalUniforms };
          (this.simpleShader = Qg.from(
            Bb,
            "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n",
            e
          )),
            (this.shader =
              t.context.webGLVersion > 1
                ? Qg.from(
                    "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
                    "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n",
                    e
                  )
                : Qg.from(
                    Bb,
                    "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n",
                    e
                  ));
        }),
        (e.prototype.render = function (t) {
          var e = this.renderer,
            n = this.quad,
            i = n.vertices;
          (i[0] = i[6] = t._width * -t.anchor.x),
            (i[1] = i[3] = t._height * -t.anchor.y),
            (i[2] = i[4] = t._width * (1 - t.anchor.x)),
            (i[5] = i[7] = t._height * (1 - t.anchor.y));
          var r = t.uvRespectAnchor ? t.anchor.x : 0,
            s = t.uvRespectAnchor ? t.anchor.y : 0;
          ((i = n.uvs)[0] = i[6] = -r),
            (i[1] = i[3] = -s),
            (i[2] = i[4] = 1 - r),
            (i[5] = i[7] = 1 - s),
            n.invalidate();
          var o = t._texture,
            a = o.baseTexture,
            l = a.alphaMode > 0,
            h = t.tileTransform.localTransform,
            u = t.uvMatrix,
            c =
              a.isPowerOfTwo &&
              o.frame.width === a.width &&
              o.frame.height === a.height;
          c &&
            (a._glTextures[e.CONTEXT_UID]
              ? (c = a.wrapMode !== Af.CLAMP)
              : a.wrapMode === Af.CLAMP && (a.wrapMode = Af.REPEAT));
          var d = c ? this.simpleShader : this.shader,
            p = o.width,
            f = o.height,
            m = t._width,
            _ = t._height;
          kb.set(
            (h.a * p) / m,
            (h.b * p) / _,
            (h.c * f) / m,
            (h.d * f) / _,
            h.tx / m,
            h.ty / _
          ),
            kb.invert(),
            c
              ? kb.prepend(u.mapCoord)
              : ((d.uniforms.uMapCoord = u.mapCoord.toArray(!0)),
                (d.uniforms.uClampFrame = u.uClampFrame),
                (d.uniforms.uClampOffset = u.uClampOffset)),
            (d.uniforms.uTransform = kb.toArray(!0)),
            (d.uniforms.uColor = am(
              t.tint,
              t.worldAlpha,
              d.uniforms.uColor,
              l
            )),
            (d.uniforms.translationMatrix = t.transform.worldTransform.toArray(
              !0
            )),
            (d.uniforms.uSampler = o),
            e.shader.bind(d),
            e.geometry.bind(n),
            (this.state.blendMode = sm(t.blendMode, l)),
            e.state.set(this.state),
            e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
        }),
        (e.extension = { name: "tilingSprite", type: x_.RendererPlugin }),
        e
      );
    })(xg),
    Hb = function (t, e) {
      return (Hb =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  function zb(t, e) {
    function n() {
      this.constructor = t;
    }
    Hb(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var Vb = (function () {
      function t(t, e) {
        (this.uvBuffer = t),
          (this.uvMatrix = e),
          (this.data = null),
          (this._bufferUpdateId = -1),
          (this._textureUpdateId = -1),
          (this._updateID = 0);
      }
      return (
        (t.prototype.update = function (t) {
          if (
            t ||
            this._bufferUpdateId !== this.uvBuffer._updateID ||
            this._textureUpdateId !== this.uvMatrix._updateID
          ) {
            (this._bufferUpdateId = this.uvBuffer._updateID),
              (this._textureUpdateId = this.uvMatrix._updateID);
            var e = this.uvBuffer.data;
            (this.data && this.data.length === e.length) ||
              (this.data = new Float32Array(e.length)),
              this.uvMatrix.multiplyUvs(e, this.data),
              this._updateID++;
          }
        }),
        t
      );
    })(),
    Xb = new Cm(),
    Wb = new Dm(),
    jb = (function (t) {
      function e(e, n, i, r) {
        void 0 === r && (r = bf.TRIANGLES);
        var s = t.call(this) || this;
        return (
          (s.geometry = e),
          (s.shader = n),
          (s.state = i || tv.for2d()),
          (s.drawMode = r),
          (s.start = 0),
          (s.size = 0),
          (s.uvs = null),
          (s.indices = null),
          (s.vertexData = new Float32Array(1)),
          (s.vertexDirty = -1),
          (s._transformID = -1),
          (s._roundPixels = Rp.ROUND_PIXELS),
          (s.batchUvs = null),
          s
        );
      }
      return (
        zb(e, t),
        Object.defineProperty(e.prototype, "geometry", {
          get: function () {
            return this._geometry;
          },
          set: function (t) {
            this._geometry !== t &&
              (this._geometry &&
                (this._geometry.refCount--,
                0 === this._geometry.refCount && this._geometry.dispose()),
              (this._geometry = t),
              this._geometry && this._geometry.refCount++,
              (this.vertexDirty = -1));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "uvBuffer", {
          get: function () {
            return this.geometry.buffers[1];
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "verticesBuffer", {
          get: function () {
            return this.geometry.buffers[0];
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "material", {
          get: function () {
            return this.shader;
          },
          set: function (t) {
            this.shader = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "blendMode", {
          get: function () {
            return this.state.blendMode;
          },
          set: function (t) {
            this.state.blendMode = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "roundPixels", {
          get: function () {
            return this._roundPixels;
          },
          set: function (t) {
            this._roundPixels !== t && (this._transformID = -1),
              (this._roundPixels = t);
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "tint", {
          get: function () {
            return "tint" in this.shader ? this.shader.tint : null;
          },
          set: function (t) {
            this.shader.tint = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "texture", {
          get: function () {
            return "texture" in this.shader ? this.shader.texture : null;
          },
          set: function (t) {
            this.shader.texture = t;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype._render = function (t) {
          var n = this.geometry.buffers[0].data;
          this.shader.batchable &&
          this.drawMode === bf.TRIANGLES &&
          n.length < 2 * e.BATCHABLE_SIZE
            ? this._renderToBatch(t)
            : this._renderDefault(t);
        }),
        (e.prototype._renderDefault = function (t) {
          var e = this.shader;
          (e.alpha = this.worldAlpha),
            e.update && e.update(),
            t.batch.flush(),
            (e.uniforms.translationMatrix =
              this.transform.worldTransform.toArray(!0)),
            t.shader.bind(e),
            t.state.set(this.state),
            t.geometry.bind(this.geometry, e),
            t.geometry.draw(
              this.drawMode,
              this.size,
              this.start,
              this.geometry.instanceCount
            );
        }),
        (e.prototype._renderToBatch = function (t) {
          var e = this.geometry,
            n = this.shader;
          n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()),
            this.calculateVertices(),
            (this.indices = e.indexBuffer.data),
            (this._tintRGB = n._tintRGB),
            (this._texture = n.texture);
          var i = this.material.pluginName;
          t.batch.setObjectRenderer(t.plugins[i]), t.plugins[i].render(this);
        }),
        (e.prototype.calculateVertices = function () {
          var t = this.geometry.buffers[0],
            e = t.data,
            n = t._updateID;
          if (
            n !== this.vertexDirty ||
            this._transformID !== this.transform._worldID
          ) {
            (this._transformID = this.transform._worldID),
              this.vertexData.length !== e.length &&
                (this.vertexData = new Float32Array(e.length));
            for (
              var i = this.transform.worldTransform,
                r = i.a,
                s = i.b,
                o = i.c,
                a = i.d,
                l = i.tx,
                h = i.ty,
                u = this.vertexData,
                c = 0;
              c < u.length / 2;
              c++
            ) {
              var d = e[2 * c],
                p = e[2 * c + 1];
              (u[2 * c] = r * d + o * p + l),
                (u[2 * c + 1] = s * d + a * p + h);
            }
            if (this._roundPixels) {
              var f = Rp.RESOLUTION;
              for (c = 0; c < u.length; ++c)
                u[c] = Math.round(((u[c] * f) | 0) / f);
            }
            this.vertexDirty = n;
          }
        }),
        (e.prototype.calculateUvs = function () {
          var t = this.geometry.buffers[1],
            e = this.shader;
          e.uvMatrix.isSimple
            ? (this.uvs = t.data)
            : (this.batchUvs || (this.batchUvs = new Vb(t, e.uvMatrix)),
              this.batchUvs.update(),
              (this.uvs = this.batchUvs.data));
        }),
        (e.prototype._calculateBounds = function () {
          this.calculateVertices(),
            this._bounds.addVertexData(
              this.vertexData,
              0,
              this.vertexData.length
            );
        }),
        (e.prototype.containsPoint = function (t) {
          if (!this.getBounds().contains(t.x, t.y)) return !1;
          this.worldTransform.applyInverse(t, Xb);
          for (
            var e = this.geometry.getBuffer("aVertexPosition").data,
              n = Wb.points,
              i = this.geometry.getIndex().data,
              r = i.length,
              s = 4 === this.drawMode ? 3 : 1,
              o = 0;
            o + 2 < r;
            o += s
          ) {
            var a = 2 * i[o],
              l = 2 * i[o + 1],
              h = 2 * i[o + 2];
            if (
              ((n[0] = e[a]),
              (n[1] = e[a + 1]),
              (n[2] = e[l]),
              (n[3] = e[l + 1]),
              (n[4] = e[h]),
              (n[5] = e[h + 1]),
              Wb.contains(Xb.x, Xb.y))
            )
              return !0;
          }
          return !1;
        }),
        (e.prototype.destroy = function (e) {
          t.prototype.destroy.call(this, e),
            this._cachedTexture &&
              (this._cachedTexture.destroy(), (this._cachedTexture = null)),
            (this.geometry = null),
            (this.shader = null),
            (this.state = null),
            (this.uvs = null),
            (this.indices = null),
            (this.vertexData = null);
        }),
        (e.BATCHABLE_SIZE = 100),
        e
      );
    })(y_),
    Yb = (function (t) {
      function e(e, n) {
        var i = this,
          r = {
            uSampler: e,
            alpha: 1,
            uTextureMatrix: Um.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
          };
        return (
          (n = Object.assign(
            { tint: 16777215, alpha: 1, pluginName: "batch" },
            n
          )).uniforms && Object.assign(r, n.uniforms),
          ((i =
            t.call(
              this,
              n.program ||
                $g.from(
                  "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n",
                  "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"
                ),
              r
            ) || this)._colorDirty = !1),
          (i.uvMatrix = new iv(e)),
          (i.batchable = void 0 === n.program),
          (i.pluginName = n.pluginName),
          (i.tint = n.tint),
          (i.alpha = n.alpha),
          i
        );
      }
      return (
        zb(e, t),
        Object.defineProperty(e.prototype, "texture", {
          get: function () {
            return this.uniforms.uSampler;
          },
          set: function (t) {
            this.uniforms.uSampler !== t &&
              (!this.uniforms.uSampler.baseTexture.alphaMode !=
                !t.baseTexture.alphaMode && (this._colorDirty = !0),
              (this.uniforms.uSampler = t),
              (this.uvMatrix.texture = t));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "alpha", {
          get: function () {
            return this._alpha;
          },
          set: function (t) {
            t !== this._alpha && ((this._alpha = t), (this._colorDirty = !0));
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "tint", {
          get: function () {
            return this._tint;
          },
          set: function (t) {
            t !== this._tint &&
              ((this._tint = t),
              (this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)),
              (this._colorDirty = !0));
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.update = function () {
          if (this._colorDirty) {
            this._colorDirty = !1;
            var t = this.texture.baseTexture;
            am(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode);
          }
          this.uvMatrix.update() &&
            (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
        }),
        e
      );
    })(Qg),
    qb = (function (t) {
      function e(e, n, i) {
        var r = t.call(this) || this,
          s = new og(e),
          o = new og(n, !0),
          a = new og(i, !0, !0);
        return (
          r
            .addAttribute("aVertexPosition", s, 2, !1, Sf.FLOAT)
            .addAttribute("aTextureCoord", o, 2, !1, Sf.FLOAT)
            .addIndex(a),
          (r._updateId = -1),
          r
        );
      }
      return (
        zb(e, t),
        Object.defineProperty(e.prototype, "vertexDirtyId", {
          get: function () {
            return this.buffers[0]._updateID;
          },
          enumerable: !1,
          configurable: !0,
        }),
        e
      );
    })(cg),
    Kb = function (t, e) {
      return (Kb =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  var Zb = function () {
      (this.info = []),
        (this.common = []),
        (this.page = []),
        (this.char = []),
        (this.kerning = []),
        (this.distanceField = []);
    },
    Jb = (function () {
      function t() {}
      return (
        (t.test = function (t) {
          return "string" == typeof t && 0 === t.indexOf("info face=");
        }),
        (t.parse = function (t) {
          var e = t.match(/^[a-z]+\s+.+$/gm),
            n = {
              info: [],
              common: [],
              page: [],
              char: [],
              chars: [],
              kerning: [],
              kernings: [],
              distanceField: [],
            };
          for (var i in e) {
            var r = e[i].match(/^[a-z]+/gm)[0],
              s = e[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
              o = {};
            for (var a in s) {
              var l = s[a].split("="),
                h = l[0],
                u = l[1].replace(/"/gm, ""),
                c = parseFloat(u),
                d = isNaN(c) ? u : c;
              o[h] = d;
            }
            n[r].push(o);
          }
          var p = new Zb();
          return (
            n.info.forEach(function (t) {
              return p.info.push({ face: t.face, size: parseInt(t.size, 10) });
            }),
            n.common.forEach(function (t) {
              return p.common.push({ lineHeight: parseInt(t.lineHeight, 10) });
            }),
            n.page.forEach(function (t) {
              return p.page.push({ id: parseInt(t.id, 10), file: t.file });
            }),
            n.char.forEach(function (t) {
              return p.char.push({
                id: parseInt(t.id, 10),
                page: parseInt(t.page, 10),
                x: parseInt(t.x, 10),
                y: parseInt(t.y, 10),
                width: parseInt(t.width, 10),
                height: parseInt(t.height, 10),
                xoffset: parseInt(t.xoffset, 10),
                yoffset: parseInt(t.yoffset, 10),
                xadvance: parseInt(t.xadvance, 10),
              });
            }),
            n.kerning.forEach(function (t) {
              return p.kerning.push({
                first: parseInt(t.first, 10),
                second: parseInt(t.second, 10),
                amount: parseInt(t.amount, 10),
              });
            }),
            n.distanceField.forEach(function (t) {
              return p.distanceField.push({
                distanceRange: parseInt(t.distanceRange, 10),
                fieldType: t.fieldType,
              });
            }),
            p
          );
        }),
        t
      );
    })(),
    $b = (function () {
      function t() {}
      return (
        (t.test = function (t) {
          return (
            t instanceof XMLDocument &&
            t.getElementsByTagName("page").length &&
            null !== t.getElementsByTagName("info")[0].getAttribute("face")
          );
        }),
        (t.parse = function (t) {
          for (
            var e = new Zb(),
              n = t.getElementsByTagName("info"),
              i = t.getElementsByTagName("common"),
              r = t.getElementsByTagName("page"),
              s = t.getElementsByTagName("char"),
              o = t.getElementsByTagName("kerning"),
              a = t.getElementsByTagName("distanceField"),
              l = 0;
            l < n.length;
            l++
          )
            e.info.push({
              face: n[l].getAttribute("face"),
              size: parseInt(n[l].getAttribute("size"), 10),
            });
          for (l = 0; l < i.length; l++)
            e.common.push({
              lineHeight: parseInt(i[l].getAttribute("lineHeight"), 10),
            });
          for (l = 0; l < r.length; l++)
            e.page.push({
              id: parseInt(r[l].getAttribute("id"), 10) || 0,
              file: r[l].getAttribute("file"),
            });
          for (l = 0; l < s.length; l++) {
            var h = s[l];
            e.char.push({
              id: parseInt(h.getAttribute("id"), 10),
              page: parseInt(h.getAttribute("page"), 10) || 0,
              x: parseInt(h.getAttribute("x"), 10),
              y: parseInt(h.getAttribute("y"), 10),
              width: parseInt(h.getAttribute("width"), 10),
              height: parseInt(h.getAttribute("height"), 10),
              xoffset: parseInt(h.getAttribute("xoffset"), 10),
              yoffset: parseInt(h.getAttribute("yoffset"), 10),
              xadvance: parseInt(h.getAttribute("xadvance"), 10),
            });
          }
          for (l = 0; l < o.length; l++)
            e.kerning.push({
              first: parseInt(o[l].getAttribute("first"), 10),
              second: parseInt(o[l].getAttribute("second"), 10),
              amount: parseInt(o[l].getAttribute("amount"), 10),
            });
          for (l = 0; l < a.length; l++)
            e.distanceField.push({
              fieldType: a[l].getAttribute("fieldType"),
              distanceRange: parseInt(a[l].getAttribute("distanceRange"), 10),
            });
          return e;
        }),
        t
      );
    })(),
    Qb = (function () {
      function t() {}
      return (
        (t.test = function (t) {
          if ("string" == typeof t && t.indexOf("<font>") > -1) {
            var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
            return $b.test(e);
          }
          return !1;
        }),
        (t.parse = function (t) {
          var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
          return $b.parse(e);
        }),
        t
      );
    })(),
    tT = [Jb, $b, Qb];
  function eT(t) {
    for (var e = 0; e < tT.length; e++) if (tT[e].test(t)) return tT[e];
    return null;
  }
  function nT(t, e, n, i, r, s, o) {
    var a = n.text,
      l = n.fontProperties;
    e.translate(i, r), e.scale(s, s);
    var h = o.strokeThickness / 2,
      u = -o.strokeThickness / 2;
    if (
      ((e.font = o.toFontString()),
      (e.lineWidth = o.strokeThickness),
      (e.textBaseline = o.textBaseline),
      (e.lineJoin = o.lineJoin),
      (e.miterLimit = o.miterLimit),
      (e.fillStyle = (function (t, e, n, i, r, s) {
        var o,
          a = n.fill;
        if (!Array.isArray(a)) return a;
        if (1 === a.length) return a[0];
        var l = n.dropShadow ? n.dropShadowDistance : 0,
          h = n.padding || 0,
          u = t.width / i - l - 2 * h,
          c = t.height / i - l - 2 * h,
          d = a.slice(),
          p = n.fillGradientStops.slice();
        if (!p.length)
          for (var f = d.length + 1, m = 1; m < f; ++m) p.push(m / f);
        if (
          (d.unshift(a[0]),
          p.unshift(0),
          d.push(a[a.length - 1]),
          p.push(1),
          n.fillGradientType === sb.LINEAR_VERTICAL)
        ) {
          o = e.createLinearGradient(u / 2, h, u / 2, c + h);
          var _ = 0,
            g = (s.fontProperties.fontSize + n.strokeThickness) / c;
          for (m = 0; m < r.length; m++)
            for (var v = s.lineHeight * m, y = 0; y < d.length; y++) {
              var x =
                  v / c + ("number" == typeof p[y] ? p[y] : y / d.length) * g,
                b = Math.max(_, x);
              (b = Math.min(b, 1)), o.addColorStop(b, d[y]), (_ = b);
            }
        } else {
          o = e.createLinearGradient(h, c / 2, u + h, c / 2);
          var T = d.length + 1,
            E = 1;
          for (m = 0; m < d.length; m++) {
            var S = void 0;
            (S = "number" == typeof p[m] ? p[m] : E / T),
              o.addColorStop(S, d[m]),
              E++;
          }
        }
        return o;
      })(t, e, o, s, [a], n)),
      (e.strokeStyle = o.stroke),
      o.dropShadow)
    ) {
      var c = o.dropShadowColor,
        d = em("number" == typeof c ? c : im(c)),
        p = o.dropShadowBlur * s,
        f = o.dropShadowDistance * s;
      (e.shadowColor =
        "rgba(" +
        255 * d[0] +
        "," +
        255 * d[1] +
        "," +
        255 * d[2] +
        "," +
        o.dropShadowAlpha +
        ")"),
        (e.shadowBlur = p),
        (e.shadowOffsetX = Math.cos(o.dropShadowAngle) * f),
        (e.shadowOffsetY = Math.sin(o.dropShadowAngle) * f);
    } else
      (e.shadowColor = "black"),
        (e.shadowBlur = 0),
        (e.shadowOffsetX = 0),
        (e.shadowOffsetY = 0);
    o.stroke &&
      o.strokeThickness &&
      e.strokeText(a, h, u + n.lineHeight - l.descent),
      o.fill && e.fillText(a, h, u + n.lineHeight - l.descent),
      e.setTransform(1, 0, 0, 1, 0, 0),
      (e.fillStyle = "rgba(0, 0, 0, 0)");
  }
  function iT(t) {
    return Array.from ? Array.from(t) : t.split("");
  }
  function rT(t) {
    return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0);
  }
  var sT = (function () {
      function t(t, e, n) {
        var i,
          r,
          s = t.info[0],
          o = t.common[0],
          a = t.page[0],
          l = t.distanceField[0],
          h = Em(a.file),
          u = {};
        (this._ownsTextures = n),
          (this.font = s.face),
          (this.size = s.size),
          (this.lineHeight = o.lineHeight / h),
          (this.chars = {}),
          (this.pageTextures = u);
        for (var c = 0; c < t.page.length; c++) {
          var d = t.page[c],
            p = d.id,
            f = d.file;
          (u[p] = e instanceof Array ? e[c] : e[f]),
            (null == l ? void 0 : l.fieldType) &&
              "none" !== l.fieldType &&
              (u[p].baseTexture.alphaMode = Cf.NO_PREMULTIPLIED_ALPHA);
        }
        for (c = 0; c < t.char.length; c++) {
          var m = t.char[c],
            _ = ((p = m.id), m.page),
            g = t.char[c],
            v = g.x,
            y = g.y,
            x = g.width,
            b = g.height,
            T = g.xoffset,
            E = g.yoffset,
            S = g.xadvance;
          (y /= h), (x /= h), (b /= h), (T /= h), (E /= h), (S /= h);
          var w = new Pm(
            (v /= h) + u[_].frame.x / h,
            y + u[_].frame.y / h,
            x,
            b
          );
          this.chars[p] = {
            xOffset: T,
            yOffset: E,
            xAdvance: S,
            kerning: {},
            texture: new eg(u[_].baseTexture, w),
            page: _,
          };
        }
        for (c = 0; c < t.kerning.length; c++) {
          var M = t.kerning[c],
            A = M.first,
            R = M.second,
            C = M.amount;
          (A /= h),
            (R /= h),
            (C /= h),
            this.chars[R] && (this.chars[R].kerning[A] = C);
        }
        (this.distanceFieldRange = null == l ? void 0 : l.distanceRange),
          (this.distanceFieldType =
            null !==
              (r =
                null === (i = null == l ? void 0 : l.fieldType) || void 0 === i
                  ? void 0
                  : i.toLowerCase()) && void 0 !== r
              ? r
              : "none");
      }
      return (
        (t.prototype.destroy = function () {
          for (var t in this.chars)
            this.chars[t].texture.destroy(), (this.chars[t].texture = null);
          for (var t in this.pageTextures)
            this._ownsTextures && this.pageTextures[t].destroy(!0),
              (this.pageTextures[t] = null);
          (this.chars = null), (this.pageTextures = null);
        }),
        (t.install = function (e, n, i) {
          var r;
          if (e instanceof Zb) r = e;
          else {
            var s = eT(e);
            if (!s) throw new Error("Unrecognized data format for font.");
            r = s.parse(e);
          }
          n instanceof eg && (n = [n]);
          var o = new t(r, n, i);
          return (t.available[o.font] = o), o;
        }),
        (t.uninstall = function (e) {
          var n = t.available[e];
          if (!n) throw new Error("No font found named '" + e + "'");
          n.destroy(), delete t.available[e];
        }),
        (t.from = function (e, n, i) {
          if (!e) throw new Error("[BitmapFont] Property `name` is required.");
          var r = Object.assign({}, t.defaultOptions, i),
            s = r.chars,
            o = r.padding,
            a = r.resolution,
            l = r.textureWidth,
            h = r.textureHeight,
            u = (function (t) {
              "string" == typeof t && (t = [t]);
              for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                if (Array.isArray(r)) {
                  if (2 !== r.length)
                    throw new Error(
                      "[BitmapFont]: Invalid character range length, expecting 2 got " +
                        r.length +
                        "."
                    );
                  var s = r[0].charCodeAt(0),
                    o = r[1].charCodeAt(0);
                  if (o < s)
                    throw new Error("[BitmapFont]: Invalid character range.");
                  for (var a = s, l = o; a <= l; a++)
                    e.push(String.fromCharCode(a));
                } else e.push.apply(e, iT(r));
              }
              if (0 === e.length)
                throw new Error(
                  "[BitmapFont]: Empty set when resolving characters."
                );
              return e;
            })(s),
            c = n instanceof pb ? n : new pb(n),
            d = l,
            p = new Zb();
          (p.info[0] = { face: c.fontFamily, size: c.fontSize }),
            (p.common[0] = { lineHeight: c.fontSize });
          for (
            var f, m, _, g = 0, v = 0, y = 0, x = [], b = 0;
            b < u.length;
            b++
          ) {
            f ||
              (((f = Rp.ADAPTER.createCanvas()).width = l),
              (f.height = h),
              (m = f.getContext("2d")),
              (_ = new k_(f, { resolution: a })),
              x.push(new eg(_)),
              p.page.push({ id: x.length - 1, file: "" }));
            var T = gb.measureText(u[b], c, !1, f),
              E = T.width,
              S = Math.ceil(T.height),
              w = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * E);
            if (v >= h - S * a) {
              if (0 === v)
                throw new Error(
                  "[BitmapFont] textureHeight " +
                    h +
                    "px is too small for " +
                    c.fontSize +
                    "px fonts"
                );
              --b,
                (f = null),
                (m = null),
                (_ = null),
                (v = 0),
                (g = 0),
                (y = 0);
            } else if (
              ((y = Math.max(S + T.fontProperties.descent, y)), w * a + g >= d)
            )
              --b, (v += y * a), (v = Math.ceil(v)), (g = 0), (y = 0);
            else {
              nT(f, m, T, g, v, a, c);
              var M = rT(T.text);
              p.char.push({
                id: M,
                page: x.length - 1,
                x: g / a,
                y: v / a,
                width: w,
                height: S,
                xoffset: 0,
                yoffset: 0,
                xadvance: Math.ceil(
                  E -
                    (c.dropShadow ? c.dropShadowDistance : 0) -
                    (c.stroke ? c.strokeThickness : 0)
                ),
              }),
                (g += (w + 2 * o) * a),
                (g = Math.ceil(g));
            }
          }
          b = 0;
          for (var A = u.length; b < A; b++)
            for (var R = u[b], C = 0; C < A; C++) {
              var I = u[C],
                P = m.measureText(R).width,
                O = m.measureText(I).width,
                N = m.measureText(R + I).width - (P + O);
              N && p.kerning.push({ first: rT(R), second: rT(I), amount: N });
            }
          var D = new t(p, x, !0);
          return (
            void 0 !== t.available[e] && t.uninstall(e), (t.available[e] = D), D
          );
        }),
        (t.ALPHA = [["a", "z"], ["A", "Z"], " "]),
        (t.NUMERIC = [["0", "9"]]),
        (t.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
        (t.ASCII = [[" ", "~"]]),
        (t.defaultOptions = {
          resolution: 1,
          textureWidth: 512,
          textureHeight: 512,
          padding: 4,
          chars: t.ALPHANUMERIC,
        }),
        (t.available = {}),
        t
      );
    })(),
    oT = [],
    aT = [],
    lT = [];
  !(function (t) {
    function e(n, i) {
      void 0 === i && (i = {});
      var r = t.call(this) || this;
      r._tint = 16777215;
      var s = Object.assign({}, e.styleDefaults, i),
        o = s.align,
        a = s.tint,
        l = s.maxWidth,
        h = s.letterSpacing,
        u = s.fontName,
        c = s.fontSize;
      if (!sT.available[u]) throw new Error('Missing BitmapFont "' + u + '"');
      return (
        (r._activePagesMeshData = []),
        (r._textWidth = 0),
        (r._textHeight = 0),
        (r._align = o),
        (r._tint = a),
        (r._fontName = u),
        (r._fontSize = c || sT.available[u].size),
        (r.text = n),
        (r._maxWidth = l),
        (r._maxLineHeight = 0),
        (r._letterSpacing = h),
        (r._anchor = new Fm(
          function () {
            r.dirty = !0;
          },
          r,
          0,
          0
        )),
        (r._roundPixels = Rp.ROUND_PIXELS),
        (r.dirty = !0),
        (r._resolution = Rp.RESOLUTION),
        (r._autoResolution = !0),
        (r._textureCache = {}),
        r
      );
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      Kb(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t),
      (e.prototype.updateText = function () {
        for (
          var t,
            e = sT.available[this._fontName],
            n = this._fontSize / e.size,
            i = new Cm(),
            r = [],
            s = [],
            o = [],
            a = iT(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "),
            l = (this._maxWidth * e.size) / this._fontSize,
            h = "none" === e.distanceFieldType ? oT : aT,
            u = null,
            c = 0,
            d = 0,
            p = 0,
            f = -1,
            m = 0,
            _ = 0,
            g = 0,
            v = 0,
            y = 0;
          y < a.length;
          y++
        ) {
          var x = rT((G = a[y]));
          if (
            (/(?:\s)/.test(G) && ((f = y), (m = c), v++),
            "\r" !== G && "\n" !== G)
          ) {
            var b = e.chars[x];
            if (b) {
              u && b.kerning[u] && (i.x += b.kerning[u]);
              var T = lT.pop() || {
                texture: eg.EMPTY,
                line: 0,
                charCode: 0,
                prevSpaces: 0,
                position: new Cm(),
              };
              (T.texture = b.texture),
                (T.line = p),
                (T.charCode = x),
                (T.position.x = i.x + b.xOffset + this._letterSpacing / 2),
                (T.position.y = i.y + b.yOffset),
                (T.prevSpaces = v),
                r.push(T),
                (c = T.position.x + Math.max(b.xAdvance, b.texture.orig.width)),
                (i.x += b.xAdvance + this._letterSpacing),
                (g = Math.max(g, b.yOffset + b.texture.height)),
                (u = x),
                -1 !== f &&
                  l > 0 &&
                  i.x > l &&
                  (dm(r, 1 + f - ++_, 1 + y - f),
                  (y = f),
                  (f = -1),
                  s.push(m),
                  o.push(r.length > 0 ? r[r.length - 1].prevSpaces : 0),
                  (d = Math.max(d, m)),
                  p++,
                  (i.x = 0),
                  (i.y += e.lineHeight),
                  (u = null),
                  (v = 0));
            }
          } else
            s.push(c),
              o.push(-1),
              (d = Math.max(d, c)),
              ++p,
              ++_,
              (i.x = 0),
              (i.y += e.lineHeight),
              (u = null),
              (v = 0);
        }
        var E = a[a.length - 1];
        "\r" !== E &&
          "\n" !== E &&
          (/(?:\s)/.test(E) && (c = m),
          s.push(c),
          (d = Math.max(d, c)),
          o.push(-1));
        var S = [];
        for (y = 0; y <= p; y++) {
          var w = 0;
          "right" === this._align
            ? (w = d - s[y])
            : "center" === this._align
            ? (w = (d - s[y]) / 2)
            : "justify" === this._align &&
              (w = o[y] < 0 ? 0 : (d - s[y]) / o[y]),
            S.push(w);
        }
        var M = r.length,
          A = {},
          R = [],
          C = this._activePagesMeshData;
        for (y = 0; y < C.length; y++) h.push(C[y]);
        for (y = 0; y < M; y++) {
          var I = (z = r[y].texture).baseTexture.uid;
          if (!A[I]) {
            if (!(K = h.pop())) {
              var P = new qb(),
                O = void 0,
                N = void 0;
              "none" === e.distanceFieldType
                ? ((O = new Yb(eg.EMPTY)), (N = xf.NORMAL))
                : ((O = new Yb(eg.EMPTY, {
                    program: $g.from(
                      "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n",
                      "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n"
                    ),
                    uniforms: { uFWidth: 0 },
                  })),
                  (N = xf.NORMAL_NPM));
              var D = new jb(P, O);
              (D.blendMode = N),
                (K = {
                  index: 0,
                  indexCount: 0,
                  vertexCount: 0,
                  uvsCount: 0,
                  total: 0,
                  mesh: D,
                  vertices: null,
                  uvs: null,
                  indices: null,
                });
            }
            (K.index = 0),
              (K.indexCount = 0),
              (K.vertexCount = 0),
              (K.uvsCount = 0),
              (K.total = 0);
            var L = this._textureCache;
            (L[I] = L[I] || new eg(z.baseTexture)),
              (K.mesh.texture = L[I]),
              (K.mesh.tint = this._tint),
              R.push(K),
              (A[I] = K);
          }
          A[I].total++;
        }
        for (y = 0; y < C.length; y++)
          -1 === R.indexOf(C[y]) && this.removeChild(C[y].mesh);
        for (y = 0; y < R.length; y++)
          R[y].mesh.parent !== this && this.addChild(R[y].mesh);
        for (var y in ((this._activePagesMeshData = R), A)) {
          var F = (K = A[y]).total;
          if (
            !(
              (null === (t = K.indices) || void 0 === t ? void 0 : t.length) >
              6 * F
            ) ||
            K.vertices.length < 2 * jb.BATCHABLE_SIZE
          )
            (K.vertices = new Float32Array(8 * F)),
              (K.uvs = new Float32Array(8 * F)),
              (K.indices = new Uint16Array(6 * F));
          else
            for (
              var U = K.total, B = K.vertices, k = 4 * U * 2;
              k < B.length;
              k++
            )
              B[k] = 0;
          K.mesh.size = 6 * F;
        }
        for (y = 0; y < M; y++) {
          var G,
            H =
              (G = r[y]).position.x +
              S[G.line] * ("justify" === this._align ? G.prevSpaces : 1);
          this._roundPixels && (H = Math.round(H));
          var z,
            V = H * n,
            X = G.position.y * n,
            W = A[(z = G.texture).baseTexture.uid],
            j = z.frame,
            Y = z._uvs,
            q = W.index++;
          (W.indices[6 * q + 0] = 0 + 4 * q),
            (W.indices[6 * q + 1] = 1 + 4 * q),
            (W.indices[6 * q + 2] = 2 + 4 * q),
            (W.indices[6 * q + 3] = 0 + 4 * q),
            (W.indices[6 * q + 4] = 2 + 4 * q),
            (W.indices[6 * q + 5] = 3 + 4 * q),
            (W.vertices[8 * q + 0] = V),
            (W.vertices[8 * q + 1] = X),
            (W.vertices[8 * q + 2] = V + j.width * n),
            (W.vertices[8 * q + 3] = X),
            (W.vertices[8 * q + 4] = V + j.width * n),
            (W.vertices[8 * q + 5] = X + j.height * n),
            (W.vertices[8 * q + 6] = V),
            (W.vertices[8 * q + 7] = X + j.height * n),
            (W.uvs[8 * q + 0] = Y.x0),
            (W.uvs[8 * q + 1] = Y.y0),
            (W.uvs[8 * q + 2] = Y.x1),
            (W.uvs[8 * q + 3] = Y.y1),
            (W.uvs[8 * q + 4] = Y.x2),
            (W.uvs[8 * q + 5] = Y.y2),
            (W.uvs[8 * q + 6] = Y.x3),
            (W.uvs[8 * q + 7] = Y.y3);
        }
        for (var y in ((this._textWidth = d * n),
        (this._textHeight = (i.y + e.lineHeight) * n),
        A)) {
          var K = A[y];
          if (0 !== this.anchor.x || 0 !== this.anchor.y)
            for (
              var Z = 0,
                J = this._textWidth * this.anchor.x,
                $ = this._textHeight * this.anchor.y,
                Q = 0;
              Q < K.total;
              Q++
            )
              (K.vertices[Z++] -= J),
                (K.vertices[Z++] -= $),
                (K.vertices[Z++] -= J),
                (K.vertices[Z++] -= $),
                (K.vertices[Z++] -= J),
                (K.vertices[Z++] -= $),
                (K.vertices[Z++] -= J),
                (K.vertices[Z++] -= $);
          this._maxLineHeight = g * n;
          var tt = K.mesh.geometry.getBuffer("aVertexPosition"),
            et = K.mesh.geometry.getBuffer("aTextureCoord"),
            nt = K.mesh.geometry.getIndex();
          (tt.data = K.vertices),
            (et.data = K.uvs),
            (nt.data = K.indices),
            tt.update(),
            et.update(),
            nt.update();
        }
        for (y = 0; y < r.length; y++) lT.push(r[y]);
      }),
      (e.prototype.updateTransform = function () {
        this.validate(), this.containerUpdateTransform();
      }),
      (e.prototype._render = function (e) {
        this._autoResolution &&
          this._resolution !== e.resolution &&
          ((this._resolution = e.resolution), (this.dirty = !0));
        var n = sT.available[this._fontName],
          i = n.distanceFieldRange,
          r = n.distanceFieldType,
          s = n.size;
        if ("none" !== r)
          for (
            var o = this.worldTransform,
              a = o.a,
              l = o.b,
              h = o.c,
              u = o.d,
              c = Math.sqrt(a * a + l * l),
              d = Math.sqrt(h * h + u * u),
              p = (Math.abs(c) + Math.abs(d)) / 2,
              f = this._fontSize / s,
              m = 0,
              _ = this._activePagesMeshData;
            m < _.length;
            m++
          ) {
            _[m].mesh.shader.uniforms.uFWidth = p * i * f * this._resolution;
          }
        t.prototype._render.call(this, e);
      }),
      (e.prototype.getLocalBounds = function () {
        return this.validate(), t.prototype.getLocalBounds.call(this);
      }),
      (e.prototype.validate = function () {
        this.dirty && (this.updateText(), (this.dirty = !1));
      }),
      Object.defineProperty(e.prototype, "tint", {
        get: function () {
          return this._tint;
        },
        set: function (t) {
          if (this._tint !== t) {
            this._tint = t;
            for (var e = 0; e < this._activePagesMeshData.length; e++)
              this._activePagesMeshData[e].mesh.tint = t;
          }
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "align", {
        get: function () {
          return this._align;
        },
        set: function (t) {
          this._align !== t && ((this._align = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "fontName", {
        get: function () {
          return this._fontName;
        },
        set: function (t) {
          if (!sT.available[t])
            throw new Error('Missing BitmapFont "' + t + '"');
          this._fontName !== t && ((this._fontName = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "fontSize", {
        get: function () {
          return this._fontSize;
        },
        set: function (t) {
          this._fontSize !== t && ((this._fontSize = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "anchor", {
        get: function () {
          return this._anchor;
        },
        set: function (t) {
          "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "text", {
        get: function () {
          return this._text;
        },
        set: function (t) {
          (t = String(null == t ? "" : t)),
            this._text !== t && ((this._text = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "maxWidth", {
        get: function () {
          return this._maxWidth;
        },
        set: function (t) {
          this._maxWidth !== t && ((this._maxWidth = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "maxLineHeight", {
        get: function () {
          return this.validate(), this._maxLineHeight;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "textWidth", {
        get: function () {
          return this.validate(), this._textWidth;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "letterSpacing", {
        get: function () {
          return this._letterSpacing;
        },
        set: function (t) {
          this._letterSpacing !== t &&
            ((this._letterSpacing = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "roundPixels", {
        get: function () {
          return this._roundPixels;
        },
        set: function (t) {
          t !== this._roundPixels &&
            ((this._roundPixels = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "textHeight", {
        get: function () {
          return this.validate(), this._textHeight;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "resolution", {
        get: function () {
          return this._resolution;
        },
        set: function (t) {
          (this._autoResolution = !1),
            this._resolution !== t &&
              ((this._resolution = t), (this.dirty = !0));
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.destroy = function (e) {
        var n = this._textureCache;
        for (var i in n) {
          n[i].destroy(), delete n[i];
        }
        (this._textureCache = null), t.prototype.destroy.call(this, e);
      }),
      (e.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0,
      });
  })(y_);
  var hT = (function () {
      function t() {}
      return (
        (t.add = function () {
          fy.setExtensionXhrType("fnt", fy.XHR_RESPONSE_TYPE.TEXT);
        }),
        (t.use = function (e, n) {
          var i = eT(e.data);
          if (i)
            for (
              var r = t.getBaseUrl(this, e),
                s = i.parse(e.data),
                o = {},
                a = function (t) {
                  (o[t.metadata.pageFile] = t.texture),
                    Object.keys(o).length === s.page.length &&
                      ((e.bitmapFont = sT.install(s, o, !0)), n());
                },
                l = 0;
              l < s.page.length;
              ++l
            ) {
              var h = s.page[l].file,
                u = r + h,
                c = !1;
              for (var d in this.resources) {
                var p = this.resources[d];
                if (p.url === u) {
                  (p.metadata.pageFile = h),
                    p.texture ? a(p) : p.onAfterMiddleware.add(a),
                    (c = !0);
                  break;
                }
              }
              if (!c) {
                var f = {
                  crossOrigin: e.crossOrigin,
                  loadType: fy.LOAD_TYPE.IMAGE,
                  metadata: Object.assign(
                    { pageFile: h },
                    e.metadata.imageMetadata
                  ),
                  parentResource: e,
                };
                this.add(u, f, a);
              }
            }
          else n();
        }),
        (t.getBaseUrl = function (e, n) {
          var i = n.isDataUrl ? "" : t.dirname(n.url);
          return (
            n.isDataUrl &&
              ("." === i && (i = ""),
              e.baseUrl &&
                i &&
                "/" === e.baseUrl.charAt(e.baseUrl.length - 1) &&
                (i += "/")),
            (i = i.replace(e.baseUrl, "")) &&
              "/" !== i.charAt(i.length - 1) &&
              (i += "/"),
            i
          );
        }),
        (t.dirname = function (t) {
          var e = t
            .replace(/\\/g, "/")
            .replace(/\/$/, "")
            .replace(/\/[^\/]*$/, "");
          return e === t ? "." : "" === e ? "/" : e;
        }),
        (t.extension = x_.Loader),
        t
      );
    })(),
    uT = function (t, e) {
      return (uT =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
  !(function (t) {
    function e(e) {
      void 0 === e && (e = 1);
      var n =
        t.call(
          this,
          "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",
          "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n",
          { uAlpha: 1 }
        ) || this;
      return (n.alpha = e), n;
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      uT(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t),
      Object.defineProperty(e.prototype, "alpha", {
        get: function () {
          return this.uniforms.uAlpha;
        },
        set: function (t) {
          this.uniforms.uAlpha = t;
        },
        enumerable: !1,
        configurable: !0,
      });
  })(ev);
  var cT = function (t, e) {
    return (cT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  function dT(t, e) {
    function n() {
      this.constructor = t;
    }
    cT(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var pT,
    fT,
    mT,
    _T,
    gT,
    vT,
    yT,
    xT,
    bT,
    TT,
    ET,
    ST,
    wT,
    MT,
    AT,
    RT,
    CT,
    IT,
    PT,
    OT,
    NT = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [
        0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641,
      ],
      15: [
        489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
        0.197448,
      ],
    },
    DT = [
      "varying vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uSampler;",
      "void main(void)",
      "{",
      "    gl_FragColor = vec4(0.0);",
      "    %blur%",
      "}",
    ].join("\n");
  !(function (t) {
    (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
      (t[(t.WEBGL = 1)] = "WEBGL"),
      (t[(t.WEBGL2 = 2)] = "WEBGL2");
  })(pT || (pT = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(fT || (fT = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })(mT || (mT = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(_T || (_T = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(gT || (gT = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(vT || (vT = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(yT || (yT = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(xT || (xT = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(bT || (bT = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(TT || (TT = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(ET || (ET = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })(ST || (ST = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(wT || (wT = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(MT || (MT = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(AT || (AT = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(RT || (RT = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(CT || (CT = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(IT || (IT = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(PT || (PT = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(OT || (OT = {}));
  var LT = (function (t) {
    function e(e, n, i, r, s) {
      void 0 === n && (n = 8),
        void 0 === i && (i = 4),
        void 0 === r && (r = Rp.FILTER_RESOLUTION),
        void 0 === s && (s = 5);
      var o = this,
        a = (function (t, e) {
          var n,
            i = Math.ceil(t / 2),
            r =
              "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",
            s = "";
          n = e
            ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);"
            : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
          for (var o = 0; o < t; o++) {
            var a = n.replace("%index%", o.toString());
            (s += a = a.replace("%sampleIndex%", o - (i - 1) + ".0")),
              (s += "\n");
          }
          return (r = r.replace("%blur%", s)).replace("%size%", t.toString());
        })(s, e),
        l = (function (t) {
          for (
            var e, n = NT[t], i = n.length, r = DT, s = "", o = 0;
            o < t;
            o++
          ) {
            var a =
              "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace(
                "%index%",
                o.toString()
              );
            (e = o),
              o >= i && (e = t - o - 1),
              (s += a = a.replace("%value%", n[e].toString())),
              (s += "\n");
          }
          return (r = r.replace("%blur%", s)).replace("%size%", t.toString());
        })(s);
      return (
        ((o = t.call(this, a, l) || this).horizontal = e),
        (o.resolution = r),
        (o._quality = 0),
        (o.quality = i),
        (o.blur = n),
        o
      );
    }
    return (
      dT(e, t),
      (e.prototype.apply = function (t, e, n, i) {
        if (
          (n
            ? this.horizontal
              ? (this.uniforms.strength = (1 / n.width) * (n.width / e.width))
              : (this.uniforms.strength =
                  (1 / n.height) * (n.height / e.height))
            : this.horizontal
            ? (this.uniforms.strength =
                (1 / t.renderer.width) * (t.renderer.width / e.width))
            : (this.uniforms.strength =
                (1 / t.renderer.height) * (t.renderer.height / e.height)),
          (this.uniforms.strength *= this.strength),
          (this.uniforms.strength /= this.passes),
          1 === this.passes)
        )
          t.applyFilter(this, e, n, i);
        else {
          var r = t.getFilterTexture(),
            s = t.renderer,
            o = e,
            a = r;
          (this.state.blend = !1), t.applyFilter(this, o, a, MT.CLEAR);
          for (var l = 1; l < this.passes - 1; l++) {
            t.bindAndClear(o, MT.BLIT), (this.uniforms.uSampler = a);
            var h = a;
            (a = o), (o = h), s.shader.bind(this), s.geometry.draw(5);
          }
          (this.state.blend = !0),
            t.applyFilter(this, a, n, i),
            t.returnFilterTexture(r);
        }
      }),
      Object.defineProperty(e.prototype, "blur", {
        get: function () {
          return this.strength;
        },
        set: function (t) {
          (this.padding = 1 + 2 * Math.abs(t)), (this.strength = t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "quality", {
        get: function () {
          return this._quality;
        },
        set: function (t) {
          (this._quality = t), (this.passes = t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      e
    );
  })(ev);
  !(function (t) {
    function e(e, n, i, r) {
      void 0 === e && (e = 8),
        void 0 === n && (n = 4),
        void 0 === i && (i = Rp.FILTER_RESOLUTION),
        void 0 === r && (r = 5);
      var s = t.call(this) || this;
      return (
        (s.blurXFilter = new LT(!0, e, n, i, r)),
        (s.blurYFilter = new LT(!1, e, n, i, r)),
        (s.resolution = i),
        (s.quality = n),
        (s.blur = e),
        (s.repeatEdgePixels = !1),
        s
      );
    }
    dT(e, t),
      (e.prototype.apply = function (t, e, n, i) {
        var r = Math.abs(this.blurXFilter.strength),
          s = Math.abs(this.blurYFilter.strength);
        if (r && s) {
          var o = t.getFilterTexture();
          this.blurXFilter.apply(t, e, o, MT.CLEAR),
            this.blurYFilter.apply(t, o, n, i),
            t.returnFilterTexture(o);
        } else
          s
            ? this.blurYFilter.apply(t, e, n, i)
            : this.blurXFilter.apply(t, e, n, i);
      }),
      (e.prototype.updatePadding = function () {
        this._repeatEdgePixels
          ? (this.padding = 0)
          : (this.padding =
              2 *
              Math.max(
                Math.abs(this.blurXFilter.strength),
                Math.abs(this.blurYFilter.strength)
              ));
      }),
      Object.defineProperty(e.prototype, "blur", {
        get: function () {
          return this.blurXFilter.blur;
        },
        set: function (t) {
          (this.blurXFilter.blur = this.blurYFilter.blur = t),
            this.updatePadding();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "quality", {
        get: function () {
          return this.blurXFilter.quality;
        },
        set: function (t) {
          this.blurXFilter.quality = this.blurYFilter.quality = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "blurX", {
        get: function () {
          return this.blurXFilter.blur;
        },
        set: function (t) {
          (this.blurXFilter.blur = t), this.updatePadding();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "blurY", {
        get: function () {
          return this.blurYFilter.blur;
        },
        set: function (t) {
          (this.blurYFilter.blur = t), this.updatePadding();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "blendMode", {
        get: function () {
          return this.blurYFilter.blendMode;
        },
        set: function (t) {
          this.blurYFilter.blendMode = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "repeatEdgePixels", {
        get: function () {
          return this._repeatEdgePixels;
        },
        set: function (t) {
          (this._repeatEdgePixels = t), this.updatePadding();
        },
        enumerable: !1,
        configurable: !0,
      });
  })(ev);
  var FT = function (t, e) {
    return (FT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  var UT = (function (t) {
    function e() {
      var e = this,
        n = {
          m: new Float32Array([
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
          ]),
          uAlpha: 1,
        };
      return (
        ((e =
          t.call(
            this,
            Nv,
            "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n",
            n
          ) || this).alpha = 1),
        e
      );
    }
    return (
      (function (t, e) {
        function n() {
          this.constructor = t;
        }
        FT(t, e),
          (t.prototype =
            null === e
              ? Object.create(e)
              : ((n.prototype = e.prototype), new n()));
      })(e, t),
      (e.prototype._loadMatrix = function (t, e) {
        void 0 === e && (e = !1);
        var n = t;
        e &&
          (this._multiply(n, this.uniforms.m, t), (n = this._colorMatrix(n))),
          (this.uniforms.m = n);
      }),
      (e.prototype._multiply = function (t, e, n) {
        return (
          (t[0] = e[0] * n[0] + e[1] * n[5] + e[2] * n[10] + e[3] * n[15]),
          (t[1] = e[0] * n[1] + e[1] * n[6] + e[2] * n[11] + e[3] * n[16]),
          (t[2] = e[0] * n[2] + e[1] * n[7] + e[2] * n[12] + e[3] * n[17]),
          (t[3] = e[0] * n[3] + e[1] * n[8] + e[2] * n[13] + e[3] * n[18]),
          (t[4] =
            e[0] * n[4] + e[1] * n[9] + e[2] * n[14] + e[3] * n[19] + e[4]),
          (t[5] = e[5] * n[0] + e[6] * n[5] + e[7] * n[10] + e[8] * n[15]),
          (t[6] = e[5] * n[1] + e[6] * n[6] + e[7] * n[11] + e[8] * n[16]),
          (t[7] = e[5] * n[2] + e[6] * n[7] + e[7] * n[12] + e[8] * n[17]),
          (t[8] = e[5] * n[3] + e[6] * n[8] + e[7] * n[13] + e[8] * n[18]),
          (t[9] =
            e[5] * n[4] + e[6] * n[9] + e[7] * n[14] + e[8] * n[19] + e[9]),
          (t[10] = e[10] * n[0] + e[11] * n[5] + e[12] * n[10] + e[13] * n[15]),
          (t[11] = e[10] * n[1] + e[11] * n[6] + e[12] * n[11] + e[13] * n[16]),
          (t[12] = e[10] * n[2] + e[11] * n[7] + e[12] * n[12] + e[13] * n[17]),
          (t[13] = e[10] * n[3] + e[11] * n[8] + e[12] * n[13] + e[13] * n[18]),
          (t[14] =
            e[10] * n[4] +
            e[11] * n[9] +
            e[12] * n[14] +
            e[13] * n[19] +
            e[14]),
          (t[15] = e[15] * n[0] + e[16] * n[5] + e[17] * n[10] + e[18] * n[15]),
          (t[16] = e[15] * n[1] + e[16] * n[6] + e[17] * n[11] + e[18] * n[16]),
          (t[17] = e[15] * n[2] + e[16] * n[7] + e[17] * n[12] + e[18] * n[17]),
          (t[18] = e[15] * n[3] + e[16] * n[8] + e[17] * n[13] + e[18] * n[18]),
          (t[19] =
            e[15] * n[4] +
            e[16] * n[9] +
            e[17] * n[14] +
            e[18] * n[19] +
            e[19]),
          t
        );
      }),
      (e.prototype._colorMatrix = function (t) {
        var e = new Float32Array(t);
        return (e[4] /= 255), (e[9] /= 255), (e[14] /= 255), (e[19] /= 255), e;
      }),
      (e.prototype.brightness = function (t, e) {
        var n = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e);
      }),
      (e.prototype.tint = function (t, e) {
        var n = [
          ((t >> 16) & 255) / 255,
          0,
          0,
          0,
          0,
          0,
          ((t >> 8) & 255) / 255,
          0,
          0,
          0,
          0,
          0,
          (255 & t) / 255,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
        ];
        this._loadMatrix(n, e);
      }),
      (e.prototype.greyscale = function (t, e) {
        var n = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e);
      }),
      (e.prototype.blackAndWhite = function (t) {
        this._loadMatrix(
          [
            0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0,
            0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.hue = function (t, e) {
        t = ((t || 0) / 180) * Math.PI;
        var n = Math.cos(t),
          i = Math.sin(t),
          r = 1 / 3,
          s = (0, Math.sqrt)(r),
          o = [
            n + (1 - n) * r,
            r * (1 - n) - s * i,
            r * (1 - n) + s * i,
            0,
            0,
            r * (1 - n) + s * i,
            n + r * (1 - n),
            r * (1 - n) - s * i,
            0,
            0,
            r * (1 - n) - s * i,
            r * (1 - n) + s * i,
            n + r * (1 - n),
            0,
            0,
            0,
            0,
            0,
            1,
            0,
          ];
        this._loadMatrix(o, e);
      }),
      (e.prototype.contrast = function (t, e) {
        var n = (t || 0) + 1,
          i = -0.5 * (n - 1),
          r = [n, 0, 0, 0, i, 0, n, 0, 0, i, 0, 0, n, 0, i, 0, 0, 0, 1, 0];
        this._loadMatrix(r, e);
      }),
      (e.prototype.saturate = function (t, e) {
        void 0 === t && (t = 0);
        var n = (2 * t) / 3 + 1,
          i = -0.5 * (n - 1),
          r = [n, i, i, 0, 0, i, n, i, 0, 0, i, i, n, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, e);
      }),
      (e.prototype.desaturate = function () {
        this.saturate(-1);
      }),
      (e.prototype.negative = function (t) {
        this._loadMatrix(
          [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0],
          t
        );
      }),
      (e.prototype.sepia = function (t) {
        this._loadMatrix(
          [
            0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0,
            0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.technicolor = function (t) {
        this._loadMatrix(
          [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
            11.793603434377337, -0.3087833385928097, 1.7658908555458428,
            -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
            -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0,
            0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.polaroid = function (t) {
        this._loadMatrix(
          [
            1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
            -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.toBGR = function (t) {
        this._loadMatrix(
          [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],
          t
        );
      }),
      (e.prototype.kodachrome = function (t) {
        this._loadMatrix(
          [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
            63.72958762196502, -0.16404339962244616, 1.0835251566291304,
            -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
            -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0,
            0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.browni = function (t) {
        this._loadMatrix(
          [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
            47.43192855600873, -0.037703249837783157, 0.8609577587992641,
            0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
            -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0,
            0, 0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.vintage = function (t) {
        this._loadMatrix(
          [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
            9.651285835294123, 0.02578397704808868, 0.6441188644374771,
            0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
            -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0,
            0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.colorTone = function (t, e, n, i, r) {
        var s = (((n = n || 16770432) >> 16) & 255) / 255,
          o = ((n >> 8) & 255) / 255,
          a = (255 & n) / 255,
          l = (((i = i || 3375104) >> 16) & 255) / 255,
          h = ((i >> 8) & 255) / 255,
          u = (255 & i) / 255,
          c = [
            0.3,
            0.59,
            0.11,
            0,
            0,
            s,
            o,
            a,
            (t = t || 0.2),
            0,
            l,
            h,
            u,
            (e = e || 0.15),
            0,
            s - l,
            o - h,
            a - u,
            0,
            0,
          ];
        this._loadMatrix(c, r);
      }),
      (e.prototype.night = function (t, e) {
        var n = [
          -2 * (t = t || 0.1),
          -t,
          0,
          0,
          0,
          -t,
          0,
          t,
          0,
          0,
          0,
          t,
          2 * t,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
        ];
        this._loadMatrix(n, e);
      }),
      (e.prototype.predator = function (t, e) {
        var n = [
          11.224130630493164 * t,
          -4.794486999511719 * t,
          -2.8746118545532227 * t,
          0 * t,
          0.40342438220977783 * t,
          -3.6330697536468506 * t,
          9.193157196044922 * t,
          -2.951810836791992 * t,
          0 * t,
          -1.316135048866272 * t,
          -3.2184197902679443 * t,
          -4.2375030517578125 * t,
          7.476448059082031 * t,
          0 * t,
          0.8044459223747253 * t,
          0,
          0,
          0,
          1,
          0,
        ];
        this._loadMatrix(n, e);
      }),
      (e.prototype.lsd = function (t) {
        this._loadMatrix(
          [
            2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0,
            0, 1, 0,
          ],
          t
        );
      }),
      (e.prototype.reset = function () {
        this._loadMatrix(
          [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
          !1
        );
      }),
      Object.defineProperty(e.prototype, "matrix", {
        get: function () {
          return this.uniforms.m;
        },
        set: function (t) {
          this.uniforms.m = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "alpha", {
        get: function () {
          return this.uniforms.uAlpha;
        },
        set: function (t) {
          this.uniforms.uAlpha = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      e
    );
  })(ev);
  UT.prototype.grayscale = UT.prototype.greyscale;
  var BT = function (t, e) {
    return (BT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  !(function (t) {
    function e(e, n) {
      var i = this,
        r = new Um();
      return (
        (e.renderable = !1),
        ((i =
          t.call(
            this,
            "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n",
            "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n",
            {
              mapSampler: e._texture,
              filterMatrix: r,
              scale: { x: 1, y: 1 },
              rotation: new Float32Array([1, 0, 0, 1]),
            }
          ) || this).maskSprite = e),
        (i.maskMatrix = r),
        null == n && (n = 20),
        (i.scale = new Cm(n, n)),
        i
      );
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      BT(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t),
      (e.prototype.apply = function (t, e, n, i) {
        (this.uniforms.filterMatrix = t.calculateSpriteMatrix(
          this.maskMatrix,
          this.maskSprite
        )),
          (this.uniforms.scale.x = this.scale.x),
          (this.uniforms.scale.y = this.scale.y);
        var r = this.maskSprite.worldTransform,
          s = Math.sqrt(r.a * r.a + r.b * r.b),
          o = Math.sqrt(r.c * r.c + r.d * r.d);
        0 !== s &&
          0 !== o &&
          ((this.uniforms.rotation[0] = r.a / s),
          (this.uniforms.rotation[1] = r.b / s),
          (this.uniforms.rotation[2] = r.c / o),
          (this.uniforms.rotation[3] = r.d / o)),
          t.applyFilter(this, e, n, i);
      }),
      Object.defineProperty(e.prototype, "map", {
        get: function () {
          return this.uniforms.mapSampler;
        },
        set: function (t) {
          this.uniforms.mapSampler = t;
        },
        enumerable: !1,
        configurable: !0,
      });
  })(ev);
  var kT = function (t, e) {
    return (kT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  !(function (t) {
    function e() {
      return (
        t.call(
          this,
          "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
          'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n'
        ) || this
      );
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      kT(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t);
  })(ev);
  var GT = function (t, e) {
    return (GT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  var HT,
    zT,
    VT,
    XT,
    WT,
    jT,
    YT,
    qT,
    KT,
    ZT,
    JT,
    $T,
    QT,
    tE,
    eE,
    nE,
    iE,
    rE,
    sE,
    oE;
  !(function (t) {
    function e(e, n) {
      void 0 === e && (e = 0.5), void 0 === n && (n = Math.random());
      var i =
        t.call(
          this,
          Nv,
          "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n",
          { uNoise: 0, uSeed: 0 }
        ) || this;
      return (i.noise = e), (i.seed = n), i;
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      GT(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t),
      Object.defineProperty(e.prototype, "noise", {
        get: function () {
          return this.uniforms.uNoise;
        },
        set: function (t) {
          this.uniforms.uNoise = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "seed", {
        get: function () {
          return this.uniforms.uSeed;
        },
        set: function (t) {
          this.uniforms.uSeed = t;
        },
        enumerable: !1,
        configurable: !0,
      });
  })(ev),
    (function (t) {
      (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.WEBGL2 = 2)] = "WEBGL2");
    })(HT || (HT = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(zT || (zT = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })(VT || (VT = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(XT || (XT = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(WT || (WT = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(jT || (jT = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(YT || (YT = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(qT || (qT = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(KT || (KT = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(ZT || (ZT = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(JT || (JT = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })($T || ($T = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(QT || (QT = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(tE || (tE = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(eE || (eE = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(nE || (nE = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(iE || (iE = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(rE || (rE = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(sE || (sE = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(oE || (oE = {}));
  var aE = new Um();
  (__.prototype._cacheAsBitmap = !1),
    (__.prototype._cacheData = null),
    (__.prototype._cacheAsBitmapResolution = null),
    (__.prototype._cacheAsBitmapMultisample = sE.NONE);
  var lE = function () {
    (this.textureCacheId = null),
      (this.originalRender = null),
      (this.originalRenderCanvas = null),
      (this.originalCalculateBounds = null),
      (this.originalGetLocalBounds = null),
      (this.originalUpdateTransform = null),
      (this.originalDestroy = null),
      (this.originalMask = null),
      (this.originalFilterArea = null),
      (this.originalContainsPoint = null),
      (this.sprite = null);
  };
  Object.defineProperties(__.prototype, {
    cacheAsBitmapResolution: {
      get: function () {
        return this._cacheAsBitmapResolution;
      },
      set: function (t) {
        t !== this._cacheAsBitmapResolution &&
          ((this._cacheAsBitmapResolution = t),
          this.cacheAsBitmap &&
            ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
      },
    },
    cacheAsBitmapMultisample: {
      get: function () {
        return this._cacheAsBitmapMultisample;
      },
      set: function (t) {
        t !== this._cacheAsBitmapMultisample &&
          ((this._cacheAsBitmapMultisample = t),
          this.cacheAsBitmap &&
            ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
      },
    },
    cacheAsBitmap: {
      get: function () {
        return this._cacheAsBitmap;
      },
      set: function (t) {
        var e;
        this._cacheAsBitmap !== t &&
          ((this._cacheAsBitmap = t),
          t
            ? (this._cacheData || (this._cacheData = new lE()),
              ((e = this._cacheData).originalRender = this.render),
              (e.originalRenderCanvas = this.renderCanvas),
              (e.originalUpdateTransform = this.updateTransform),
              (e.originalCalculateBounds = this.calculateBounds),
              (e.originalGetLocalBounds = this.getLocalBounds),
              (e.originalDestroy = this.destroy),
              (e.originalContainsPoint = this.containsPoint),
              (e.originalMask = this._mask),
              (e.originalFilterArea = this.filterArea),
              (this.render = this._renderCached),
              (this.renderCanvas = this._renderCachedCanvas),
              (this.destroy = this._cacheAsBitmapDestroy))
            : ((e = this._cacheData).sprite &&
                this._destroyCachedDisplayObject(),
              (this.render = e.originalRender),
              (this.renderCanvas = e.originalRenderCanvas),
              (this.calculateBounds = e.originalCalculateBounds),
              (this.getLocalBounds = e.originalGetLocalBounds),
              (this.destroy = e.originalDestroy),
              (this.updateTransform = e.originalUpdateTransform),
              (this.containsPoint = e.originalContainsPoint),
              (this._mask = e.originalMask),
              (this.filterArea = e.originalFilterArea)));
      },
    },
  }),
    (__.prototype._renderCached = function (t) {
      !this.visible ||
        this.worldAlpha <= 0 ||
        !this.renderable ||
        (this._initCachedDisplayObject(t),
        (this._cacheData.sprite.transform._worldID = this.transform._worldID),
        (this._cacheData.sprite.worldAlpha = this.worldAlpha),
        this._cacheData.sprite._render(t));
    }),
    (__.prototype._initCachedDisplayObject = function (t) {
      var e;
      if (!this._cacheData || !this._cacheData.sprite) {
        var n = this.alpha;
        (this.alpha = 1), t.batch.flush();
        var i = this.getLocalBounds(null, !0).clone();
        if (this.filters && this.filters.length) {
          var r = this.filters[0].padding;
          i.pad(r);
        }
        i.ceil(Rp.RESOLUTION);
        var s = t.renderTexture.current,
          o = t.renderTexture.sourceFrame.clone(),
          a = t.renderTexture.destinationFrame.clone(),
          l = t.projection.transform,
          h = ng.create({
            width: i.width,
            height: i.height,
            resolution: this.cacheAsBitmapResolution || t.resolution,
            multisample:
              null !== (e = this.cacheAsBitmapMultisample) && void 0 !== e
                ? e
                : t.multisample,
          }),
          u = "cacheAsBitmap_" + mm();
        (this._cacheData.textureCacheId = u),
          k_.addToCache(h.baseTexture, u),
          eg.addToCache(h, u);
        var c = this.transform.localTransform
          .copyTo(aE)
          .invert()
          .translate(-i.x, -i.y);
        (this.render = this._cacheData.originalRender),
          t.render(this, {
            renderTexture: h,
            clear: !0,
            transform: c,
            skipUpdateTransform: !1,
          }),
          t.framebuffer.blit(),
          (t.projection.transform = l),
          t.renderTexture.bind(s, o, a),
          (this.render = this._renderCached),
          (this.updateTransform = this.displayObjectUpdateTransform),
          (this.calculateBounds = this._calculateCachedBounds),
          (this.getLocalBounds = this._getCachedLocalBounds),
          (this._mask = null),
          (this.filterArea = null),
          (this.alpha = n);
        var d = new hb(h);
        (d.transform.worldTransform = this.transform.worldTransform),
          (d.anchor.x = -i.x / i.width),
          (d.anchor.y = -i.y / i.height),
          (d.alpha = n),
          (d._bounds = this._bounds),
          (this._cacheData.sprite = d),
          (this.transform._parentID = -1),
          this.parent
            ? this.updateTransform()
            : (this.enableTempParent(),
              this.updateTransform(),
              this.disableTempParent(null)),
          (this.containsPoint = d.containsPoint.bind(d));
      }
    }),
    (__.prototype._renderCachedCanvas = function (t) {
      !this.visible ||
        this.worldAlpha <= 0 ||
        !this.renderable ||
        (this._initCachedDisplayObjectCanvas(t),
        (this._cacheData.sprite.worldAlpha = this.worldAlpha),
        this._cacheData.sprite._renderCanvas(t));
    }),
    (__.prototype._initCachedDisplayObjectCanvas = function (t) {
      if (!this._cacheData || !this._cacheData.sprite) {
        var e = this.getLocalBounds(null, !0),
          n = this.alpha;
        this.alpha = 1;
        var i = t.context,
          r = t._projTransform;
        e.ceil(Rp.RESOLUTION);
        var s = ng.create({ width: e.width, height: e.height }),
          o = "cacheAsBitmap_" + mm();
        (this._cacheData.textureCacheId = o),
          k_.addToCache(s.baseTexture, o),
          eg.addToCache(s, o);
        var a = aE;
        this.transform.localTransform.copyTo(a),
          a.invert(),
          (a.tx -= e.x),
          (a.ty -= e.y),
          (this.renderCanvas = this._cacheData.originalRenderCanvas),
          t.render(this, {
            renderTexture: s,
            clear: !0,
            transform: a,
            skipUpdateTransform: !1,
          }),
          (t.context = i),
          (t._projTransform = r),
          (this.renderCanvas = this._renderCachedCanvas),
          (this.updateTransform = this.displayObjectUpdateTransform),
          (this.calculateBounds = this._calculateCachedBounds),
          (this.getLocalBounds = this._getCachedLocalBounds),
          (this._mask = null),
          (this.filterArea = null),
          (this.alpha = n);
        var l = new hb(s);
        (l.transform.worldTransform = this.transform.worldTransform),
          (l.anchor.x = -e.x / e.width),
          (l.anchor.y = -e.y / e.height),
          (l.alpha = n),
          (l._bounds = this._bounds),
          (this._cacheData.sprite = l),
          (this.transform._parentID = -1),
          this.parent
            ? this.updateTransform()
            : ((this.parent = t._tempDisplayObjectParent),
              this.updateTransform(),
              (this.parent = null)),
          (this.containsPoint = l.containsPoint.bind(l));
      }
    }),
    (__.prototype._calculateCachedBounds = function () {
      this._bounds.clear(),
        (this._cacheData.sprite.transform._worldID = this.transform._worldID),
        this._cacheData.sprite._calculateBounds(),
        (this._bounds.updateID = this._boundsID);
    }),
    (__.prototype._getCachedLocalBounds = function () {
      return this._cacheData.sprite.getLocalBounds(null);
    }),
    (__.prototype._destroyCachedDisplayObject = function () {
      this._cacheData.sprite._texture.destroy(!0),
        (this._cacheData.sprite = null),
        k_.removeFromCache(this._cacheData.textureCacheId),
        eg.removeFromCache(this._cacheData.textureCacheId),
        (this._cacheData.textureCacheId = null);
    }),
    (__.prototype._cacheAsBitmapDestroy = function (t) {
      (this.cacheAsBitmap = !1), this.destroy(t);
    }),
    (__.prototype.name = null),
    (y_.prototype.getChildByName = function (t, e) {
      for (var n = 0, i = this.children.length; n < i; n++)
        if (this.children[n].name === t) return this.children[n];
      if (e)
        for (n = 0, i = this.children.length; n < i; n++) {
          var r = this.children[n];
          if (r.getChildByName) {
            var s = r.getChildByName(t, !0);
            if (s) return s;
          }
        }
      return null;
    }),
    (__.prototype.getGlobalPosition = function (t, e) {
      return (
        void 0 === t && (t = new Cm()),
        void 0 === e && (e = !1),
        this.parent
          ? this.parent.toGlobal(this.position, t, e)
          : ((t.x = this.position.x), (t.y = this.position.y)),
        t
      );
    });
  var hE,
    uE,
    cE,
    dE,
    pE,
    fE,
    mE,
    _E,
    gE,
    vE,
    yE,
    xE,
    bE,
    TE,
    EE,
    SE,
    wE,
    ME,
    AE,
    RE,
    CE = (function () {
      function t() {}
      return (
        (t.init = function (t) {
          var e = this;
          Object.defineProperty(this, "resizeTo", {
            set: function (t) {
              globalThis.removeEventListener("resize", this.queueResize),
                (this._resizeTo = t),
                t &&
                  (globalThis.addEventListener("resize", this.queueResize),
                  this.resize());
            },
            get: function () {
              return this._resizeTo;
            },
          }),
            (this.queueResize = function () {
              e._resizeTo &&
                (e.cancelResize(),
                (e._resizeId = requestAnimationFrame(function () {
                  return e.resize();
                })));
            }),
            (this.cancelResize = function () {
              e._resizeId &&
                (cancelAnimationFrame(e._resizeId), (e._resizeId = null));
            }),
            (this.resize = function () {
              if (e._resizeTo) {
                var t, n;
                if ((e.cancelResize(), e._resizeTo === globalThis.window))
                  (t = globalThis.innerWidth), (n = globalThis.innerHeight);
                else {
                  var i = e._resizeTo;
                  (t = i.clientWidth), (n = i.clientHeight);
                }
                e.renderer.resize(t, n);
              }
            }),
            (this._resizeId = null),
            (this._resizeTo = null),
            (this.resizeTo = t.resizeTo || null);
        }),
        (t.destroy = function () {
          globalThis.removeEventListener("resize", this.queueResize),
            this.cancelResize(),
            (this.cancelResize = null),
            (this.queueResize = null),
            (this.resizeTo = null),
            (this.resize = null);
        }),
        (t.extension = x_.Application),
        t
      );
    })();
  !(function (t) {
    (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
      (t[(t.WEBGL = 1)] = "WEBGL"),
      (t[(t.WEBGL2 = 2)] = "WEBGL2");
  })(hE || (hE = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(uE || (uE = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })(cE || (cE = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(dE || (dE = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(pE || (pE = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(fE || (fE = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(mE || (mE = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(_E || (_E = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(gE || (gE = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(vE || (vE = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(yE || (yE = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })(xE || (xE = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(bE || (bE = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(TE || (TE = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(EE || (EE = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(SE || (SE = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(wE || (wE = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(ME || (ME = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(AE || (AE = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(RE || (RE = {}));
  var IE = {
      createCanvas: function (t, e) {
        var n = document.createElement("canvas");
        return (n.width = t), (n.height = e), n;
      },
      getWebGLRenderingContext: function () {
        return WebGLRenderingContext;
      },
      getNavigator: function () {
        return navigator;
      },
      getBaseUrl: function () {
        var t;
        return null !== (t = document.baseURI) && void 0 !== t
          ? t
          : window.location.href;
      },
      fetch: function (t, e) {
        return fetch(t, e);
      },
    },
    PE = /iPhone/i,
    OE = /iPod/i,
    NE = /iPad/i,
    DE = /\biOS-universal(?:.+)Mac\b/i,
    LE = /\bAndroid(?:.+)Mobile\b/i,
    FE = /Android/i,
    UE = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    BE = /Silk/i,
    kE = /Windows Phone/i,
    GE = /\bWindows(?:.+)ARM\b/i,
    HE = /BlackBerry/i,
    zE = /BB10/i,
    VE = /Opera Mini/i,
    XE = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    WE = /Mobile(?:.+)Firefox\b/i,
    jE = function (t) {
      return (
        void 0 !== t &&
        "MacIntel" === t.platform &&
        "number" == typeof t.maxTouchPoints &&
        t.maxTouchPoints > 1 &&
        "undefined" == typeof MSStream
      );
    };
  var YE = (function (t) {
    var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
    t || "undefined" == typeof navigator
      ? "string" == typeof t
        ? (e.userAgent = t)
        : t &&
          t.userAgent &&
          (e = {
            userAgent: t.userAgent,
            platform: t.platform,
            maxTouchPoints: t.maxTouchPoints || 0,
          })
      : (e = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0,
        });
    var n = e.userAgent,
      i = n.split("[FBAN");
    void 0 !== i[1] && (n = i[0]),
      void 0 !== (i = n.split("Twitter"))[1] && (n = i[0]);
    var r = (function (t) {
        return function (e) {
          return e.test(t);
        };
      })(n),
      s = {
        apple: {
          phone: r(PE) && !r(kE),
          ipod: r(OE),
          tablet: !r(PE) && (r(NE) || jE(e)) && !r(kE),
          universal: r(DE),
          device: (r(PE) || r(OE) || r(NE) || r(DE) || jE(e)) && !r(kE),
        },
        amazon: {
          phone: r(UE),
          tablet: !r(UE) && r(BE),
          device: r(UE) || r(BE),
        },
        android: {
          phone: (!r(kE) && r(UE)) || (!r(kE) && r(LE)),
          tablet: !r(kE) && !r(UE) && !r(LE) && (r(BE) || r(FE)),
          device:
            (!r(kE) && (r(UE) || r(BE) || r(LE) || r(FE))) || r(/\bokhttp\b/i),
        },
        windows: { phone: r(kE), tablet: r(GE), device: r(kE) || r(GE) },
        other: {
          blackberry: r(HE),
          blackberry10: r(zE),
          opera: r(VE),
          firefox: r(WE),
          chrome: r(XE),
          device: r(HE) || r(zE) || r(VE) || r(WE) || r(XE),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      };
    return (
      (s.any =
        s.apple.device ||
        s.android.device ||
        s.windows.device ||
        s.other.device),
      (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
      (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
      s
    );
  })(globalThis.navigator);
  var qE = {
      ADAPTER: IE,
      MIPMAP_TEXTURES: xE.POW2,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      FILTER_MULTISAMPLE: AE.NONE,
      SPRITE_MAX_TEXTURES: (function (t) {
        var e = !0;
        if (YE.tablet || YE.phone) {
          var n;
          if (YE.apple.device)
            if ((n = navigator.userAgent.match(/OS (\d+)_(\d+)?/)))
              parseInt(n[1], 10) < 11 && (e = !1);
          if (YE.android.device)
            if ((n = navigator.userAgent.match(/Android\s([0-9.]*)/)))
              parseInt(n[1], 10) < 7 && (e = !1);
        }
        return e ? t : 4;
      })(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: !1,
        autoDensity: !1,
        backgroundColor: 0,
        backgroundAlpha: 1,
        useContextAlpha: !0,
        clearBeforeRender: !0,
        preserveDrawingBuffer: !1,
        width: 800,
        height: 600,
        legacy: !1,
      },
      GC_MODE: EE.AUTO,
      GC_MAX_IDLE: 3600,
      GC_MAX_CHECK_COUNT: 600,
      WRAP_MODE: yE.CLAMP,
      SCALE_MODE: vE.LINEAR,
      PRECISION_VERTEX: SE.HIGH,
      PRECISION_FRAGMENT: YE.apple.device ? SE.HIGH : SE.MEDIUM,
      CAN_UPLOAD_SAME_BUFFER: !YE.apple.device,
      CREATE_IMAGE_BITMAP: !1,
      ROUND_PIXELS: !1,
    },
    KE =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
        ? self
        : {};
  function ZE(t, e, n) {
    return (
      t(
        (n = {
          path: e,
          exports: {},
          require: function (t, e) {
            return (function () {
              throw new Error(
                "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
              );
            })(null == e && n.path);
          },
        }),
        n.exports
      ),
      n.exports
    );
  }
  function JE(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  ZE(function (t) {
    var e = Object.prototype.hasOwnProperty,
      n = "~";
    function i() {}
    function r(t, e, n) {
      (this.fn = t), (this.context = e), (this.once = n || !1);
    }
    function s(t, e, i, s, o) {
      if ("function" != typeof i)
        throw new TypeError("The listener must be a function");
      var a = new r(i, s || t, o),
        l = n ? n + e : e;
      return (
        t._events[l]
          ? t._events[l].fn
            ? (t._events[l] = [t._events[l], a])
            : t._events[l].push(a)
          : ((t._events[l] = a), t._eventsCount++),
        t
      );
    }
    function o(t, e) {
      0 == --t._eventsCount ? (t._events = new i()) : delete t._events[e];
    }
    function a() {
      (this._events = new i()), (this._eventsCount = 0);
    }
    Object.create &&
      ((i.prototype = Object.create(null)), new i().__proto__ || (n = !1)),
      (a.prototype.eventNames = function () {
        var t,
          i,
          r = [];
        if (0 === this._eventsCount) return r;
        for (i in (t = this._events))
          e.call(t, i) && r.push(n ? i.slice(1) : i);
        return Object.getOwnPropertySymbols
          ? r.concat(Object.getOwnPropertySymbols(t))
          : r;
      }),
      (a.prototype.listeners = function (t) {
        var e = n ? n + t : t,
          i = this._events[e];
        if (!i) return [];
        if (i.fn) return [i.fn];
        for (var r = 0, s = i.length, o = new Array(s); r < s; r++)
          o[r] = i[r].fn;
        return o;
      }),
      (a.prototype.listenerCount = function (t) {
        var e = n ? n + t : t,
          i = this._events[e];
        return i ? (i.fn ? 1 : i.length) : 0;
      }),
      (a.prototype.emit = function (t, e, i, r, s, o) {
        var a = arguments,
          l = n ? n + t : t;
        if (!this._events[l]) return !1;
        var h,
          u,
          c = this._events[l],
          d = arguments.length;
        if (c.fn) {
          switch ((c.once && this.removeListener(t, c.fn, void 0, !0), d)) {
            case 1:
              return c.fn.call(c.context), !0;
            case 2:
              return c.fn.call(c.context, e), !0;
            case 3:
              return c.fn.call(c.context, e, i), !0;
            case 4:
              return c.fn.call(c.context, e, i, r), !0;
            case 5:
              return c.fn.call(c.context, e, i, r, s), !0;
            case 6:
              return c.fn.call(c.context, e, i, r, s, o), !0;
          }
          for (u = 1, h = new Array(d - 1); u < d; u++) h[u - 1] = a[u];
          c.fn.apply(c.context, h);
        } else {
          var p,
            f = c.length;
          for (u = 0; u < f; u++)
            switch (
              (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), d)
            ) {
              case 1:
                c[u].fn.call(c[u].context);
                break;
              case 2:
                c[u].fn.call(c[u].context, e);
                break;
              case 3:
                c[u].fn.call(c[u].context, e, i);
                break;
              case 4:
                c[u].fn.call(c[u].context, e, i, r);
                break;
              default:
                if (!h)
                  for (p = 1, h = new Array(d - 1); p < d; p++) h[p - 1] = a[p];
                c[u].fn.apply(c[u].context, h);
            }
        }
        return !0;
      }),
      (a.prototype.on = function (t, e, n) {
        return s(this, t, e, n, !1);
      }),
      (a.prototype.once = function (t, e, n) {
        return s(this, t, e, n, !0);
      }),
      (a.prototype.removeListener = function (t, e, i, r) {
        var s = n ? n + t : t;
        if (!this._events[s]) return this;
        if (!e) return o(this, s), this;
        var a = this._events[s];
        if (a.fn)
          a.fn !== e || (r && !a.once) || (i && a.context !== i) || o(this, s);
        else {
          for (var l = 0, h = [], u = a.length; l < u; l++)
            (a[l].fn !== e || (r && !a[l].once) || (i && a[l].context !== i)) &&
              h.push(a[l]);
          h.length ? (this._events[s] = 1 === h.length ? h[0] : h) : o(this, s);
        }
        return this;
      }),
      (a.prototype.removeAllListeners = function (t) {
        var e;
        return (
          t
            ? ((e = n ? n + t : t), this._events[e] && o(this, e))
            : ((this._events = new i()), (this._eventsCount = 0)),
          this
        );
      }),
      (a.prototype.off = a.prototype.removeListener),
      (a.prototype.addListener = a.prototype.on),
      (a.prefixed = n),
      (a.EventEmitter = a),
      (t.exports = a);
  }),
    ZE(function (t, e) {
      !(function (n) {
        var i = e && !e.nodeType && e,
          r = t && !t.nodeType && t,
          s = "object" == typeof KE && KE;
        (s.global !== s && s.window !== s && s.self !== s) || (n = s);
        var o,
          a,
          l = 2147483647,
          h = 36,
          u = /^xn--/,
          c = /[^\x20-\x7E]/,
          d = /[\x2E\u3002\uFF0E\uFF61]/g,
          p = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input",
          },
          f = Math.floor,
          m = String.fromCharCode;
        function _(t) {
          throw RangeError(p[t]);
        }
        function g(t, e) {
          for (var n = t.length, i = []; n--; ) i[n] = e(t[n]);
          return i;
        }
        function v(t, e) {
          var n = t.split("@"),
            i = "";
          return (
            n.length > 1 && ((i = n[0] + "@"), (t = n[1])),
            i + g((t = t.replace(d, ".")).split("."), e).join(".")
          );
        }
        function y(t) {
          for (var e, n, i = [], r = 0, s = t.length; r < s; )
            (e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < s
              ? 56320 == (64512 & (n = t.charCodeAt(r++)))
                ? i.push(((1023 & e) << 10) + (1023 & n) + 65536)
                : (i.push(e), r--)
              : i.push(e);
          return i;
        }
        function x(t) {
          return g(t, function (t) {
            var e = "";
            return (
              t > 65535 &&
                ((e += m((((t -= 65536) >>> 10) & 1023) | 55296)),
                (t = 56320 | (1023 & t))),
              (e += m(t))
            );
          }).join("");
        }
        function b(t, e) {
          return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
        }
        function T(t, e, n) {
          var i = 0;
          for (t = n ? f(t / 700) : t >> 1, t += f(t / e); t > 455; i += h)
            t = f(t / 35);
          return f(i + (36 * t) / (t + 38));
        }
        function E(t) {
          var e,
            n,
            i,
            r,
            s,
            o,
            a,
            u,
            c,
            d,
            p,
            m = [],
            g = t.length,
            v = 0,
            y = 128,
            b = 72;
          for ((n = t.lastIndexOf("-")) < 0 && (n = 0), i = 0; i < n; ++i)
            t.charCodeAt(i) >= 128 && _("not-basic"), m.push(t.charCodeAt(i));
          for (r = n > 0 ? n + 1 : 0; r < g; ) {
            for (
              s = v, o = 1, a = h;
              r >= g && _("invalid-input"),
                ((u =
                  (p = t.charCodeAt(r++)) - 48 < 10
                    ? p - 22
                    : p - 65 < 26
                    ? p - 65
                    : p - 97 < 26
                    ? p - 97
                    : h) >= h ||
                  u > f((l - v) / o)) &&
                  _("overflow"),
                (v += u * o),
                !(u < (c = a <= b ? 1 : a >= b + 26 ? 26 : a - b));
              a += h
            )
              o > f(l / (d = h - c)) && _("overflow"), (o *= d);
            (b = T(v - s, (e = m.length + 1), 0 == s)),
              f(v / e) > l - y && _("overflow"),
              (y += f(v / e)),
              (v %= e),
              m.splice(v++, 0, y);
          }
          return x(m);
        }
        function S(t) {
          var e,
            n,
            i,
            r,
            s,
            o,
            a,
            u,
            c,
            d,
            p,
            g,
            v,
            x,
            E,
            S = [];
          for (g = (t = y(t)).length, e = 128, n = 0, s = 72, o = 0; o < g; ++o)
            (p = t[o]) < 128 && S.push(m(p));
          for (i = r = S.length, r && S.push("-"); i < g; ) {
            for (a = l, o = 0; o < g; ++o) (p = t[o]) >= e && p < a && (a = p);
            for (
              a - e > f((l - n) / (v = i + 1)) && _("overflow"),
                n += (a - e) * v,
                e = a,
                o = 0;
              o < g;
              ++o
            )
              if (((p = t[o]) < e && ++n > l && _("overflow"), p == e)) {
                for (
                  u = n, c = h;
                  !(u < (d = c <= s ? 1 : c >= s + 26 ? 26 : c - s));
                  c += h
                )
                  (E = u - d),
                    (x = h - d),
                    S.push(m(b(d + (E % x), 0))),
                    (u = f(E / x));
                S.push(m(b(u, 0))), (s = T(n, v, i == r)), (n = 0), ++i;
              }
            ++n, ++e;
          }
          return S.join("");
        }
        if (
          ((o = {
            version: "1.3.2",
            ucs2: { decode: y, encode: x },
            decode: E,
            encode: S,
            toASCII: function (t) {
              return v(t, function (t) {
                return c.test(t) ? "xn--" + S(t) : t;
              });
            },
            toUnicode: function (t) {
              return v(t, function (t) {
                return u.test(t) ? E(t.slice(4).toLowerCase()) : t;
              });
            },
          }),
          i && r)
        )
          if (t.exports == i) r.exports = o;
          else for (a in o) o.hasOwnProperty(a) && (i[a] = o[a]);
        else n.punycode = o;
      })(KE);
    });
  var $E,
    QE,
    tS,
    eS,
    nS,
    iS,
    rS,
    sS,
    oS,
    aS,
    lS,
    hS,
    uS,
    cS,
    dS,
    pS,
    fS,
    mS,
    _S,
    gS,
    vS = function (t, e, n, i) {
      (e = e || "&"), (n = n || "=");
      var r = {};
      if ("string" != typeof t || 0 === t.length) return r;
      var s = /\+/g;
      t = t.split(e);
      var o = 1e3;
      i && "number" == typeof i.maxKeys && (o = i.maxKeys);
      var a = t.length;
      o > 0 && a > o && (a = o);
      for (var l = 0; l < a; ++l) {
        var h,
          u,
          c,
          d,
          p = t[l].replace(s, "%20"),
          f = p.indexOf(n);
        f >= 0
          ? ((h = p.substr(0, f)), (u = p.substr(f + 1)))
          : ((h = p), (u = "")),
          (c = decodeURIComponent(h)),
          (d = decodeURIComponent(u)),
          JE(r, c)
            ? Array.isArray(r[c])
              ? r[c].push(d)
              : (r[c] = [r[c], d])
            : (r[c] = d);
      }
      return r;
    },
    yS = function (t) {
      switch (typeof t) {
        case "string":
          return t;
        case "boolean":
          return t ? "true" : "false";
        case "number":
          return isFinite(t) ? t : "";
        default:
          return "";
      }
    },
    xS = function (t, e, n, i) {
      return (
        (e = e || "&"),
        (n = n || "="),
        null === t && (t = void 0),
        "object" == typeof t
          ? Object.keys(t)
              .map(function (i) {
                var r = encodeURIComponent(yS(i)) + n;
                return Array.isArray(t[i])
                  ? t[i]
                      .map(function (t) {
                        return r + encodeURIComponent(yS(t));
                      })
                      .join(e)
                  : r + encodeURIComponent(yS(t[i]));
              })
              .join(e)
          : i
          ? encodeURIComponent(yS(i)) + n + encodeURIComponent(yS(t))
          : ""
      );
    };
  ZE(function (t, e) {
    (e.decode = e.parse = vS), (e.encode = e.stringify = xS);
  }),
    (function (t) {
      (t[(t.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.WEBGL2 = 2)] = "WEBGL2");
    })($E || ($E = {})),
    (function (t) {
      (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
        (t[(t.WEBGL = 1)] = "WEBGL"),
        (t[(t.CANVAS = 2)] = "CANVAS");
    })(QE || (QE = {})),
    (function (t) {
      (t[(t.COLOR = 16384)] = "COLOR"),
        (t[(t.DEPTH = 256)] = "DEPTH"),
        (t[(t.STENCIL = 1024)] = "STENCIL");
    })(tS || (tS = {})),
    (function (t) {
      (t[(t.NORMAL = 0)] = "NORMAL"),
        (t[(t.ADD = 1)] = "ADD"),
        (t[(t.MULTIPLY = 2)] = "MULTIPLY"),
        (t[(t.SCREEN = 3)] = "SCREEN"),
        (t[(t.OVERLAY = 4)] = "OVERLAY"),
        (t[(t.DARKEN = 5)] = "DARKEN"),
        (t[(t.LIGHTEN = 6)] = "LIGHTEN"),
        (t[(t.COLOR_DODGE = 7)] = "COLOR_DODGE"),
        (t[(t.COLOR_BURN = 8)] = "COLOR_BURN"),
        (t[(t.HARD_LIGHT = 9)] = "HARD_LIGHT"),
        (t[(t.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
        (t[(t.DIFFERENCE = 11)] = "DIFFERENCE"),
        (t[(t.EXCLUSION = 12)] = "EXCLUSION"),
        (t[(t.HUE = 13)] = "HUE"),
        (t[(t.SATURATION = 14)] = "SATURATION"),
        (t[(t.COLOR = 15)] = "COLOR"),
        (t[(t.LUMINOSITY = 16)] = "LUMINOSITY"),
        (t[(t.NORMAL_NPM = 17)] = "NORMAL_NPM"),
        (t[(t.ADD_NPM = 18)] = "ADD_NPM"),
        (t[(t.SCREEN_NPM = 19)] = "SCREEN_NPM"),
        (t[(t.NONE = 20)] = "NONE"),
        (t[(t.SRC_OVER = 0)] = "SRC_OVER"),
        (t[(t.SRC_IN = 21)] = "SRC_IN"),
        (t[(t.SRC_OUT = 22)] = "SRC_OUT"),
        (t[(t.SRC_ATOP = 23)] = "SRC_ATOP"),
        (t[(t.DST_OVER = 24)] = "DST_OVER"),
        (t[(t.DST_IN = 25)] = "DST_IN"),
        (t[(t.DST_OUT = 26)] = "DST_OUT"),
        (t[(t.DST_ATOP = 27)] = "DST_ATOP"),
        (t[(t.ERASE = 26)] = "ERASE"),
        (t[(t.SUBTRACT = 28)] = "SUBTRACT"),
        (t[(t.XOR = 29)] = "XOR");
    })(eS || (eS = {})),
    (function (t) {
      (t[(t.POINTS = 0)] = "POINTS"),
        (t[(t.LINES = 1)] = "LINES"),
        (t[(t.LINE_LOOP = 2)] = "LINE_LOOP"),
        (t[(t.LINE_STRIP = 3)] = "LINE_STRIP"),
        (t[(t.TRIANGLES = 4)] = "TRIANGLES"),
        (t[(t.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
        (t[(t.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN");
    })(nS || (nS = {})),
    (function (t) {
      (t[(t.RGBA = 6408)] = "RGBA"),
        (t[(t.RGB = 6407)] = "RGB"),
        (t[(t.RG = 33319)] = "RG"),
        (t[(t.RED = 6403)] = "RED"),
        (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (t[(t.ALPHA = 6406)] = "ALPHA"),
        (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
        (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL");
    })(iS || (iS = {})),
    (function (t) {
      (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
        (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
        (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
          "TEXTURE_CUBE_MAP_POSITIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_X"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
        (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
          "TEXTURE_CUBE_MAP_POSITIVE_Z"),
        (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
          "TEXTURE_CUBE_MAP_NEGATIVE_Z");
    })(rS || (rS = {})),
    (function (t) {
      (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
        (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
        (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
        (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
        (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
        (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
        (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
          "UNSIGNED_INT_10F_11F_11F_REV"),
        (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
          "UNSIGNED_INT_2_10_10_10_REV"),
        (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
        (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
        (t[(t.BYTE = 5120)] = "BYTE"),
        (t[(t.SHORT = 5122)] = "SHORT"),
        (t[(t.INT = 5124)] = "INT"),
        (t[(t.FLOAT = 5126)] = "FLOAT"),
        (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
          "FLOAT_32_UNSIGNED_INT_24_8_REV"),
        (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT");
    })(sS || (sS = {})),
    (function (t) {
      (t[(t.FLOAT = 0)] = "FLOAT"),
        (t[(t.INT = 1)] = "INT"),
        (t[(t.UINT = 2)] = "UINT");
    })(oS || (oS = {})),
    (function (t) {
      (t[(t.NEAREST = 0)] = "NEAREST"), (t[(t.LINEAR = 1)] = "LINEAR");
    })(aS || (aS = {})),
    (function (t) {
      (t[(t.CLAMP = 33071)] = "CLAMP"),
        (t[(t.REPEAT = 10497)] = "REPEAT"),
        (t[(t.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT");
    })(lS || (lS = {})),
    (function (t) {
      (t[(t.OFF = 0)] = "OFF"),
        (t[(t.POW2 = 1)] = "POW2"),
        (t[(t.ON = 2)] = "ON"),
        (t[(t.ON_MANUAL = 3)] = "ON_MANUAL");
    })(hS || (hS = {})),
    (function (t) {
      (t[(t.NPM = 0)] = "NPM"),
        (t[(t.UNPACK = 1)] = "UNPACK"),
        (t[(t.PMA = 2)] = "PMA"),
        (t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
        (t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
        (t[(t.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
        (t[(t.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA");
    })(uS || (uS = {})),
    (function (t) {
      (t[(t.NO = 0)] = "NO"),
        (t[(t.YES = 1)] = "YES"),
        (t[(t.AUTO = 2)] = "AUTO"),
        (t[(t.BLEND = 0)] = "BLEND"),
        (t[(t.CLEAR = 1)] = "CLEAR"),
        (t[(t.BLIT = 2)] = "BLIT");
    })(cS || (cS = {})),
    (function (t) {
      (t[(t.AUTO = 0)] = "AUTO"), (t[(t.MANUAL = 1)] = "MANUAL");
    })(dS || (dS = {})),
    (function (t) {
      (t.LOW = "lowp"), (t.MEDIUM = "mediump"), (t.HIGH = "highp");
    })(pS || (pS = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.SCISSOR = 1)] = "SCISSOR"),
        (t[(t.STENCIL = 2)] = "STENCIL"),
        (t[(t.SPRITE = 3)] = "SPRITE"),
        (t[(t.COLOR = 4)] = "COLOR");
    })(fS || (fS = {})),
    (function (t) {
      (t[(t.RED = 1)] = "RED"),
        (t[(t.GREEN = 2)] = "GREEN"),
        (t[(t.BLUE = 4)] = "BLUE"),
        (t[(t.ALPHA = 8)] = "ALPHA");
    })(mS || (mS = {})),
    (function (t) {
      (t[(t.NONE = 0)] = "NONE"),
        (t[(t.LOW = 2)] = "LOW"),
        (t[(t.MEDIUM = 4)] = "MEDIUM"),
        (t[(t.HIGH = 8)] = "HIGH");
    })(_S || (_S = {})),
    (function (t) {
      (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER");
    })(gS || (gS = {})),
    (qE.RETINA_PREFIX = /@([0-9\.]+)x/),
    (qE.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1),
    (function () {
      for (var t = [], e = [], n = 0; n < 32; n++) (t[n] = n), (e[n] = n);
      (t[eS.NORMAL_NPM] = eS.NORMAL),
        (t[eS.ADD_NPM] = eS.ADD),
        (t[eS.SCREEN_NPM] = eS.SCREEN),
        (e[eS.NORMAL] = eS.NORMAL_NPM),
        (e[eS.ADD] = eS.ADD_NPM),
        (e[eS.SCREEN] = eS.SCREEN_NPM);
      var i = [];
      i.push(e), i.push(t);
    })();
  var bS = {};
  !(function () {
    function t(t, e, n) {
      (this.canvas = qE.ADAPTER.createCanvas()),
        (this.context = this.canvas.getContext("2d")),
        (this.resolution = n || qE.RESOLUTION),
        this.resize(t, e);
    }
    (t.prototype.clear = function () {
      this.context.setTransform(1, 0, 0, 1, 0, 0),
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }),
      (t.prototype.resize = function (t, e) {
        (this.canvas.width = Math.round(t * this.resolution)),
          (this.canvas.height = Math.round(e * this.resolution));
      }),
      (t.prototype.destroy = function () {
        (this.context = null), (this.canvas = null);
      }),
      Object.defineProperty(t.prototype, "width", {
        get: function () {
          return this.canvas.width;
        },
        set: function (t) {
          this.canvas.width = Math.round(t);
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "height", {
        get: function () {
          return this.canvas.height;
        },
        set: function (t) {
          this.canvas.height = Math.round(t);
        },
        enumerable: !1,
        configurable: !0,
      });
  })();
  var TS = (function () {
    function t(e) {
      var n = this;
      (this.stage = new y_()),
        (e = Object.assign({ forceCanvas: !1 }, e)),
        (this.renderer = (function (t) {
          return Ov.create(t);
        })(e)),
        t._plugins.forEach(function (t) {
          t.init.call(n, e);
        });
    }
    return (
      (t.registerPlugin = function (t) {
        !(function (t, e, n) {
          if ((void 0 === n && (n = 3), !bS[e])) {
            var i = new Error().stack;
            void 0 === i
              ? console.warn(
                  "PixiJS Deprecation Warning: ",
                  e + "\nDeprecated since v" + t
                )
              : ((i = i.split("\n").splice(n).join("\n")),
                console.groupCollapsed
                  ? (console.groupCollapsed(
                      "%cPixiJS Deprecation Warning: %c%s",
                      "color:#614108;background:#fffbe6",
                      "font-weight:normal;color:#614108;background:#fffbe6",
                      e + "\nDeprecated since v" + t
                    ),
                    console.warn(i),
                    console.groupEnd())
                  : (console.warn(
                      "PixiJS Deprecation Warning: ",
                      e + "\nDeprecated since v" + t
                    ),
                    console.warn(i))),
              (bS[e] = !0);
          }
        })(
          "6.5.0",
          "Application.registerPlugin() is deprecated, use extensions.add()"
        ),
          M_.add({ type: x_.Application, ref: t });
      }),
      (t.prototype.render = function () {
        this.renderer.render(this.stage);
      }),
      Object.defineProperty(t.prototype, "view", {
        get: function () {
          return this.renderer.view;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "screen", {
        get: function () {
          return this.renderer.screen;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype.destroy = function (e, n) {
        var i = this,
          r = t._plugins.slice(0);
        r.reverse(),
          r.forEach(function (t) {
            t.destroy.call(i);
          }),
          this.stage.destroy(n),
          (this.stage = null),
          this.renderer.destroy(e),
          (this.renderer = null);
      }),
      (t._plugins = []),
      t
    );
  })();
  M_.handleByList(x_.Application, TS._plugins), M_.add(CE);
  var ES = function (t, e) {
    return (ES =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  function SS(t, e) {
    function n() {
      this.constructor = t;
    }
    ES(t, e),
      (t.prototype =
        null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()));
  }
  var wS = (function (t) {
      function e(e, n, i, r) {
        void 0 === e && (e = 100),
          void 0 === n && (n = 100),
          void 0 === i && (i = 10),
          void 0 === r && (r = 10);
        var s = t.call(this) || this;
        return (
          (s.segWidth = i),
          (s.segHeight = r),
          (s.width = e),
          (s.height = n),
          s.build(),
          s
        );
      }
      return (
        SS(e, t),
        (e.prototype.build = function () {
          for (
            var t = this.segWidth * this.segHeight,
              e = [],
              n = [],
              i = [],
              r = this.segWidth - 1,
              s = this.segHeight - 1,
              o = this.width / r,
              a = this.height / s,
              l = 0;
            l < t;
            l++
          ) {
            var h = l % this.segWidth,
              u = (l / this.segWidth) | 0;
            e.push(h * o, u * a), n.push(h / r, u / s);
          }
          var c = r * s;
          for (l = 0; l < c; l++) {
            var d = l % r,
              p = (l / r) | 0,
              f = p * this.segWidth + d,
              m = p * this.segWidth + d + 1,
              _ = (p + 1) * this.segWidth + d,
              g = (p + 1) * this.segWidth + d + 1;
            i.push(f, m, _, m, g, _);
          }
          (this.buffers[0].data = new Float32Array(e)),
            (this.buffers[1].data = new Float32Array(n)),
            (this.indexBuffer.data = new Uint16Array(i)),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update();
        }),
        e
      );
    })(qb),
    MS = (function (t) {
      function e(e, n, i) {
        void 0 === e && (e = 200), void 0 === i && (i = 0);
        var r =
          t.call(
            this,
            new Float32Array(4 * n.length),
            new Float32Array(4 * n.length),
            new Uint16Array(6 * (n.length - 1))
          ) || this;
        return (
          (r.points = n), (r._width = e), (r.textureScale = i), r.build(), r
        );
      }
      return (
        SS(e, t),
        Object.defineProperty(e.prototype, "width", {
          get: function () {
            return this._width;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (e.prototype.build = function () {
          var t = this.points;
          if (t) {
            var e = this.getBuffer("aVertexPosition"),
              n = this.getBuffer("aTextureCoord"),
              i = this.getIndex();
            if (!(t.length < 1)) {
              e.data.length / 4 !== t.length &&
                ((e.data = new Float32Array(4 * t.length)),
                (n.data = new Float32Array(4 * t.length)),
                (i.data = new Uint16Array(6 * (t.length - 1))));
              var r = n.data,
                s = i.data;
              (r[0] = 0), (r[1] = 0), (r[2] = 0), (r[3] = 1);
              for (
                var o = 0,
                  a = t[0],
                  l = this._width * this.textureScale,
                  h = t.length,
                  u = 0;
                u < h;
                u++
              ) {
                var c = 4 * u;
                if (this.textureScale > 0) {
                  var d = a.x - t[u].x,
                    p = a.y - t[u].y,
                    f = Math.sqrt(d * d + p * p);
                  (a = t[u]), (o += f / l);
                } else o = u / (h - 1);
                (r[c] = o), (r[c + 1] = 0), (r[c + 2] = o), (r[c + 3] = 1);
              }
              var m = 0;
              for (u = 0; u < h - 1; u++) {
                c = 2 * u;
                (s[m++] = c),
                  (s[m++] = c + 1),
                  (s[m++] = c + 2),
                  (s[m++] = c + 2),
                  (s[m++] = c + 1),
                  (s[m++] = c + 3);
              }
              n.update(), i.update(), this.updateVertices();
            }
          }
        }),
        (e.prototype.updateVertices = function () {
          var t = this.points;
          if (!(t.length < 1)) {
            for (
              var e,
                n = t[0],
                i = 0,
                r = 0,
                s = this.buffers[0].data,
                o = t.length,
                a = 0;
              a < o;
              a++
            ) {
              var l = t[a],
                h = 4 * a;
              (r = -((e = a < t.length - 1 ? t[a + 1] : l).x - n.x)),
                (i = e.y - n.y);
              var u = Math.sqrt(i * i + r * r),
                c =
                  this.textureScale > 0
                    ? (this.textureScale * this._width) / 2
                    : this._width / 2;
              (i /= u),
                (r /= u),
                (i *= c),
                (r *= c),
                (s[h] = l.x + i),
                (s[h + 1] = l.y + r),
                (s[h + 2] = l.x - i),
                (s[h + 3] = l.y - r),
                (n = l);
            }
            this.buffers[0].update();
          }
        }),
        (e.prototype.update = function () {
          this.textureScale > 0 ? this.build() : this.updateVertices();
        }),
        e
      );
    })(qb);
  !(function (t) {
    function e(e, n, i) {
      void 0 === i && (i = 0);
      var r = this,
        s = new MS(e.height, n, i),
        o = new Yb(e);
      return (
        i > 0 && (e.baseTexture.wrapMode = Af.REPEAT),
        ((r = t.call(this, s, o) || this).autoUpdate = !0),
        r
      );
    }
    SS(e, t),
      (e.prototype._render = function (e) {
        var n = this.geometry;
        (this.autoUpdate || n._width !== this.shader.texture.height) &&
          ((n._width = this.shader.texture.height), n.update()),
          t.prototype._render.call(this, e);
      });
  })(jb);
  var AS = (function (t) {
    function e(e, n, i) {
      var r = this,
        s = new wS(e.width, e.height, n, i),
        o = new Yb(eg.WHITE);
      return (
        ((r = t.call(this, s, o) || this).texture = e), (r.autoResize = !0), r
      );
    }
    return (
      SS(e, t),
      (e.prototype.textureUpdated = function () {
        this._textureID = this.shader.texture._updateID;
        var t = this.geometry,
          e = this.shader.texture,
          n = e.width,
          i = e.height;
        !this.autoResize ||
          (t.width === n && t.height === i) ||
          ((t.width = this.shader.texture.width),
          (t.height = this.shader.texture.height),
          t.build());
      }),
      Object.defineProperty(e.prototype, "texture", {
        get: function () {
          return this.shader.texture;
        },
        set: function (t) {
          this.shader.texture !== t &&
            ((this.shader.texture = t),
            (this._textureID = -1),
            t.baseTexture.valid
              ? this.textureUpdated()
              : t.once("update", this.textureUpdated, this));
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._render = function (e) {
        this._textureID !== this.shader.texture._updateID &&
          this.textureUpdated(),
          t.prototype._render.call(this, e);
      }),
      (e.prototype.destroy = function (e) {
        this.shader.texture.off("update", this.textureUpdated, this),
          t.prototype.destroy.call(this, e);
      }),
      e
    );
  })(jb);
  !(function (t) {
    function e(e, n, i, r, s) {
      void 0 === e && (e = eg.EMPTY);
      var o = this,
        a = new qb(n, i, r);
      a.getBuffer("aVertexPosition").static = !1;
      var l = new Yb(e);
      return ((o = t.call(this, a, l, null, s) || this).autoUpdate = !0), o;
    }
    SS(e, t),
      Object.defineProperty(e.prototype, "vertices", {
        get: function () {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function (t) {
          this.geometry.getBuffer("aVertexPosition").data = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._render = function (e) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
          t.prototype._render.call(this, e);
      });
  })(jb);
  !(function (t) {
    function e(e, n, i, r, s) {
      void 0 === n && (n = 10),
        void 0 === i && (i = 10),
        void 0 === r && (r = 10),
        void 0 === s && (s = 10);
      var o = t.call(this, eg.WHITE, 4, 4) || this;
      return (
        (o._origWidth = e.orig.width),
        (o._origHeight = e.orig.height),
        (o._width = o._origWidth),
        (o._height = o._origHeight),
        (o._leftWidth = n),
        (o._rightWidth = r),
        (o._topHeight = i),
        (o._bottomHeight = s),
        (o.texture = e),
        o
      );
    }
    SS(e, t),
      (e.prototype.textureUpdated = function () {
        (this._textureID = this.shader.texture._updateID), this._refresh();
      }),
      Object.defineProperty(e.prototype, "vertices", {
        get: function () {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function (t) {
          this.geometry.getBuffer("aVertexPosition").data = t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.updateHorizontalVertices = function () {
        var t = this.vertices,
          e = this._getMinScale();
        (t[9] = t[11] = t[13] = t[15] = this._topHeight * e),
          (t[17] =
            t[19] =
            t[21] =
            t[23] =
              this._height - this._bottomHeight * e),
          (t[25] = t[27] = t[29] = t[31] = this._height);
      }),
      (e.prototype.updateVerticalVertices = function () {
        var t = this.vertices,
          e = this._getMinScale();
        (t[2] = t[10] = t[18] = t[26] = this._leftWidth * e),
          (t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e),
          (t[6] = t[14] = t[22] = t[30] = this._width);
      }),
      (e.prototype._getMinScale = function () {
        var t = this._leftWidth + this._rightWidth,
          e = this._width > t ? 1 : this._width / t,
          n = this._topHeight + this._bottomHeight,
          i = this._height > n ? 1 : this._height / n;
        return Math.min(e, i);
      }),
      Object.defineProperty(e.prototype, "width", {
        get: function () {
          return this._width;
        },
        set: function (t) {
          (this._width = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "height", {
        get: function () {
          return this._height;
        },
        set: function (t) {
          (this._height = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "leftWidth", {
        get: function () {
          return this._leftWidth;
        },
        set: function (t) {
          (this._leftWidth = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "rightWidth", {
        get: function () {
          return this._rightWidth;
        },
        set: function (t) {
          (this._rightWidth = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "topHeight", {
        get: function () {
          return this._topHeight;
        },
        set: function (t) {
          (this._topHeight = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "bottomHeight", {
        get: function () {
          return this._bottomHeight;
        },
        set: function (t) {
          (this._bottomHeight = t), this._refresh();
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype._refresh = function () {
        var t = this.texture,
          e = this.geometry.buffers[1].data;
        (this._origWidth = t.orig.width), (this._origHeight = t.orig.height);
        var n = 1 / this._origWidth,
          i = 1 / this._origHeight;
        (e[0] = e[8] = e[16] = e[24] = 0),
          (e[1] = e[3] = e[5] = e[7] = 0),
          (e[6] = e[14] = e[22] = e[30] = 1),
          (e[25] = e[27] = e[29] = e[31] = 1),
          (e[2] = e[10] = e[18] = e[26] = n * this._leftWidth),
          (e[4] = e[12] = e[20] = e[28] = 1 - n * this._rightWidth),
          (e[9] = e[11] = e[13] = e[15] = i * this._topHeight),
          (e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight),
          this.updateHorizontalVertices(),
          this.updateVerticalVertices(),
          this.geometry.buffers[0].update(),
          this.geometry.buffers[1].update();
      });
  })(AS);
  var RS = function (t, e) {
    return (RS =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, e) {
          t.__proto__ = e;
        }) ||
      function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      })(t, e);
  };
  !(function (t) {
    function e(e, n) {
      void 0 === n && (n = !0);
      var i = t.call(this, e[0] instanceof eg ? e[0] : e[0].texture) || this;
      return (
        (i._textures = null),
        (i._durations = null),
        (i._autoUpdate = n),
        (i._isConnectedToTicker = !1),
        (i.animationSpeed = 1),
        (i.loop = !0),
        (i.updateAnchor = !1),
        (i.onComplete = null),
        (i.onFrameChange = null),
        (i.onLoop = null),
        (i._currentTime = 0),
        (i._playing = !1),
        (i._previousFrame = null),
        (i.textures = e),
        i
      );
    }
    (function (t, e) {
      function n() {
        this.constructor = t;
      }
      RS(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    })(e, t),
      (e.prototype.stop = function () {
        this._playing &&
          ((this._playing = !1),
          this._autoUpdate &&
            this._isConnectedToTicker &&
            (C_.shared.remove(this.update, this),
            (this._isConnectedToTicker = !1)));
      }),
      (e.prototype.play = function () {
        this._playing ||
          ((this._playing = !0),
          this._autoUpdate &&
            !this._isConnectedToTicker &&
            (C_.shared.add(this.update, this, E_.HIGH),
            (this._isConnectedToTicker = !0)));
      }),
      (e.prototype.gotoAndStop = function (t) {
        this.stop();
        var e = this.currentFrame;
        (this._currentTime = t),
          e !== this.currentFrame && this.updateTexture();
      }),
      (e.prototype.gotoAndPlay = function (t) {
        var e = this.currentFrame;
        (this._currentTime = t),
          e !== this.currentFrame && this.updateTexture(),
          this.play();
      }),
      (e.prototype.update = function (t) {
        if (this._playing) {
          var e = this.animationSpeed * t,
            n = this.currentFrame;
          if (null !== this._durations) {
            var i =
              (this._currentTime % 1) * this._durations[this.currentFrame];
            for (i += (e / 60) * 1e3; i < 0; )
              this._currentTime--, (i += this._durations[this.currentFrame]);
            var r = Math.sign(this.animationSpeed * t);
            for (
              this._currentTime = Math.floor(this._currentTime);
              i >= this._durations[this.currentFrame];

            )
              (i -= this._durations[this.currentFrame] * r),
                (this._currentTime += r);
            this._currentTime += i / this._durations[this.currentFrame];
          } else this._currentTime += e;
          this._currentTime < 0 && !this.loop
            ? (this.gotoAndStop(0), this.onComplete && this.onComplete())
            : this._currentTime >= this._textures.length && !this.loop
            ? (this.gotoAndStop(this._textures.length - 1),
              this.onComplete && this.onComplete())
            : n !== this.currentFrame &&
              (this.loop &&
                this.onLoop &&
                ((this.animationSpeed > 0 && this.currentFrame < n) ||
                  (this.animationSpeed < 0 && this.currentFrame > n)) &&
                this.onLoop(),
              this.updateTexture());
        }
      }),
      (e.prototype.updateTexture = function () {
        var t = this.currentFrame;
        this._previousFrame !== t &&
          ((this._previousFrame = t),
          (this._texture = this._textures[t]),
          (this._textureID = -1),
          (this._textureTrimmedID = -1),
          (this._cachedTint = 16777215),
          (this.uvs = this._texture._uvs.uvsFloat32),
          this.updateAnchor &&
            this._anchor.copyFrom(this._texture.defaultAnchor),
          this.onFrameChange && this.onFrameChange(this.currentFrame));
      }),
      (e.prototype.destroy = function (e) {
        this.stop(),
          t.prototype.destroy.call(this, e),
          (this.onComplete = null),
          (this.onFrameChange = null),
          (this.onLoop = null);
      }),
      (e.fromFrames = function (t) {
        for (var n = [], i = 0; i < t.length; ++i) n.push(eg.from(t[i]));
        return new e(n);
      }),
      (e.fromImages = function (t) {
        for (var n = [], i = 0; i < t.length; ++i) n.push(eg.from(t[i]));
        return new e(n);
      }),
      Object.defineProperty(e.prototype, "totalFrames", {
        get: function () {
          return this._textures.length;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "textures", {
        get: function () {
          return this._textures;
        },
        set: function (t) {
          if (t[0] instanceof eg)
            (this._textures = t), (this._durations = null);
          else {
            (this._textures = []), (this._durations = []);
            for (var e = 0; e < t.length; e++)
              this._textures.push(t[e].texture),
                this._durations.push(t[e].time);
          }
          (this._previousFrame = null),
            this.gotoAndStop(0),
            this.updateTexture();
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "currentFrame", {
        get: function () {
          var t = Math.floor(this._currentTime) % this._textures.length;
          return t < 0 && (t += this._textures.length), t;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "playing", {
        get: function () {
          return this._playing;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "autoUpdate", {
        get: function () {
          return this._autoUpdate;
        },
        set: function (t) {
          t !== this._autoUpdate &&
            ((this._autoUpdate = t),
            !this._autoUpdate && this._isConnectedToTicker
              ? (C_.shared.remove(this.update, this),
                (this._isConnectedToTicker = !1))
              : this._autoUpdate &&
                !this._isConnectedToTicker &&
                this._playing &&
                (C_.shared.add(this.update, this),
                (this._isConnectedToTicker = !0)));
        },
        enumerable: !1,
        configurable: !0,
      });
  })(hb),
    M_.add(Vv, Qv, Jv, Cx, Ob, zv, Gb, hT, Fy, xx, bx, Db, I_, by);
  const CS = "@firebase/installations",
    IS = "0.5.12",
    PS = 1e4,
    OS = "w:0.5.12",
    NS = "FIS_v2",
    DS = 36e5,
    LS = new Rt("installations", "Installations", {
      "missing-app-config-values":
        'Missing App configuration value: "{$valueName}"',
      "not-registered": "Firebase Installation is not registered.",
      "installation-not-found": "Firebase Installation not found.",
      "request-failed":
        '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
      "app-offline": "Could not process request. Application offline.",
      "delete-pending-registration":
        "Can't delete installation while there is a pending registration request.",
    });
  function FS(t) {
    return t instanceof At && t.code.includes("request-failed");
  }
  function US({ projectId: t }) {
    return `https://firebaseinstallations.googleapis.com/v1/projects/${t}/installations`;
  }
  function BS(t) {
    return {
      token: t.token,
      requestStatus: 2,
      expiresIn: ((e = t.expiresIn), Number(e.replace("s", "000"))),
      creationTime: Date.now(),
    };
    var e;
  }
  async function kS(t, e) {
    const n = (await e.json()).error;
    return LS.create("request-failed", {
      requestName: t,
      serverCode: n.code,
      serverMessage: n.message,
      serverStatus: n.status,
    });
  }
  function GS({ apiKey: t }) {
    return new Headers({
      "Content-Type": "application/json",
      Accept: "application/json",
      "x-goog-api-key": t,
    });
  }
  function HS(t, { refreshToken: e }) {
    const n = GS(t);
    return (
      n.append(
        "Authorization",
        (function (t) {
          return `FIS_v2 ${t}`;
        })(e)
      ),
      n
    );
  }
  async function zS(t) {
    const e = await t();
    return e.status >= 500 && e.status < 600 ? t() : e;
  }
  function VS(t) {
    return new Promise((e) => {
      setTimeout(e, t);
    });
  }
  const XS = /^[cdef][\w-]{21}$/;
  function WS() {
    try {
      const t = new Uint8Array(17);
      (self.crypto || self.msCrypto).getRandomValues(t),
        (t[0] = 112 + (t[0] % 16));
      const e = (function (t) {
        return ((e = t),
        btoa(String.fromCharCode(...e))
          .replace(/\+/g, "-")
          .replace(/\//g, "_")).substr(0, 22);
        var e;
      })(t);
      return XS.test(e) ? e : "";
    } catch (t) {
      return "";
    }
  }
  function jS(t) {
    return `${t.appName}!${t.appId}`;
  }
  const YS = new Map();
  function qS(t, e) {
    const n = jS(t);
    KS(n, e),
      (function (t, e) {
        const n = (function () {
          !ZS &&
            "BroadcastChannel" in self &&
            ((ZS = new BroadcastChannel("[Firebase] FID Change")),
            (ZS.onmessage = (t) => {
              KS(t.data.key, t.data.fid);
            }));
          return ZS;
        })();
        n && n.postMessage({ key: t, fid: e });
        0 === YS.size && ZS && (ZS.close(), (ZS = null));
      })(n, e);
  }
  function KS(t, e) {
    const n = YS.get(t);
    if (n) for (const i of n) i(e);
  }
  let ZS = null;
  const JS = "firebase-installations-store";
  let $S = null;
  function QS() {
    return (
      $S ||
        ($S = pe("firebase-installations-database", 1, {
          upgrade: (t, e) => {
            if (0 === e) t.createObjectStore(JS);
          },
        })),
      $S
    );
  }
  async function tw(t, e) {
    const n = jS(t),
      i = (await QS()).transaction(JS, "readwrite"),
      r = i.objectStore(JS),
      s = await r.get(n);
    return (
      await r.put(e, n), await i.done, (s && s.fid === e.fid) || qS(t, e.fid), e
    );
  }
  async function ew(t) {
    const e = jS(t),
      n = (await QS()).transaction(JS, "readwrite");
    await n.objectStore(JS).delete(e), await n.done;
  }
  async function nw(t, e) {
    const n = jS(t),
      i = (await QS()).transaction(JS, "readwrite"),
      r = i.objectStore(JS),
      s = await r.get(n),
      o = e(s);
    return (
      void 0 === o ? await r.delete(n) : await r.put(o, n),
      await i.done,
      !o || (s && s.fid === o.fid) || qS(t, o.fid),
      o
    );
  }
  async function iw(t) {
    let e;
    const n = await nw(t.appConfig, (n) => {
      const i = (function (t) {
          return ow(t || { fid: WS(), registrationStatus: 0 });
        })(n),
        r = (function (t, e) {
          if (0 === e.registrationStatus) {
            if (!navigator.onLine) {
              return {
                installationEntry: e,
                registrationPromise: Promise.reject(LS.create("app-offline")),
              };
            }
            const n = {
                fid: e.fid,
                registrationStatus: 1,
                registrationTime: Date.now(),
              },
              i = (async function (t, e) {
                try {
                  const n = await (async function (
                    { appConfig: t, heartbeatServiceProvider: e },
                    { fid: n }
                  ) {
                    const i = US(t),
                      r = GS(t),
                      s = e.getImmediate({ optional: !0 });
                    if (s) {
                      const t = await s.getHeartbeatsHeader();
                      t && r.append("x-firebase-client", t);
                    }
                    const o = {
                        fid: n,
                        authVersion: NS,
                        appId: t.appId,
                        sdkVersion: OS,
                      },
                      a = {
                        method: "POST",
                        headers: r,
                        body: JSON.stringify(o),
                      },
                      l = await zS(() => fetch(i, a));
                    if (l.ok) {
                      const t = await l.json();
                      return {
                        fid: t.fid || n,
                        registrationStatus: 2,
                        refreshToken: t.refreshToken,
                        authToken: BS(t.authToken),
                      };
                    }
                    throw await kS("Create Installation", l);
                  })(t, e);
                  return tw(t.appConfig, n);
                } catch (n) {
                  throw (
                    (FS(n) && 409 === n.customData.serverCode
                      ? await ew(t.appConfig)
                      : await tw(t.appConfig, {
                          fid: e.fid,
                          registrationStatus: 0,
                        }),
                    n)
                  );
                }
              })(t, n);
            return { installationEntry: n, registrationPromise: i };
          }
          return 1 === e.registrationStatus
            ? { installationEntry: e, registrationPromise: rw(t) }
            : { installationEntry: e };
        })(t, i);
      return (e = r.registrationPromise), r.installationEntry;
    });
    return "" === n.fid
      ? { installationEntry: await e }
      : { installationEntry: n, registrationPromise: e };
  }
  async function rw(t) {
    let e = await sw(t.appConfig);
    for (; 1 === e.registrationStatus; )
      await VS(100), (e = await sw(t.appConfig));
    if (0 === e.registrationStatus) {
      const { installationEntry: e, registrationPromise: n } = await iw(t);
      return n || e;
    }
    return e;
  }
  function sw(t) {
    return nw(t, (t) => {
      if (!t) throw LS.create("installation-not-found");
      return ow(t);
    });
  }
  function ow(t) {
    return 1 === (e = t).registrationStatus &&
      e.registrationTime + PS < Date.now()
      ? { fid: t.fid, registrationStatus: 0 }
      : t;
    var e;
  }
  async function aw({ appConfig: t, heartbeatServiceProvider: e }, n) {
    const i = (function (t, { fid: e }) {
        return `${US(t)}/${e}/authTokens:generate`;
      })(t, n),
      r = HS(t, n),
      s = e.getImmediate({ optional: !0 });
    if (s) {
      const t = await s.getHeartbeatsHeader();
      t && r.append("x-firebase-client", t);
    }
    const o = { installation: { sdkVersion: OS, appId: t.appId } },
      a = { method: "POST", headers: r, body: JSON.stringify(o) },
      l = await zS(() => fetch(i, a));
    if (l.ok) {
      return BS(await l.json());
    }
    throw await kS("Generate Auth Token", l);
  }
  async function lw(t, e = !1) {
    let n;
    const i = await nw(t.appConfig, (i) => {
      if (!uw(i)) throw LS.create("not-registered");
      const r = i.authToken;
      if (
        !e &&
        (function (t) {
          return (
            2 === t.requestStatus &&
            !(function (t) {
              const e = Date.now();
              return (
                e < t.creationTime || t.creationTime + t.expiresIn < e + DS
              );
            })(t)
          );
        })(r)
      )
        return i;
      if (1 === r.requestStatus)
        return (
          (n = (async function (t, e) {
            let n = await hw(t.appConfig);
            for (; 1 === n.authToken.requestStatus; )
              await VS(100), (n = await hw(t.appConfig));
            const i = n.authToken;
            return 0 === i.requestStatus ? lw(t, e) : i;
          })(t, e)),
          i
        );
      {
        if (!navigator.onLine) throw LS.create("app-offline");
        const e = (function (t) {
          const e = { requestStatus: 1, requestTime: Date.now() };
          return Object.assign(Object.assign({}, t), { authToken: e });
        })(i);
        return (
          (n = (async function (t, e) {
            try {
              const n = await aw(t, e),
                i = Object.assign(Object.assign({}, e), { authToken: n });
              return await tw(t.appConfig, i), n;
            } catch (n) {
              if (
                !FS(n) ||
                (401 !== n.customData.serverCode &&
                  404 !== n.customData.serverCode)
              ) {
                const n = Object.assign(Object.assign({}, e), {
                  authToken: { requestStatus: 0 },
                });
                await tw(t.appConfig, n);
              } else await ew(t.appConfig);
              throw n;
            }
          })(t, e)),
          e
        );
      }
    });
    return n ? await n : i.authToken;
  }
  function hw(t) {
    return nw(t, (t) => {
      if (!uw(t)) throw LS.create("not-registered");
      const e = t.authToken;
      return 1 === (n = e).requestStatus && n.requestTime + PS < Date.now()
        ? Object.assign(Object.assign({}, t), {
            authToken: { requestStatus: 0 },
          })
        : t;
      var n;
    });
  }
  function uw(t) {
    return void 0 !== t && 2 === t.registrationStatus;
  }
  async function cw(t, e = !1) {
    const n = t;
    await (async function (t) {
      const { registrationPromise: e } = await iw(t);
      e && (await e);
    })(n);
    return (await lw(n, e)).token;
  }
  function dw(t) {
    return LS.create("missing-app-config-values", { valueName: t });
  }
  const pw = "installations",
    fw = (t) => {
      const e = Re(t.getProvider("app").getImmediate(), pw).getImmediate();
      return {
        getId: () =>
          (async function (t) {
            const e = t,
              { installationEntry: n, registrationPromise: i } = await iw(e);
            return (
              i ? i.catch(console.error) : lw(e).catch(console.error), n.fid
            );
          })(e),
        getToken: (t) => cw(e, t),
      };
    };
  Ae(
    new Xt(
      pw,
      (t) => {
        const e = t.getProvider("app").getImmediate(),
          n = (function (t) {
            if (!t || !t.options) throw dw("App Configuration");
            if (!t.name) throw dw("App Name");
            const e = ["projectId", "apiKey", "appId"];
            for (const n of e) if (!t.options[n]) throw dw(n);
            return {
              appName: t.name,
              projectId: t.options.projectId,
              apiKey: t.options.apiKey,
              appId: t.options.appId,
            };
          })(e);
        return {
          app: e,
          appConfig: n,
          heartbeatServiceProvider: Re(e, "heartbeat"),
          _delete: () => Promise.resolve(),
        };
      },
      "PUBLIC"
    )
  ),
    Ae(new Xt("installations-internal", fw, "PRIVATE")),
    Oe(CS, IS),
    Oe(CS, IS, "esm2017");
  const mw = "analytics",
    _w = "https://www.googletagmanager.com/gtag/js",
    gw = new te("@firebase/analytics");
  function vw(t) {
    return Promise.all(t.map((t) => t.catch((t) => t)));
  }
  function yw(t, e, n, i) {
    return async function (r, s, o) {
      try {
        "event" === r
          ? await (async function (t, e, n, i, r) {
              try {
                let s = [];
                if (r && r.send_to) {
                  let t = r.send_to;
                  Array.isArray(t) || (t = [t]);
                  const i = await vw(n);
                  for (const n of t) {
                    const t = i.find((t) => t.measurementId === n),
                      r = t && e[t.appId];
                    if (!r) {
                      s = [];
                      break;
                    }
                    s.push(r);
                  }
                }
                0 === s.length && (s = Object.values(e)),
                  await Promise.all(s),
                  t("event", i, r || {});
              } catch (s) {
                gw.error(s);
              }
            })(t, e, n, s, o)
          : "config" === r
          ? await (async function (t, e, n, i, r, s) {
              const o = i[r];
              try {
                if (o) await e[o];
                else {
                  const t = (await vw(n)).find((t) => t.measurementId === r);
                  t && (await e[t.appId]);
                }
              } catch (a) {
                gw.error(a);
              }
              t("config", r, s);
            })(t, e, n, i, s, o)
          : "consent" === r
          ? t("consent", "update", o)
          : t("set", s);
      } catch (a) {
        gw.error(a);
      }
    };
  }
  const xw = new Rt("analytics", "Analytics", {
    "already-exists":
      "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
    "already-initialized":
      "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
    "already-initialized-settings":
      "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
    "interop-component-reg-failed":
      "Firebase Analytics Interop Component failed to instantiate: {$reason}",
    "invalid-analytics-context":
      "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
    "indexeddb-unavailable":
      "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
    "fetch-throttle":
      "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
    "config-fetch-failed":
      "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
    "no-api-key":
      'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
    "no-app-id":
      'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
  });
  const bw = new (class {
    constructor(t = {}, e = 1e3) {
      (this.throttleMetadata = t), (this.intervalMillis = e);
    }
    getThrottleMetadata(t) {
      return this.throttleMetadata[t];
    }
    setThrottleMetadata(t, e) {
      this.throttleMetadata[t] = e;
    }
    deleteThrottleMetadata(t) {
      delete this.throttleMetadata[t];
    }
  })();
  function Tw(t) {
    return new Headers({ Accept: "application/json", "x-goog-api-key": t });
  }
  async function Ew(t, e = bw, n) {
    const { appId: i, apiKey: r, measurementId: s } = t.options;
    if (!i) throw xw.create("no-app-id");
    if (!r) {
      if (s) return { measurementId: s, appId: i };
      throw xw.create("no-api-key");
    }
    const o = e.getThrottleMetadata(i) || {
        backoffCount: 0,
        throttleEndTimeMillis: Date.now(),
      },
      a = new ww();
    return (
      setTimeout(
        async () => {
          a.abort();
        },
        void 0 !== n ? n : 6e4
      ),
      Sw({ appId: i, apiKey: r, measurementId: s }, o, a, e)
    );
  }
  async function Sw(
    t,
    { throttleEndTimeMillis: e, backoffCount: n },
    i,
    r = bw
  ) {
    var s, o;
    const { appId: a, measurementId: l } = t;
    try {
      await (function (t, e) {
        return new Promise((n, i) => {
          const r = Math.max(e - Date.now(), 0),
            s = setTimeout(n, r);
          t.addEventListener(() => {
            clearTimeout(s),
              i(xw.create("fetch-throttle", { throttleEndTimeMillis: e }));
          });
        });
      })(i, e);
    } catch (h) {
      if (l)
        return (
          gw.warn(
            `Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${l} provided in the "measurementId" field in the local Firebase config. [${
              null === (s = h) || void 0 === s ? void 0 : s.message
            }]`
          ),
          { appId: a, measurementId: l }
        );
      throw h;
    }
    try {
      const e = await (async function (t) {
        var e;
        const { appId: n, apiKey: i } = t,
          r = { method: "GET", headers: Tw(i) },
          s =
            "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig".replace(
              "{app-id}",
              n
            ),
          o = await fetch(s, r);
        if (200 !== o.status && 304 !== o.status) {
          let t = "";
          try {
            const n = await o.json();
            (null === (e = n.error) || void 0 === e ? void 0 : e.message) &&
              (t = n.error.message);
          } catch (a) {}
          throw xw.create("config-fetch-failed", {
            httpStatus: o.status,
            responseMessage: t,
          });
        }
        return o.json();
      })(t);
      return r.deleteThrottleMetadata(a), e;
    } catch (h) {
      const e = h;
      if (
        !(function (t) {
          if (!(t instanceof At && t.customData)) return !1;
          const e = Number(t.customData.httpStatus);
          return 429 === e || 500 === e || 503 === e || 504 === e;
        })(e)
      ) {
        if ((r.deleteThrottleMetadata(a), l))
          return (
            gw.warn(
              `Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${l} provided in the "measurementId" field in the local Firebase config. [${
                null == e ? void 0 : e.message
              }]`
            ),
            { appId: a, measurementId: l }
          );
        throw h;
      }
      const s =
          503 ===
          Number(
            null === (o = null == e ? void 0 : e.customData) || void 0 === o
              ? void 0
              : o.httpStatus
          )
            ? zt(n, r.intervalMillis, 30)
            : zt(n, r.intervalMillis),
        u = { throttleEndTimeMillis: Date.now() + s, backoffCount: n + 1 };
      return (
        r.setThrottleMetadata(a, u),
        gw.debug(`Calling attemptFetch again in ${s} millis`),
        Sw(t, u, i, r)
      );
    }
  }
  class ww {
    constructor() {
      this.listeners = [];
    }
    addEventListener(t) {
      this.listeners.push(t);
    }
    abort() {
      this.listeners.forEach((t) => t());
    }
  }
  async function Mw(t, e, n, i, r, s, o) {
    var a;
    const l = Ew(t);
    l
      .then((e) => {
        (n[e.measurementId] = e.appId),
          t.options.measurementId &&
            e.measurementId !== t.options.measurementId &&
            gw.warn(
              `The measurement ID in the local Firebase config (${t.options.measurementId}) does not match the measurement ID fetched from the server (${e.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`
            );
      })
      .catch((t) => gw.error(t)),
      e.push(l);
    const h = (async function () {
        var t;
        if (!wt())
          return (
            gw.warn(
              xw.create("indexeddb-unavailable", {
                errorInfo: "IndexedDB is not available in this environment.",
              }).message
            ),
            !1
          );
        try {
          await Mt();
        } catch (e) {
          return (
            gw.warn(
              xw.create("indexeddb-unavailable", {
                errorInfo:
                  null === (t = e) || void 0 === t ? void 0 : t.toString(),
              }).message
            ),
            !1
          );
        }
        return !0;
      })().then((t) => (t ? i.getId() : void 0)),
      [u, c] = await Promise.all([l, h]);
    (function () {
      const t = window.document.getElementsByTagName("script");
      for (const e of Object.values(t))
        if (e.src && e.src.includes(_w)) return e;
      return null;
    })() ||
      (function (t, e) {
        const n = document.createElement("script");
        (n.src = `${_w}?l=${t}&id=${e}`),
          (n.async = !0),
          document.head.appendChild(n);
      })(s, u.measurementId),
      r("js", new Date());
    const d =
      null !== (a = null == o ? void 0 : o.config) && void 0 !== a ? a : {};
    return (
      (d.origin = "firebase"),
      (d.update = !0),
      null != c && (d.firebase_id = c),
      r("config", u.measurementId, d),
      u.measurementId
    );
  }
  class Aw {
    constructor(t) {
      this.app = t;
    }
    _delete() {
      return delete Rw[this.app.options.appId], Promise.resolve();
    }
  }
  let Rw = {},
    Cw = [];
  const Iw = {};
  let Pw,
    Ow,
    Nw = "dataLayer",
    Dw = !1;
  function Lw() {
    const t = [];
    if (
      ((function () {
        const t =
          "object" == typeof chrome
            ? chrome.runtime
            : "object" == typeof browser
            ? browser.runtime
            : void 0;
        return "object" == typeof t && void 0 !== t.id;
      })() && t.push("This is a browser extension environment."),
      ("undefined" != typeof navigator && navigator.cookieEnabled) ||
        t.push("Cookies are not available."),
      t.length > 0)
    ) {
      const e = t.map((t, e) => `(${e + 1}) ${t}`).join(" "),
        n = xw.create("invalid-analytics-context", { errorInfo: e });
      gw.warn(n.message);
    }
  }
  function Fw(t, e, n) {
    Lw();
    const i = t.options.appId;
    if (!i) throw xw.create("no-app-id");
    if (!t.options.apiKey) {
      if (!t.options.measurementId) throw xw.create("no-api-key");
      gw.warn(
        `The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${t.options.measurementId} provided in the "measurementId" field in the local Firebase config.`
      );
    }
    if (null != Rw[i]) throw xw.create("already-exists", { id: i });
    if (!Dw) {
      !(function (t) {
        let e = [];
        Array.isArray(window[t]) ? (e = window[t]) : (window[t] = e);
      })(Nw);
      const { wrappedGtag: t, gtagCore: e } = (function (t, e, n, i, r) {
        let s = function (...t) {
          window[i].push(arguments);
        };
        return (
          window[r] && "function" == typeof window[r] && (s = window[r]),
          (window[r] = yw(s, t, e, n)),
          { gtagCore: s, wrappedGtag: window[r] }
        );
      })(Rw, Cw, Iw, Nw, "gtag");
      (Ow = t), (Pw = e), (Dw = !0);
    }
    Rw[i] = Mw(t, Cw, Iw, e, Pw, Nw, n);
    return new Aw(t);
  }
  function Uw(t, e, n, i) {
    (t = Vt(t)),
      (async function (t, e, n, i, r) {
        if (r && r.global) t("event", n, i);
        else {
          const r = await e;
          t("event", n, Object.assign(Object.assign({}, i), { send_to: r }));
        }
      })(Ow, Rw[t.app.options.appId], e, n, i).catch((t) => gw.error(t));
  }
  const Bw = "@firebase/analytics",
    kw = "0.8.0";
  Ae(
    new Xt(
      mw,
      (t, { options: e }) =>
        Fw(
          t.getProvider("app").getImmediate(),
          t.getProvider("installations-internal").getImmediate(),
          e
        ),
      "PUBLIC"
    )
  ),
    Ae(
      new Xt(
        "analytics-internal",
        function (t) {
          try {
            const e = t.getProvider(mw).getImmediate();
            return { logEvent: (t, n, i) => Uw(e, t, n, i) };
          } catch (e) {
            throw xw.create("interop-component-reg-failed", { reason: e });
          }
        },
        "PRIVATE"
      )
    ),
    Oe(Bw, kw),
    Oe(Bw, kw, "esm2017");
  pa(
    Pe({
      apiKey: "AIzaSyA4ejI9WIiV2cM26aj-02dJdUtP5nWKguo",
      authDomain: "design-threads.firebaseapp.com",
      databaseURL: "https://design-threads-default-rtdb.firebaseio.com",
      projectId: "design-threads",
      storageBucket: "design-threads.appspot.com",
      messagingSenderId: "344888432111",
      appId: "1:344888432111:web:7135a68fd29f51874dd21a",
      measurementId: "G-909WJCMPV5",
    })
  );
  const Gw = pa();
  function Hw(t, e, n) {
    return ea($o(Gw, t), { [e]: n });
  }
  function zw(t, e) {
    return (function (t, e) {
      (t = Vt(t)), _o("push", t._path), co("push", e, t._path, !0);
      const n = Mo(t._repo),
        i = Vi(n),
        r = Qo(t, i),
        s = Qo(t, i);
      let o;
      return (
        (o = null != e ? ta(s, e).then(() => s) : Promise.resolve(s)),
        (r.then = o.then.bind(o)),
        (r.catch = o.then.bind(o, void 0)),
        r
      );
    })($o(Gw, t), e);
  }
  function Vw(t, e, n = 500) {
    !(function (t, e, n, i) {
      ra(t, "child_added", e, n, i);
    })(ha($o(Gw, t), la(n)), (t) => {
      const n = t.val();
      e(n);
    });
  }
  function Xw(t, e, n = 100) {
    sa(ha($o(Gw, t), la(n)), (t) => {
      const n = t.val();
      e(n);
    });
  }
  function Ww(t) {
    let e = new ib();
    return (
      t.addChild(e),
      e.position.set(0, 0),
      e.lineStyle(1, 16777215),
      {
        drawLine: function (t, n, i, r) {
          e.moveTo(t, n), e.lineTo(i, r);
        },
      }
    );
  }
  $o(Gw, "table/test");
  let jw = ht();
  var Yw = {};
  Object.defineProperty(Yw, "__esModule", { value: !0 }),
    (Yw.IsMobile = Yw.getFileExtension = qw = Yw.rand = Yw.remap = void 0),
    (Yw.remap = function (t, e, n, i, r) {
      return i + ((r - i) * (t - e)) / (n - e);
    });
  var qw = (Yw.rand = function (t, e) {
    var n;
    if (((n = Math.random()), void 0 === t)) return n;
    if (void 0 === e)
      return t instanceof Array ? t[Math.floor(n * t.length)] : n * t;
    if (t > e) {
      var i = t;
      (t = e), (e = i);
    }
    return n * (e - t) + t;
  });
  (Yw.getFileExtension = function (t) {
    return t.split(".").pop();
  }),
    (Yw.IsMobile = function () {
      return !(
        !/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
          navigator.userAgent
        ) &&
        !/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
          navigator.userAgent.substr(0, 4)
        )
      );
    });
  const Kw = {
    images: [
      { src: "assets/3d/11_Sponge Bob.mp4" },
      { src: "assets/3d/20_Elmo.mp4" },
      { src: "assets/Compressed_Videos/087K43-QEaBUgwsj.mp4" },
      {
        src: "assets/Compressed_Videos/371901180_INSTALIKES_400_AdobeExpress.mp4",
      },
      { src: "assets/Compressed_Videos/697363033-12850.mp4" },
      { src: "assets/Compressed_Videos/89e468471b05a0d3f49b0b14def8879a.mp4" },
      {
        src: "assets/Compressed_Videos/8d3426_3ad53d804a4744c1b9291f608851caec_mv2.mp4",
      },
      {
        src: "assets/Compressed_Videos/8nwMTNL_IRznDZuuORixgeIjn6klThbUOho_v7KuMB4.mp4",
      },
      {
        src: "assets/Compressed_Videos/99ea51_15feb55f0840497fbe8eff38357992c9_mv2.mp4",
      },
      { src: "assets/Compressed_Videos/billions_1.mp4" },
      { src: "assets/Compressed_Videos/cleaning-chores_AdobeExpress.mp4" },
      { src: "assets/Compressed_Videos/coffee_pouring.mp4" },
      { src: "assets/Compressed_Videos/doge_AdobeExpress.mp4" },
      { src: "assets/Compressed_Videos/download.mp4" },
      { src: "assets/Compressed_Videos/elmo-fire_AdobeExpress.mp4" },
      {
        src: "assets/Compressed_Videos/everything-everywhere-all-at-once_AdobeExpress.mp4",
      },
      { src: "assets/Compressed_Videos/ezgif-3-5b307eb748.mp4" },
      { src: "assets/Compressed_Videos/FR7NSBsWQAU0bAO.mp4" },
      { src: "assets/Compressed_Videos/gecko changing gif.mp4" },
      { src: "assets/Compressed_Videos/giphy_AdobeExpress.mp4" },
      {
        src: "assets/Compressed_Videos/Girl-With-A-Pearl-Earring-Bts-Cropped.mp4",
      },
      { src: "assets/Compressed_Videos/hamster-wheel-6_AdobeExpress.mp4" },
      { src: "assets/Compressed_Videos/HemRhXRHtv5gXTJi.mp4" },
      { src: "assets/Compressed_Videos/icegif-846_AdobeExpress.mp4" },
      { src: "assets/Compressed_Videos/o5gMZz5_2sVnjt0-.mp4" },
      {
        src: "assets/Compressed_Videos/original_0259c76ded2608804bee84727dbd9b8d_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_091faef5f12fe76173dfcb16ca670b03_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_3105e66d018cfaad1dca09882a9ce8c3_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_3913e89eb36f6a7a5bcba6d700e0e0d3_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_55511954f3a309ed5b098cba25cef362_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_57bd7a0fd0444e2b8b646870f1072291_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_623e2122cc57c3850c028359032b9c30_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_722fb76cb526b574038a3fcfa3551ef4_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_789745be574ccc71816248b648ef6431_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_882e7ca47499fdc185b3bf01cd881b6e_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_95a36245b5e27e2b3230cd969bb596f6-11582.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_a3a204cf5eef9eda0a52212ff1613f80_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_a8eaa55417cd94ce8c152e7dec9321b9_AdobeExpress.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_aa8548e8170868ab016ca0a332e9b002-12881.mp4",
      },
      {
        src: "assets/Compressed_Videos/original_f3b6a2652f21c3ba4e98d948b3075e19-12873.mp4",
      },
      { src: "assets/Compressed_Videos/spongebob-coffee_AdobeExpress.mp4" },
      { src: "assets/Compressed_Videos/T_I_EvH2wM3nx4ko.mp4" },
      { src: "assets/Compressed_Videos/thugkeez.mp4" },
      { src: "assets/Compressed_Videos/Tikmate 7112621976744807726(2).mp4" },
      { src: "assets/Compressed_Videos/Tikmate 7131125788937719086.mp4" },
      { src: "assets/Compressed_Videos/Tikmate 7132455667289443590.mp4" },
      { src: "assets/Compressed_Videos/Tikmate_7112621976744807726.mp4" },
      { src: "assets/Compressed_Videos/Tikmate_7131125788937719086.mp4" },
      { src: "assets/Compressed_Videos/Tikmate_7132455667289443590.mp4" },
      { src: "assets/Compressed_Videos/tiktok.mp4" },
      {
        src: "assets/Compressed_Videos/tumblr_d145d27db02c9fe40a14e9a4ca3ac2b0_fface2dc_540-12158.mp4",
      },
      {
        src: "assets/Compressed_Videos/tumblr_p5zxhkVWXd1rpidzao1_500-11595.mp4",
      },
      {
        src: "assets/Compressed_Videos/tumblr_pen1tpu5Sp1w2ypcro1_640-11590.mp4",
      },
      { src: "assets/Compressed_Videos/unnamed.mp4" },
      { src: "assets/Compressed_Videos/Untitledproject31.mp4" },
      { src: "assets/Compressed_Videos/videoplayback.mp4" },
      { src: "assets/Compressed_Videos/wbu3oxmcuvb81.mp4" },
      {
        src: "assets/Compressed_Videos/WhatsApp Video 2022-08-25 at 4.52.26 PM.mp4",
      },
      { src: "assets/storm/storm1.mp4" },
      { src: "assets/storm/storm2.mp4" },
      { src: "assets/storm/storm3.mp4" },
      { src: "assets/storm/storm4.mp4" },
      { src: "assets/videos/Cat - 18284.mp4" },
      { src: "assets/videos/Cat - 4915.mp4" },
      { src: "assets/videos/Eye - 91698.mp4" },
      {
        src: "assets/videos/mixkit-a-couple-of-cats-in-the-snow-9949-medium.mp4",
      },
      { src: "assets/videos/mixkit-ancient-roman-statue-9755-medium.mp4" },
      { src: "assets/videos/mixkit-green-eye-blinking-4257.mp4" },
      {
        src: "assets/videos/mixkit-green-toad-breathing-with-a-dark-background-1466.mp4",
      },
      { src: "assets/videos/mixkit-newborn-baby-crying-22081-medium.mp4" },
      {
        src: "assets/videos/mixkit-person-passing-sand-from-one-hand-to-another-33490-medium.mp4",
      },
      { src: "assets/videos/Mouth - 9519.mp4" },
      { src: "assets/videos/Poppy - 17005.mp4" },
      { src: "assets/videos/Rocket Launch - 233.mp4" },
      { src: "assets/videos/Starry Sky - 14955.mp4" },
    ],
  };
  let Zw = ht() + "/";
  function Jw(t) {
    let e = Kw.images.filter((t) => 1 == t.src.includes("mp4")),
      n = Kw.images,
      i = [];
    const r = t.offsetWidth,
      s = t.offsetHeight;
    let o = !1,
      a = { isDown: !1, px: 0, py: 0, x: 0, y: 0 };
    const l = new TS({
      resizeTo: t,
      antialias: !1,
      autoDensity: !0,
      interactive: !1,
      resolution: 2,
      backgroundColor: 15988208,
    });
    t.appendChild(l.view),
      (l.renderer.plugins.interaction.autoPreventDefault = !1);
    const h = new y_();
    function u(t) {
      a.isDown = !1;
    }
    function c(t, r) {
      if (!o) return;
      let s;
      var a, u;
      qw(e),
        Math.random() > 0.2
          ? ((a = l.loader.resources[`sprites-${Math.floor(qw(2))}`].textures),
            (u = Object.keys(a)),
            (s = a[u[(u.length * Math.random()) << 0]]))
          : (s = Zw + qw(n).src);
      let c = hb.from(s);
      c.position.set(t, r),
        c.scale.set(qw(0.5, 0.9)),
        c.anchor.set(0.5),
        s.toString().includes("mp4") && c.scale.set(qw(0.1, 0.2));
      let d = c.texture.baseTexture.resource.source;
      (d.volume = 0),
        (d.loop = !0),
        (d.muted = !0),
        (d.autoPlay = !0),
        i.push(c),
        h.addChild(c);
    }
    return (
      (h.position.x = 0),
      (h.position.y = 0),
      (h.hitArea = new Pm(0, 0, r, s)),
      (h.anchor = 0.5),
      (h.interactive = !0),
      l.stage.addChild(h),
      l.loader
        .add("sprites-0", Zw + "assets/sprites/sprites-0.json")
        .add("sprites-1", Zw + "assets/sprites/sprites-1.json")
        .load(function () {
          l.loader.resources, (o = !0);
        }),
      h
        .on("pointerdown", function (t) {
          a.isDown = !0;
        })
        .on("pointermove", function (t) {
          (a.px = a.x),
            (a.py = a.y),
            (a.x = t.data.global.x),
            (a.y = t.data.global.y),
            Math.random() < 0.5 && c(a.x, a.y);
        })
        .on("pointerup", u)
        .on("pointerupoutside", u),
      (l.renderer.view.style["touch-action"] = "auto"),
      l.ticker.add(() => {
        Math.random() < 0.1 && c(Math.random() * r, Math.random() * s),
          i.length > 300 &&
            (h.removeChild(i[0]), i[0].destroy(), i.splice(0, 1));
      }),
      { app: l }
    );
  }
  let $w = { data: "" },
    Qw = (t) =>
      "object" == typeof window
        ? (
            (t ? t.querySelector("#_goober") : window._goober) ||
            Object.assign(
              (t || document.head).appendChild(document.createElement("style")),
              { innerHTML: " ", id: "_goober" }
            )
          ).firstChild
        : t || $w,
    tM = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
    eM = /\/\*[^]*?\*\/|  +/g,
    nM = /\n+/g,
    iM = (t, e) => {
      let n = "",
        i = "",
        r = "";
      for (let s in t) {
        let o = t[s];
        "@" == s[0]
          ? "i" == s[1]
            ? (n = s + " " + o + ";")
            : (i +=
                "f" == s[1]
                  ? iM(o, s)
                  : s + "{" + iM(o, "k" == s[1] ? "" : e) + "}")
          : "object" == typeof o
          ? (i += iM(
              o,
              e
                ? e.replace(/([^,])+/g, (t) =>
                    s.replace(/(^:.*)|([^,])+/g, (e) =>
                      /&/.test(e) ? e.replace(/&/g, t) : t ? t + " " + e : e
                    )
                  )
                : s
            ))
          : null != o &&
            ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase()),
            (r += iM.p ? iM.p(s, o) : s + ":" + o + ";"));
      }
      return n + (e && r ? e + "{" + r + "}" : r) + i;
    },
    rM = {},
    sM = (t) => {
      if ("object" == typeof t) {
        let e = "";
        for (let n in t) e += n + sM(t[n]);
        return e;
      }
      return t;
    },
    oM = (t, e, n, i, r) => {
      let s = sM(t),
        o =
          rM[s] ||
          (rM[s] = ((t) => {
            let e = 0,
              n = 11;
            for (; e < t.length; ) n = (101 * n + t.charCodeAt(e++)) >>> 0;
            return "go" + n;
          })(s));
      if (!rM[o]) {
        let e =
          s !== t
            ? t
            : ((t) => {
                let e,
                  n,
                  i = [{}];
                for (; (e = tM.exec(t.replace(eM, ""))); )
                  e[4]
                    ? i.shift()
                    : e[3]
                    ? ((n = e[3].replace(nM, " ").trim()),
                      i.unshift((i[0][n] = i[0][n] || {})))
                    : (i[0][e[1]] = e[2].replace(nM, " ").trim());
                return i[0];
              })(t);
        rM[o] = iM(r ? { ["@keyframes " + o]: e } : e, n ? "" : "." + o);
      }
      return (
        (a = rM[o]),
        (h = i),
        -1 == (l = e).data.indexOf(a) && (l.data = h ? a + l.data : l.data + a),
        o
      );
      var a, l, h;
    },
    aM = (t, e, n) =>
      t.reduce((t, i, r) => {
        let s = e[r];
        if (s && s.call) {
          let t = s(n),
            e = (t && t.props && t.props.className) || (/^go/.test(t) && t);
          s = e
            ? "." + e
            : t && "object" == typeof t
            ? t.props
              ? ""
              : iM(t, "")
            : !1 === t
            ? ""
            : t;
        }
        return t + i + (null == s ? "" : s);
      }, "");
  function lM(t) {
    let e = this || {},
      n = t.call ? t(e.p) : t;
    return oM(
      n.unshift
        ? n.raw
          ? aM(n, [].slice.call(arguments, 1), e.p)
          : n.reduce((t, n) => Object.assign(t, n && n.call ? n(e.p) : n), {})
        : n,
      Qw(e.target),
      e.g,
      e.o,
      e.k
    );
  }
  lM.bind({ g: 1 }), lM.bind({ k: 1 });
  const hM = ({ value: t }) => {
    const [e, n] = tt({ value: 0 }),
      i = nt(),
      r = nt();
    return (
      et(() => {
        Jc.to(i.current, { height: "100%" });
      }, []),
      et(() => {
        Jc.to(e, {
          value: t,
          ease: Lu,
          duration: 1,
          onUpdate: () => {
            n({ value: e.value });
          },
        }),
          (r.current = t);
      }, [t]),
      Qc("span", {
        ref: i,
        style: { height: "0%" },
        children: e.value.toFixed(),
      })
    );
  };
  ht();
  const uM = lM`
  padding: 10px;

  text-transform: uppercase;
  text-align: center;

  .transparent {
    opacity: 0.5;
  }

  .ps-subtitle {
    margin-top: 5px;
  }
`,
    cM = lM`
  display: flex;
  aspect-ratio: 2/1;
  /* gap: 4px; */
  align-items: center;
  justify-content: center;
  margin-top: 20px;
  margin: 20px;
`,
    dM = lM``,
    pM = lM`
  position: fixed;
  top: 0px;
  left: 0px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(4px);
  border-radius: 4px;
  font-size: 12px;
  padding: 8px 12px;
  opacity: 0;
  color: black;
  pointer-events: none;

  &.mobile {
    @media (max-width: 768px) {
      width: fit-content;
      margin: auto;
      position: relative;
      top: 10px;
      opacity: 1;
    }
  }
`,
    fM = (t) =>
      t
        .toString()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "-")
        .replace(/[^\w-]+/g, "")
        .replace(/--+/g, "-"),
    mM = lM`
  /* @font-face {
    font-family: "Simone Mono";
    src: url(${ht()}/ABCSimonMono-Regular.woff2) format("woff2");
  } */

  height: 100%;
  padding: 10px;
  text-transform: uppercase;
  font-family: "Simone Mono";
  text-align: center;

  header {
    caption {
      display: block;
    }
  }

  .transparent {
    opacity: 0.5;
  }

  .ps-subtitle {
    margin-top: 5px;
  }
`,
    _M = lM`
  position: fixed;
  top: 0px;
  left: 0px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(4px);
  border-radius: 4px;
  color: black;
  pointer-events: none;

  padding: 8px 12px;
  opacity: 0;
`,
    gM = lM`
  display: flex;
  gap: 10px;
  margin: 2rem 0;
  div {
    width: 100%;
    /* height: 300px; */
    display: flex;
    flex-direction: column;
    aspect-ratio: 1/1;

    caption {
      text-align: left;
      margin-top: 10px;
    }
    img {
      width: 100%;
      height: 100%;
      background: rgba(35, 31, 32, 0.05);
      aspect-ratio: 1/1;
      object-fit: contain;
    }
  }
`,
    vM = lM`
  border-radius: 1px;
  border: 1px solid black;
  height: 28px;
  background: none;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  justify-content: center;
  cursor: pointer;
  margin-bottom: -1px;

  --a-bar: 0%;
  --b-bar: 0%;

  &:hover {
    background: rgba(35, 31, 32, 0.05);
  }

  &:before {
    content: " ";

    height: 100%;
    background: rgba(35, 31, 32, 0.05);
    /* z-index: -1; */
    top: 0;
    left: 0;
    position: absolute;
  }

  &.a:before {
    width: var(--a-bar);
  }
  &.b:before {
    width: var(--b-bar);
  }
`,
    yM = lM`
  display: flex;
  flex-direction: column;
  gap: 0px;
  font-family: inherit;
  text-align: center;
  margin-top: 20px;
`,
    xM = lM`
  text-transform: uppercase;

  & > a {
    color: black;
    &:hover {
      opacity: 0.5;
    }
  }

  &.underline {
    display: inline-block;
    border-bottom: 1px solid black;
    margin-top: 30px;
    padding-bottom: 3px;
    cursor: pointer;
    &:hover {
      opacity: 0.6;
    }
  }
`;
  let bM = ht(),
    TM = {
      data: [
        {
          id: "archizoom-studio",
          a: {
            title: "Global Tools",
            credit: "Archizoom Associati, 1973",
            url: "2a-Global Tools, Archizoom Associati, 1973.png",
          },
          b: {
            title: "Luis Vuitton - Studio Crewneck",
            credit: "Studio Temp, 2020",
            url: "2b-Luis Vuitton - Studio Crewneck, Studio Temp, 2020.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "stanislaw-pilar",
          a: {
            title: "Omni Magazine",
            credit: "Stanislaw Fernandes, 1985",
            url: "3a-Omni Magazine, Stanislaw Fernandes, 1985.png",
          },
          b: {
            title: "Jimmy Edgar - This Ones For The Children",
            credit: "Pilar Zeta and Jimmy Edgar, 2012",
            url: "3b-Jimmy Edgar - This Ones For The Children, Pilar Zeta and Jimmy Edgar, 2012.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "atlus-studio",
          a: {
            title: "Persona 2 Innocent Sin",
            credit: "Atlus, 1999",
            url: "4a-Persona 2 Innocent Sin, Atlus, 1999.png",
          },
          b: {
            title: "Post Malone - Beerbongs & Bentleys",
            credit: "Bryan Rivera + team, 2018",
            url: "4b-Post Malone - Beerbongs & Bentleys, Bryan Rivera + team, 2018.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "braulio-studio",
          a: {
            title: "Good Room poster",
            credit: "Braulio Amado, 2017",
            url: "5a-Good Room poster, Braulio Amado, 2017.png",
          },
          b: {
            title: "Tama Art University poster",
            credit: "Unknown, 2018",
            url: "5b-Tama Art University poster, Unknown, 2018.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "mahalia-studio",
          a: {
            title: "Mahalia Jackson - Self-Titled",
            credit: "Unknown, 1978",
            url: "6a-Mahalia Jackson - Self-Titled, Unknown, 1978.png",
          },
          b: {
            title: "Madvillain - Madvillainy",
            credit: "Jeff Jank, 2004",
            url: "6b-Madvillain - Madvillainy, Jeff Jank, 2004.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "stephen-studio",
          a: {
            title: "CDG SS10",
            credit: "Stephen J. Shanabrook, 2010",
            url: "7a-CDG SS10, Stephen J. Shanabrook, 2010.png",
          },
          b: {
            title: "Aphex Twin - T69 Collapse",
            credit: "Weirdcore, 2018",
            url: "7b-Aphex Twin - T69 Collapse, Weirdcore, 2018.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "theophilus-studio",
          a: {
            title: "Theophilus London - Bebey",
            credit: "Unknown, 2018",
            url: "8a-Theophilus London - Bebey, Unknown, 2018.png",
          },
          b: {
            title: "Celeste - Coco Blood",
            credit: "Bryan Rivera, 2019",
            url: "8b-Celeste - Coco Blood, Bryan Rivera, 2019.png",
          },
          homage: 0,
          copycat: 0,
        },
        {
          id: "free-throw",
          a: {
            title: "Free Throw",
            credit: "Andrew Herzog, 2015",
            url: "9a-Free Throw, Andrew Herzog, 2015 .png",
          },
          b: {
            title: "Final Shot",
            credit: "Hoop Projects, 2020",
            url: "9b-Final Shot, Hoop Projects, 2020.png",
          },
          homage: 0,
          copycat: 0,
        },
      ],
    },
    EM = "poll";
  const SM = "143",
    wM = 100,
    MM = 301,
    AM = 302,
    RM = 306,
    CM = 1e3,
    IM = 1001,
    PM = 1002,
    OM = 1003,
    NM = 1004,
    DM = 1005,
    LM = 1006,
    FM = 1008,
    UM = 1009,
    BM = 1014,
    kM = 1015,
    GM = 1016,
    HM = 1020,
    zM = 1023,
    VM = 1026,
    XM = 1027,
    WM = 33776,
    jM = 33777,
    YM = 33778,
    qM = 33779,
    KM = 2300,
    ZM = 2301,
    JM = 2302,
    $M = 3e3,
    QM = 3001,
    tA = 3201,
    eA = "srgb",
    nA = "srgb-linear",
    iA = 7680,
    rA = 35044,
    sA = "300 es",
    oA = 1035;
  class aA {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[t];
      if (void 0 !== n) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const n = e.slice(0);
        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
        t.target = null;
      }
    }
  }
  const lA = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
  let hA = 1234567;
  const uA = Math.PI / 180,
    cA = 180 / Math.PI;
  function dA() {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0;
    return (
      lA[255 & t] +
      lA[(t >> 8) & 255] +
      lA[(t >> 16) & 255] +
      lA[(t >> 24) & 255] +
      "-" +
      lA[255 & e] +
      lA[(e >> 8) & 255] +
      "-" +
      lA[((e >> 16) & 15) | 64] +
      lA[(e >> 24) & 255] +
      "-" +
      lA[(63 & n) | 128] +
      lA[(n >> 8) & 255] +
      "-" +
      lA[(n >> 16) & 255] +
      lA[(n >> 24) & 255] +
      lA[255 & i] +
      lA[(i >> 8) & 255] +
      lA[(i >> 16) & 255] +
      lA[(i >> 24) & 255]
    ).toLowerCase();
  }
  function pA(t, e, n) {
    return Math.max(e, Math.min(n, t));
  }
  function fA(t, e) {
    return ((t % e) + e) % e;
  }
  function mA(t, e, n) {
    return (1 - n) * t + n * e;
  }
  function _A(t) {
    return 0 == (t & (t - 1)) && 0 !== t;
  }
  function gA(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  }
  function vA(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  }
  var yA = Object.freeze({
    __proto__: null,
    DEG2RAD: uA,
    RAD2DEG: cA,
    generateUUID: dA,
    clamp: pA,
    euclideanModulo: fA,
    mapLinear: function (t, e, n, i, r) {
      return i + ((t - e) * (r - i)) / (n - e);
    },
    inverseLerp: function (t, e, n) {
      return t !== e ? (n - t) / (e - t) : 0;
    },
    lerp: mA,
    damp: function (t, e, n, i) {
      return mA(t, e, 1 - Math.exp(-n * i));
    },
    pingpong: function (t, e = 1) {
      return e - Math.abs(fA(t, 2 * e) - e);
    },
    smoothstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
    },
    smootherstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
    },
    randInt: function (t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function (t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function (t) {
      return t * (0.5 - Math.random());
    },
    seededRandom: function (t) {
      void 0 !== t && (hA = t);
      let e = (hA += 1831565813);
      return (
        (e = Math.imul(e ^ (e >>> 15), 1 | e)),
        (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
        ((e ^ (e >>> 14)) >>> 0) / 4294967296
      );
    },
    degToRad: function (t) {
      return t * uA;
    },
    radToDeg: function (t) {
      return t * cA;
    },
    isPowerOfTwo: _A,
    ceilPowerOfTwo: gA,
    floorPowerOfTwo: vA,
    setQuaternionFromProperEuler: function (t, e, n, i, r) {
      const s = Math.cos,
        o = Math.sin,
        a = s(n / 2),
        l = o(n / 2),
        h = s((e + i) / 2),
        u = o((e + i) / 2),
        c = s((e - i) / 2),
        d = o((e - i) / 2),
        p = s((i - e) / 2),
        f = o((i - e) / 2);
      switch (r) {
        case "XYX":
          t.set(a * u, l * c, l * d, a * h);
          break;
        case "YZY":
          t.set(l * d, a * u, l * c, a * h);
          break;
        case "ZXZ":
          t.set(l * c, l * d, a * u, a * h);
          break;
        case "XZX":
          t.set(a * u, l * f, l * p, a * h);
          break;
        case "YXY":
          t.set(l * p, a * u, l * f, a * h);
          break;
        case "ZYZ":
          t.set(l * f, l * p, a * u, a * h);
          break;
        default:
          console.warn(
            "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
              r
          );
      }
    },
    normalize: function (t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint16Array:
          return Math.round(65535 * t);
        case Uint8Array:
          return Math.round(255 * t);
        case Int16Array:
          return Math.round(32767 * t);
        case Int8Array:
          return Math.round(127 * t);
        default:
          throw new Error("Invalid component type.");
      }
    },
    denormalize: function (t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint16Array:
          return t / 65535;
        case Uint8Array:
          return t / 255;
        case Int16Array:
          return Math.max(t / 32767, -1);
        case Int8Array:
          return Math.max(t / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    },
  });
  class xA {
    constructor(t = 0, e = 0) {
      (xA.prototype.isVector2 = !0), (this.x = t), (this.y = e);
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this;
    }
    addVectors(t, e) {
      return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
    }
    addScaledVector(t, e) {
      return (this.x += t.x * e), (this.y += t.y * e), this;
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this;
    }
    subVectors(t, e) {
      return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this;
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = t.elements;
      return (
        (this.x = i[0] * e + i[3] * n + i[6]),
        (this.y = i[1] * e + i[4] * n + i[7]),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
      );
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), t;
    }
    fromBufferAttribute(t, e) {
      return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
    }
    rotateAround(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return (
        (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class bA {
    constructor() {
      (bA.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }
    set(t, e, n, i, r, s, o, a, l) {
      const h = this.elements;
      return (
        (h[0] = t),
        (h[1] = i),
        (h[2] = o),
        (h[3] = e),
        (h[4] = r),
        (h[5] = a),
        (h[6] = n),
        (h[7] = s),
        (h[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return (
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        o = n[3],
        a = n[6],
        l = n[1],
        h = n[4],
        u = n[7],
        c = n[2],
        d = n[5],
        p = n[8],
        f = i[0],
        m = i[3],
        _ = i[6],
        g = i[1],
        v = i[4],
        y = i[7],
        x = i[2],
        b = i[5],
        T = i[8];
      return (
        (r[0] = s * f + o * g + a * x),
        (r[3] = s * m + o * v + a * b),
        (r[6] = s * _ + o * y + a * T),
        (r[1] = l * f + h * g + u * x),
        (r[4] = l * m + h * v + u * b),
        (r[7] = l * _ + h * y + u * T),
        (r[2] = c * f + d * g + p * x),
        (r[5] = c * m + d * v + p * b),
        (r[8] = c * _ + d * y + p * T),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[3] *= t),
        (e[6] *= t),
        (e[1] *= t),
        (e[4] *= t),
        (e[7] *= t),
        (e[2] *= t),
        (e[5] *= t),
        (e[8] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        o = t[5],
        a = t[6],
        l = t[7],
        h = t[8];
      return (
        e * s * h - e * o * l - n * r * h + n * o * a + i * r * l - i * s * a
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        o = t[5],
        a = t[6],
        l = t[7],
        h = t[8],
        u = h * s - o * l,
        c = o * a - h * r,
        d = l * r - s * a,
        p = e * u + n * c + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (t[0] = u * f),
        (t[1] = (i * l - h * n) * f),
        (t[2] = (o * n - i * s) * f),
        (t[3] = c * f),
        (t[4] = (h * e - i * a) * f),
        (t[5] = (i * r - o * e) * f),
        (t[6] = d * f),
        (t[7] = (n * a - l * e) * f),
        (t[8] = (s * e - n * r) * f),
        this
      );
    }
    transpose() {
      let t;
      const e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[3]),
        (e[3] = t),
        (t = e[2]),
        (e[2] = e[6]),
        (e[6] = t),
        (t = e[5]),
        (e[5] = e[7]),
        (e[7] = t),
        this
      );
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return (
        (t[0] = e[0]),
        (t[1] = e[3]),
        (t[2] = e[6]),
        (t[3] = e[1]),
        (t[4] = e[4]),
        (t[5] = e[7]),
        (t[6] = e[2]),
        (t[7] = e[5]),
        (t[8] = e[8]),
        this
      );
    }
    setUvTransform(t, e, n, i, r, s, o) {
      const a = Math.cos(r),
        l = Math.sin(r);
      return (
        this.set(
          n * a,
          n * l,
          -n * (a * s + l * o) + s + t,
          -i * l,
          i * a,
          -i * (-l * s + a * o) + o + e,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(t, e) {
      const n = this.elements;
      return (
        (n[0] *= t),
        (n[3] *= t),
        (n[6] *= t),
        (n[1] *= e),
        (n[4] *= e),
        (n[7] *= e),
        this
      );
    }
    rotate(t) {
      const e = Math.cos(t),
        n = Math.sin(t),
        i = this.elements,
        r = i[0],
        s = i[3],
        o = i[6],
        a = i[1],
        l = i[4],
        h = i[7];
      return (
        (i[0] = e * r + n * a),
        (i[3] = e * s + n * l),
        (i[6] = e * o + n * h),
        (i[1] = -n * r + e * a),
        (i[4] = -n * s + e * l),
        (i[7] = -n * o + e * h),
        this
      );
    }
    translate(t, e) {
      const n = this.elements;
      return (
        (n[0] += t * n[2]),
        (n[3] += t * n[5]),
        (n[6] += t * n[8]),
        (n[1] += e * n[2]),
        (n[4] += e * n[5]),
        (n[7] += e * n[8]),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        t
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  function TA(t) {
    for (let e = t.length - 1; e >= 0; --e) if (t[e] > 65535) return !0;
    return !1;
  }
  function EA(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t);
  }
  function SA(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function wA(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  const MA = { [eA]: { [nA]: SA }, [nA]: { [eA]: wA } },
    AA = {
      legacyMode: !0,
      get workingColorSpace() {
        return nA;
      },
      set workingColorSpace(t) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function (t, e, n) {
        if (this.legacyMode || e === n || !e || !n) return t;
        if (MA[e] && void 0 !== MA[e][n]) {
          const i = MA[e][n];
          return (t.r = i(t.r)), (t.g = i(t.g)), (t.b = i(t.b)), t;
        }
        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function (t, e) {
        return this.convert(t, this.workingColorSpace, e);
      },
      toWorkingColorSpace: function (t, e) {
        return this.convert(t, e, this.workingColorSpace);
      },
    },
    RA = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    CA = { r: 0, g: 0, b: 0 },
    IA = { h: 0, s: 0, l: 0 },
    PA = { h: 0, s: 0, l: 0 };
  function OA(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? t + 6 * (e - t) * n
        : n < 0.5
        ? e
        : n < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - n)
        : t
    );
  }
  function NA(t, e) {
    return (e.r = t.r), (e.g = t.g), (e.b = t.b), e;
  }
  class DA {
    constructor(t, e, n) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
      );
    }
    set(t) {
      return (
        t && t.isColor
          ? this.copy(t)
          : "number" == typeof t
          ? this.setHex(t)
          : "string" == typeof t && this.setStyle(t),
        this
      );
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    }
    setHex(t, e = "srgb") {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        AA.toWorkingColorSpace(this, e),
        this
      );
    }
    setRGB(t, e, n, i = "srgb-linear") {
      return (
        (this.r = t),
        (this.g = e),
        (this.b = n),
        AA.toWorkingColorSpace(this, i),
        this
      );
    }
    setHSL(t, e, n, i = "srgb-linear") {
      if (((t = fA(t, 1)), (e = pA(e, 0, 1)), (n = pA(n, 0, 1)), 0 === e))
        this.r = this.g = this.b = n;
      else {
        const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
          r = 2 * n - i;
        (this.r = OA(r, i, t + 1 / 3)),
          (this.g = OA(r, i, t)),
          (this.b = OA(r, i, t - 1 / 3));
      }
      return AA.toWorkingColorSpace(this, i), this;
    }
    setStyle(t, e = "srgb") {
      function n(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + t + " will be ignored."
          );
      }
      let i;
      if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
        let t;
        const r = i[1],
          s = i[2];
        switch (r) {
          case "rgb":
          case "rgba":
            if (
              (t =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                AA.toWorkingColorSpace(this, e),
                n(t[4]),
                this
              );
            if (
              (t =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                AA.toWorkingColorSpace(this, e),
                n(t[4]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (t =
                /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            ) {
              const i = parseFloat(t[1]) / 360,
                r = parseInt(t[2], 10) / 100,
                s = parseInt(t[3], 10) / 100;
              return n(t[4]), this.setHSL(i, r, s, e);
            }
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const t = i[1],
          n = t.length;
        if (3 === n)
          return (
            (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
            (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
            (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
            AA.toWorkingColorSpace(this, e),
            this
          );
        if (6 === n)
          return (
            (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
            (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
            (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
            AA.toWorkingColorSpace(this, e),
            this
          );
      }
      return t && t.length > 0 ? this.setColorName(t, e) : this;
    }
    setColorName(t, e = "srgb") {
      const n = RA[t.toLowerCase()];
      return (
        void 0 !== n
          ? this.setHex(n, e)
          : console.warn("THREE.Color: Unknown color " + t),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    }
    copySRGBToLinear(t) {
      return (this.r = SA(t.r)), (this.g = SA(t.g)), (this.b = SA(t.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.r = wA(t.r)), (this.g = wA(t.g)), (this.b = wA(t.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t = "srgb") {
      return (
        AA.fromWorkingColorSpace(NA(this, CA), t),
        (pA(255 * CA.r, 0, 255) << 16) ^
          (pA(255 * CA.g, 0, 255) << 8) ^
          (pA(255 * CA.b, 0, 255) << 0)
      );
    }
    getHexString(t = "srgb") {
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e = "srgb-linear") {
      AA.fromWorkingColorSpace(NA(this, CA), e);
      const n = CA.r,
        i = CA.g,
        r = CA.b,
        s = Math.max(n, i, r),
        o = Math.min(n, i, r);
      let a, l;
      const h = (o + s) / 2;
      if (o === s) (a = 0), (l = 0);
      else {
        const t = s - o;
        switch (((l = h <= 0.5 ? t / (s + o) : t / (2 - s - o)), s)) {
          case n:
            a = (i - r) / t + (i < r ? 6 : 0);
            break;
          case i:
            a = (r - n) / t + 2;
            break;
          case r:
            a = (n - i) / t + 4;
        }
        a /= 6;
      }
      return (t.h = a), (t.s = l), (t.l = h), t;
    }
    getRGB(t, e = "srgb-linear") {
      return (
        AA.fromWorkingColorSpace(NA(this, CA), e),
        (t.r = CA.r),
        (t.g = CA.g),
        (t.b = CA.b),
        t
      );
    }
    getStyle(t = "srgb") {
      return (
        AA.fromWorkingColorSpace(NA(this, CA), t),
        t !== eA
          ? `color(${t} ${CA.r} ${CA.g} ${CA.b})`
          : `rgb(${(255 * CA.r) | 0},${(255 * CA.g) | 0},${(255 * CA.b) | 0})`
      );
    }
    offsetHSL(t, e, n) {
      return (
        this.getHSL(IA),
        (IA.h += t),
        (IA.s += e),
        (IA.l += n),
        this.setHSL(IA.h, IA.s, IA.l),
        this
      );
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    }
    addColors(t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    }
    lerp(t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    }
    lerpColors(t, e, n) {
      return (
        (this.r = t.r + (e.r - t.r) * n),
        (this.g = t.g + (e.g - t.g) * n),
        (this.b = t.b + (e.b - t.b) * n),
        this
      );
    }
    lerpHSL(t, e) {
      this.getHSL(IA), t.getHSL(PA);
      const n = mA(IA.h, PA.h, e),
        i = mA(IA.s, PA.s, e),
        r = mA(IA.l, PA.l, e);
      return this.setHSL(n, i, r), this;
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.r = t.getX(e)),
        (this.g = t.getY(e)),
        (this.b = t.getZ(e)),
        !0 === t.normalized &&
          ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
        this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  let LA;
  DA.NAMES = RA;
  class FA {
    static getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        void 0 === LA && (LA = EA("canvas")),
          (LA.width = t.width),
          (LA.height = t.height);
        const n = LA.getContext("2d");
        t instanceof ImageData
          ? n.putImageData(t, 0, 0)
          : n.drawImage(t, 0, 0, t.width, t.height),
          (e = LA);
      }
      return e.width > 2048 || e.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            t
          ),
          e.toDataURL("image/jpeg", 0.6))
        : e.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const e = EA("canvas");
        (e.width = t.width), (e.height = t.height);
        const n = e.getContext("2d");
        n.drawImage(t, 0, 0, t.width, t.height);
        const i = n.getImageData(0, 0, t.width, t.height),
          r = i.data;
        for (let t = 0; t < r.length; t++) r[t] = 255 * SA(r[t] / 255);
        return n.putImageData(i, 0, 0), e;
      }
      if (t.data) {
        const e = t.data.slice(0);
        for (let t = 0; t < e.length; t++)
          e instanceof Uint8Array || e instanceof Uint8ClampedArray
            ? (e[t] = Math.floor(255 * SA(e[t] / 255)))
            : (e[t] = SA(e[t]));
        return { data: e, width: t.width, height: t.height };
      }
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        t
      );
    }
  }
  class UA {
    constructor(t = null) {
      (this.isSource = !0),
        (this.uuid = dA()),
        (this.data = t),
        (this.version = 0);
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
      const n = { uuid: this.uuid, url: "" },
        i = this.data;
      if (null !== i) {
        let t;
        if (Array.isArray(i)) {
          t = [];
          for (let e = 0, n = i.length; e < n; e++)
            i[e].isDataTexture ? t.push(BA(i[e].image)) : t.push(BA(i[e]));
        } else t = BA(i);
        n.url = t;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }
  function BA(t) {
    return ("undefined" != typeof HTMLImageElement &&
      t instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ? FA.getDataURL(t)
      : t.data
      ? {
          data: Array.from(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let kA = 0;
  class GA extends aA {
    constructor(
      t = GA.DEFAULT_IMAGE,
      e = GA.DEFAULT_MAPPING,
      n = 1001,
      i = 1001,
      r = 1006,
      s = 1008,
      o = 1023,
      a = 1009,
      l = 1,
      h = 3e3
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: kA++ }),
        (this.uuid = dA()),
        (this.name = ""),
        (this.source = new UA(t)),
        (this.mipmaps = []),
        (this.mapping = e),
        (this.wrapS = n),
        (this.wrapT = i),
        (this.magFilter = r),
        (this.minFilter = s),
        (this.anisotropy = l),
        (this.format = o),
        (this.internalFormat = null),
        (this.type = a),
        (this.offset = new xA(0, 0)),
        (this.repeat = new xA(1, 1)),
        (this.center = new xA(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new bA()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = h),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    get image() {
      return this.source.data;
    }
    set image(t) {
      this.source.data = t;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.source = t.source),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.encoding = t.encoding),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        e || (t.textures[this.uuid] = n),
        n
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (300 !== this.mapping) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case CM:
            t.x = t.x - Math.floor(t.x);
            break;
          case IM:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case PM:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case CM:
            t.y = t.y - Math.floor(t.y);
            break;
          case IM:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case PM:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      !0 === t && (this.version++, (this.source.needsUpdate = !0));
    }
  }
  (GA.DEFAULT_IMAGE = null), (GA.DEFAULT_MAPPING = 300);
  class HA {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (HA.prototype.isVector4 = !0),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        (this.w = i);
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, i) {
      return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setW(t) {
      return (this.w = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = void 0 !== t.w ? t.w : 1),
        this
      );
    }
    add(t) {
      return (
        (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
      );
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x),
        (this.y = t.y + e.y),
        (this.z = t.z + e.z),
        (this.w = t.w + e.w),
        this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e),
        (this.y += t.y * e),
        (this.z += t.z * e),
        (this.w += t.w * e),
        this
      );
    }
    sub(t) {
      return (
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
      );
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x),
        (this.y = t.y - e.y),
        (this.z = t.z - e.z),
        (this.w = t.w - e.w),
        this
      );
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      );
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        s = t.elements;
      return (
        (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
        (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
        (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
        (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
        this
      );
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return (
        e < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, i, r;
      const s = 0.01,
        o = 0.1,
        a = t.elements,
        l = a[0],
        h = a[4],
        u = a[8],
        c = a[1],
        d = a[5],
        p = a[9],
        f = a[2],
        m = a[6],
        _ = a[10];
      if (Math.abs(h - c) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
        if (
          Math.abs(h + c) < o &&
          Math.abs(u + f) < o &&
          Math.abs(p + m) < o &&
          Math.abs(l + d + _ - 3) < o
        )
          return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (l + 1) / 2,
          a = (d + 1) / 2,
          g = (_ + 1) / 2,
          v = (h + c) / 4,
          y = (u + f) / 4,
          x = (p + m) / 4;
        return (
          t > a && t > g
            ? t < s
              ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
              : ((n = Math.sqrt(t)), (i = v / n), (r = y / n))
            : a > g
            ? a < s
              ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
              : ((i = Math.sqrt(a)), (n = v / i), (r = x / i))
            : g < s
            ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
            : ((r = Math.sqrt(g)), (n = y / r), (i = x / r)),
          this.set(n, i, r, e),
          this
        );
      }
      let g = Math.sqrt(
        (m - p) * (m - p) + (u - f) * (u - f) + (c - h) * (c - h)
      );
      return (
        Math.abs(g) < 0.001 && (g = 1),
        (this.x = (m - p) / g),
        (this.y = (u - f) / g),
        (this.z = (c - h) / g),
        (this.w = Math.acos((l + d + _ - 1) / 2)),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        (this.w = Math.max(t, Math.min(e, this.w))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        (this.w += (t.w - this.w) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        (this.w = t.w + (e.w - t.w) * n),
        this
      );
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        (this.w = t[e + 3]),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        (t[e + 3] = this.w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        (this.w = t.getW(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class zA extends aA {
    constructor(t, e, n = {}) {
      super(),
        (this.isWebGLRenderTarget = !0),
        (this.width = t),
        (this.height = e),
        (this.depth = 1),
        (this.scissor = new HA(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new HA(0, 0, t, e));
      const i = { width: t, height: e, depth: 1 };
      (this.texture = new GA(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.encoding
      )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps =
          void 0 !== n.generateMipmaps && n.generateMipmaps),
        (this.texture.internalFormat =
          void 0 !== n.internalFormat ? n.internalFormat : null),
        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : LM),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null),
        (this.samples = void 0 !== n.samples ? n.samples : 0);
    }
    setSize(t, e, n = 1) {
      (this.width === t && this.height === e && this.depth === n) ||
        ((this.width = t),
        (this.height = e),
        (this.depth = n),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.image.depth = n),
        this.dispose()),
        this.viewport.set(0, 0, t, e),
        this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.width = t.width),
        (this.height = t.height),
        (this.depth = t.depth),
        this.viewport.copy(t.viewport),
        (this.texture = t.texture.clone()),
        (this.texture.isRenderTargetTexture = !0);
      const e = Object.assign({}, t.texture.image);
      return (
        (this.texture.source = new UA(e)),
        (this.depthBuffer = t.depthBuffer),
        (this.stencilBuffer = t.stencilBuffer),
        null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
        (this.samples = t.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class VA extends GA {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = OM),
        (this.minFilter = OM),
        (this.wrapR = IM),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class XA extends GA {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = OM),
        (this.minFilter = OM),
        (this.wrapR = IM),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class WA {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (this.isQuaternion = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i);
    }
    static slerpFlat(t, e, n, i, r, s, o) {
      let a = n[i + 0],
        l = n[i + 1],
        h = n[i + 2],
        u = n[i + 3];
      const c = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        f = r[s + 3];
      if (0 === o)
        return (
          (t[e + 0] = a), (t[e + 1] = l), (t[e + 2] = h), void (t[e + 3] = u)
        );
      if (1 === o)
        return (
          (t[e + 0] = c), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
        );
      if (u !== f || a !== c || l !== d || h !== p) {
        let t = 1 - o;
        const e = a * c + l * d + h * p + u * f,
          n = e >= 0 ? 1 : -1,
          i = 1 - e * e;
        if (i > Number.EPSILON) {
          const r = Math.sqrt(i),
            s = Math.atan2(r, e * n);
          (t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r);
        }
        const r = o * n;
        if (
          ((a = a * t + c * r),
          (l = l * t + d * r),
          (h = h * t + p * r),
          (u = u * t + f * r),
          t === 1 - o)
        ) {
          const t = 1 / Math.sqrt(a * a + l * l + h * h + u * u);
          (a *= t), (l *= t), (h *= t), (u *= t);
        }
      }
      (t[e] = a), (t[e + 1] = l), (t[e + 2] = h), (t[e + 3] = u);
    }
    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
      const o = n[i],
        a = n[i + 1],
        l = n[i + 2],
        h = n[i + 3],
        u = r[s],
        c = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return (
        (t[e] = o * p + h * u + a * d - l * c),
        (t[e + 1] = a * p + h * c + l * u - o * d),
        (t[e + 2] = l * p + h * d + o * c - a * u),
        (t[e + 3] = h * p - o * u - a * c - l * d),
        t
      );
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      (this._w = t), this._onChangeCallback();
    }
    set(t, e, n, i) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(t, e) {
      if (!t || !t.isEuler)
        throw new Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._order,
        o = Math.cos,
        a = Math.sin,
        l = o(n / 2),
        h = o(i / 2),
        u = o(r / 2),
        c = a(n / 2),
        d = a(i / 2),
        p = a(r / 2);
      switch (s) {
        case "XYZ":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "YXZ":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        case "ZXY":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "ZYX":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        case "YZX":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "XZY":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              s
          );
      }
      return !1 !== e && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const n = e / 2,
        i = Math.sin(n);
      return (
        (this._x = t.x * i),
        (this._y = t.y * i),
        (this._z = t.z * i),
        (this._w = Math.cos(n)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t) {
      const e = t.elements,
        n = e[0],
        i = e[4],
        r = e[8],
        s = e[1],
        o = e[5],
        a = e[9],
        l = e[2],
        h = e[6],
        u = e[10],
        c = n + o + u;
      if (c > 0) {
        const t = 0.5 / Math.sqrt(c + 1);
        (this._w = 0.25 / t),
          (this._x = (h - a) * t),
          (this._y = (r - l) * t),
          (this._z = (s - i) * t);
      } else if (n > o && n > u) {
        const t = 2 * Math.sqrt(1 + n - o - u);
        (this._w = (h - a) / t),
          (this._x = 0.25 * t),
          (this._y = (i + s) / t),
          (this._z = (r + l) / t);
      } else if (o > u) {
        const t = 2 * Math.sqrt(1 + o - n - u);
        (this._w = (r - l) / t),
          (this._x = (i + s) / t),
          (this._y = 0.25 * t),
          (this._z = (a + h) / t);
      } else {
        const t = 2 * Math.sqrt(1 + u - n - o);
        (this._w = (s - i) / t),
          (this._x = (r + l) / t),
          (this._y = (a + h) / t),
          (this._z = 0.25 * t);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return (
        n < Number.EPSILON
          ? ((n = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = n))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = n)))
          : ((this._x = t.y * e.z - t.z * e.y),
            (this._y = t.z * e.x - t.x * e.z),
            (this._z = t.x * e.y - t.y * e.x),
            (this._w = n)),
        this.normalize()
      );
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(pA(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (0 === n) return this;
      const i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let t = this.length();
      return (
        0 === t
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._w,
        o = e._x,
        a = e._y,
        l = e._z,
        h = e._w;
      return (
        (this._x = n * h + s * o + i * l - r * a),
        (this._y = i * h + s * a + r * o - n * l),
        (this._z = r * h + s * l + n * a - i * o),
        (this._w = s * h - n * o - i * a - r * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const n = this._x,
        i = this._y,
        r = this._z,
        s = this._w;
      let o = s * t._w + n * t._x + i * t._y + r * t._z;
      if (
        (o < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (o = -o))
          : this.copy(t),
        o >= 1)
      )
        return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
      const a = 1 - o * o;
      if (a <= Number.EPSILON) {
        const t = 1 - e;
        return (
          (this._w = t * s + e * this._w),
          (this._x = t * n + e * this._x),
          (this._y = t * i + e * this._y),
          (this._z = t * r + e * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      }
      const l = Math.sqrt(a),
        h = Math.atan2(l, o),
        u = Math.sin((1 - e) * h) / l,
        c = Math.sin(e * h) / l;
      return (
        (this._w = s * u + this._w * c),
        (this._x = n * u + this._x * c),
        (this._y = i * u + this._y * c),
        (this._z = r * u + this._z * c),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
    random() {
      const t = Math.random(),
        e = Math.sqrt(1 - t),
        n = Math.sqrt(t),
        i = 2 * Math.PI * Math.random(),
        r = 2 * Math.PI * Math.random();
      return this.set(
        e * Math.cos(i),
        n * Math.sin(r),
        n * Math.cos(r),
        e * Math.sin(i)
      );
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this._x = t[e]),
        (this._y = t[e + 1]),
        (this._z = t[e + 2]),
        (this._w = t[e + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this._x = t.getX(e)),
        (this._y = t.getY(e)),
        (this._z = t.getZ(e)),
        (this._w = t.getW(e)),
        this
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class jA {
    constructor(t = 0, e = 0, n = 0) {
      (jA.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
    }
    set(t, e, n) {
      return (
        void 0 === n && (n = this.z),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        this
      );
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    }
    multiplyVectors(t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    }
    applyEuler(t) {
      return this.applyQuaternion(qA.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(qA.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * n + r[6] * i),
        (this.y = r[1] * e + r[4] * n + r[7] * i),
        (this.z = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
        this
      );
    }
    applyQuaternion(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        s = t.y,
        o = t.z,
        a = t.w,
        l = a * e + s * i - o * n,
        h = a * n + o * e - r * i,
        u = a * i + r * n - s * e,
        c = -r * e - s * n - o * i;
      return (
        (this.x = l * a + c * -r + h * -o - u * -s),
        (this.y = h * a + c * -s + u * -r - l * -o),
        (this.z = u * a + c * -o + l * -s - h * -r),
        this
      );
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld
      );
    }
    transformDirection(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * n + r[8] * i),
        (this.y = r[1] * e + r[5] * n + r[9] * i),
        (this.z = r[2] * e + r[6] * n + r[10] * i),
        this.normalize()
      );
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        this
      );
    }
    cross(t) {
      return this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = e.x,
        o = e.y,
        a = e.z;
      return (
        (this.x = i * a - r * o),
        (this.y = r * s - n * a),
        (this.z = n * o - i * s),
        this
      );
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return YA.copy(this).projectOnVector(t), this.sub(YA);
    }
    reflect(t) {
      return this.sub(YA.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(pA(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      const i = Math.sin(e) * t;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(e) * t),
        (this.z = i * Math.cos(n)),
        this
      );
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = n),
        (this.z = t * Math.cos(e)),
        this
      );
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
    setFromEuler(t) {
      return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const t = 2 * (Math.random() - 0.5),
        e = Math.random() * Math.PI * 2,
        n = Math.sqrt(1 - t ** 2);
      return (
        (this.x = n * Math.cos(e)),
        (this.y = n * Math.sin(e)),
        (this.z = t),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const YA = new jA(),
    qA = new WA();
  class KA {
    constructor(
      t = new jA(1 / 0, 1 / 0, 1 / 0),
      e = new jA(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.isBox3 = !0), (this.min = t), (this.max = e);
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      let e = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        s = -1 / 0,
        o = -1 / 0;
      for (let a = 0, l = t.length; a < l; a += 3) {
        const l = t[a],
          h = t[a + 1],
          u = t[a + 2];
        l < e && (e = l),
          h < n && (n = h),
          u < i && (i = u),
          l > r && (r = l),
          h > s && (s = h),
          u > o && (o = u);
      }
      return this.min.set(e, n, i), this.max.set(r, s, o), this;
    }
    setFromBufferAttribute(t) {
      let e = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        s = -1 / 0,
        o = -1 / 0;
      for (let a = 0, l = t.count; a < l; a++) {
        const l = t.getX(a),
          h = t.getY(a),
          u = t.getZ(a);
        l < e && (e = l),
          h < n && (n = h),
          u < i && (i = u),
          l > r && (r = l),
          h > s && (s = h),
          u > o && (o = u);
      }
      return this.min.set(e, n, i), this.max.set(r, s, o), this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const n = JA.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = !1) {
      t.updateWorldMatrix(!1, !1);
      const n = t.geometry;
      if (void 0 !== n)
        if (e && null != n.attributes && void 0 !== n.attributes.position) {
          const e = n.attributes.position;
          for (let n = 0, i = e.count; n < i; n++)
            JA.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
              this.expandByPoint(JA);
        } else
          null === n.boundingBox && n.computeBoundingBox(),
            $A.copy(n.boundingBox),
            $A.applyMatrix4(t.matrixWorld),
            this.union($A);
      const i = t.children;
      for (let r = 0, s = i.length; r < s; r++) this.expandByObject(i[r], e);
      return this;
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    }
    getParameter(t, e) {
      return e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, JA),
        JA.distanceToSquared(t.center) <= t.radius * t.radius
      );
    }
    intersectsPlane(t) {
      let e, n;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
        e <= -t.constant && n >= -t.constant
      );
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(sR),
        oR.subVectors(this.max, sR),
        QA.subVectors(t.a, sR),
        tR.subVectors(t.b, sR),
        eR.subVectors(t.c, sR),
        nR.subVectors(tR, QA),
        iR.subVectors(eR, tR),
        rR.subVectors(QA, eR);
      let e = [
        0,
        -nR.z,
        nR.y,
        0,
        -iR.z,
        iR.y,
        0,
        -rR.z,
        rR.y,
        nR.z,
        0,
        -nR.x,
        iR.z,
        0,
        -iR.x,
        rR.z,
        0,
        -rR.x,
        -nR.y,
        nR.x,
        0,
        -iR.y,
        iR.x,
        0,
        -rR.y,
        rR.x,
        0,
      ];
      return (
        !!hR(e, QA, tR, eR, oR) &&
        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!hR(e, QA, tR, eR, oR) &&
          (aR.crossVectors(nR, iR),
          (e = [aR.x, aR.y, aR.z]),
          hR(e, QA, tR, eR, oR)))
      );
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return JA.copy(t).clamp(this.min, this.max).sub(t).length();
    }
    getBoundingSphere(t) {
      return (
        this.getCenter(t.center),
        (t.radius = 0.5 * this.getSize(JA).length()),
        t
      );
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return (
        this.isEmpty() ||
          (ZA[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          ZA[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          ZA[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          ZA[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          ZA[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          ZA[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          ZA[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          ZA[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(ZA)),
        this
      );
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  const ZA = [
      new jA(),
      new jA(),
      new jA(),
      new jA(),
      new jA(),
      new jA(),
      new jA(),
      new jA(),
    ],
    JA = new jA(),
    $A = new KA(),
    QA = new jA(),
    tR = new jA(),
    eR = new jA(),
    nR = new jA(),
    iR = new jA(),
    rR = new jA(),
    sR = new jA(),
    oR = new jA(),
    aR = new jA(),
    lR = new jA();
  function hR(t, e, n, i, r) {
    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
      lR.fromArray(t, s);
      const o =
          r.x * Math.abs(lR.x) + r.y * Math.abs(lR.y) + r.z * Math.abs(lR.z),
        a = e.dot(lR),
        l = n.dot(lR),
        h = i.dot(lR);
      if (Math.max(-Math.max(a, l, h), Math.min(a, l, h)) > o) return !1;
    }
    return !0;
  }
  const uR = new KA(),
    cR = new jA(),
    dR = new jA(),
    pR = new jA();
  class fR {
    constructor(t = new jA(), e = -1) {
      (this.center = t), (this.radius = e);
    }
    set(t, e) {
      return this.center.copy(t), (this.radius = e), this;
    }
    setFromPoints(t, e) {
      const n = this.center;
      void 0 !== e ? n.copy(e) : uR.setFromPoints(t).getCenter(n);
      let i = 0;
      for (let r = 0, s = t.length; r < s; r++)
        i = Math.max(i, n.distanceToSquared(t[r]));
      return (this.radius = Math.sqrt(i)), this;
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return (
        e.copy(t),
        n > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      pR.subVectors(t, this.center);
      const e = pR.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e),
          n = 0.5 * (t - this.radius);
        this.center.add(pR.multiplyScalar(n / t)), (this.radius += n);
      }
      return this;
    }
    union(t) {
      return (
        !0 === this.center.equals(t.center)
          ? dR.set(0, 0, 1).multiplyScalar(t.radius)
          : dR
              .subVectors(t.center, this.center)
              .normalize()
              .multiplyScalar(t.radius),
        this.expandByPoint(cR.copy(t.center).add(dR)),
        this.expandByPoint(cR.copy(t.center).sub(dR)),
        this
      );
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const mR = new jA(),
    _R = new jA(),
    gR = new jA(),
    vR = new jA(),
    yR = new jA(),
    xR = new jA(),
    bR = new jA();
  class TR {
    constructor(t = new jA(), e = new jA(0, 0, -1)) {
      (this.origin = t), (this.direction = e);
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, mR)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0
        ? e.copy(this.origin)
        : e.copy(this.direction).multiplyScalar(n).add(this.origin);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = mR.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (mR.copy(this.direction).multiplyScalar(e).add(this.origin),
          mR.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, i) {
      _R.copy(t).add(e).multiplyScalar(0.5),
        gR.copy(e).sub(t).normalize(),
        vR.copy(this.origin).sub(_R);
      const r = 0.5 * t.distanceTo(e),
        s = -this.direction.dot(gR),
        o = vR.dot(this.direction),
        a = -vR.dot(gR),
        l = vR.lengthSq(),
        h = Math.abs(1 - s * s);
      let u, c, d, p;
      if (h > 0)
        if (((u = s * a - o), (c = s * o - a), (p = r * h), u >= 0))
          if (c >= -p)
            if (c <= p) {
              const t = 1 / h;
              (u *= t),
                (c *= t),
                (d = u * (u + s * c + 2 * o) + c * (s * u + c + 2 * a) + l);
            } else
              (c = r),
                (u = Math.max(0, -(s * c + o))),
                (d = -u * u + c * (c + 2 * a) + l);
          else
            (c = -r),
              (u = Math.max(0, -(s * c + o))),
              (d = -u * u + c * (c + 2 * a) + l);
        else
          c <= -p
            ? ((u = Math.max(0, -(-s * r + o))),
              (c = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
              (d = -u * u + c * (c + 2 * a) + l))
            : c <= p
            ? ((u = 0),
              (c = Math.min(Math.max(-r, -a), r)),
              (d = c * (c + 2 * a) + l))
            : ((u = Math.max(0, -(s * r + o))),
              (c = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
              (d = -u * u + c * (c + 2 * a) + l));
      else
        (c = s > 0 ? -r : r),
          (u = Math.max(0, -(s * c + o))),
          (d = -u * u + c * (c + 2 * a) + l);
      return (
        n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
        i && i.copy(gR).multiplyScalar(c).add(_R),
        d
      );
    }
    intersectSphere(t, e) {
      mR.subVectors(t.center, this.origin);
      const n = mR.dot(this.direction),
        i = mR.dot(mR) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      const s = Math.sqrt(r - i),
        o = n - s,
        a = n + s;
      return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, i, r, s, o, a;
      const l = 1 / this.direction.x,
        h = 1 / this.direction.y,
        u = 1 / this.direction.z,
        c = this.origin;
      return (
        l >= 0
          ? ((n = (t.min.x - c.x) * l), (i = (t.max.x - c.x) * l))
          : ((n = (t.max.x - c.x) * l), (i = (t.min.x - c.x) * l)),
        h >= 0
          ? ((r = (t.min.y - c.y) * h), (s = (t.max.y - c.y) * h))
          : ((r = (t.max.y - c.y) * h), (s = (t.min.y - c.y) * h)),
        n > s || r > i
          ? null
          : ((r > n || n != n) && (n = r),
            (s < i || i != i) && (i = s),
            u >= 0
              ? ((o = (t.min.z - c.z) * u), (a = (t.max.z - c.z) * u))
              : ((o = (t.max.z - c.z) * u), (a = (t.min.z - c.z) * u)),
            n > a || o > i
              ? null
              : ((o > n || n != n) && (n = o),
                (a < i || i != i) && (i = a),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
      );
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, mR);
    }
    intersectTriangle(t, e, n, i, r) {
      yR.subVectors(e, t), xR.subVectors(n, t), bR.crossVectors(yR, xR);
      let s,
        o = this.direction.dot(bR);
      if (o > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(o < 0)) return null;
        (s = -1), (o = -o);
      }
      vR.subVectors(this.origin, t);
      const a = s * this.direction.dot(xR.crossVectors(vR, xR));
      if (a < 0) return null;
      const l = s * this.direction.dot(yR.cross(vR));
      if (l < 0) return null;
      if (a + l > o) return null;
      const h = -s * vR.dot(bR);
      return h < 0 ? null : this.at(h / o, r);
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class ER {
    constructor() {
      (ER.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    set(t, e, n, i, r, s, o, a, l, h, u, c, d, p, f, m) {
      const _ = this.elements;
      return (
        (_[0] = t),
        (_[4] = e),
        (_[8] = n),
        (_[12] = i),
        (_[1] = r),
        (_[5] = s),
        (_[9] = o),
        (_[13] = a),
        (_[2] = l),
        (_[6] = h),
        (_[10] = u),
        (_[14] = c),
        (_[3] = d),
        (_[7] = p),
        (_[11] = f),
        (_[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new ER().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        (e[9] = n[9]),
        (e[10] = n[10]),
        (e[11] = n[11]),
        (e[12] = n[12]),
        (e[13] = n[13]),
        (e[14] = n[14]),
        (e[15] = n[15]),
        this
      );
    }
    copyPosition(t) {
      const e = this.elements,
        n = t.elements;
      return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return (
        this.set(
          e[0],
          e[3],
          e[6],
          0,
          e[1],
          e[4],
          e[7],
          0,
          e[2],
          e[5],
          e[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(t, e, n) {
      return (
        this.set(
          t.x,
          e.x,
          n.x,
          0,
          t.y,
          e.y,
          n.y,
          0,
          t.z,
          e.z,
          n.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(t) {
      const e = this.elements,
        n = t.elements,
        i = 1 / SR.setFromMatrixColumn(t, 0).length(),
        r = 1 / SR.setFromMatrixColumn(t, 1).length(),
        s = 1 / SR.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = n[0] * i),
        (e[1] = n[1] * i),
        (e[2] = n[2] * i),
        (e[3] = 0),
        (e[4] = n[4] * r),
        (e[5] = n[5] * r),
        (e[6] = n[6] * r),
        (e[7] = 0),
        (e[8] = n[8] * s),
        (e[9] = n[9] * s),
        (e[10] = n[10] * s),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromEuler(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        s = Math.cos(n),
        o = Math.sin(n),
        a = Math.cos(i),
        l = Math.sin(i),
        h = Math.cos(r),
        u = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = s * h,
          n = s * u,
          i = o * h,
          r = o * u;
        (e[0] = a * h),
          (e[4] = -a * u),
          (e[8] = l),
          (e[1] = n + i * l),
          (e[5] = t - r * l),
          (e[9] = -o * a),
          (e[2] = r - t * l),
          (e[6] = i + n * l),
          (e[10] = s * a);
      } else if ("YXZ" === t.order) {
        const t = a * h,
          n = a * u,
          i = l * h,
          r = l * u;
        (e[0] = t + r * o),
          (e[4] = i * o - n),
          (e[8] = s * l),
          (e[1] = s * u),
          (e[5] = s * h),
          (e[9] = -o),
          (e[2] = n * o - i),
          (e[6] = r + t * o),
          (e[10] = s * a);
      } else if ("ZXY" === t.order) {
        const t = a * h,
          n = a * u,
          i = l * h,
          r = l * u;
        (e[0] = t - r * o),
          (e[4] = -s * u),
          (e[8] = i + n * o),
          (e[1] = n + i * o),
          (e[5] = s * h),
          (e[9] = r - t * o),
          (e[2] = -s * l),
          (e[6] = o),
          (e[10] = s * a);
      } else if ("ZYX" === t.order) {
        const t = s * h,
          n = s * u,
          i = o * h,
          r = o * u;
        (e[0] = a * h),
          (e[4] = i * l - n),
          (e[8] = t * l + r),
          (e[1] = a * u),
          (e[5] = r * l + t),
          (e[9] = n * l - i),
          (e[2] = -l),
          (e[6] = o * a),
          (e[10] = s * a);
      } else if ("YZX" === t.order) {
        const t = s * a,
          n = s * l,
          i = o * a,
          r = o * l;
        (e[0] = a * h),
          (e[4] = r - t * u),
          (e[8] = i * u + n),
          (e[1] = u),
          (e[5] = s * h),
          (e[9] = -o * h),
          (e[2] = -l * h),
          (e[6] = n * u + i),
          (e[10] = t - r * u);
      } else if ("XZY" === t.order) {
        const t = s * a,
          n = s * l,
          i = o * a,
          r = o * l;
        (e[0] = a * h),
          (e[4] = -u),
          (e[8] = l * h),
          (e[1] = t * u + r),
          (e[5] = s * h),
          (e[9] = n * u - i),
          (e[2] = i * u - n),
          (e[6] = o * h),
          (e[10] = r * u + t);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(t) {
      return this.compose(MR, t, AR);
    }
    lookAt(t, e, n) {
      const i = this.elements;
      return (
        IR.subVectors(t, e),
        0 === IR.lengthSq() && (IR.z = 1),
        IR.normalize(),
        RR.crossVectors(n, IR),
        0 === RR.lengthSq() &&
          (1 === Math.abs(n.z) ? (IR.x += 1e-4) : (IR.z += 1e-4),
          IR.normalize(),
          RR.crossVectors(n, IR)),
        RR.normalize(),
        CR.crossVectors(IR, RR),
        (i[0] = RR.x),
        (i[4] = CR.x),
        (i[8] = IR.x),
        (i[1] = RR.y),
        (i[5] = CR.y),
        (i[9] = IR.y),
        (i[2] = RR.z),
        (i[6] = CR.z),
        (i[10] = IR.z),
        this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        o = n[4],
        a = n[8],
        l = n[12],
        h = n[1],
        u = n[5],
        c = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        _ = n[14],
        g = n[3],
        v = n[7],
        y = n[11],
        x = n[15],
        b = i[0],
        T = i[4],
        E = i[8],
        S = i[12],
        w = i[1],
        M = i[5],
        A = i[9],
        R = i[13],
        C = i[2],
        I = i[6],
        P = i[10],
        O = i[14],
        N = i[3],
        D = i[7],
        L = i[11],
        F = i[15];
      return (
        (r[0] = s * b + o * w + a * C + l * N),
        (r[4] = s * T + o * M + a * I + l * D),
        (r[8] = s * E + o * A + a * P + l * L),
        (r[12] = s * S + o * R + a * O + l * F),
        (r[1] = h * b + u * w + c * C + d * N),
        (r[5] = h * T + u * M + c * I + d * D),
        (r[9] = h * E + u * A + c * P + d * L),
        (r[13] = h * S + u * R + c * O + d * F),
        (r[2] = p * b + f * w + m * C + _ * N),
        (r[6] = p * T + f * M + m * I + _ * D),
        (r[10] = p * E + f * A + m * P + _ * L),
        (r[14] = p * S + f * R + m * O + _ * F),
        (r[3] = g * b + v * w + y * C + x * N),
        (r[7] = g * T + v * M + y * I + x * D),
        (r[11] = g * E + v * A + y * P + x * L),
        (r[15] = g * S + v * R + y * O + x * F),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        s = t[1],
        o = t[5],
        a = t[9],
        l = t[13],
        h = t[2],
        u = t[6],
        c = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * a * u -
            i * l * u -
            r * o * c +
            n * l * c +
            i * o * d -
            n * a * d) +
        t[7] *
          (+e * a * d -
            e * l * c +
            r * s * c -
            i * s * d +
            i * l * h -
            r * a * h) +
        t[11] *
          (+e * l * u -
            e * o * d -
            r * s * u +
            n * s * d +
            r * o * h -
            n * l * h) +
        t[15] *
          (-i * o * h -
            e * a * u +
            e * o * c +
            i * s * u -
            n * s * c +
            n * a * h)
      );
    }
    transpose() {
      const t = this.elements;
      let e;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    }
    setPosition(t, e, n) {
      const i = this.elements;
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = e), (i[14] = n)),
        this
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        o = t[5],
        a = t[6],
        l = t[7],
        h = t[8],
        u = t[9],
        c = t[10],
        d = t[11],
        p = t[12],
        f = t[13],
        m = t[14],
        _ = t[15],
        g =
          u * m * l - f * c * l + f * a * d - o * m * d - u * a * _ + o * c * _,
        v =
          p * c * l - h * m * l - p * a * d + s * m * d + h * a * _ - s * c * _,
        y =
          h * f * l - p * u * l + p * o * d - s * f * d - h * o * _ + s * u * _,
        x =
          p * u * a - h * f * a - p * o * c + s * f * c + h * o * m - s * u * m,
        b = e * g + n * v + i * y + r * x;
      if (0 === b)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const T = 1 / b;
      return (
        (t[0] = g * T),
        (t[1] =
          (f * c * r -
            u * m * r -
            f * i * d +
            n * m * d +
            u * i * _ -
            n * c * _) *
          T),
        (t[2] =
          (o * m * r -
            f * a * r +
            f * i * l -
            n * m * l -
            o * i * _ +
            n * a * _) *
          T),
        (t[3] =
          (u * a * r -
            o * c * r -
            u * i * l +
            n * c * l +
            o * i * d -
            n * a * d) *
          T),
        (t[4] = v * T),
        (t[5] =
          (h * m * r -
            p * c * r +
            p * i * d -
            e * m * d -
            h * i * _ +
            e * c * _) *
          T),
        (t[6] =
          (p * a * r -
            s * m * r -
            p * i * l +
            e * m * l +
            s * i * _ -
            e * a * _) *
          T),
        (t[7] =
          (s * c * r -
            h * a * r +
            h * i * l -
            e * c * l -
            s * i * d +
            e * a * d) *
          T),
        (t[8] = y * T),
        (t[9] =
          (p * u * r -
            h * f * r -
            p * n * d +
            e * f * d +
            h * n * _ -
            e * u * _) *
          T),
        (t[10] =
          (s * f * r -
            p * o * r +
            p * n * l -
            e * f * l -
            s * n * _ +
            e * o * _) *
          T),
        (t[11] =
          (h * o * r -
            s * u * r -
            h * n * l +
            e * u * l +
            s * n * d -
            e * o * d) *
          T),
        (t[12] = x * T),
        (t[13] =
          (h * f * i -
            p * u * i +
            p * n * c -
            e * f * c -
            h * n * m +
            e * u * m) *
          T),
        (t[14] =
          (p * o * i -
            s * f * i -
            p * n * a +
            e * f * a +
            s * n * m -
            e * o * m) *
          T),
        (t[15] =
          (s * u * i -
            h * o * i +
            h * n * a -
            e * u * a -
            s * n * c +
            e * o * c) *
          T),
        this
      );
    }
    scale(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return (
        (e[0] *= n),
        (e[4] *= i),
        (e[8] *= r),
        (e[1] *= n),
        (e[5] *= i),
        (e[9] *= r),
        (e[2] *= n),
        (e[6] *= i),
        (e[10] *= r),
        (e[3] *= n),
        (e[7] *= i),
        (e[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
    makeTranslation(t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        s = t.x,
        o = t.y,
        a = t.z,
        l = r * s,
        h = r * o;
      return (
        this.set(
          l * s + n,
          l * o - i * a,
          l * a + i * o,
          0,
          l * o + i * a,
          h * o + n,
          h * a - i * s,
          0,
          l * a - i * o,
          h * a + i * s,
          r * a * a + n,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, i, r, s) {
      return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      const i = this.elements,
        r = e._x,
        s = e._y,
        o = e._z,
        a = e._w,
        l = r + r,
        h = s + s,
        u = o + o,
        c = r * l,
        d = r * h,
        p = r * u,
        f = s * h,
        m = s * u,
        _ = o * u,
        g = a * l,
        v = a * h,
        y = a * u,
        x = n.x,
        b = n.y,
        T = n.z;
      return (
        (i[0] = (1 - (f + _)) * x),
        (i[1] = (d + y) * x),
        (i[2] = (p - v) * x),
        (i[3] = 0),
        (i[4] = (d - y) * b),
        (i[5] = (1 - (c + _)) * b),
        (i[6] = (m + g) * b),
        (i[7] = 0),
        (i[8] = (p + v) * T),
        (i[9] = (m - g) * T),
        (i[10] = (1 - (c + f)) * T),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      );
    }
    decompose(t, e, n) {
      const i = this.elements;
      let r = SR.set(i[0], i[1], i[2]).length();
      const s = SR.set(i[4], i[5], i[6]).length(),
        o = SR.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        wR.copy(this);
      const a = 1 / r,
        l = 1 / s,
        h = 1 / o;
      return (
        (wR.elements[0] *= a),
        (wR.elements[1] *= a),
        (wR.elements[2] *= a),
        (wR.elements[4] *= l),
        (wR.elements[5] *= l),
        (wR.elements[6] *= l),
        (wR.elements[8] *= h),
        (wR.elements[9] *= h),
        (wR.elements[10] *= h),
        e.setFromRotationMatrix(wR),
        (n.x = r),
        (n.y = s),
        (n.z = o),
        this
      );
    }
    makePerspective(t, e, n, i, r, s) {
      const o = this.elements,
        a = (2 * r) / (e - t),
        l = (2 * r) / (n - i),
        h = (e + t) / (e - t),
        u = (n + i) / (n - i),
        c = -(s + r) / (s - r),
        d = (-2 * s * r) / (s - r);
      return (
        (o[0] = a),
        (o[4] = 0),
        (o[8] = h),
        (o[12] = 0),
        (o[1] = 0),
        (o[5] = l),
        (o[9] = u),
        (o[13] = 0),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = c),
        (o[14] = d),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = -1),
        (o[15] = 0),
        this
      );
    }
    makeOrthographic(t, e, n, i, r, s) {
      const o = this.elements,
        a = 1 / (e - t),
        l = 1 / (n - i),
        h = 1 / (s - r),
        u = (e + t) * a,
        c = (n + i) * l,
        d = (s + r) * h;
      return (
        (o[0] = 2 * a),
        (o[4] = 0),
        (o[8] = 0),
        (o[12] = -u),
        (o[1] = 0),
        (o[5] = 2 * l),
        (o[9] = 0),
        (o[13] = -c),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = -2 * h),
        (o[14] = -d),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = 0),
        (o[15] = 1),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        (t[e + 9] = n[9]),
        (t[e + 10] = n[10]),
        (t[e + 11] = n[11]),
        (t[e + 12] = n[12]),
        (t[e + 13] = n[13]),
        (t[e + 14] = n[14]),
        (t[e + 15] = n[15]),
        t
      );
    }
  }
  const SR = new jA(),
    wR = new ER(),
    MR = new jA(0, 0, 0),
    AR = new jA(1, 1, 1),
    RR = new jA(),
    CR = new jA(),
    IR = new jA(),
    PR = new ER(),
    OR = new WA();
  class NR {
    constructor(t = 0, e = 0, n = 0, i = NR.DefaultOrder) {
      (this.isEuler = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i);
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      (this._order = t), this._onChangeCallback();
    }
    set(t, e, n, i = this._order) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t, e = this._order, n = !0) {
      const i = t.elements,
        r = i[0],
        s = i[4],
        o = i[8],
        a = i[1],
        l = i[5],
        h = i[9],
        u = i[2],
        c = i[6],
        d = i[10];
      switch (e) {
        case "XYZ":
          (this._y = Math.asin(pA(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-s, r)))
              : ((this._x = Math.atan2(c, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-pA(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
              : ((this._y = Math.atan2(-u, r)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(pA(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(a, r)));
          break;
        case "ZYX":
          (this._y = Math.asin(-pA(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._x = Math.atan2(c, d)), (this._z = Math.atan2(a, r)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(pA(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-u, r)))
              : ((this._x = 0), (this._y = Math.atan2(o, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-pA(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(c, l)), (this._y = Math.atan2(o, r)))
              : ((this._x = Math.atan2(-h, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              e
          );
      }
      return (this._order = e), !0 === n && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return (
        PR.makeRotationFromQuaternion(t), this.setFromRotationMatrix(PR, e, n)
      );
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return OR.setFromEuler(this), this.setFromQuaternion(OR, t);
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      );
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._order),
        t
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
    toVector3() {
      console.error(
        "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
      );
    }
  }
  (NR.DefaultOrder = "XYZ"),
    (NR.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
  class DR {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = ((1 << t) | 0) >>> 0;
    }
    enable(t) {
      this.mask |= (1 << t) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= (1 << t) | 0;
    }
    disable(t) {
      this.mask &= ~((1 << t) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return 0 != (this.mask & t.mask);
    }
    isEnabled(t) {
      return 0 != (this.mask & ((1 << t) | 0));
    }
  }
  let LR = 0;
  const FR = new jA(),
    UR = new WA(),
    BR = new ER(),
    kR = new jA(),
    GR = new jA(),
    HR = new jA(),
    zR = new WA(),
    VR = new jA(1, 0, 0),
    XR = new jA(0, 1, 0),
    WR = new jA(0, 0, 1),
    jR = { type: "added" },
    YR = { type: "removed" };
  class qR extends aA {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: LR++ }),
        (this.uuid = dA()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = qR.DefaultUp.clone());
      const t = new jA(),
        e = new NR(),
        n = new WA(),
        i = new jA(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new ER() },
          normalMatrix: { value: new bA() },
        }),
        (this.matrix = new ER()),
        (this.matrixWorld = new ER()),
        (this.matrixAutoUpdate = qR.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new DR()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return UR.setFromAxisAngle(t, e), this.quaternion.multiply(UR), this;
    }
    rotateOnWorldAxis(t, e) {
      return UR.setFromAxisAngle(t, e), this.quaternion.premultiply(UR), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(VR, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(XR, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(WR, t);
    }
    translateOnAxis(t, e) {
      return (
        FR.copy(t).applyQuaternion(this.quaternion),
        this.position.add(FR.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(VR, t);
    }
    translateY(t) {
      return this.translateOnAxis(XR, t);
    }
    translateZ(t) {
      return this.translateOnAxis(WR, t);
    }
    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return t.applyMatrix4(BR.copy(this.matrixWorld).invert());
    }
    lookAt(t, e, n) {
      t.isVector3 ? kR.copy(t) : kR.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(!0, !1),
        GR.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? BR.lookAt(GR, kR, this.up)
          : BR.lookAt(kR, GR, this.up),
        this.quaternion.setFromRotationMatrix(BR),
        i &&
          (BR.extractRotation(i.matrixWorld),
          UR.setFromRotationMatrix(BR),
          this.quaternion.premultiply(UR.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(jR))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t
              ),
          this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(YR)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        (e.parent = null), e.dispatchEvent(YR);
      }
      return (this.children.length = 0), this;
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        BR.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          BR.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(BR),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const i = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== i) return i;
      }
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(GR, t, HR), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(GR, zR, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
    }
    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (
        (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++)
          t[e].updateWorldMatrix(!1, !0);
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        n = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (n.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = "InstancedMesh"),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (i.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (i.background = this.background.toJSON())
            : this.background.isTexture &&
              (i.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            !0 !== this.environment.isRenderTargetTexture &&
            (i.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n))
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              r(t.shapes, i);
            }
          else r(t.shapes, n);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((i.bindMode = this.bindMode),
          (i.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let n = 0, i = this.material.length; n < i; n++)
            e.push(r(t.materials, this.material[n]));
          i.material = e;
        } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let e = 0; e < this.children.length; e++)
          i.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const n = this.animations[e];
          i.animations.push(r(t.animations, n));
        }
      }
      if (e) {
        const e = s(t.geometries),
          i = s(t.materials),
          r = s(t.textures),
          o = s(t.images),
          a = s(t.shapes),
          l = s(t.skeletons),
          h = s(t.animations),
          u = s(t.nodes);
        e.length > 0 && (n.geometries = e),
          i.length > 0 && (n.materials = i),
          r.length > 0 && (n.textures = r),
          o.length > 0 && (n.images = o),
          a.length > 0 && (n.shapes = a),
          l.length > 0 && (n.skeletons = l),
          h.length > 0 && (n.animations = h),
          u.length > 0 && (n.nodes = u);
      }
      return (n.object = i), n;
      function s(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let n = 0; n < t.children.length; n++) {
          const e = t.children[n];
          this.add(e.clone());
        }
      return this;
    }
  }
  (qR.DefaultUp = new jA(0, 1, 0)), (qR.DefaultMatrixAutoUpdate = !0);
  const KR = new jA(),
    ZR = new jA(),
    JR = new jA(),
    $R = new jA(),
    QR = new jA(),
    tC = new jA(),
    eC = new jA(),
    nC = new jA(),
    iC = new jA(),
    rC = new jA();
  class sC {
    constructor(t = new jA(), e = new jA(), n = new jA()) {
      (this.a = t), (this.b = e), (this.c = n);
    }
    static getNormal(t, e, n, i) {
      i.subVectors(n, e), KR.subVectors(t, e), i.cross(KR);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, i, r) {
      KR.subVectors(i, e), ZR.subVectors(n, e), JR.subVectors(t, e);
      const s = KR.dot(KR),
        o = KR.dot(ZR),
        a = KR.dot(JR),
        l = ZR.dot(ZR),
        h = ZR.dot(JR),
        u = s * l - o * o;
      if (0 === u) return r.set(-2, -1, -1);
      const c = 1 / u,
        d = (l * a - o * h) * c,
        p = (s * h - o * a) * c;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(t, e, n, i) {
      return (
        this.getBarycoord(t, e, n, i, $R),
        $R.x >= 0 && $R.y >= 0 && $R.x + $R.y <= 1
      );
    }
    static getUV(t, e, n, i, r, s, o, a) {
      return (
        this.getBarycoord(t, e, n, i, $R),
        a.set(0, 0),
        a.addScaledVector(r, $R.x),
        a.addScaledVector(s, $R.y),
        a.addScaledVector(o, $R.z),
        a
      );
    }
    static isFrontFacing(t, e, n, i) {
      return KR.subVectors(n, e), ZR.subVectors(t, e), KR.cross(ZR).dot(i) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
    setFromAttributeAndIndices(t, e, n, i) {
      return (
        this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, n),
        this.c.fromBufferAttribute(t, i),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return (
        KR.subVectors(this.c, this.b),
        ZR.subVectors(this.a, this.b),
        0.5 * KR.cross(ZR).length()
      );
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return sC.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return sC.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getUV(t, e, n, i, r) {
      return sC.getUV(t, this.a, this.b, this.c, e, n, i, r);
    }
    containsPoint(t) {
      return sC.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return sC.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const n = this.a,
        i = this.b,
        r = this.c;
      let s, o;
      QR.subVectors(i, n), tC.subVectors(r, n), nC.subVectors(t, n);
      const a = QR.dot(nC),
        l = tC.dot(nC);
      if (a <= 0 && l <= 0) return e.copy(n);
      iC.subVectors(t, i);
      const h = QR.dot(iC),
        u = tC.dot(iC);
      if (h >= 0 && u <= h) return e.copy(i);
      const c = a * u - h * l;
      if (c <= 0 && a >= 0 && h <= 0)
        return (s = a / (a - h)), e.copy(n).addScaledVector(QR, s);
      rC.subVectors(t, r);
      const d = QR.dot(rC),
        p = tC.dot(rC);
      if (p >= 0 && d <= p) return e.copy(r);
      const f = d * l - a * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (o = l / (l - p)), e.copy(n).addScaledVector(tC, o);
      const m = h * p - d * u;
      if (m <= 0 && u - h >= 0 && d - p >= 0)
        return (
          eC.subVectors(r, i),
          (o = (u - h) / (u - h + (d - p))),
          e.copy(i).addScaledVector(eC, o)
        );
      const _ = 1 / (m + f + c);
      return (
        (s = f * _),
        (o = c * _),
        e.copy(n).addScaledVector(QR, s).addScaledVector(tC, o)
      );
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }
  let oC = 0;
  class aC extends aA {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: oC++ }),
        (this.uuid = dA()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = wM),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = iA),
        (this.stencilZFail = iA),
        (this.stencilZPass = iA),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const n = t[e];
          if (void 0 === n) {
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
            continue;
          }
          if ("shading" === e) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === n);
            continue;
          }
          const i = this[e];
          void 0 !== i
            ? i && i.isColor
              ? i.set(n)
              : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
            : console.warn(
                "THREE." +
                  this.type +
                  ": '" +
                  e +
                  "' is not a property of this material."
              );
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = { textures: {}, images: {} });
      const n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function i(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        void 0 !== this.sheen && (n.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (n.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (n.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (n.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (n.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        void 0 !== this.iridescence && (n.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR &&
          (n.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange &&
          (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (n.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((n.lightMap = this.lightMap.toJSON(t).uuid),
          (n.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(t).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid),
          void 0 !== this.combine && (n.combine = this.combine)),
        void 0 !== this.envMapIntensity &&
          (n.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (n.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (n.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (n.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance &&
          (n.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (n.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (n.size = this.size),
        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        0 !== this.side && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        (n.depthFunc = this.depthFunc),
        (n.depthTest = this.depthTest),
        (n.depthWrite = this.depthWrite),
        (n.colorWrite = this.colorWrite),
        (n.stencilWrite = this.stencilWrite),
        (n.stencilWriteMask = this.stencilWriteMask),
        (n.stencilFunc = this.stencilFunc),
        (n.stencilRef = this.stencilRef),
        (n.stencilFuncMask = this.stencilFuncMask),
        (n.stencilFail = this.stencilFail),
        (n.stencilZFail = this.stencilZFail),
        (n.stencilZPass = this.stencilZPass),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.alphaToCoverage &&
          (n.alphaToCoverage = this.alphaToCoverage),
        !0 === this.premultipliedAlpha &&
          (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        !1 === this.fog && (n.fog = !1),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        e)
      ) {
        const e = i(t.textures),
          r = i(t.images);
        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.name = t.name),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      const e = t.clippingPlanes;
      let n = null;
      if (null !== e) {
        const t = e.length;
        n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  class lC extends aC {
    constructor(t) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new DA(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const hC = new jA(),
    uC = new xA();
  class cC {
    constructor(t, e, n) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === n),
        (this.usage = rA),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.itemSize), (n *= e.itemSize);
      for (let i = 0, r = this.itemSize; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    copyColorsArray(t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyColorsArray(): color is undefined",
            i
          ),
          (r = new DA())),
          (e[n++] = r.r),
          (e[n++] = r.g),
          (e[n++] = r.b);
      }
      return this;
    }
    copyVector2sArray(t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
            i
          ),
          (r = new xA())),
          (e[n++] = r.x),
          (e[n++] = r.y);
      }
      return this;
    }
    copyVector3sArray(t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
            i
          ),
          (r = new jA())),
          (e[n++] = r.x),
          (e[n++] = r.y),
          (e[n++] = r.z);
      }
      return this;
    }
    copyVector4sArray(t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
            i
          ),
          (r = new HA())),
          (e[n++] = r.x),
          (e[n++] = r.y),
          (e[n++] = r.z),
          (e[n++] = r.w);
      }
      return this;
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          uC.fromBufferAttribute(this, e),
            uC.applyMatrix3(t),
            this.setXY(e, uC.x, uC.y);
      else if (3 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          hC.fromBufferAttribute(this, e),
            hC.applyMatrix3(t),
            this.setXYZ(e, hC.x, hC.y, hC.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++)
        hC.fromBufferAttribute(this, e),
          hC.applyMatrix4(t),
          this.setXYZ(e, hC.x, hC.y, hC.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        hC.fromBufferAttribute(this, e),
          hC.applyNormalMatrix(t),
          this.setXYZ(e, hC.x, hC.y, hC.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        hC.fromBufferAttribute(this, e),
          hC.transformDirection(t),
          this.setXYZ(e, hC.x, hC.y, hC.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getX(t) {
      return this.array[t * this.itemSize];
    }
    setX(t, e) {
      return (this.array[t * this.itemSize] = e), this;
    }
    getY(t) {
      return this.array[t * this.itemSize + 1];
    }
    setY(t, e) {
      return (this.array[t * this.itemSize + 1] = e), this;
    }
    getZ(t) {
      return this.array[t * this.itemSize + 2];
    }
    setZ(t, e) {
      return (this.array[t * this.itemSize + 2] = e), this;
    }
    getW(t) {
      return this.array[t * this.itemSize + 3];
    }
    setW(t, e) {
      return (this.array[t * this.itemSize + 3] = e), this;
    }
    setXY(t, e, n) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        (this.array[t + 3] = r),
        this
      );
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (t.name = this.name),
        this.usage !== rA && (t.usage = this.usage),
        (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
          (t.updateRange = this.updateRange),
        t
      );
    }
  }
  class dC extends cC {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  }
  class pC extends cC {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  }
  class fC extends cC {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  }
  let mC = 0;
  const _C = new ER(),
    gC = new qR(),
    vC = new jA(),
    yC = new KA(),
    xC = new KA(),
    bC = new jA();
  class TC extends aA {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: mC++ }),
        (this.uuid = dA()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (TA(t) ? pC : dC)(t, 1))
          : (this.index = t),
        this
      );
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return (this.attributes[t] = e), this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
    addGroup(t, e, n = 0) {
      this.groups.push({ start: t, count: e, materialIndex: n });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const e = new bA().getNormalMatrix(t);
        n.applyNormalMatrix(e), (n.needsUpdate = !0);
      }
      const i = this.attributes.tangent;
      return (
        void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(t) {
      return _C.makeRotationFromQuaternion(t), this.applyMatrix4(_C), this;
    }
    rotateX(t) {
      return _C.makeRotationX(t), this.applyMatrix4(_C), this;
    }
    rotateY(t) {
      return _C.makeRotationY(t), this.applyMatrix4(_C), this;
    }
    rotateZ(t) {
      return _C.makeRotationZ(t), this.applyMatrix4(_C), this;
    }
    translate(t, e, n) {
      return _C.makeTranslation(t, e, n), this.applyMatrix4(_C), this;
    }
    scale(t, e, n) {
      return _C.makeScale(t, e, n), this.applyMatrix4(_C), this;
    }
    lookAt(t) {
      return (
        gC.lookAt(t), gC.updateMatrix(), this.applyMatrix4(gC.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(vC).negate(),
        this.translate(vC.x, vC.y, vC.z),
        this
      );
    }
    setFromPoints(t) {
      const e = [];
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.push(i.x, i.y, i.z || 0);
      }
      return this.setAttribute("position", new fC(e, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new KA());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingBox.set(
            new jA(-1 / 0, -1 / 0, -1 / 0),
            new jA(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (let n = 0, i = e.length; n < i; n++) {
            const t = e[n];
            yC.setFromBufferAttribute(t),
              this.morphTargetsRelative
                ? (bC.addVectors(this.boundingBox.min, yC.min),
                  this.boundingBox.expandByPoint(bC),
                  bC.addVectors(this.boundingBox.max, yC.max),
                  this.boundingBox.expandByPoint(bC))
                : (this.boundingBox.expandByPoint(yC.min),
                  this.boundingBox.expandByPoint(yC.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new fR());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingSphere.set(new jA(), 1 / 0)
        );
      if (t) {
        const n = this.boundingSphere.center;
        if ((yC.setFromBufferAttribute(t), e))
          for (let t = 0, r = e.length; t < r; t++) {
            const n = e[t];
            xC.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (bC.addVectors(yC.min, xC.min),
                  yC.expandByPoint(bC),
                  bC.addVectors(yC.max, xC.max),
                  yC.expandByPoint(bC))
                : (yC.expandByPoint(xC.min), yC.expandByPoint(xC.max));
          }
        yC.getCenter(n);
        let i = 0;
        for (let e = 0, r = t.count; e < r; e++)
          bC.fromBufferAttribute(t, e),
            (i = Math.max(i, n.distanceToSquared(bC)));
        if (e)
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              o = this.morphTargetsRelative;
            for (let e = 0, r = s.count; e < r; e++)
              bC.fromBufferAttribute(s, e),
                o && (vC.fromBufferAttribute(t, e), bC.add(vC)),
                (i = Math.max(i, n.distanceToSquared(bC)));
          }
        (this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      const t = this.index,
        e = this.attributes;
      if (
        null === t ||
        void 0 === e.position ||
        void 0 === e.normal ||
        void 0 === e.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
      const n = t.array,
        i = e.position.array,
        r = e.normal.array,
        s = e.uv.array,
        o = i.length / 3;
      !1 === this.hasAttribute("tangent") &&
        this.setAttribute("tangent", new cC(new Float32Array(4 * o), 4));
      const a = this.getAttribute("tangent").array,
        l = [],
        h = [];
      for (let w = 0; w < o; w++) (l[w] = new jA()), (h[w] = new jA());
      const u = new jA(),
        c = new jA(),
        d = new jA(),
        p = new xA(),
        f = new xA(),
        m = new xA(),
        _ = new jA(),
        g = new jA();
      function v(t, e, n) {
        u.fromArray(i, 3 * t),
          c.fromArray(i, 3 * e),
          d.fromArray(i, 3 * n),
          p.fromArray(s, 2 * t),
          f.fromArray(s, 2 * e),
          m.fromArray(s, 2 * n),
          c.sub(u),
          d.sub(u),
          f.sub(p),
          m.sub(p);
        const r = 1 / (f.x * m.y - m.x * f.y);
        isFinite(r) &&
          (_.copy(c)
            .multiplyScalar(m.y)
            .addScaledVector(d, -f.y)
            .multiplyScalar(r),
          g
            .copy(d)
            .multiplyScalar(f.x)
            .addScaledVector(c, -m.x)
            .multiplyScalar(r),
          l[t].add(_),
          l[e].add(_),
          l[n].add(_),
          h[t].add(g),
          h[e].add(g),
          h[n].add(g));
      }
      let y = this.groups;
      0 === y.length && (y = [{ start: 0, count: n.length }]);
      for (let w = 0, M = y.length; w < M; ++w) {
        const t = y[w],
          e = t.start;
        for (let i = e, r = e + t.count; i < r; i += 3)
          v(n[i + 0], n[i + 1], n[i + 2]);
      }
      const x = new jA(),
        b = new jA(),
        T = new jA(),
        E = new jA();
      function S(t) {
        T.fromArray(r, 3 * t), E.copy(T);
        const e = l[t];
        x.copy(e),
          x.sub(T.multiplyScalar(T.dot(e))).normalize(),
          b.crossVectors(E, e);
        const n = b.dot(h[t]) < 0 ? -1 : 1;
        (a[4 * t] = x.x),
          (a[4 * t + 1] = x.y),
          (a[4 * t + 2] = x.z),
          (a[4 * t + 3] = n);
      }
      for (let w = 0, M = y.length; w < M; ++w) {
        const t = y[w],
          e = t.start;
        for (let i = e, r = e + t.count; i < r; i += 3)
          S(n[i + 0]), S(n[i + 1]), S(n[i + 2]);
      }
    }
    computeVertexNormals() {
      const t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        let n = this.getAttribute("normal");
        if (void 0 === n)
          (n = new cC(new Float32Array(3 * e.count), 3)),
            this.setAttribute("normal", n);
        else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
        const i = new jA(),
          r = new jA(),
          s = new jA(),
          o = new jA(),
          a = new jA(),
          l = new jA(),
          h = new jA(),
          u = new jA();
        if (t)
          for (let c = 0, d = t.count; c < d; c += 3) {
            const d = t.getX(c + 0),
              p = t.getX(c + 1),
              f = t.getX(c + 2);
            i.fromBufferAttribute(e, d),
              r.fromBufferAttribute(e, p),
              s.fromBufferAttribute(e, f),
              h.subVectors(s, r),
              u.subVectors(i, r),
              h.cross(u),
              o.fromBufferAttribute(n, d),
              a.fromBufferAttribute(n, p),
              l.fromBufferAttribute(n, f),
              o.add(h),
              a.add(h),
              l.add(h),
              n.setXYZ(d, o.x, o.y, o.z),
              n.setXYZ(p, a.x, a.y, a.z),
              n.setXYZ(f, l.x, l.y, l.z);
          }
        else
          for (let t = 0, c = e.count; t < c; t += 3)
            i.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              s.fromBufferAttribute(e, t + 2),
              h.subVectors(s, r),
              u.subVectors(i, r),
              h.cross(u),
              n.setXYZ(t + 0, h.x, h.y, h.z),
              n.setXYZ(t + 1, h.x, h.y, h.z),
              n.setXYZ(t + 2, h.x, h.y, h.z);
        this.normalizeNormals(), (n.needsUpdate = !0);
      }
    }
    merge(t, e) {
      if (!t || !t.isBufferGeometry)
        return void console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          t
        );
      void 0 === e &&
        ((e = 0),
        console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
      const n = this.attributes;
      for (const i in n) {
        if (void 0 === t.attributes[i]) continue;
        const r = n[i].array,
          s = t.attributes[i],
          o = s.array,
          a = s.itemSize * e,
          l = Math.min(o.length, r.length - a);
        for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t];
      }
      return this;
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++)
        bC.fromBufferAttribute(t, e),
          bC.normalize(),
          t.setXYZ(e, bC.x, bC.y, bC.z);
    }
    toNonIndexed() {
      function t(t, e) {
        const n = t.array,
          i = t.itemSize,
          r = t.normalized,
          s = new n.constructor(e.length * i);
        let o = 0,
          a = 0;
        for (let l = 0, h = e.length; l < h; l++) {
          o = t.isInterleavedBufferAttribute
            ? e[l] * t.data.stride + t.offset
            : e[l] * i;
          for (let t = 0; t < i; t++) s[a++] = n[o++];
        }
        return new cC(s, i, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      const e = new TC(),
        n = this.index.array,
        i = this.attributes;
      for (const o in i) {
        const r = t(i[o], n);
        e.setAttribute(o, r);
      }
      const r = this.morphAttributes;
      for (const o in r) {
        const i = [],
          s = r[o];
        for (let e = 0, r = s.length; e < r; e++) {
          const r = t(s[e], n);
          i.push(r);
        }
        e.morphAttributes[o] = i;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const s = this.groups;
      for (let o = 0, a = s.length; o < a; o++) {
        const t = s[o];
        e.addGroup(t.start, t.count, t.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      t.data = { attributes: {} };
      const e = this.index;
      null !== e &&
        (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array),
        });
      const n = this.attributes;
      for (const a in n) {
        const e = n[a];
        t.data.attributes[a] = e.toJSON(t.data);
      }
      const i = {};
      let r = !1;
      for (const a in this.morphAttributes) {
        const e = this.morphAttributes[a],
          n = [];
        for (let i = 0, r = e.length; i < r; i++) {
          const r = e[i];
          n.push(r.toJSON(t.data));
        }
        n.length > 0 && ((i[a] = n), (r = !0));
      }
      r &&
        ((t.data.morphAttributes = i),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const o = this.boundingSphere;
      return (
        null !== o &&
          (t.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius,
          }),
        t
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const e = {};
      this.name = t.name;
      const n = t.index;
      null !== n && this.setIndex(n.clone(e));
      const i = t.attributes;
      for (const l in i) {
        const t = i[l];
        this.setAttribute(l, t.clone(e));
      }
      const r = t.morphAttributes;
      for (const l in r) {
        const t = [],
          n = r[l];
        for (let i = 0, r = n.length; i < r; i++) t.push(n[i].clone(e));
        this.morphAttributes[l] = t;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const s = t.groups;
      for (let l = 0, h = s.length; l < h; l++) {
        const t = s[l];
        this.addGroup(t.start, t.count, t.materialIndex);
      }
      const o = t.boundingBox;
      null !== o && (this.boundingBox = o.clone());
      const a = t.boundingSphere;
      return (
        null !== a && (this.boundingSphere = a.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        void 0 !== t.parameters &&
          (this.parameters = Object.assign({}, t.parameters)),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const EC = new ER(),
    SC = new TR(),
    wC = new fR(),
    MC = new jA(),
    AC = new jA(),
    RC = new jA(),
    CC = new jA(),
    IC = new jA(),
    PC = new jA(),
    OC = new jA(),
    NC = new jA(),
    DC = new jA(),
    LC = new xA(),
    FC = new xA(),
    UC = new xA(),
    BC = new jA(),
    kC = new jA();
  class GC extends qR {
    constructor(t = new TC(), e = new lC()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary
          )),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 === i) return;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        wC.copy(n.boundingSphere),
        wC.applyMatrix4(r),
        !1 === t.ray.intersectsSphere(wC))
      )
        return;
      if (
        (EC.copy(r).invert(),
        SC.copy(t.ray).applyMatrix4(EC),
        null !== n.boundingBox && !1 === SC.intersectsBox(n.boundingBox))
      )
        return;
      let s;
      const o = n.index,
        a = n.attributes.position,
        l = n.morphAttributes.position,
        h = n.morphTargetsRelative,
        u = n.attributes.uv,
        c = n.attributes.uv2,
        d = n.groups,
        p = n.drawRange;
      if (null !== o)
        if (Array.isArray(i))
          for (let f = 0, m = d.length; f < m; f++) {
            const n = d[f],
              r = i[n.materialIndex];
            for (
              let i = Math.max(n.start, p.start),
                d = Math.min(
                  o.count,
                  Math.min(n.start + n.count, p.start + p.count)
                );
              i < d;
              i += 3
            ) {
              const d = o.getX(i),
                p = o.getX(i + 1),
                f = o.getX(i + 2);
              (s = HC(this, r, t, SC, a, l, h, u, c, d, p, f)),
                s &&
                  ((s.faceIndex = Math.floor(i / 3)),
                  (s.face.materialIndex = n.materialIndex),
                  e.push(s));
            }
          }
        else {
          for (
            let n = Math.max(0, p.start),
              r = Math.min(o.count, p.start + p.count);
            n < r;
            n += 3
          ) {
            const r = o.getX(n),
              d = o.getX(n + 1),
              p = o.getX(n + 2);
            (s = HC(this, i, t, SC, a, l, h, u, c, r, d, p)),
              s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
          }
        }
      else if (void 0 !== a)
        if (Array.isArray(i))
          for (let f = 0, m = d.length; f < m; f++) {
            const n = d[f],
              r = i[n.materialIndex];
            for (
              let i = Math.max(n.start, p.start),
                o = Math.min(
                  a.count,
                  Math.min(n.start + n.count, p.start + p.count)
                );
              i < o;
              i += 3
            ) {
              (s = HC(this, r, t, SC, a, l, h, u, c, i, i + 1, i + 2)),
                s &&
                  ((s.faceIndex = Math.floor(i / 3)),
                  (s.face.materialIndex = n.materialIndex),
                  e.push(s));
            }
          }
        else {
          for (
            let n = Math.max(0, p.start),
              r = Math.min(a.count, p.start + p.count);
            n < r;
            n += 3
          ) {
            (s = HC(this, i, t, SC, a, l, h, u, c, n, n + 1, n + 2)),
              s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
          }
        }
    }
  }
  function HC(t, e, n, i, r, s, o, a, l, h, u, c) {
    MC.fromBufferAttribute(r, h),
      AC.fromBufferAttribute(r, u),
      RC.fromBufferAttribute(r, c);
    const d = t.morphTargetInfluences;
    if (s && d) {
      OC.set(0, 0, 0), NC.set(0, 0, 0), DC.set(0, 0, 0);
      for (let t = 0, e = s.length; t < e; t++) {
        const e = d[t],
          n = s[t];
        0 !== e &&
          (CC.fromBufferAttribute(n, h),
          IC.fromBufferAttribute(n, u),
          PC.fromBufferAttribute(n, c),
          o
            ? (OC.addScaledVector(CC, e),
              NC.addScaledVector(IC, e),
              DC.addScaledVector(PC, e))
            : (OC.addScaledVector(CC.sub(MC), e),
              NC.addScaledVector(IC.sub(AC), e),
              DC.addScaledVector(PC.sub(RC), e)));
      }
      MC.add(OC), AC.add(NC), RC.add(DC);
    }
    t.isSkinnedMesh &&
      (t.boneTransform(h, MC), t.boneTransform(u, AC), t.boneTransform(c, RC));
    const p = (function (t, e, n, i, r, s, o, a) {
      let l;
      if (
        ((l =
          1 === e.side
            ? i.intersectTriangle(o, s, r, !0, a)
            : i.intersectTriangle(r, s, o, 2 !== e.side, a)),
        null === l)
      )
        return null;
      kC.copy(a), kC.applyMatrix4(t.matrixWorld);
      const h = n.ray.origin.distanceTo(kC);
      return h < n.near || h > n.far
        ? null
        : { distance: h, point: kC.clone(), object: t };
    })(t, e, n, i, MC, AC, RC, BC);
    if (p) {
      a &&
        (LC.fromBufferAttribute(a, h),
        FC.fromBufferAttribute(a, u),
        UC.fromBufferAttribute(a, c),
        (p.uv = sC.getUV(BC, MC, AC, RC, LC, FC, UC, new xA()))),
        l &&
          (LC.fromBufferAttribute(l, h),
          FC.fromBufferAttribute(l, u),
          UC.fromBufferAttribute(l, c),
          (p.uv2 = sC.getUV(BC, MC, AC, RC, LC, FC, UC, new xA())));
      const t = { a: h, b: u, c: c, normal: new jA(), materialIndex: 0 };
      sC.getNormal(MC, AC, RC, t.normal), (p.face = t);
    }
    return p;
  }
  class zC extends TC {
    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
      super(),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: s,
        });
      const o = this;
      (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
      const a = [],
        l = [],
        h = [],
        u = [];
      let c = 0,
        d = 0;
      function p(t, e, n, i, r, s, p, f, m, _, g) {
        const v = s / m,
          y = p / _,
          x = s / 2,
          b = p / 2,
          T = f / 2,
          E = m + 1,
          S = _ + 1;
        let w = 0,
          M = 0;
        const A = new jA();
        for (let o = 0; o < S; o++) {
          const s = o * y - b;
          for (let a = 0; a < E; a++) {
            const c = a * v - x;
            (A[t] = c * i),
              (A[e] = s * r),
              (A[n] = T),
              l.push(A.x, A.y, A.z),
              (A[t] = 0),
              (A[e] = 0),
              (A[n] = f > 0 ? 1 : -1),
              h.push(A.x, A.y, A.z),
              u.push(a / m),
              u.push(1 - o / _),
              (w += 1);
          }
        }
        for (let o = 0; o < _; o++)
          for (let t = 0; t < m; t++) {
            const e = c + t + E * o,
              n = c + t + E * (o + 1),
              i = c + (t + 1) + E * (o + 1),
              r = c + (t + 1) + E * o;
            a.push(e, n, r), a.push(n, i, r), (M += 6);
          }
        o.addGroup(d, M, g), (d += M), (c += w);
      }
      p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
        p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
        p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
        p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
        p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(a),
        this.setAttribute("position", new fC(l, 3)),
        this.setAttribute("normal", new fC(h, 3)),
        this.setAttribute("uv", new fC(u, 2));
    }
    static fromJSON(t) {
      return new zC(
        t.width,
        t.height,
        t.depth,
        t.widthSegments,
        t.heightSegments,
        t.depthSegments
      );
    }
  }
  function VC(t) {
    const e = {};
    for (const n in t) {
      e[n] = {};
      for (const i in t[n]) {
        const r = t[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture ||
          r.isQuaternion)
          ? (e[n][i] = r.clone())
          : Array.isArray(r)
          ? (e[n][i] = r.slice())
          : (e[n][i] = r);
      }
    }
    return e;
  }
  function XC(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const i = VC(t[n]);
      for (const t in i) e[t] = i[t];
    }
    return e;
  }
  const WC = { clone: VC, merge: XC };
  class jC extends aC {
    constructor(t) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(t));
    }
    copy(t) {
      return (
        super.copy(t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = VC(t.uniforms)),
        (this.uniformsGroups = (function (t) {
          const e = [];
          for (let n = 0; n < t.length; n++) e.push(t[n].clone());
          return e;
        })(t.uniformsGroups)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.extensions = Object.assign({}, t.extensions)),
        (this.glslVersion = t.glslVersion),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      (e.glslVersion = this.glslVersion), (e.uniforms = {});
      for (const i in this.uniforms) {
        const n = this.uniforms[i].value;
        n && n.isTexture
          ? (e.uniforms[i] = { type: "t", value: n.toJSON(t).uuid })
          : n && n.isColor
          ? (e.uniforms[i] = { type: "c", value: n.getHex() })
          : n && n.isVector2
          ? (e.uniforms[i] = { type: "v2", value: n.toArray() })
          : n && n.isVector3
          ? (e.uniforms[i] = { type: "v3", value: n.toArray() })
          : n && n.isVector4
          ? (e.uniforms[i] = { type: "v4", value: n.toArray() })
          : n && n.isMatrix3
          ? (e.uniforms[i] = { type: "m3", value: n.toArray() })
          : n && n.isMatrix4
          ? (e.uniforms[i] = { type: "m4", value: n.toArray() })
          : (e.uniforms[i] = { value: n });
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader);
      const n = {};
      for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }
  class YC extends qR {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new ER()),
        (this.projectionMatrix = new ER()),
        (this.projectionMatrixInverse = new ER());
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        this
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class qC extends YC {
    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = n),
        (this.far = i),
        (this.focus = 10),
        (this.aspect = e),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    }
    setFocalLength(t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * cA * Math.atan(e)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(0.5 * uA * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    }
    getEffectiveFOV() {
      return 2 * cA * Math.atan(Math.tan(0.5 * uA * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e, n, i, r, s) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = (t * Math.tan(0.5 * uA * this.fov)) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -0.5 * i;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          o = s.fullHeight;
        (r += (s.offsetX * i) / t),
          (e -= (s.offsetY * n) / o),
          (i *= s.width / t),
          (n *= s.height / o);
      }
      const o = this.filmOffset;
      0 !== o && (r += (t * o) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    }
  }
  const KC = 90;
  class ZC extends qR {
    constructor(t, e, n) {
      if (
        (super(), (this.type = "CubeCamera"), !0 !== n.isWebGLCubeRenderTarget)
      )
        return void console.error(
          "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
        );
      this.renderTarget = n;
      const i = new qC(KC, 1, t, e);
      (i.layers = this.layers),
        i.up.set(0, -1, 0),
        i.lookAt(new jA(1, 0, 0)),
        this.add(i);
      const r = new qC(KC, 1, t, e);
      (r.layers = this.layers),
        r.up.set(0, -1, 0),
        r.lookAt(new jA(-1, 0, 0)),
        this.add(r);
      const s = new qC(KC, 1, t, e);
      (s.layers = this.layers),
        s.up.set(0, 0, 1),
        s.lookAt(new jA(0, 1, 0)),
        this.add(s);
      const o = new qC(KC, 1, t, e);
      (o.layers = this.layers),
        o.up.set(0, 0, -1),
        o.lookAt(new jA(0, -1, 0)),
        this.add(o);
      const a = new qC(KC, 1, t, e);
      (a.layers = this.layers),
        a.up.set(0, -1, 0),
        a.lookAt(new jA(0, 0, 1)),
        this.add(a);
      const l = new qC(KC, 1, t, e);
      (l.layers = this.layers),
        l.up.set(0, -1, 0),
        l.lookAt(new jA(0, 0, -1)),
        this.add(l);
    }
    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const n = this.renderTarget,
        [i, r, s, o, a, l] = this.children,
        h = t.getRenderTarget(),
        u = t.toneMapping,
        c = t.xr.enabled;
      (t.toneMapping = 0), (t.xr.enabled = !1);
      const d = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        t.setRenderTarget(n, 0),
        t.render(e, i),
        t.setRenderTarget(n, 1),
        t.render(e, r),
        t.setRenderTarget(n, 2),
        t.render(e, s),
        t.setRenderTarget(n, 3),
        t.render(e, o),
        t.setRenderTarget(n, 4),
        t.render(e, a),
        (n.texture.generateMipmaps = d),
        t.setRenderTarget(n, 5),
        t.render(e, l),
        t.setRenderTarget(h),
        (t.toneMapping = u),
        (t.xr.enabled = c),
        (n.texture.needsPMREMUpdate = !0);
    }
  }
  class JC extends GA {
    constructor(t, e, n, i, r, s, o, a, l, h) {
      super(
        (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : MM),
        n,
        i,
        r,
        s,
        o,
        a,
        l,
        h
      ),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  }
  class $C extends zA {
    constructor(t, e = {}) {
      super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
      const n = { width: t, height: t, depth: 1 },
        i = [n, n, n, n, n, n];
      (this.texture = new JC(
        i,
        e.mapping,
        e.wrapS,
        e.wrapT,
        e.magFilter,
        e.minFilter,
        e.format,
        e.type,
        e.anisotropy,
        e.encoding
      )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          void 0 !== e.generateMipmaps && e.generateMipmaps),
        (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : LM);
    }
    fromEquirectangularTexture(t, e) {
      (this.texture.type = e.type),
        (this.texture.encoding = e.encoding),
        (this.texture.generateMipmaps = e.generateMipmaps),
        (this.texture.minFilter = e.minFilter),
        (this.texture.magFilter = e.magFilter);
      const n = {
          uniforms: { tEquirect: { value: null } },
          vertexShader:
            "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
          fragmentShader:
            "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
        },
        i = new zC(5, 5, 5),
        r = new jC({
          name: "CubemapFromEquirect",
          uniforms: VC(n.uniforms),
          vertexShader: n.vertexShader,
          fragmentShader: n.fragmentShader,
          side: 1,
          blending: 0,
        });
      r.uniforms.tEquirect.value = e;
      const s = new GC(i, r),
        o = e.minFilter;
      e.minFilter === FM && (e.minFilter = LM);
      return (
        new ZC(1, 10, this).update(t, s),
        (e.minFilter = o),
        s.geometry.dispose(),
        s.material.dispose(),
        this
      );
    }
    clear(t, e, n, i) {
      const r = t.getRenderTarget();
      for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, i);
      t.setRenderTarget(r);
    }
  }
  const QC = new jA(),
    tI = new jA(),
    eI = new bA();
  class nI {
    constructor(t = new jA(1, 0, 0), e = 0) {
      (this.isPlane = !0), (this.normal = t), (this.constant = e);
    }
    set(t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    }
    setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), (this.constant = i), this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    }
    setFromCoplanarPoints(t, e, n) {
      const i = QC.subVectors(n, e).cross(tI.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e
        .copy(this.normal)
        .multiplyScalar(-this.distanceToPoint(t))
        .add(t);
    }
    intersectLine(t, e) {
      const n = t.delta(QC),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return (e < 0 && n > 0) || (n < 0 && e > 0);
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const n = e || eI.getNormalMatrix(t),
        i = this.coplanarPoint(QC).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const iI = new fR(),
    rI = new jA();
  class sI {
    constructor(
      t = new nI(),
      e = new nI(),
      n = new nI(),
      i = new nI(),
      r = new nI(),
      s = new nI()
    ) {
      this.planes = [t, e, n, i, r, s];
    }
    set(t, e, n, i, r, s) {
      const o = this.planes;
      return (
        o[0].copy(t),
        o[1].copy(e),
        o[2].copy(n),
        o[3].copy(i),
        o[4].copy(r),
        o[5].copy(s),
        this
      );
    }
    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t) {
      const e = this.planes,
        n = t.elements,
        i = n[0],
        r = n[1],
        s = n[2],
        o = n[3],
        a = n[4],
        l = n[5],
        h = n[6],
        u = n[7],
        c = n[8],
        d = n[9],
        p = n[10],
        f = n[11],
        m = n[12],
        _ = n[13],
        g = n[14],
        v = n[15];
      return (
        e[0].setComponents(o - i, u - a, f - c, v - m).normalize(),
        e[1].setComponents(o + i, u + a, f + c, v + m).normalize(),
        e[2].setComponents(o + r, u + l, f + d, v + _).normalize(),
        e[3].setComponents(o - r, u - l, f - d, v - _).normalize(),
        e[4].setComponents(o - s, u - h, f - p, v - g).normalize(),
        e[5].setComponents(o + s, u + h, f + p, v + g).normalize(),
        this
      );
    }
    intersectsObject(t) {
      const e = t.geometry;
      return (
        null === e.boundingSphere && e.computeBoundingSphere(),
        iI.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
        this.intersectsSphere(iI)
      );
    }
    intersectsSprite(t) {
      return (
        iI.center.set(0, 0, 0),
        (iI.radius = 0.7071067811865476),
        iI.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(iI)
      );
    }
    intersectsSphere(t) {
      const e = this.planes,
        n = t.center,
        i = -t.radius;
      for (let r = 0; r < 6; r++) {
        if (e[r].distanceToPoint(n) < i) return !1;
      }
      return !0;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = e[n];
        if (
          ((rI.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (rI.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (rI.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(rI) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function oI() {
    let t = null,
      e = !1,
      n = null,
      i = null;
    function r(e, s) {
      n(e, s), (i = t.requestAnimationFrame(r));
    }
    return {
      start: function () {
        !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
      },
      stop: function () {
        t.cancelAnimationFrame(i), (e = !1);
      },
      setAnimationLoop: function (t) {
        n = t;
      },
      setContext: function (e) {
        t = e;
      },
    };
  }
  function aI(t, e) {
    const n = e.isWebGL2,
      i = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
      },
      remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const n = i.get(e);
        n && (t.deleteBuffer(n.buffer), i.delete(e));
      },
      update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = i.get(e);
          return void (
            (!t || t.version < e.version) &&
            i.set(e, {
              buffer: e.buffer,
              type: e.type,
              bytesPerElement: e.elementSize,
              version: e.version,
            })
          );
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const s = i.get(e);
        void 0 === s
          ? i.set(
              e,
              (function (e, i) {
                const r = e.array,
                  s = e.usage,
                  o = t.createBuffer();
                let a;
                if (
                  (t.bindBuffer(i, o),
                  t.bufferData(i, r, s),
                  e.onUploadCallback(),
                  r instanceof Float32Array)
                )
                  a = 5126;
                else if (r instanceof Uint16Array)
                  if (e.isFloat16BufferAttribute) {
                    if (!n)
                      throw new Error(
                        "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                      );
                    a = 5131;
                  } else a = 5123;
                else if (r instanceof Int16Array) a = 5122;
                else if (r instanceof Uint32Array) a = 5125;
                else if (r instanceof Int32Array) a = 5124;
                else if (r instanceof Int8Array) a = 5120;
                else if (r instanceof Uint8Array) a = 5121;
                else {
                  if (!(r instanceof Uint8ClampedArray))
                    throw new Error(
                      "THREE.WebGLAttributes: Unsupported buffer data format: " +
                        r
                    );
                  a = 5121;
                }
                return {
                  buffer: o,
                  type: a,
                  bytesPerElement: r.BYTES_PER_ELEMENT,
                  version: e.version,
                };
              })(e, r)
            )
          : s.version < e.version &&
            (!(function (e, i, r) {
              const s = i.array,
                o = i.updateRange;
              t.bindBuffer(r, e),
                -1 === o.count
                  ? t.bufferSubData(r, 0, s)
                  : (n
                      ? t.bufferSubData(
                          r,
                          o.offset * s.BYTES_PER_ELEMENT,
                          s,
                          o.offset,
                          o.count
                        )
                      : t.bufferSubData(
                          r,
                          o.offset * s.BYTES_PER_ELEMENT,
                          s.subarray(o.offset, o.offset + o.count)
                        ),
                    (o.count = -1));
            })(s.buffer, e, r),
            (s.version = e.version));
      },
    };
  }
  class lI extends TC {
    constructor(t = 1, e = 1, n = 1, i = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      const r = t / 2,
        s = e / 2,
        o = Math.floor(n),
        a = Math.floor(i),
        l = o + 1,
        h = a + 1,
        u = t / o,
        c = e / a,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let _ = 0; _ < h; _++) {
        const t = _ * c - s;
        for (let e = 0; e < l; e++) {
          const n = e * u - r;
          p.push(n, -t, 0), f.push(0, 0, 1), m.push(e / o), m.push(1 - _ / a);
        }
      }
      for (let _ = 0; _ < a; _++)
        for (let t = 0; t < o; t++) {
          const e = t + l * _,
            n = t + l * (_ + 1),
            i = t + 1 + l * (_ + 1),
            r = t + 1 + l * _;
          d.push(e, n, r), d.push(n, i, r);
        }
      this.setIndex(d),
        this.setAttribute("position", new fC(p, 3)),
        this.setAttribute("normal", new fC(f, 3)),
        this.setAttribute("uv", new fC(m, 2));
    }
    static fromJSON(t) {
      return new lI(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }
  const hI = {
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
      alphatest_pars_fragment:
        "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      begin_vertex: "vec3 transformed = vec3( position );",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
      iridescence_fragment:
        "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      encodings_pars_fragment:
        "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_vertex:
        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphcolor_vertex:
        "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin:
        "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      normal_fragment_maps:
        "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex:
        "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
      iridescence_pars_fragment:
        "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      output_fragment:
        "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment:
        "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
      transmission_pars_fragment:
        "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
      uv_pars_fragment:
        "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
      uv_pars_vertex:
        "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
      uv_vertex:
        "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
      uv2_pars_fragment:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
      uv2_pars_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
      uv2_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag:
        "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag:
        "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      depth_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    },
    uI = {
      common: {
        diffuse: { value: new DA(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new bA() },
        uv2Transform: { value: new bA() },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new xA(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new DA(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new DA(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new bA() },
      },
      sprite: {
        diffuse: { value: new DA(16777215) },
        opacity: { value: 1 },
        center: { value: new xA(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new bA() },
      },
    },
    cI = {
      basic: {
        uniforms: XC([
          uI.common,
          uI.specularmap,
          uI.envmap,
          uI.aomap,
          uI.lightmap,
          uI.fog,
        ]),
        vertexShader: hI.meshbasic_vert,
        fragmentShader: hI.meshbasic_frag,
      },
      lambert: {
        uniforms: XC([
          uI.common,
          uI.specularmap,
          uI.envmap,
          uI.aomap,
          uI.lightmap,
          uI.emissivemap,
          uI.fog,
          uI.lights,
          { emissive: { value: new DA(0) } },
        ]),
        vertexShader: hI.meshlambert_vert,
        fragmentShader: hI.meshlambert_frag,
      },
      phong: {
        uniforms: XC([
          uI.common,
          uI.specularmap,
          uI.envmap,
          uI.aomap,
          uI.lightmap,
          uI.emissivemap,
          uI.bumpmap,
          uI.normalmap,
          uI.displacementmap,
          uI.fog,
          uI.lights,
          {
            emissive: { value: new DA(0) },
            specular: { value: new DA(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: hI.meshphong_vert,
        fragmentShader: hI.meshphong_frag,
      },
      standard: {
        uniforms: XC([
          uI.common,
          uI.envmap,
          uI.aomap,
          uI.lightmap,
          uI.emissivemap,
          uI.bumpmap,
          uI.normalmap,
          uI.displacementmap,
          uI.roughnessmap,
          uI.metalnessmap,
          uI.fog,
          uI.lights,
          {
            emissive: { value: new DA(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: hI.meshphysical_vert,
        fragmentShader: hI.meshphysical_frag,
      },
      toon: {
        uniforms: XC([
          uI.common,
          uI.aomap,
          uI.lightmap,
          uI.emissivemap,
          uI.bumpmap,
          uI.normalmap,
          uI.displacementmap,
          uI.gradientmap,
          uI.fog,
          uI.lights,
          { emissive: { value: new DA(0) } },
        ]),
        vertexShader: hI.meshtoon_vert,
        fragmentShader: hI.meshtoon_frag,
      },
      matcap: {
        uniforms: XC([
          uI.common,
          uI.bumpmap,
          uI.normalmap,
          uI.displacementmap,
          uI.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: hI.meshmatcap_vert,
        fragmentShader: hI.meshmatcap_frag,
      },
      points: {
        uniforms: XC([uI.points, uI.fog]),
        vertexShader: hI.points_vert,
        fragmentShader: hI.points_frag,
      },
      dashed: {
        uniforms: XC([
          uI.common,
          uI.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: hI.linedashed_vert,
        fragmentShader: hI.linedashed_frag,
      },
      depth: {
        uniforms: XC([uI.common, uI.displacementmap]),
        vertexShader: hI.depth_vert,
        fragmentShader: hI.depth_frag,
      },
      normal: {
        uniforms: XC([
          uI.common,
          uI.bumpmap,
          uI.normalmap,
          uI.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: hI.meshnormal_vert,
        fragmentShader: hI.meshnormal_frag,
      },
      sprite: {
        uniforms: XC([uI.sprite, uI.fog]),
        vertexShader: hI.sprite_vert,
        fragmentShader: hI.sprite_frag,
      },
      background: {
        uniforms: { uvTransform: { value: new bA() }, t2D: { value: null } },
        vertexShader: hI.background_vert,
        fragmentShader: hI.background_frag,
      },
      cube: {
        uniforms: XC([uI.envmap, { opacity: { value: 1 } }]),
        vertexShader: hI.cube_vert,
        fragmentShader: hI.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: hI.equirect_vert,
        fragmentShader: hI.equirect_frag,
      },
      distanceRGBA: {
        uniforms: XC([
          uI.common,
          uI.displacementmap,
          {
            referencePosition: { value: new jA() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: hI.distanceRGBA_vert,
        fragmentShader: hI.distanceRGBA_frag,
      },
      shadow: {
        uniforms: XC([
          uI.lights,
          uI.fog,
          { color: { value: new DA(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: hI.shadow_vert,
        fragmentShader: hI.shadow_frag,
      },
    };
  function dI(t, e, n, i, r, s) {
    const o = new DA(0);
    let a,
      l,
      h = !0 === r ? 0 : 1,
      u = null,
      c = 0,
      d = null;
    function p(t, e) {
      n.buffers.color.setClear(t.r, t.g, t.b, e, s);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (t, e = 1) {
        o.set(t), (h = e), p(o, h);
      },
      getClearAlpha: function () {
        return h;
      },
      setClearAlpha: function (t) {
        (h = t), p(o, h);
      },
      render: function (n, r) {
        let s = !1,
          f = !0 === r.isScene ? r.background : null;
        f && f.isTexture && (f = e.get(f));
        const m = t.xr,
          _ = m.getSession && m.getSession();
        _ && "additive" === _.environmentBlendMode && (f = null),
          null === f ? p(o, h) : f && f.isColor && (p(f, 1), (s = !0)),
          (t.autoClear || s) &&
            t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          f && (f.isCubeTexture || f.mapping === RM)
            ? (void 0 === l &&
                ((l = new GC(
                  new zC(1, 1, 1),
                  new jC({
                    name: "BackgroundCubeMaterial",
                    uniforms: VC(cI.cube.uniforms),
                    vertexShader: cI.cube.vertexShader,
                    fragmentShader: cI.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                l.geometry.deleteAttribute("normal"),
                l.geometry.deleteAttribute("uv"),
                (l.onBeforeRender = function (t, e, n) {
                  this.matrixWorld.copyPosition(n.matrixWorld);
                }),
                Object.defineProperty(l.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                i.update(l)),
              (l.material.uniforms.envMap.value = f),
              (l.material.uniforms.flipEnvMap.value =
                f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
              (u === f && c === f.version && d === t.toneMapping) ||
                ((l.material.needsUpdate = !0),
                (u = f),
                (c = f.version),
                (d = t.toneMapping)),
              l.layers.enableAll(),
              n.unshift(l, l.geometry, l.material, 0, 0, null))
            : f &&
              f.isTexture &&
              (void 0 === a &&
                ((a = new GC(
                  new lI(2, 2),
                  new jC({
                    name: "BackgroundMaterial",
                    uniforms: VC(cI.background.uniforms),
                    vertexShader: cI.background.vertexShader,
                    fragmentShader: cI.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                a.geometry.deleteAttribute("normal"),
                Object.defineProperty(a.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                i.update(a)),
              (a.material.uniforms.t2D.value = f),
              !0 === f.matrixAutoUpdate && f.updateMatrix(),
              a.material.uniforms.uvTransform.value.copy(f.matrix),
              (u === f && c === f.version && d === t.toneMapping) ||
                ((a.material.needsUpdate = !0),
                (u = f),
                (c = f.version),
                (d = t.toneMapping)),
              a.layers.enableAll(),
              n.unshift(a, a.geometry, a.material, 0, 0, null));
      },
    };
  }
  function pI(t, e, n, i) {
    const r = t.getParameter(34921),
      s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      o = i.isWebGL2 || null !== s,
      a = {},
      l = p(null);
    let h = l,
      u = !1;
    function c(e) {
      return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
    }
    function d(e) {
      return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
    }
    function p(t) {
      const e = [],
        n = [],
        i = [];
      for (let s = 0; s < r; s++) (e[s] = 0), (n[s] = 0), (i[s] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: n,
        attributeDivisors: i,
        object: t,
        attributes: {},
        index: null,
      };
    }
    function f() {
      const t = h.newAttributes;
      for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
    }
    function m(t) {
      _(t, 0);
    }
    function _(n, r) {
      const s = h.newAttributes,
        o = h.enabledAttributes,
        a = h.attributeDivisors;
      if (
        ((s[n] = 1),
        0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
        a[n] !== r)
      ) {
        (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](n, r),
          (a[n] = r);
      }
    }
    function g() {
      const e = h.newAttributes,
        n = h.enabledAttributes;
      for (let i = 0, r = n.length; i < r; i++)
        n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
    }
    function v(e, n, r, s, o, a) {
      !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
        ? t.vertexAttribPointer(e, n, r, s, o, a)
        : t.vertexAttribIPointer(e, n, r, o, a);
    }
    function y() {
      x(), (u = !0), h !== l && ((h = l), c(h.object));
    }
    function x() {
      (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
      setup: function (r, l, d, y, x) {
        let b = !1;
        if (o) {
          const e = (function (e, n, r) {
            const o = !0 === r.wireframe;
            let l = a[e.id];
            void 0 === l && ((l = {}), (a[e.id] = l));
            let h = l[n.id];
            void 0 === h && ((h = {}), (l[n.id] = h));
            let u = h[o];
            void 0 === u &&
              ((u = p(
                i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
              )),
              (h[o] = u));
            return u;
          })(y, d, l);
          h !== e && ((h = e), c(h.object)),
            (b = (function (t, e, n, i) {
              const r = h.attributes,
                s = e.attributes;
              let o = 0;
              const a = n.getAttributes();
              for (const l in a) {
                if (a[l].location >= 0) {
                  const e = r[l];
                  let n = s[l];
                  if (
                    (void 0 === n &&
                      ("instanceMatrix" === l &&
                        t.instanceMatrix &&
                        (n = t.instanceMatrix),
                      "instanceColor" === l &&
                        t.instanceColor &&
                        (n = t.instanceColor)),
                    void 0 === e)
                  )
                    return !0;
                  if (e.attribute !== n) return !0;
                  if (n && e.data !== n.data) return !0;
                  o++;
                }
              }
              return h.attributesNum !== o || h.index !== i;
            })(r, y, d, x)),
            b &&
              (function (t, e, n, i) {
                const r = {},
                  s = e.attributes;
                let o = 0;
                const a = n.getAttributes();
                for (const l in a) {
                  if (a[l].location >= 0) {
                    let e = s[l];
                    void 0 === e &&
                      ("instanceMatrix" === l &&
                        t.instanceMatrix &&
                        (e = t.instanceMatrix),
                      "instanceColor" === l &&
                        t.instanceColor &&
                        (e = t.instanceColor));
                    const n = {};
                    (n.attribute = e),
                      e && e.data && (n.data = e.data),
                      (r[l] = n),
                      o++;
                  }
                }
                (h.attributes = r), (h.attributesNum = o), (h.index = i);
              })(r, y, d, x);
        } else {
          const t = !0 === l.wireframe;
          (h.geometry === y.id && h.program === d.id && h.wireframe === t) ||
            ((h.geometry = y.id),
            (h.program = d.id),
            (h.wireframe = t),
            (b = !0));
        }
        null !== x && n.update(x, 34963),
          (b || u) &&
            ((u = !1),
            (function (r, s, o, a) {
              if (
                !1 === i.isWebGL2 &&
                (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                null === e.get("ANGLE_instanced_arrays")
              )
                return;
              f();
              const l = a.attributes,
                h = o.getAttributes(),
                u = s.defaultAttributeValues;
              for (const e in h) {
                const i = h[e];
                if (i.location >= 0) {
                  let s = l[e];
                  if (
                    (void 0 === s &&
                      ("instanceMatrix" === e &&
                        r.instanceMatrix &&
                        (s = r.instanceMatrix),
                      "instanceColor" === e &&
                        r.instanceColor &&
                        (s = r.instanceColor)),
                    void 0 !== s)
                  ) {
                    const e = s.normalized,
                      o = s.itemSize,
                      l = n.get(s);
                    if (void 0 === l) continue;
                    const h = l.buffer,
                      u = l.type,
                      c = l.bytesPerElement;
                    if (s.isInterleavedBufferAttribute) {
                      const n = s.data,
                        l = n.stride,
                        d = s.offset;
                      if (n.isInstancedInterleavedBuffer) {
                        for (let t = 0; t < i.locationSize; t++)
                          _(i.location + t, n.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = n.meshPerAttribute * n.count);
                      } else
                        for (let t = 0; t < i.locationSize; t++)
                          m(i.location + t);
                      t.bindBuffer(34962, h);
                      for (let t = 0; t < i.locationSize; t++)
                        v(
                          i.location + t,
                          o / i.locationSize,
                          u,
                          e,
                          l * c,
                          (d + (o / i.locationSize) * t) * c
                        );
                    } else {
                      if (s.isInstancedBufferAttribute) {
                        for (let t = 0; t < i.locationSize; t++)
                          _(i.location + t, s.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = s.meshPerAttribute * s.count);
                      } else
                        for (let t = 0; t < i.locationSize; t++)
                          m(i.location + t);
                      t.bindBuffer(34962, h);
                      for (let t = 0; t < i.locationSize; t++)
                        v(
                          i.location + t,
                          o / i.locationSize,
                          u,
                          e,
                          o * c,
                          (o / i.locationSize) * t * c
                        );
                    }
                  } else if (void 0 !== u) {
                    const n = u[e];
                    if (void 0 !== n)
                      switch (n.length) {
                        case 2:
                          t.vertexAttrib2fv(i.location, n);
                          break;
                        case 3:
                          t.vertexAttrib3fv(i.location, n);
                          break;
                        case 4:
                          t.vertexAttrib4fv(i.location, n);
                          break;
                        default:
                          t.vertexAttrib1fv(i.location, n);
                      }
                  }
                }
              }
              g();
            })(r, l, d, y),
            null !== x && t.bindBuffer(34963, n.get(x).buffer));
      },
      reset: y,
      resetDefaultState: x,
      dispose: function () {
        y();
        for (const t in a) {
          const e = a[t];
          for (const t in e) {
            const n = e[t];
            for (const t in n) d(n[t].object), delete n[t];
            delete e[t];
          }
          delete a[t];
        }
      },
      releaseStatesOfGeometry: function (t) {
        if (void 0 === a[t.id]) return;
        const e = a[t.id];
        for (const n in e) {
          const t = e[n];
          for (const e in t) d(t[e].object), delete t[e];
          delete e[n];
        }
        delete a[t.id];
      },
      releaseStatesOfProgram: function (t) {
        for (const e in a) {
          const n = a[e];
          if (void 0 === n[t.id]) continue;
          const i = n[t.id];
          for (const t in i) d(i[t].object), delete i[t];
          delete n[t.id];
        }
      },
      initAttributes: f,
      enableAttribute: m,
      disableUnusedAttributes: g,
    };
  }
  function fI(t, e, n, i) {
    const r = i.isWebGL2;
    let s;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.render = function (e, i) {
        t.drawArrays(s, e, i), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, o, a) {
        if (0 === a) return;
        let l, h;
        if (r) (l = t), (h = "drawArraysInstanced");
        else if (
          ((l = e.get("ANGLE_instanced_arrays")),
          (h = "drawArraysInstancedANGLE"),
          null === l)
        )
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        l[h](s, i, o, a), n.update(o, s, a);
      });
  }
  function mI(t, e, n) {
    let i;
    function r(e) {
      if ("highp" === e) {
        if (
          t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
          t.getShaderPrecisionFormat(35632, 36338).precision > 0
        )
          return "highp";
        e = "mediump";
      }
      return "mediump" === e &&
        t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
        t.getShaderPrecisionFormat(35632, 36337).precision > 0
        ? "mediump"
        : "lowp";
    }
    const s =
      ("undefined" != typeof WebGL2RenderingContext &&
        t instanceof WebGL2RenderingContext) ||
      ("undefined" != typeof WebGL2ComputeRenderingContext &&
        t instanceof WebGL2ComputeRenderingContext);
    let o = void 0 !== n.precision ? n.precision : "highp";
    const a = r(o);
    a !== o &&
      (console.warn(
        "THREE.WebGLRenderer:",
        o,
        "not supported, using",
        a,
        "instead."
      ),
      (o = a));
    const l = s || e.has("WEBGL_draw_buffers"),
      h = !0 === n.logarithmicDepthBuffer,
      u = t.getParameter(34930),
      c = t.getParameter(35660),
      d = t.getParameter(3379),
      p = t.getParameter(34076),
      f = t.getParameter(34921),
      m = t.getParameter(36347),
      _ = t.getParameter(36348),
      g = t.getParameter(36349),
      v = c > 0,
      y = s || e.has("OES_texture_float");
    return {
      isWebGL2: s,
      drawBuffers: l,
      getMaxAnisotropy: function () {
        if (void 0 !== i) return i;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const n = e.get("EXT_texture_filter_anisotropic");
          i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else i = 0;
        return i;
      },
      getMaxPrecision: r,
      precision: o,
      logarithmicDepthBuffer: h,
      maxTextures: u,
      maxVertexTextures: c,
      maxTextureSize: d,
      maxCubemapSize: p,
      maxAttributes: f,
      maxVertexUniforms: m,
      maxVaryings: _,
      maxFragmentUniforms: g,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y,
      maxSamples: s ? t.getParameter(36183) : 0,
    };
  }
  function _I(t) {
    const e = this;
    let n = null,
      i = 0,
      r = !1,
      s = !1;
    const o = new nI(),
      a = new bA(),
      l = { value: null, needsUpdate: !1 };
    function h() {
      l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
        (e.numPlanes = i),
        (e.numIntersection = 0);
    }
    function u(t, n, i, r) {
      const s = null !== t ? t.length : 0;
      let h = null;
      if (0 !== s) {
        if (((h = l.value), !0 !== r || null === h)) {
          const e = i + 4 * s,
            r = n.matrixWorldInverse;
          a.getNormalMatrix(r),
            (null === h || h.length < e) && (h = new Float32Array(e));
          for (let n = 0, l = i; n !== s; ++n, l += 4)
            o.copy(t[n]).applyMatrix4(r, a),
              o.normal.toArray(h, l),
              (h[l + 3] = o.constant);
        }
        (l.value = h), (l.needsUpdate = !0);
      }
      return (e.numPlanes = s), (e.numIntersection = 0), h;
    }
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, e, s) {
        const o = 0 !== t.length || e || 0 !== i || r;
        return (r = e), (n = u(t, s, 0)), (i = t.length), o;
      }),
      (this.beginShadows = function () {
        (s = !0), u(null);
      }),
      (this.endShadows = function () {
        (s = !1), h();
      }),
      (this.setState = function (e, o, a) {
        const c = e.clippingPlanes,
          d = e.clipIntersection,
          p = e.clipShadows,
          f = t.get(e);
        if (!r || null === c || 0 === c.length || (s && !p)) s ? u(null) : h();
        else {
          const t = s ? 0 : i,
            e = 4 * t;
          let r = f.clippingState || null;
          (l.value = r), (r = u(c, o, e, a));
          for (let i = 0; i !== e; ++i) r[i] = n[i];
          (f.clippingState = r),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += t);
        }
      });
  }
  function gI(t) {
    let e = new WeakMap();
    function n(t, e) {
      return 303 === e ? (t.mapping = MM) : 304 === e && (t.mapping = AM), t;
    }
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
          const s = r.mapping;
          if (303 === s || 304 === s) {
            if (e.has(r)) {
              return n(e.get(r).texture, r.mapping);
            }
            {
              const s = r.image;
              if (s && s.height > 0) {
                const o = new $C(s.height / 2);
                return (
                  o.fromEquirectangularTexture(t, r),
                  e.set(r, o),
                  r.addEventListener("dispose", i),
                  n(o.texture, r.mapping)
                );
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  cI.physical = {
    uniforms: XC([
      cI.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new xA(1, 1) },
        clearcoatNormalMap: { value: null },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        sheen: { value: 0 },
        sheenColor: { value: new DA(0) },
        sheenColorMap: { value: null },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionSamplerSize: { value: new xA() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new DA(0) },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularColor: { value: new DA(1, 1, 1) },
        specularColorMap: { value: null },
      },
    ]),
    vertexShader: hI.meshphysical_vert,
    fragmentShader: hI.meshphysical_frag,
  };
  class vI extends YC {
    constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = n),
        (this.bottom = i),
        (this.near = r),
        (this.far = s),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    }
    setViewOffset(t, e, n, i, r, s) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      let r = n - t,
        s = n + t,
        o = i + e,
        a = i - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (s = r + t * this.view.width),
          (o -= e * this.view.offsetY),
          (a = o - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    }
  }
  const yI = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    xI = 20,
    bI = new vI(),
    TI = new DA();
  let EI = null;
  const SI = (1 + Math.sqrt(5)) / 2,
    wI = 1 / SI,
    MI = [
      new jA(1, 1, 1),
      new jA(-1, 1, 1),
      new jA(1, 1, -1),
      new jA(-1, 1, -1),
      new jA(0, SI, wI),
      new jA(0, SI, -wI),
      new jA(wI, 0, SI),
      new jA(-wI, 0, SI),
      new jA(SI, wI, 0),
      new jA(-SI, wI, 0),
    ];
  class AI {
    constructor(t) {
      (this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, i = 100) {
      (EI = this._renderer.getRenderTarget()), this._setSize(256);
      const r = this._allocateTargets();
      return (
        (r.depthBuffer = !0),
        this._sceneToCubeUV(t, n, i, r),
        e > 0 && this._blur(r, 0, 0, e),
        this._applyPMREM(r),
        this._cleanup(r),
        r
      );
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e);
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial &&
        ((this._cubemapMaterial = PI()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial &&
        ((this._equirectMaterial = II()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(t) {
      (this._lodMax = Math.floor(Math.log2(t))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget &&
          this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(EI),
        (t.scissorTest = !1),
        CI(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e) {
      t.mapping === MM || t.mapping === AM
        ? this._setSize(
            0 === t.image.length
              ? 16
              : t.image[0].width || t.image[0].image.width
          )
        : this._setSize(t.image.width / 4),
        (EI = this._renderer.getRenderTarget());
      const n = e || this._allocateTargets();
      return (
        this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
      );
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112),
        e = 4 * this._cubeSize,
        n = {
          magFilter: LM,
          minFilter: LM,
          generateMipmaps: !1,
          type: GM,
          format: zM,
          encoding: $M,
          depthBuffer: !1,
        },
        i = RI(t, e, n);
      if (
        null === this._pingPongRenderTarget ||
        this._pingPongRenderTarget.width !== t
      ) {
        null !== this._pingPongRenderTarget && this._dispose(),
          (this._pingPongRenderTarget = RI(t, e, n));
        const { _lodMax: i } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = (function (t) {
          const e = [],
            n = [],
            i = [];
          let r = t;
          const s = t - 4 + 1 + yI.length;
          for (let o = 0; o < s; o++) {
            const s = Math.pow(2, r);
            n.push(s);
            let a = 1 / s;
            o > t - 4 ? (a = yI[o - t + 4 - 1]) : 0 === o && (a = 0), i.push(a);
            const l = 1 / (s - 2),
              h = -l,
              u = 1 + l,
              c = [h, h, u, h, u, u, h, h, u, u, h, u],
              d = 6,
              p = 6,
              f = 3,
              m = 2,
              _ = 1,
              g = new Float32Array(f * p * d),
              v = new Float32Array(m * p * d),
              y = new Float32Array(_ * p * d);
            for (let t = 0; t < d; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              g.set(i, f * p * t), v.set(c, m * p * t);
              const r = [t, t, t, t, t, t];
              y.set(r, _ * p * t);
            }
            const x = new TC();
            x.setAttribute("position", new cC(g, f)),
              x.setAttribute("uv", new cC(v, m)),
              x.setAttribute("faceIndex", new cC(y, _)),
              e.push(x),
              r > 4 && r--;
          }
          return { lodPlanes: e, sizeLods: n, sigmas: i };
        })(i)),
          (this._blurMaterial = (function (t, e, n) {
            const i = new Float32Array(xI),
              r = new jA(0, 1, 0);
            return new jC({
              name: "SphericalGaussianBlur",
              defines: {
                n: xI,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / n,
                CUBEUV_MAX_MIP: `${t}.0`,
              },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: i },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: r },
              },
              vertexShader: OI(),
              fragmentShader:
                "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(i, t, e));
      }
      return i;
    }
    _compileMaterial(t) {
      const e = new GC(this._lodPlanes[0], t);
      this._renderer.compile(e, bI);
    }
    _sceneToCubeUV(t, e, n, i) {
      const r = new qC(90, 1, e, n),
        s = [1, -1, 1, 1, 1, 1],
        o = [1, 1, 1, -1, -1, -1],
        a = this._renderer,
        l = a.autoClear,
        h = a.toneMapping;
      a.getClearColor(TI), (a.toneMapping = 0), (a.autoClear = !1);
      const u = new lC({
          name: "PMREM.Background",
          side: 1,
          depthWrite: !1,
          depthTest: !1,
        }),
        c = new GC(new zC(), u);
      let d = !1;
      const p = t.background;
      p
        ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
        : (u.color.copy(TI), (d = !0));
      for (let f = 0; f < 6; f++) {
        const e = f % 3;
        0 === e
          ? (r.up.set(0, s[f], 0), r.lookAt(o[f], 0, 0))
          : 1 === e
          ? (r.up.set(0, 0, s[f]), r.lookAt(0, o[f], 0))
          : (r.up.set(0, s[f], 0), r.lookAt(0, 0, o[f]));
        const n = this._cubeSize;
        CI(i, e * n, f > 2 ? n : 0, n, n),
          a.setRenderTarget(i),
          d && a.render(c, r),
          a.render(t, r);
      }
      c.geometry.dispose(),
        c.material.dispose(),
        (a.toneMapping = h),
        (a.autoClear = l),
        (t.background = p);
    }
    _textureToCubeUV(t, e) {
      const n = this._renderer,
        i = t.mapping === MM || t.mapping === AM;
      i
        ? (null === this._cubemapMaterial && (this._cubemapMaterial = PI()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            !1 === t.isRenderTargetTexture ? -1 : 1))
        : null === this._equirectMaterial && (this._equirectMaterial = II());
      const r = i ? this._cubemapMaterial : this._equirectMaterial,
        s = new GC(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      const o = this._cubeSize;
      CI(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, bI);
    }
    _applyPMREM(t) {
      const e = this._renderer,
        n = e.autoClear;
      e.autoClear = !1;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const e = Math.sqrt(
            this._sigmas[i] * this._sigmas[i] -
              this._sigmas[i - 1] * this._sigmas[i - 1]
          ),
          n = MI[(i - 1) % MI.length];
        this._blur(t, i - 1, i, e, n);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, i, r) {
      const s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r),
        this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
    _halfBlur(t, e, n, i, r, s, o) {
      const a = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== s &&
        "longitudinal" !== s &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      const h = new GC(this._lodPlanes[i], l),
        u = l.uniforms,
        c = this._sizeLods[n] - 1,
        d = isFinite(r) ? Math.PI / (2 * c) : (2 * Math.PI) / 39,
        p = r / d,
        f = isFinite(r) ? 1 + Math.floor(3 * p) : xI;
      f > xI &&
        console.warn(
          `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
        );
      const m = [];
      let _ = 0;
      for (let y = 0; y < xI; ++y) {
        const t = y / p,
          e = Math.exp((-t * t) / 2);
        m.push(e), 0 === y ? (_ += e) : y < f && (_ += 2 * e);
      }
      for (let y = 0; y < m.length; y++) m[y] = m[y] / _;
      (u.envMap.value = t.texture),
        (u.samples.value = f),
        (u.weights.value = m),
        (u.latitudinal.value = "latitudinal" === s),
        o && (u.poleAxis.value = o);
      const { _lodMax: g } = this;
      (u.dTheta.value = d), (u.mipInt.value = g - n);
      const v = this._sizeLods[i];
      CI(
        e,
        3 * v * (i > g - 4 ? i - g + 4 : 0),
        4 * (this._cubeSize - v),
        3 * v,
        2 * v
      ),
        a.setRenderTarget(e),
        a.render(h, bI);
    }
  }
  function RI(t, e, n) {
    const i = new zA(t, e, n);
    return (
      (i.texture.mapping = RM),
      (i.texture.name = "PMREM.cubeUv"),
      (i.scissorTest = !0),
      i
    );
  }
  function CI(t, e, n, i, r) {
    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
  }
  function II() {
    return new jC({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader: OI(),
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function PI() {
    return new jC({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader: OI(),
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function OI() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
  }
  function NI(t) {
    let e = new WeakMap(),
      n = null;
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping,
            o = 303 === s || 304 === s,
            a = s === MM || s === AM;
          if (o || a) {
            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
              r.needsPMREMUpdate = !1;
              let i = e.get(r);
              return (
                null === n && (n = new AI(t)),
                (i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                e.set(r, i),
                i.texture
              );
            }
            if (e.has(r)) return e.get(r).texture;
            {
              const s = r.image;
              if (
                (o && s && s.height > 0) ||
                (a &&
                  s &&
                  (function (t) {
                    let e = 0;
                    const n = 6;
                    for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                    return e === n;
                  })(s))
              ) {
                null === n && (n = new AI(t));
                const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                return e.set(r, s), r.addEventListener("dispose", i), s.texture;
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
      },
    };
  }
  function DI(t) {
    const e = {};
    function n(n) {
      if (void 0 !== e[n]) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (e[n] = i), i;
    }
    return {
      has: function (t) {
        return null !== n(t);
      },
      init: function (t) {
        t.isWebGL2
          ? n("EXT_color_buffer_float")
          : (n("WEBGL_depth_texture"),
            n("OES_texture_float"),
            n("OES_texture_half_float"),
            n("OES_texture_half_float_linear"),
            n("OES_standard_derivatives"),
            n("OES_element_index_uint"),
            n("OES_vertex_array_object"),
            n("ANGLE_instanced_arrays")),
          n("OES_texture_float_linear"),
          n("EXT_color_buffer_half_float"),
          n("WEBGL_multisampled_render_to_texture");
      },
      get: function (t) {
        const e = n(t);
        return (
          null === e &&
            console.warn(
              "THREE.WebGLRenderer: " + t + " extension not supported."
            ),
          e
        );
      },
    };
  }
  function LI(t, e, n, i) {
    const r = {},
      s = new WeakMap();
    function o(t) {
      const a = t.target;
      null !== a.index && e.remove(a.index);
      for (const n in a.attributes) e.remove(a.attributes[n]);
      a.removeEventListener("dispose", o), delete r[a.id];
      const l = s.get(a);
      l && (e.remove(l), s.delete(a)),
        i.releaseStatesOfGeometry(a),
        !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
        n.memory.geometries--;
    }
    function a(t) {
      const n = [],
        i = t.index,
        r = t.attributes.position;
      let o = 0;
      if (null !== i) {
        const t = i.array;
        o = i.version;
        for (let e = 0, i = t.length; e < i; e += 3) {
          const i = t[e + 0],
            r = t[e + 1],
            s = t[e + 2];
          n.push(i, r, r, s, s, i);
        }
      } else {
        const t = r.array;
        o = r.version;
        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
          const t = e + 0,
            i = e + 1,
            r = e + 2;
          n.push(t, i, i, r, r, t);
        }
      }
      const a = new (TA(n) ? pC : dC)(n, 1);
      a.version = o;
      const l = s.get(t);
      l && e.remove(l), s.set(t, a);
    }
    return {
      get: function (t, e) {
        return (
          !0 === r[e.id] ||
            (e.addEventListener("dispose", o),
            (r[e.id] = !0),
            n.memory.geometries++),
          e
        );
      },
      update: function (t) {
        const n = t.attributes;
        for (const r in n) e.update(n[r], 34962);
        const i = t.morphAttributes;
        for (const r in i) {
          const t = i[r];
          for (let n = 0, i = t.length; n < i; n++) e.update(t[n], 34962);
        }
      },
      getWireframeAttribute: function (t) {
        const e = s.get(t);
        if (e) {
          const n = t.index;
          null !== n && e.version < n.version && a(t);
        } else a(t);
        return s.get(t);
      },
    };
  }
  function FI(t, e, n, i) {
    const r = i.isWebGL2;
    let s, o, a;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.setIndex = function (t) {
        (o = t.type), (a = t.bytesPerElement);
      }),
      (this.render = function (e, i) {
        t.drawElements(s, i, o, e * a), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, l, h) {
        if (0 === h) return;
        let u, c;
        if (r) (u = t), (c = "drawElementsInstanced");
        else if (
          ((u = e.get("ANGLE_instanced_arrays")),
          (c = "drawElementsInstancedANGLE"),
          null === u)
        )
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        u[c](s, l, o, i * a, h), n.update(l, s, h);
      });
  }
  function UI(t) {
    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        e.frame++,
          (e.calls = 0),
          (e.triangles = 0),
          (e.points = 0),
          (e.lines = 0);
      },
      update: function (t, n, i) {
        switch ((e.calls++, n)) {
          case 4:
            e.triangles += i * (t / 3);
            break;
          case 1:
            e.lines += i * (t / 2);
            break;
          case 3:
            e.lines += i * (t - 1);
            break;
          case 2:
            e.lines += i * t;
            break;
          case 0:
            e.points += i * t;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      },
    };
  }
  function BI(t, e) {
    return t[0] - e[0];
  }
  function kI(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function GI(t, e) {
    let n = 1;
    const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
    i instanceof Int8Array
      ? (n = 127)
      : i instanceof Uint8Array
      ? (n = 255)
      : i instanceof Uint16Array
      ? (n = 65535)
      : i instanceof Int16Array
      ? (n = 32767)
      : i instanceof Int32Array
      ? (n = 2147483647)
      : console.error(
          "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
          i
        ),
      t.divideScalar(n);
  }
  function HI(t, e, n) {
    const i = {},
      r = new Float32Array(8),
      s = new WeakMap(),
      o = new HA(),
      a = [];
    for (let l = 0; l < 8; l++) a[l] = [l, 0];
    return {
      update: function (l, h, u, c) {
        const d = l.morphTargetInfluences;
        if (!0 === e.isWebGL2) {
          const i =
              h.morphAttributes.position ||
              h.morphAttributes.normal ||
              h.morphAttributes.color,
            r = void 0 !== i ? i.length : 0;
          let a = s.get(h);
          if (void 0 === a || a.count !== r) {
            let t = function () {
              g.dispose(), s.delete(h), h.removeEventListener("dispose", t);
            };
            void 0 !== a && a.texture.dispose();
            const n = void 0 !== h.morphAttributes.position,
              i = void 0 !== h.morphAttributes.normal,
              l = void 0 !== h.morphAttributes.color,
              u = h.morphAttributes.position || [],
              c = h.morphAttributes.normal || [],
              d = h.morphAttributes.color || [];
            let p = 0;
            !0 === n && (p = 1), !0 === i && (p = 2), !0 === l && (p = 3);
            let f = h.attributes.position.count * p,
              m = 1;
            f > e.maxTextureSize &&
              ((m = Math.ceil(f / e.maxTextureSize)), (f = e.maxTextureSize));
            const _ = new Float32Array(f * m * 4 * r),
              g = new VA(_, f, m, r);
            (g.type = kM), (g.needsUpdate = !0);
            const v = 4 * p;
            for (let e = 0; e < r; e++) {
              const t = u[e],
                r = c[e],
                s = d[e],
                a = f * m * 4 * e;
              for (let e = 0; e < t.count; e++) {
                const h = e * v;
                !0 === n &&
                  (o.fromBufferAttribute(t, e),
                  !0 === t.normalized && GI(o, t),
                  (_[a + h + 0] = o.x),
                  (_[a + h + 1] = o.y),
                  (_[a + h + 2] = o.z),
                  (_[a + h + 3] = 0)),
                  !0 === i &&
                    (o.fromBufferAttribute(r, e),
                    !0 === r.normalized && GI(o, r),
                    (_[a + h + 4] = o.x),
                    (_[a + h + 5] = o.y),
                    (_[a + h + 6] = o.z),
                    (_[a + h + 7] = 0)),
                  !0 === l &&
                    (o.fromBufferAttribute(s, e),
                    !0 === s.normalized && GI(o, s),
                    (_[a + h + 8] = o.x),
                    (_[a + h + 9] = o.y),
                    (_[a + h + 10] = o.z),
                    (_[a + h + 11] = 4 === s.itemSize ? o.w : 1));
              }
            }
            (a = { count: r, texture: g, size: new xA(f, m) }),
              s.set(h, a),
              h.addEventListener("dispose", t);
          }
          let l = 0;
          for (let t = 0; t < d.length; t++) l += d[t];
          const u = h.morphTargetsRelative ? 1 : 1 - l;
          c.getUniforms().setValue(t, "morphTargetBaseInfluence", u),
            c.getUniforms().setValue(t, "morphTargetInfluences", d),
            c.getUniforms().setValue(t, "morphTargetsTexture", a.texture, n),
            c.getUniforms().setValue(t, "morphTargetsTextureSize", a.size);
        } else {
          const e = void 0 === d ? 0 : d.length;
          let n = i[h.id];
          if (void 0 === n || n.length !== e) {
            n = [];
            for (let t = 0; t < e; t++) n[t] = [t, 0];
            i[h.id] = n;
          }
          for (let t = 0; t < e; t++) {
            const e = n[t];
            (e[0] = t), (e[1] = d[t]);
          }
          n.sort(kI);
          for (let t = 0; t < 8; t++)
            t < e && n[t][1]
              ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
              : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0));
          a.sort(BI);
          const s = h.morphAttributes.position,
            o = h.morphAttributes.normal;
          let l = 0;
          for (let t = 0; t < 8; t++) {
            const e = a[t],
              n = e[0],
              i = e[1];
            n !== Number.MAX_SAFE_INTEGER && i
              ? (s &&
                  h.getAttribute("morphTarget" + t) !== s[n] &&
                  h.setAttribute("morphTarget" + t, s[n]),
                o &&
                  h.getAttribute("morphNormal" + t) !== o[n] &&
                  h.setAttribute("morphNormal" + t, o[n]),
                (r[t] = i),
                (l += i))
              : (s &&
                  !0 === h.hasAttribute("morphTarget" + t) &&
                  h.deleteAttribute("morphTarget" + t),
                o &&
                  !0 === h.hasAttribute("morphNormal" + t) &&
                  h.deleteAttribute("morphNormal" + t),
                (r[t] = 0));
          }
          const u = h.morphTargetsRelative ? 1 : 1 - l;
          c.getUniforms().setValue(t, "morphTargetBaseInfluence", u),
            c.getUniforms().setValue(t, "morphTargetInfluences", r);
        }
      },
    };
  }
  function zI(t, e, n, i) {
    let r = new WeakMap();
    function s(t) {
      const e = t.target;
      e.removeEventListener("dispose", s),
        n.remove(e.instanceMatrix),
        null !== e.instanceColor && n.remove(e.instanceColor);
    }
    return {
      update: function (t) {
        const o = i.render.frame,
          a = t.geometry,
          l = e.get(t, a);
        return (
          r.get(l) !== o && (e.update(l), r.set(l, o)),
          t.isInstancedMesh &&
            (!1 === t.hasEventListener("dispose", s) &&
              t.addEventListener("dispose", s),
            n.update(t.instanceMatrix, 34962),
            null !== t.instanceColor && n.update(t.instanceColor, 34962)),
          l
        );
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  const VI = new GA(),
    XI = new VA(),
    WI = new XA(),
    jI = new JC(),
    YI = [],
    qI = [],
    KI = new Float32Array(16),
    ZI = new Float32Array(9),
    JI = new Float32Array(4);
  function $I(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0) return t;
    const r = e * n;
    let s = YI[r];
    if ((void 0 === s && ((s = new Float32Array(r)), (YI[r] = s)), 0 !== e)) {
      i.toArray(s, 0);
      for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
    }
    return s;
  }
  function QI(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function tP(t, e) {
    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
  }
  function eP(t, e) {
    let n = qI[e];
    void 0 === n && ((n = new Int32Array(e)), (qI[e] = n));
    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n;
  }
  function nP(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
  }
  function iP(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (QI(n, e)) return;
      t.uniform2fv(this.addr, e), tP(n, e);
    }
  }
  function rP(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else if (void 0 !== e.r)
      (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b),
        (n[0] = e.r),
        (n[1] = e.g),
        (n[2] = e.b));
    else {
      if (QI(n, e)) return;
      t.uniform3fv(this.addr, e), tP(n, e);
    }
  }
  function sP(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (QI(n, e)) return;
      t.uniform4fv(this.addr, e), tP(n, e);
    }
  }
  function oP(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (QI(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), tP(n, e);
    } else {
      if (QI(n, i)) return;
      JI.set(i), t.uniformMatrix2fv(this.addr, !1, JI), tP(n, i);
    }
  }
  function aP(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (QI(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), tP(n, e);
    } else {
      if (QI(n, i)) return;
      ZI.set(i), t.uniformMatrix3fv(this.addr, !1, ZI), tP(n, i);
    }
  }
  function lP(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (QI(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), tP(n, e);
    } else {
      if (QI(n, i)) return;
      KI.set(i), t.uniformMatrix4fv(this.addr, !1, KI), tP(n, i);
    }
  }
  function hP(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
  }
  function uP(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform2iv(this.addr, e), tP(n, e));
  }
  function cP(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform3iv(this.addr, e), tP(n, e));
  }
  function dP(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform4iv(this.addr, e), tP(n, e));
  }
  function pP(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
  }
  function fP(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform2uiv(this.addr, e), tP(n, e));
  }
  function mP(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform3uiv(this.addr, e), tP(n, e));
  }
  function _P(t, e) {
    const n = this.cache;
    QI(n, e) || (t.uniform4uiv(this.addr, e), tP(n, e));
  }
  function gP(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2D(e || VI, r);
  }
  function vP(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(e || WI, r);
  }
  function yP(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTextureCube(e || jI, r);
  }
  function xP(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(e || XI, r);
  }
  function bP(t, e) {
    t.uniform1fv(this.addr, e);
  }
  function TP(t, e) {
    const n = $I(e, this.size, 2);
    t.uniform2fv(this.addr, n);
  }
  function EP(t, e) {
    const n = $I(e, this.size, 3);
    t.uniform3fv(this.addr, n);
  }
  function SP(t, e) {
    const n = $I(e, this.size, 4);
    t.uniform4fv(this.addr, n);
  }
  function wP(t, e) {
    const n = $I(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n);
  }
  function MP(t, e) {
    const n = $I(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n);
  }
  function AP(t, e) {
    const n = $I(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n);
  }
  function RP(t, e) {
    t.uniform1iv(this.addr, e);
  }
  function CP(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function IP(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function PP(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function OP(t, e) {
    t.uniform1uiv(this.addr, e);
  }
  function NP(t, e) {
    t.uniform2uiv(this.addr, e);
  }
  function DP(t, e) {
    t.uniform3uiv(this.addr, e);
  }
  function LP(t, e) {
    t.uniform4uiv(this.addr, e);
  }
  function FP(t, e, n) {
    const i = e.length,
      r = eP(n, i);
    t.uniform1iv(this.addr, r);
    for (let s = 0; s !== i; ++s) n.setTexture2D(e[s] || VI, r[s]);
  }
  function UP(t, e, n) {
    const i = e.length,
      r = eP(n, i);
    t.uniform1iv(this.addr, r);
    for (let s = 0; s !== i; ++s) n.setTexture3D(e[s] || WI, r[s]);
  }
  function BP(t, e, n) {
    const i = e.length,
      r = eP(n, i);
    t.uniform1iv(this.addr, r);
    for (let s = 0; s !== i; ++s) n.setTextureCube(e[s] || jI, r[s]);
  }
  function kP(t, e, n) {
    const i = e.length,
      r = eP(n, i);
    t.uniform1iv(this.addr, r);
    for (let s = 0; s !== i; ++s) n.setTexture2DArray(e[s] || XI, r[s]);
  }
  class GP {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return nP;
            case 35664:
              return iP;
            case 35665:
              return rP;
            case 35666:
              return sP;
            case 35674:
              return oP;
            case 35675:
              return aP;
            case 35676:
              return lP;
            case 5124:
            case 35670:
              return hP;
            case 35667:
            case 35671:
              return uP;
            case 35668:
            case 35672:
              return cP;
            case 35669:
            case 35673:
              return dP;
            case 5125:
              return pP;
            case 36294:
              return fP;
            case 36295:
              return mP;
            case 36296:
              return _P;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return gP;
            case 35679:
            case 36299:
            case 36307:
              return vP;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return yP;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return xP;
          }
        })(e.type));
    }
  }
  class HP {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return bP;
            case 35664:
              return TP;
            case 35665:
              return EP;
            case 35666:
              return SP;
            case 35674:
              return wP;
            case 35675:
              return MP;
            case 35676:
              return AP;
            case 5124:
            case 35670:
              return RP;
            case 35667:
            case 35671:
              return CP;
            case 35668:
            case 35672:
              return IP;
            case 35669:
            case 35673:
              return PP;
            case 5125:
              return OP;
            case 36294:
              return NP;
            case 36295:
              return DP;
            case 36296:
              return LP;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return FP;
            case 35679:
            case 36299:
            case 36307:
              return UP;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return BP;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return kP;
          }
        })(e.type));
    }
  }
  class zP {
    constructor(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    setValue(t, e, n) {
      const i = this.seq;
      for (let r = 0, s = i.length; r !== s; ++r) {
        const s = i[r];
        s.setValue(t, e[s.id], n);
      }
    }
  }
  const VP = /(\w+)(\])?(\[|\.)?/g;
  function XP(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function WP(t, e, n) {
    const i = t.name,
      r = i.length;
    for (VP.lastIndex = 0; ; ) {
      const s = VP.exec(i),
        o = VP.lastIndex;
      let a = s[1];
      const l = "]" === s[2],
        h = s[3];
      if ((l && (a |= 0), void 0 === h || ("[" === h && o + 2 === r))) {
        XP(n, void 0 === h ? new GP(a, t, e) : new HP(a, t, e));
        break;
      }
      {
        let t = n.map[a];
        void 0 === t && ((t = new zP(a)), XP(n, t)), (n = t);
      }
    }
  }
  class jP {
    constructor(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, 35718);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        WP(n, t.getUniformLocation(e, n.name), this);
      }
    }
    setValue(t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }
    setOptional(t, e, n) {
      const i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }
    static upload(t, e, n, i) {
      for (let r = 0, s = e.length; r !== s; ++r) {
        const s = e[r],
          o = n[s.id];
        !1 !== o.needsUpdate && s.setValue(t, o.value, i);
      }
    }
    static seqWithValue(t, e) {
      const n = [];
      for (let i = 0, r = t.length; i !== r; ++i) {
        const r = t[i];
        r.id in e && n.push(r);
      }
      return n;
    }
  }
  function YP(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  let qP = 0;
  function KP(t, e, n) {
    const i = t.getShaderParameter(e, 35713),
      r = t.getShaderInfoLog(e).trim();
    if (i && "" === r) return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
      const i = parseInt(s[1]);
      return (
        n.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (t, e) {
          const n = t.split("\n"),
            i = [],
            r = Math.max(e - 6, 0),
            s = Math.min(e + 6, n.length);
          for (let o = r; o < s; o++) {
            const t = o + 1;
            i.push(`${t === e ? ">" : " "} ${t}: ${n[o]}`);
          }
          return i.join("\n");
        })(t.getShaderSource(e), i)
      );
    }
    return r;
  }
  function ZP(t, e) {
    const n = (function (t) {
      switch (t) {
        case $M:
          return ["Linear", "( value )"];
        case QM:
          return ["sRGB", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
          );
      }
    })(e);
    return (
      "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    );
  }
  function JP(t, e) {
    let n;
    switch (e) {
      case 1:
        n = "Linear";
        break;
      case 2:
        n = "Reinhard";
        break;
      case 3:
        n = "OptimizedCineon";
        break;
      case 4:
        n = "ACESFilmic";
        break;
      case 5:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          (n = "Linear");
    }
    return (
      "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    );
  }
  function $P(t) {
    return "" !== t;
  }
  function QP(t, e) {
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function tO(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection
      );
  }
  const eO = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function nO(t) {
    return t.replace(eO, iO);
  }
  function iO(t, e) {
    const n = hI[e];
    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
    return nO(n);
  }
  const rO =
      /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    sO =
      /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function oO(t) {
    return t.replace(sO, lO).replace(rO, aO);
  }
  function aO(t, e, n, i) {
    return (
      console.warn(
        "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
      ),
      lO(t, e, n, i)
    );
  }
  function lO(t, e, n, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(n); s++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, s);
    return r;
  }
  function hO(t) {
    let e =
      "precision " +
      t.precision +
      " float;\nprecision " +
      t.precision +
      " int;";
    return (
      "highp" === t.precision
        ? (e += "\n#define HIGH_PRECISION")
        : "mediump" === t.precision
        ? (e += "\n#define MEDIUM_PRECISION")
        : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
      e
    );
  }
  function uO(t, e, n, i) {
    const r = t.getContext(),
      s = n.defines;
    let o = n.vertexShader,
      a = n.fragmentShader;
    const l = (function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          1 === t.shadowMapType
            ? (e = "SHADOWMAP_TYPE_PCF")
            : 2 === t.shadowMapType
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      })(n),
      h = (function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case MM:
            case AM:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case RM:
              e = "ENVMAP_TYPE_CUBE_UV";
          }
        return e;
      })(n),
      u = (function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        t.envMap && t.envMapMode === AM && (e = "ENVMAP_MODE_REFRACTION");
        return e;
      })(n),
      c = (function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case 0:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case 1:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case 2:
              e = "ENVMAP_BLENDING_ADD";
          }
        return e;
      })(n),
      d = (function (t) {
        const e = t.envMapCubeUVHeight;
        if (null === e) return null;
        const n = Math.log2(e) - 2,
          i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
          texelHeight: i,
          maxMip: n,
        };
      })(n),
      p = n.isWebGL2
        ? ""
        : (function (t) {
            return [
              t.extensionDerivatives ||
              t.envMapCubeUVHeight ||
              t.bumpMap ||
              t.tangentSpaceNormalMap ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              "physical" === t.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
              t.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter($P)
              .join("\n");
          })(n),
      f = (function (t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      })(s),
      m = r.createProgram();
    let _,
      g,
      v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial
      ? ((_ = [f].filter($P).join("\n")),
        _.length > 0 && (_ += "\n"),
        (g = [p, f].filter($P).join("\n")),
        g.length > 0 && (g += "\n"))
      : ((_ = [
          hO(n),
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.instancing ? "#define USE_INSTANCING" : "",
          n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + u : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.displacementMap && n.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && !1 === n.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
            : "",
          n.morphTargetsCount > 0 && n.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
            : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter($P)
          .join("\n")),
        (g = [
          p,
          hO(n),
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + h : "",
          n.envMap ? "#define " + u : "",
          n.envMap ? "#define " + c : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoat ? "#define USE_CLEARCOAT" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescence ? "#define USE_IRIDESCENCE" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaTest ? "#define USE_ALPHATEST" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
          0 !== n.toneMapping ? hI.tonemapping_pars_fragment : "",
          0 !== n.toneMapping ? JP("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          n.opaque ? "#define OPAQUE" : "",
          hI.encodings_pars_fragment,
          ZP("linearToOutputTexel", n.outputEncoding),
          n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          "\n",
        ]
          .filter($P)
          .join("\n"))),
      (o = nO(o)),
      (o = QP(o, n)),
      (o = tO(o, n)),
      (a = nO(a)),
      (a = QP(a, n)),
      (a = tO(a, n)),
      (o = oO(o)),
      (a = oO(a)),
      n.isWebGL2 &&
        !0 !== n.isRawShaderMaterial &&
        ((v = "#version 300 es\n"),
        (_ =
          [
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          _),
        (g =
          [
            "#define varying in",
            n.glslVersion === sA
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            n.glslVersion === sA ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          g));
    const y = v + g + a,
      x = YP(r, 35633, v + _ + o),
      b = YP(r, 35632, y);
    if (
      (r.attachShader(m, x),
      r.attachShader(m, b),
      void 0 !== n.index0AttributeName
        ? r.bindAttribLocation(m, 0, n.index0AttributeName)
        : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
      r.linkProgram(m),
      t.debug.checkShaderErrors)
    ) {
      const t = r.getProgramInfoLog(m).trim(),
        e = r.getShaderInfoLog(x).trim(),
        n = r.getShaderInfoLog(b).trim();
      let i = !0,
        s = !0;
      if (!1 === r.getProgramParameter(m, 35714)) {
        i = !1;
        const e = KP(r, x, "vertex"),
          n = KP(r, b, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(m, 35715) +
            "\n\nProgram Info Log: " +
            t +
            "\n" +
            e +
            "\n" +
            n
        );
      } else
        "" !== t
          ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
          : ("" !== e && "" !== n) || (s = !1);
      s &&
        (this.diagnostics = {
          runnable: i,
          programLog: t,
          vertexShader: { log: e, prefix: _ },
          fragmentShader: { log: n, prefix: g },
        });
    }
    let T, E;
    return (
      r.deleteShader(x),
      r.deleteShader(b),
      (this.getUniforms = function () {
        return void 0 === T && (T = new jP(r, m)), T;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === E &&
            (E = (function (t, e) {
              const n = {},
                i = t.getProgramParameter(e, 35721);
              for (let r = 0; r < i; r++) {
                const i = t.getActiveAttrib(e, r),
                  s = i.name;
                let o = 1;
                35674 === i.type && (o = 2),
                  35675 === i.type && (o = 3),
                  35676 === i.type && (o = 4),
                  (n[s] = {
                    type: i.type,
                    location: t.getAttribLocation(e, s),
                    locationSize: o,
                  });
              }
              return n;
            })(r, m)),
          E
        );
      }),
      (this.destroy = function () {
        i.releaseStatesOfProgram(this),
          r.deleteProgram(m),
          (this.program = void 0);
      }),
      (this.name = n.shaderName),
      (this.id = qP++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = m),
      (this.vertexShader = x),
      (this.fragmentShader = b),
      this
    );
  }
  let cO = 0;
  class dO {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(t) {
      const e = t.vertexShader,
        n = t.fragmentShader,
        i = this._getShaderStage(e),
        r = this._getShaderStage(n),
        s = this._getShaderCacheForMaterial(t);
      return (
        !1 === s.has(i) && (s.add(i), i.usedTimes++),
        !1 === s.has(r) && (s.add(r), r.usedTimes++),
        this
      );
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const n of e)
        n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n.code);
      return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      return !1 === e.has(t) && e.set(t, new Set()), e.get(t);
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      if (!1 === e.has(t)) {
        const n = new pO(t);
        e.set(t, n);
      }
      return e.get(t);
    }
  }
  class pO {
    constructor(t) {
      (this.id = cO++), (this.code = t), (this.usedTimes = 0);
    }
  }
  function fO(t, e, n, i, r, s, o) {
    const a = new DR(),
      l = new dO(),
      h = [],
      u = r.isWebGL2,
      c = r.logarithmicDepthBuffer,
      d = r.vertexTextures;
    let p = r.precision;
    const f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
    return {
      getParameters: function (s, a, h, m, _) {
        const g = m.fog,
          v = _.geometry,
          y = s.isMeshStandardMaterial ? m.environment : null,
          x = (s.isMeshStandardMaterial ? n : e).get(s.envMap || y),
          b = x && x.mapping === RM ? x.image.height : null,
          T = f[s.type];
        null !== s.precision &&
          ((p = r.getMaxPrecision(s.precision)),
          p !== s.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              s.precision,
              "not supported, using",
              p,
              "instead."
            ));
        const E =
            v.morphAttributes.position ||
            v.morphAttributes.normal ||
            v.morphAttributes.color,
          S = void 0 !== E ? E.length : 0;
        let w,
          M,
          A,
          R,
          C = 0;
        if (
          (void 0 !== v.morphAttributes.position && (C = 1),
          void 0 !== v.morphAttributes.normal && (C = 2),
          void 0 !== v.morphAttributes.color && (C = 3),
          T)
        ) {
          const t = cI[T];
          (w = t.vertexShader), (M = t.fragmentShader);
        } else
          (w = s.vertexShader),
            (M = s.fragmentShader),
            l.update(s),
            (A = l.getVertexShaderID(s)),
            (R = l.getFragmentShaderID(s));
        const I = t.getRenderTarget(),
          P = s.alphaTest > 0,
          O = s.clearcoat > 0,
          N = s.iridescence > 0;
        return {
          isWebGL2: u,
          shaderID: T,
          shaderName: s.type,
          vertexShader: w,
          fragmentShader: M,
          defines: s.defines,
          customVertexShaderID: A,
          customFragmentShaderID: R,
          isRawShaderMaterial: !0 === s.isRawShaderMaterial,
          glslVersion: s.glslVersion,
          precision: p,
          instancing: !0 === _.isInstancedMesh,
          instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
          supportsVertexTextures: d,
          outputEncoding:
            null === I
              ? t.outputEncoding
              : !0 === I.isXRRenderTarget
              ? I.texture.encoding
              : $M,
          map: !!s.map,
          matcap: !!s.matcap,
          envMap: !!x,
          envMapMode: x && x.mapping,
          envMapCubeUVHeight: b,
          lightMap: !!s.lightMap,
          aoMap: !!s.aoMap,
          emissiveMap: !!s.emissiveMap,
          bumpMap: !!s.bumpMap,
          normalMap: !!s.normalMap,
          objectSpaceNormalMap: 1 === s.normalMapType,
          tangentSpaceNormalMap: 0 === s.normalMapType,
          decodeVideoTexture:
            !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === QM,
          clearcoat: O,
          clearcoatMap: O && !!s.clearcoatMap,
          clearcoatRoughnessMap: O && !!s.clearcoatRoughnessMap,
          clearcoatNormalMap: O && !!s.clearcoatNormalMap,
          iridescence: N,
          iridescenceMap: N && !!s.iridescenceMap,
          iridescenceThicknessMap: N && !!s.iridescenceThicknessMap,
          displacementMap: !!s.displacementMap,
          roughnessMap: !!s.roughnessMap,
          metalnessMap: !!s.metalnessMap,
          specularMap: !!s.specularMap,
          specularIntensityMap: !!s.specularIntensityMap,
          specularColorMap: !!s.specularColorMap,
          opaque: !1 === s.transparent && 1 === s.blending,
          alphaMap: !!s.alphaMap,
          alphaTest: P,
          gradientMap: !!s.gradientMap,
          sheen: s.sheen > 0,
          sheenColorMap: !!s.sheenColorMap,
          sheenRoughnessMap: !!s.sheenRoughnessMap,
          transmission: s.transmission > 0,
          transmissionMap: !!s.transmissionMap,
          thicknessMap: !!s.thicknessMap,
          combine: s.combine,
          vertexTangents: !!s.normalMap && !!v.attributes.tangent,
          vertexColors: s.vertexColors,
          vertexAlphas:
            !0 === s.vertexColors &&
            !!v.attributes.color &&
            4 === v.attributes.color.itemSize,
          vertexUvs: !!(
            s.map ||
            s.bumpMap ||
            s.normalMap ||
            s.specularMap ||
            s.alphaMap ||
            s.emissiveMap ||
            s.roughnessMap ||
            s.metalnessMap ||
            s.clearcoatMap ||
            s.clearcoatRoughnessMap ||
            s.clearcoatNormalMap ||
            s.iridescenceMap ||
            s.iridescenceThicknessMap ||
            s.displacementMap ||
            s.transmissionMap ||
            s.thicknessMap ||
            s.specularIntensityMap ||
            s.specularColorMap ||
            s.sheenColorMap ||
            s.sheenRoughnessMap
          ),
          uvsVertexOnly: !(
            s.map ||
            s.bumpMap ||
            s.normalMap ||
            s.specularMap ||
            s.alphaMap ||
            s.emissiveMap ||
            s.roughnessMap ||
            s.metalnessMap ||
            s.clearcoatNormalMap ||
            s.iridescenceMap ||
            s.iridescenceThicknessMap ||
            s.transmission > 0 ||
            s.transmissionMap ||
            s.thicknessMap ||
            s.specularIntensityMap ||
            s.specularColorMap ||
            s.sheen > 0 ||
            s.sheenColorMap ||
            s.sheenRoughnessMap ||
            !s.displacementMap
          ),
          fog: !!g,
          useFog: !0 === s.fog,
          fogExp2: g && g.isFogExp2,
          flatShading: !!s.flatShading,
          sizeAttenuation: s.sizeAttenuation,
          logarithmicDepthBuffer: c,
          skinning: !0 === _.isSkinnedMesh,
          morphTargets: void 0 !== v.morphAttributes.position,
          morphNormals: void 0 !== v.morphAttributes.normal,
          morphColors: void 0 !== v.morphAttributes.color,
          morphTargetsCount: S,
          morphTextureStride: C,
          numDirLights: a.directional.length,
          numPointLights: a.point.length,
          numSpotLights: a.spot.length,
          numRectAreaLights: a.rectArea.length,
          numHemiLights: a.hemi.length,
          numDirLightShadows: a.directionalShadowMap.length,
          numPointLightShadows: a.pointShadowMap.length,
          numSpotLightShadows: a.spotShadowMap.length,
          numClippingPlanes: o.numPlanes,
          numClipIntersection: o.numIntersection,
          dithering: s.dithering,
          shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: s.toneMapped ? t.toneMapping : 0,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: s.premultipliedAlpha,
          doubleSided: 2 === s.side,
          flipSided: 1 === s.side,
          useDepthPacking: !!s.depthPacking,
          depthPacking: s.depthPacking || 0,
          index0AttributeName: s.index0AttributeName,
          extensionDerivatives: s.extensions && s.extensions.derivatives,
          extensionFragDepth: s.extensions && s.extensions.fragDepth,
          extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
          extensionShaderTextureLOD:
            s.extensions && s.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod:
            u || i.has("EXT_shader_texture_lod"),
          customProgramCacheKey: s.customProgramCacheKey(),
        };
      },
      getProgramCacheKey: function (e) {
        const n = [];
        if (
          (e.shaderID
            ? n.push(e.shaderID)
            : (n.push(e.customVertexShaderID),
              n.push(e.customFragmentShaderID)),
          void 0 !== e.defines)
        )
          for (const t in e.defines) n.push(t), n.push(e.defines[t]);
        return (
          !1 === e.isRawShaderMaterial &&
            (!(function (t, e) {
              t.push(e.precision),
                t.push(e.outputEncoding),
                t.push(e.envMapMode),
                t.push(e.envMapCubeUVHeight),
                t.push(e.combine),
                t.push(e.vertexUvs),
                t.push(e.fogExp2),
                t.push(e.sizeAttenuation),
                t.push(e.morphTargetsCount),
                t.push(e.morphAttributeCount),
                t.push(e.numDirLights),
                t.push(e.numPointLights),
                t.push(e.numSpotLights),
                t.push(e.numHemiLights),
                t.push(e.numRectAreaLights),
                t.push(e.numDirLightShadows),
                t.push(e.numPointLightShadows),
                t.push(e.numSpotLightShadows),
                t.push(e.shadowMapType),
                t.push(e.toneMapping),
                t.push(e.numClippingPlanes),
                t.push(e.numClipIntersection),
                t.push(e.depthPacking);
            })(n, e),
            (function (t, e) {
              a.disableAll(), e.isWebGL2 && a.enable(0);
              e.supportsVertexTextures && a.enable(1);
              e.instancing && a.enable(2);
              e.instancingColor && a.enable(3);
              e.map && a.enable(4);
              e.matcap && a.enable(5);
              e.envMap && a.enable(6);
              e.lightMap && a.enable(7);
              e.aoMap && a.enable(8);
              e.emissiveMap && a.enable(9);
              e.bumpMap && a.enable(10);
              e.normalMap && a.enable(11);
              e.objectSpaceNormalMap && a.enable(12);
              e.tangentSpaceNormalMap && a.enable(13);
              e.clearcoat && a.enable(14);
              e.clearcoatMap && a.enable(15);
              e.clearcoatRoughnessMap && a.enable(16);
              e.clearcoatNormalMap && a.enable(17);
              e.iridescence && a.enable(18);
              e.iridescenceMap && a.enable(19);
              e.iridescenceThicknessMap && a.enable(20);
              e.displacementMap && a.enable(21);
              e.specularMap && a.enable(22);
              e.roughnessMap && a.enable(23);
              e.metalnessMap && a.enable(24);
              e.gradientMap && a.enable(25);
              e.alphaMap && a.enable(26);
              e.alphaTest && a.enable(27);
              e.vertexColors && a.enable(28);
              e.vertexAlphas && a.enable(29);
              e.vertexUvs && a.enable(30);
              e.vertexTangents && a.enable(31);
              e.uvsVertexOnly && a.enable(32);
              e.fog && a.enable(33);
              t.push(a.mask), a.disableAll(), e.useFog && a.enable(0);
              e.flatShading && a.enable(1);
              e.logarithmicDepthBuffer && a.enable(2);
              e.skinning && a.enable(3);
              e.morphTargets && a.enable(4);
              e.morphNormals && a.enable(5);
              e.morphColors && a.enable(6);
              e.premultipliedAlpha && a.enable(7);
              e.shadowMapEnabled && a.enable(8);
              e.physicallyCorrectLights && a.enable(9);
              e.doubleSided && a.enable(10);
              e.flipSided && a.enable(11);
              e.useDepthPacking && a.enable(12);
              e.dithering && a.enable(13);
              e.specularIntensityMap && a.enable(14);
              e.specularColorMap && a.enable(15);
              e.transmission && a.enable(16);
              e.transmissionMap && a.enable(17);
              e.thicknessMap && a.enable(18);
              e.sheen && a.enable(19);
              e.sheenColorMap && a.enable(20);
              e.sheenRoughnessMap && a.enable(21);
              e.decodeVideoTexture && a.enable(22);
              e.opaque && a.enable(23);
              t.push(a.mask);
            })(n, e),
            n.push(t.outputEncoding)),
          n.push(e.customProgramCacheKey),
          n.join()
        );
      },
      getUniforms: function (t) {
        const e = f[t.type];
        let n;
        if (e) {
          const t = cI[e];
          n = WC.clone(t.uniforms);
        } else n = t.uniforms;
        return n;
      },
      acquireProgram: function (e, n) {
        let i;
        for (let t = 0, r = h.length; t < r; t++) {
          const e = h[t];
          if (e.cacheKey === n) {
            (i = e), ++i.usedTimes;
            break;
          }
        }
        return void 0 === i && ((i = new uO(t, n, e, s)), h.push(i)), i;
      },
      releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = h.indexOf(t);
          (h[e] = h[h.length - 1]), h.pop(), t.destroy();
        }
      },
      releaseShaderCache: function (t) {
        l.remove(t);
      },
      programs: h,
      dispose: function () {
        l.dispose();
      },
    };
  }
  function mO() {
    let t = new WeakMap();
    return {
      get: function (e) {
        let n = t.get(e);
        return void 0 === n && ((n = {}), t.set(e, n)), n;
      },
      remove: function (e) {
        t.delete(e);
      },
      update: function (e, n, i) {
        t.get(e)[n] = i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function _O(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function gO(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function vO() {
    const t = [];
    let e = 0;
    const n = [],
      i = [],
      r = [];
    function s(n, i, r, s, o, a) {
      let l = t[e];
      return (
        void 0 === l
          ? ((l = {
              id: n.id,
              object: n,
              geometry: i,
              material: r,
              groupOrder: s,
              renderOrder: n.renderOrder,
              z: o,
              group: a,
            }),
            (t[e] = l))
          : ((l.id = n.id),
            (l.object = n),
            (l.geometry = i),
            (l.material = r),
            (l.groupOrder = s),
            (l.renderOrder = n.renderOrder),
            (l.z = o),
            (l.group = a)),
        e++,
        l
      );
    }
    return {
      opaque: n,
      transmissive: i,
      transparent: r,
      init: function () {
        (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
      },
      push: function (t, e, o, a, l, h) {
        const u = s(t, e, o, a, l, h);
        o.transmission > 0
          ? i.push(u)
          : !0 === o.transparent
          ? r.push(u)
          : n.push(u);
      },
      unshift: function (t, e, o, a, l, h) {
        const u = s(t, e, o, a, l, h);
        o.transmission > 0
          ? i.unshift(u)
          : !0 === o.transparent
          ? r.unshift(u)
          : n.unshift(u);
      },
      finish: function () {
        for (let n = e, i = t.length; n < i; n++) {
          const e = t[n];
          if (null === e.id) break;
          (e.id = null),
            (e.object = null),
            (e.geometry = null),
            (e.material = null),
            (e.group = null);
        }
      },
      sort: function (t, e) {
        n.length > 1 && n.sort(t || _O),
          i.length > 1 && i.sort(e || gO),
          r.length > 1 && r.sort(e || gO);
      },
    };
  }
  function yO() {
    let t = new WeakMap();
    return {
      get: function (e, n) {
        let i;
        return (
          !1 === t.has(e)
            ? ((i = new vO()), t.set(e, [i]))
            : n >= t.get(e).length
            ? ((i = new vO()), t.get(e).push(i))
            : (i = t.get(e)[n]),
          i
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function xO() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;
        switch (e.type) {
          case "DirectionalLight":
            n = { direction: new jA(), color: new DA() };
            break;
          case "SpotLight":
            n = {
              position: new jA(),
              direction: new jA(),
              color: new DA(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            n = { position: new jA(), color: new DA(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            n = {
              direction: new jA(),
              skyColor: new DA(),
              groundColor: new DA(),
            };
            break;
          case "RectAreaLight":
            n = {
              color: new DA(),
              position: new jA(),
              halfWidth: new jA(),
              halfHeight: new jA(),
            };
        }
        return (t[e.id] = n), n;
      },
    };
  }
  let bO = 0;
  function TO(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
  }
  function EO(t, e) {
    const n = new xO(),
      i = (function () {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new xA(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new xA(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (t[e.id] = n), n;
          },
        };
      })(),
      r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
      };
    for (let l = 0; l < 9; l++) r.probe.push(new jA());
    const s = new jA(),
      o = new ER(),
      a = new ER();
    return {
      setup: function (s, o) {
        let a = 0,
          l = 0,
          h = 0;
        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
        let u = 0,
          c = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          _ = 0,
          g = 0;
        s.sort(TO);
        const v = !0 !== o ? Math.PI : 1;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t],
            o = e.color,
            y = e.intensity,
            x = e.distance,
            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight)
            (a += o.r * y * v), (l += o.g * y * v), (h += o.b * y * v);
          else if (e.isLightProbe)
            for (let t = 0; t < 9; t++)
              r.probe[t].addScaledVector(e.sh.coefficients[t], y);
          else if (e.isDirectionalLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * v),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (r.directionalShadow[u] = n),
                (r.directionalShadowMap[u] = b),
                (r.directionalShadowMatrix[u] = e.shadow.matrix),
                m++;
            }
            (r.directional[u] = t), u++;
          } else if (e.isSpotLight) {
            const t = n.get(e);
            if (
              (t.position.setFromMatrixPosition(e.matrixWorld),
              t.color.copy(o).multiplyScalar(y * v),
              (t.distance = x),
              (t.coneCos = Math.cos(e.angle)),
              (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
              (t.decay = e.decay),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (r.spotShadow[d] = n),
                (r.spotShadowMap[d] = b),
                (r.spotShadowMatrix[d] = e.shadow.matrix),
                g++;
            }
            (r.spot[d] = t), d++;
          } else if (e.isRectAreaLight) {
            const t = n.get(e);
            t.color.copy(o).multiplyScalar(y),
              t.halfWidth.set(0.5 * e.width, 0, 0),
              t.halfHeight.set(0, 0.5 * e.height, 0),
              (r.rectArea[p] = t),
              p++;
          } else if (e.isPointLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * v),
              (t.distance = e.distance),
              (t.decay = e.decay),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (n.shadowCameraNear = t.camera.near),
                (n.shadowCameraFar = t.camera.far),
                (r.pointShadow[c] = n),
                (r.pointShadowMap[c] = b),
                (r.pointShadowMatrix[c] = e.shadow.matrix),
                _++;
            }
            (r.point[c] = t), c++;
          } else if (e.isHemisphereLight) {
            const t = n.get(e);
            t.skyColor.copy(e.color).multiplyScalar(y * v),
              t.groundColor.copy(e.groundColor).multiplyScalar(y * v),
              (r.hemi[f] = t),
              f++;
          }
        }
        p > 0 &&
          (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
            ? ((r.rectAreaLTC1 = uI.LTC_FLOAT_1),
              (r.rectAreaLTC2 = uI.LTC_FLOAT_2))
            : !0 === t.has("OES_texture_half_float_linear")
            ? ((r.rectAreaLTC1 = uI.LTC_HALF_1),
              (r.rectAreaLTC2 = uI.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
              )),
          (r.ambient[0] = a),
          (r.ambient[1] = l),
          (r.ambient[2] = h);
        const y = r.hash;
        (y.directionalLength === u &&
          y.pointLength === c &&
          y.spotLength === d &&
          y.rectAreaLength === p &&
          y.hemiLength === f &&
          y.numDirectionalShadows === m &&
          y.numPointShadows === _ &&
          y.numSpotShadows === g) ||
          ((r.directional.length = u),
          (r.spot.length = d),
          (r.rectArea.length = p),
          (r.point.length = c),
          (r.hemi.length = f),
          (r.directionalShadow.length = m),
          (r.directionalShadowMap.length = m),
          (r.pointShadow.length = _),
          (r.pointShadowMap.length = _),
          (r.spotShadow.length = g),
          (r.spotShadowMap.length = g),
          (r.directionalShadowMatrix.length = m),
          (r.pointShadowMatrix.length = _),
          (r.spotShadowMatrix.length = g),
          (y.directionalLength = u),
          (y.pointLength = c),
          (y.spotLength = d),
          (y.rectAreaLength = p),
          (y.hemiLength = f),
          (y.numDirectionalShadows = m),
          (y.numPointShadows = _),
          (y.numSpotShadows = g),
          (r.version = bO++));
      },
      setupView: function (t, e) {
        let n = 0,
          i = 0,
          l = 0,
          h = 0,
          u = 0;
        const c = e.matrixWorldInverse;
        for (let d = 0, p = t.length; d < p; d++) {
          const e = t[d];
          if (e.isDirectionalLight) {
            const t = r.directional[n];
            t.direction.setFromMatrixPosition(e.matrixWorld),
              s.setFromMatrixPosition(e.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(c),
              n++;
          } else if (e.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(c),
              t.direction.setFromMatrixPosition(e.matrixWorld),
              s.setFromMatrixPosition(e.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(c),
              l++;
          } else if (e.isRectAreaLight) {
            const t = r.rectArea[h];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(c),
              a.identity(),
              o.copy(e.matrixWorld),
              o.premultiply(c),
              a.extractRotation(o),
              t.halfWidth.set(0.5 * e.width, 0, 0),
              t.halfHeight.set(0, 0.5 * e.height, 0),
              t.halfWidth.applyMatrix4(a),
              t.halfHeight.applyMatrix4(a),
              h++;
          } else if (e.isPointLight) {
            const t = r.point[i];
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.position.applyMatrix4(c),
              i++;
          } else if (e.isHemisphereLight) {
            const t = r.hemi[u];
            t.direction.setFromMatrixPosition(e.matrixWorld),
              t.direction.transformDirection(c),
              u++;
          }
        }
      },
      state: r,
    };
  }
  function SO(t, e) {
    const n = new EO(t, e),
      i = [],
      r = [];
    return {
      init: function () {
        (i.length = 0), (r.length = 0);
      },
      state: { lightsArray: i, shadowsArray: r, lights: n },
      setupLights: function (t) {
        n.setup(i, t);
      },
      setupLightsView: function (t) {
        n.setupView(i, t);
      },
      pushLight: function (t) {
        i.push(t);
      },
      pushShadow: function (t) {
        r.push(t);
      },
    };
  }
  function wO(t, e) {
    let n = new WeakMap();
    return {
      get: function (i, r = 0) {
        let s;
        return (
          !1 === n.has(i)
            ? ((s = new SO(t, e)), n.set(i, [s]))
            : r >= n.get(i).length
            ? ((s = new SO(t, e)), n.get(i).push(s))
            : (s = n.get(i)[r]),
          s
        );
      },
      dispose: function () {
        n = new WeakMap();
      },
    };
  }
  class MO extends aC {
    constructor(t) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.depthPacking = t.depthPacking),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }
  }
  class AO extends aC {
    constructor(t) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new jA()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.referencePosition.copy(t.referencePosition),
        (this.nearDistance = t.nearDistance),
        (this.farDistance = t.farDistance),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }
  }
  function RO(t, e, n) {
    let i = new sI();
    const r = new xA(),
      s = new xA(),
      o = new HA(),
      a = new MO({ depthPacking: tA }),
      l = new AO(),
      h = {},
      u = n.maxTextureSize,
      c = { 0: 1, 1: 0, 2: 2 },
      d = new jC({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new xA() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const f = new TC();
    f.setAttribute(
      "position",
      new cC(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const m = new GC(f, d),
      _ = this;
    function g(n, i) {
      const s = e.update(m);
      d.defines.VSM_SAMPLES !== n.blurSamples &&
        ((d.defines.VSM_SAMPLES = n.blurSamples),
        (p.defines.VSM_SAMPLES = n.blurSamples),
        (d.needsUpdate = !0),
        (p.needsUpdate = !0)),
        null === n.mapPass && (n.mapPass = new zA(r.x, r.y)),
        (d.uniforms.shadow_pass.value = n.map.texture),
        (d.uniforms.resolution.value = n.mapSize),
        (d.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.mapPass),
        t.clear(),
        t.renderBufferDirect(i, null, s, d, m, null),
        (p.uniforms.shadow_pass.value = n.mapPass.texture),
        (p.uniforms.resolution.value = n.mapSize),
        (p.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.map),
        t.clear(),
        t.renderBufferDirect(i, null, s, p, m, null);
    }
    function v(e, n, i, r, s, o) {
      let u = null;
      const d =
        !0 === i.isPointLight
          ? e.customDistanceMaterial
          : e.customDepthMaterial;
      if (
        ((u = void 0 !== d ? d : !0 === i.isPointLight ? l : a),
        (t.localClippingEnabled &&
          !0 === n.clipShadows &&
          Array.isArray(n.clippingPlanes) &&
          0 !== n.clippingPlanes.length) ||
          (n.displacementMap && 0 !== n.displacementScale) ||
          (n.alphaMap && n.alphaTest > 0))
      ) {
        const t = u.uuid,
          e = n.uuid;
        let i = h[t];
        void 0 === i && ((i = {}), (h[t] = i));
        let r = i[e];
        void 0 === r && ((r = u.clone()), (i[e] = r)), (u = r);
      }
      return (
        (u.visible = n.visible),
        (u.wireframe = n.wireframe),
        (u.side =
          3 === o
            ? null !== n.shadowSide
              ? n.shadowSide
              : n.side
            : null !== n.shadowSide
            ? n.shadowSide
            : c[n.side]),
        (u.alphaMap = n.alphaMap),
        (u.alphaTest = n.alphaTest),
        (u.clipShadows = n.clipShadows),
        (u.clippingPlanes = n.clippingPlanes),
        (u.clipIntersection = n.clipIntersection),
        (u.displacementMap = n.displacementMap),
        (u.displacementScale = n.displacementScale),
        (u.displacementBias = n.displacementBias),
        (u.wireframeLinewidth = n.wireframeLinewidth),
        (u.linewidth = n.linewidth),
        !0 === i.isPointLight &&
          !0 === u.isMeshDistanceMaterial &&
          (u.referencePosition.setFromMatrixPosition(i.matrixWorld),
          (u.nearDistance = r),
          (u.farDistance = s)),
        u
      );
    }
    function y(n, r, s, o, a) {
      if (!1 === n.visible) return;
      if (
        n.layers.test(r.layers) &&
        (n.isMesh || n.isLine || n.isPoints) &&
        (n.castShadow || (n.receiveShadow && 3 === a)) &&
        (!n.frustumCulled || i.intersectsObject(n))
      ) {
        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
        const i = e.update(n),
          r = n.material;
        if (Array.isArray(r)) {
          const e = i.groups;
          for (let l = 0, h = e.length; l < h; l++) {
            const h = e[l],
              u = r[h.materialIndex];
            if (u && u.visible) {
              const e = v(n, u, o, s.near, s.far, a);
              t.renderBufferDirect(s, null, i, e, n, h);
            }
          }
        } else if (r.visible) {
          const e = v(n, r, o, s.near, s.far, a);
          t.renderBufferDirect(s, null, i, e, n, null);
        }
      }
      const l = n.children;
      for (let t = 0, e = l.length; t < e; t++) y(l[t], r, s, o, a);
    }
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = 1),
      (this.render = function (e, n, a) {
        if (!1 === _.enabled) return;
        if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(),
          h = t.getActiveCubeFace(),
          c = t.getActiveMipmapLevel(),
          d = t.state;
        d.setBlending(0),
          d.buffers.color.setClear(1, 1, 1, 1),
          d.buffers.depth.setTest(!0),
          d.setScissorTest(!1);
        for (let p = 0, f = e.length; p < f; p++) {
          const l = e[p],
            h = l.shadow;
          if (void 0 === h) {
            console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
            continue;
          }
          if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
          r.copy(h.mapSize);
          const c = h.getFrameExtents();
          if (
            (r.multiply(c),
            s.copy(h.mapSize),
            (r.x > u || r.y > u) &&
              (r.x > u &&
                ((s.x = Math.floor(u / c.x)),
                (r.x = s.x * c.x),
                (h.mapSize.x = s.x)),
              r.y > u &&
                ((s.y = Math.floor(u / c.y)),
                (r.y = s.y * c.y),
                (h.mapSize.y = s.y))),
            null === h.map)
          ) {
            const t = 3 !== this.type ? { minFilter: OM, magFilter: OM } : {};
            (h.map = new zA(r.x, r.y, t)),
              (h.map.texture.name = l.name + ".shadowMap"),
              h.camera.updateProjectionMatrix();
          }
          t.setRenderTarget(h.map), t.clear();
          const f = h.getViewportCount();
          for (let t = 0; t < f; t++) {
            const e = h.getViewport(t);
            o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
              d.viewport(o),
              h.updateMatrices(l, t),
              (i = h.getFrustum()),
              y(n, a, h.camera, l, this.type);
          }
          !0 !== h.isPointLightShadow && 3 === this.type && g(h, a),
            (h.needsUpdate = !1);
        }
        (_.needsUpdate = !1), t.setRenderTarget(l, h, c);
      });
  }
  function CO(t, e, n) {
    const i = n.isWebGL2;
    const r = new (function () {
        let e = !1;
        const n = new HA();
        let i = null;
        const r = new HA(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, s, o, a) {
            !0 === a && ((e *= o), (i *= o), (s *= o)),
              n.set(e, i, s, o),
              !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      s = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (t) {
            t ? G(2929) : H(2929);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              if (e)
                switch (e) {
                  case 0:
                    t.depthFunc(512);
                    break;
                  case 1:
                    t.depthFunc(519);
                    break;
                  case 2:
                    t.depthFunc(513);
                    break;
                  case 3:
                  default:
                    t.depthFunc(515);
                    break;
                  case 4:
                    t.depthFunc(514);
                    break;
                  case 5:
                    t.depthFunc(518);
                    break;
                  case 6:
                    t.depthFunc(516);
                    break;
                  case 7:
                    t.depthFunc(517);
                }
              else t.depthFunc(515);
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      o = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null,
          s = null,
          o = null,
          a = null,
          l = null,
          h = null;
        return {
          setTest: function (t) {
            e || (t ? G(2960) : H(2960));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, o) {
            (i === e && r === n && s === o) ||
              (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o));
          },
          setOp: function (e, n, i) {
            (o === e && a === n && l === i) ||
              (t.stencilOp(e, n, i), (o = e), (a = n), (l = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            h !== e && (t.clearStencil(e), (h = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (s = null),
              (o = null),
              (a = null),
              (l = null),
              (h = null);
          },
        };
      })(),
      a = new WeakMap(),
      l = new WeakMap();
    let h = {},
      u = {},
      c = new WeakMap(),
      d = [],
      p = null,
      f = !1,
      m = null,
      _ = null,
      g = null,
      v = null,
      y = null,
      x = null,
      b = null,
      T = !1,
      E = null,
      S = null,
      w = null,
      M = null,
      A = null;
    const R = t.getParameter(35661);
    let C = !1,
      I = 0;
    const P = t.getParameter(7938);
    -1 !== P.indexOf("WebGL")
      ? ((I = parseFloat(/^WebGL (\d)/.exec(P)[1])), (C = I >= 1))
      : -1 !== P.indexOf("OpenGL ES") &&
        ((I = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (C = I >= 2));
    let O = null,
      N = {};
    const D = t.getParameter(3088),
      L = t.getParameter(2978),
      F = new HA().fromArray(D),
      U = new HA().fromArray(L);
    function B(e, n, i) {
      const r = new Uint8Array(4),
        s = t.createTexture();
      t.bindTexture(e, s),
        t.texParameteri(e, 10241, 9728),
        t.texParameteri(e, 10240, 9728);
      for (let o = 0; o < i; o++)
        t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
      return s;
    }
    const k = {};
    function G(e) {
      !0 !== h[e] && (t.enable(e), (h[e] = !0));
    }
    function H(e) {
      !1 !== h[e] && (t.disable(e), (h[e] = !1));
    }
    (k[3553] = B(3553, 3553, 1)),
      (k[34067] = B(34067, 34069, 6)),
      r.setClear(0, 0, 0, 1),
      s.setClear(1),
      o.setClear(0),
      G(2929),
      s.setFunc(3),
      W(!1),
      j(1),
      G(2884),
      X(0);
    const z = { [wM]: 32774, 101: 32778, 102: 32779 };
    if (i) (z[103] = 32775), (z[104] = 32776);
    else {
      const t = e.get("EXT_blend_minmax");
      null !== t && ((z[103] = t.MIN_EXT), (z[104] = t.MAX_EXT));
    }
    const V = {
      200: 0,
      201: 1,
      202: 768,
      204: 770,
      210: 776,
      208: 774,
      206: 772,
      203: 769,
      205: 771,
      209: 775,
      207: 773,
    };
    function X(e, n, i, r, s, o, a, l) {
      if (0 !== e) {
        if ((!1 === f && (G(3042), (f = !0)), 5 === e))
          (s = s || n),
            (o = o || i),
            (a = a || r),
            (n === _ && s === y) ||
              (t.blendEquationSeparate(z[n], z[s]), (_ = n), (y = s)),
            (i === g && r === v && o === x && a === b) ||
              (t.blendFuncSeparate(V[i], V[r], V[o], V[a]),
              (g = i),
              (v = r),
              (x = o),
              (b = a)),
            (m = e),
            (T = null);
        else if (e !== m || l !== T) {
          if (
            ((_ === wM && y === wM) ||
              (t.blendEquation(32774), (_ = wM), (y = wM)),
            l)
          )
            switch (e) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 769, 0, 1);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          else
            switch (e) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 769, 0, 1);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          (g = null), (v = null), (x = null), (b = null), (m = e), (T = l);
        }
      } else !0 === f && (H(3042), (f = !1));
    }
    function W(e) {
      E !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (E = e));
    }
    function j(e) {
      0 !== e
        ? (G(2884),
          e !== S &&
            (1 === e
              ? t.cullFace(1029)
              : 2 === e
              ? t.cullFace(1028)
              : t.cullFace(1032)))
        : H(2884),
        (S = e);
    }
    function Y(e, n, i) {
      e
        ? (G(32823),
          (M === n && A === i) || (t.polygonOffset(n, i), (M = n), (A = i)))
        : H(32823);
    }
    function q(e) {
      void 0 === e && (e = 33984 + R - 1),
        O !== e && (t.activeTexture(e), (O = e));
    }
    return {
      buffers: { color: r, depth: s, stencil: o },
      enable: G,
      disable: H,
      bindFramebuffer: function (e, n) {
        return (
          u[e] !== n &&
          (t.bindFramebuffer(e, n),
          (u[e] = n),
          i && (36009 === e && (u[36160] = n), 36160 === e && (u[36009] = n)),
          !0)
        );
      },
      drawBuffers: function (i, r) {
        let s = d,
          o = !1;
        if (i)
          if (
            ((s = c.get(r)),
            void 0 === s && ((s = []), c.set(r, s)),
            i.isWebGLMultipleRenderTargets)
          ) {
            const t = i.texture;
            if (s.length !== t.length || 36064 !== s[0]) {
              for (let e = 0, n = t.length; e < n; e++) s[e] = 36064 + e;
              (s.length = t.length), (o = !0);
            }
          } else 36064 !== s[0] && ((s[0] = 36064), (o = !0));
        else 1029 !== s[0] && ((s[0] = 1029), (o = !0));
        o &&
          (n.isWebGL2
            ? t.drawBuffers(s)
            : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
      },
      useProgram: function (e) {
        return p !== e && (t.useProgram(e), (p = e), !0);
      },
      setBlending: X,
      setMaterial: function (t, e) {
        2 === t.side ? H(2884) : G(2884);
        let n = 1 === t.side;
        e && (n = !n),
          W(n),
          1 === t.blending && !1 === t.transparent
            ? X(0)
            : X(
                t.blending,
                t.blendEquation,
                t.blendSrc,
                t.blendDst,
                t.blendEquationAlpha,
                t.blendSrcAlpha,
                t.blendDstAlpha,
                t.premultipliedAlpha
              ),
          s.setFunc(t.depthFunc),
          s.setTest(t.depthTest),
          s.setMask(t.depthWrite),
          r.setMask(t.colorWrite);
        const i = t.stencilWrite;
        o.setTest(i),
          i &&
            (o.setMask(t.stencilWriteMask),
            o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
            o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
          Y(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
          !0 === t.alphaToCoverage ? G(32926) : H(32926);
      },
      setFlipSided: W,
      setCullFace: j,
      setLineWidth: function (e) {
        e !== w && (C && t.lineWidth(e), (w = e));
      },
      setPolygonOffset: Y,
      setScissorTest: function (t) {
        t ? G(3089) : H(3089);
      },
      activeTexture: q,
      bindTexture: function (e, n) {
        null === O && q();
        let i = N[O];
        void 0 === i && ((i = { type: void 0, texture: void 0 }), (N[O] = i)),
          (i.type === e && i.texture === n) ||
            (t.bindTexture(e, n || k[e]), (i.type = e), (i.texture = n));
      },
      unbindTexture: function () {
        const e = N[O];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      updateUBOMapping: function (e, n) {
        let i = l.get(n);
        void 0 === i && ((i = new WeakMap()), l.set(n, i));
        let r = i.get(e);
        void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
      },
      uniformBlockBinding: function (e, n) {
        const i = l.get(n).get(e);
        a.get(e) !== i &&
          (t.uniformBlockBinding(n, i, e.__bindingPointIndex), a.set(e, i));
      },
      texStorage2D: function () {
        try {
          t.texStorage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texStorage3D: function () {
        try {
          t.texStorage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage2D: function () {
        try {
          t.texSubImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage3D: function () {
        try {
          t.texSubImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexSubImage2D: function () {
        try {
          t.compressedTexSubImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      scissor: function (e) {
        !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e));
      },
      viewport: function (e) {
        !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e));
      },
      reset: function () {
        t.disable(3042),
          t.disable(2884),
          t.disable(2929),
          t.disable(32823),
          t.disable(3089),
          t.disable(2960),
          t.disable(32926),
          t.blendEquation(32774),
          t.blendFunc(1, 0),
          t.blendFuncSeparate(1, 0, 1, 0),
          t.colorMask(!0, !0, !0, !0),
          t.clearColor(0, 0, 0, 0),
          t.depthMask(!0),
          t.depthFunc(513),
          t.clearDepth(1),
          t.stencilMask(4294967295),
          t.stencilFunc(519, 0, 4294967295),
          t.stencilOp(7680, 7680, 7680),
          t.clearStencil(0),
          t.cullFace(1029),
          t.frontFace(2305),
          t.polygonOffset(0, 0),
          t.activeTexture(33984),
          t.bindFramebuffer(36160, null),
          !0 === i &&
            (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
          t.useProgram(null),
          t.lineWidth(1),
          t.scissor(0, 0, t.canvas.width, t.canvas.height),
          t.viewport(0, 0, t.canvas.width, t.canvas.height),
          (h = {}),
          (O = null),
          (N = {}),
          (u = {}),
          (c = new WeakMap()),
          (d = []),
          (p = null),
          (f = !1),
          (m = null),
          (_ = null),
          (g = null),
          (v = null),
          (y = null),
          (x = null),
          (b = null),
          (T = !1),
          (E = null),
          (S = null),
          (w = null),
          (M = null),
          (A = null),
          F.set(0, 0, t.canvas.width, t.canvas.height),
          U.set(0, 0, t.canvas.width, t.canvas.height),
          r.reset(),
          s.reset(),
          o.reset();
      },
    };
  }
  function IO(t, e, n, i, r, s, o) {
    const a = r.isWebGL2,
      l = r.maxTextures,
      h = r.maxCubemapSize,
      u = r.maxTextureSize,
      c = r.maxSamples,
      d = e.has("WEBGL_multisampled_render_to_texture")
        ? e.get("WEBGL_multisampled_render_to_texture")
        : null,
      p = /OculusBrowser/g.test(navigator.userAgent),
      f = new WeakMap();
    let m;
    const _ = new WeakMap();
    let g = !1;
    try {
      g =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (z) {}
    function v(t, e) {
      return g ? new OffscreenCanvas(t, e) : EA("canvas");
    }
    function y(t, e, n, i) {
      let r = 1;
      if (
        ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
        r < 1 || !0 === e)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          const i = e ? vA : Math.floor,
            s = i(r * t.width),
            o = i(r * t.height);
          void 0 === m && (m = v(s, o));
          const a = n ? v(s, o) : m;
          (a.width = s), (a.height = o);
          return (
            a.getContext("2d").drawImage(t, 0, 0, s, o),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                t.width +
                "x" +
                t.height +
                ") to (" +
                s +
                "x" +
                o +
                ")."
            ),
            a
          );
        }
        return (
          "data" in t &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                t.width +
                "x" +
                t.height +
                ")."
            ),
          t
        );
      }
      return t;
    }
    function x(t) {
      return _A(t.width) && _A(t.height);
    }
    function b(t, e) {
      return t.generateMipmaps && e && t.minFilter !== OM && t.minFilter !== LM;
    }
    function T(e) {
      t.generateMipmap(e);
    }
    function E(n, i, r, s, o = !1) {
      if (!1 === a) return i;
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            n +
            "'"
        );
      }
      let l = i;
      return (
        6403 === i &&
          (5126 === r && (l = 33326),
          5131 === r && (l = 33325),
          5121 === r && (l = 33321)),
        33319 === i &&
          (5126 === r && (l = 33328),
          5131 === r && (l = 33327),
          5121 === r && (l = 33323)),
        6408 === i &&
          (5126 === r && (l = 34836),
          5131 === r && (l = 34842),
          5121 === r && (l = s === QM && !1 === o ? 35907 : 32856),
          32819 === r && (l = 32854),
          32820 === r && (l = 32855)),
        (33325 !== l &&
          33326 !== l &&
          33327 !== l &&
          33328 !== l &&
          34842 !== l &&
          34836 !== l) ||
          e.get("EXT_color_buffer_float"),
        l
      );
    }
    function S(t, e, n) {
      return !0 === b(t, n) ||
        (t.isFramebufferTexture && t.minFilter !== OM && t.minFilter !== LM)
        ? Math.log2(Math.max(e.width, e.height)) + 1
        : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
        ? e.mipmaps.length
        : 1;
    }
    function w(t) {
      return t === OM || t === NM || t === DM ? 9728 : 9729;
    }
    function M(t) {
      const e = t.target;
      e.removeEventListener("dispose", M),
        (function (t) {
          const e = i.get(t);
          if (void 0 === e.__webglInit) return;
          const n = t.source,
            r = _.get(n);
          if (r) {
            const i = r[e.__cacheKey];
            i.usedTimes--,
              0 === i.usedTimes && R(t),
              0 === Object.keys(r).length && _.delete(n);
          }
          i.remove(t);
        })(e),
        e.isVideoTexture && f.delete(e);
    }
    function A(e) {
      const n = e.target;
      n.removeEventListener("dispose", A),
        (function (e) {
          const n = e.texture,
            r = i.get(e),
            s = i.get(n);
          void 0 !== s.__webglTexture &&
            (t.deleteTexture(s.__webglTexture), o.memory.textures--);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget)
            for (let i = 0; i < 6; i++)
              t.deleteFramebuffer(r.__webglFramebuffer[i]),
                r.__webglDepthbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthbuffer[i]);
          else {
            if (
              (t.deleteFramebuffer(r.__webglFramebuffer),
              r.__webglDepthbuffer &&
                t.deleteRenderbuffer(r.__webglDepthbuffer),
              r.__webglMultisampledFramebuffer &&
                t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
              r.__webglColorRenderbuffer)
            )
              for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                r.__webglColorRenderbuffer[e] &&
                  t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
            r.__webglDepthRenderbuffer &&
              t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
          }
          if (e.isWebGLMultipleRenderTargets)
            for (let a = 0, l = n.length; a < l; a++) {
              const e = i.get(n[a]);
              e.__webglTexture &&
                (t.deleteTexture(e.__webglTexture), o.memory.textures--),
                i.remove(n[a]);
            }
          i.remove(n), i.remove(e);
        })(n);
    }
    function R(e) {
      const n = i.get(e);
      t.deleteTexture(n.__webglTexture);
      const r = e.source;
      delete _.get(r)[n.__cacheKey], o.memory.textures--;
    }
    let C = 0;
    function I(t, e) {
      const r = i.get(t);
      if (
        (t.isVideoTexture &&
          (function (t) {
            const e = o.render.frame;
            f.get(t) !== e && (f.set(t, e), t.update());
          })(t),
        !1 === t.isRenderTargetTexture &&
          t.version > 0 &&
          r.__version !== t.version)
      ) {
        const n = t.image;
        if (null === n)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found."
          );
        else {
          if (!1 !== n.complete) return void L(r, t, e);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        }
      }
      n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
    }
    const P = { [CM]: 10497, [IM]: 33071, [PM]: 33648 },
      O = {
        [OM]: 9728,
        [NM]: 9984,
        [DM]: 9986,
        [LM]: 9729,
        1007: 9985,
        [FM]: 9987,
      };
    function N(n, s, o) {
      if (
        (o
          ? (t.texParameteri(n, 10242, P[s.wrapS]),
            t.texParameteri(n, 10243, P[s.wrapT]),
            (32879 !== n && 35866 !== n) ||
              t.texParameteri(n, 32882, P[s.wrapR]),
            t.texParameteri(n, 10240, O[s.magFilter]),
            t.texParameteri(n, 10241, O[s.minFilter]))
          : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
            (s.wrapS === IM && s.wrapT === IM) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            t.texParameteri(n, 10240, w(s.magFilter)),
            t.texParameteri(n, 10241, w(s.minFilter)),
            s.minFilter !== OM &&
              s.minFilter !== LM &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              )),
        !0 === e.has("EXT_texture_filter_anisotropic"))
      ) {
        const o = e.get("EXT_texture_filter_anisotropic");
        if (s.type === kM && !1 === e.has("OES_texture_float_linear")) return;
        if (
          !1 === a &&
          s.type === GM &&
          !1 === e.has("OES_texture_half_float_linear")
        )
          return;
        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
          (t.texParameterf(
            n,
            o.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(s.anisotropy, r.getMaxAnisotropy())
          ),
          (i.get(s).__currentAnisotropy = s.anisotropy));
      }
    }
    function D(e, n) {
      let i = !1;
      void 0 === e.__webglInit &&
        ((e.__webglInit = !0), n.addEventListener("dispose", M));
      const r = n.source;
      let s = _.get(r);
      void 0 === s && ((s = {}), _.set(r, s));
      const a = (function (t) {
        const e = [];
        return (
          e.push(t.wrapS),
          e.push(t.wrapT),
          e.push(t.magFilter),
          e.push(t.minFilter),
          e.push(t.anisotropy),
          e.push(t.internalFormat),
          e.push(t.format),
          e.push(t.type),
          e.push(t.generateMipmaps),
          e.push(t.premultiplyAlpha),
          e.push(t.flipY),
          e.push(t.unpackAlignment),
          e.push(t.encoding),
          e.join()
        );
      })(n);
      if (a !== e.__cacheKey) {
        void 0 === s[a] &&
          ((s[a] = { texture: t.createTexture(), usedTimes: 0 }),
          o.memory.textures++,
          (i = !0)),
          s[a].usedTimes++;
        const r = s[e.__cacheKey];
        void 0 !== r &&
          (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && R(n)),
          (e.__cacheKey = a),
          (e.__webglTexture = s[a].texture);
      }
      return i;
    }
    function L(e, i, r) {
      let o = 3553;
      i.isDataArrayTexture && (o = 35866), i.isData3DTexture && (o = 32879);
      const l = D(e, i),
        h = i.source;
      if (
        (n.activeTexture(33984 + r),
        n.bindTexture(o, e.__webglTexture),
        h.version !== h.__currentVersion || !0 === l)
      ) {
        t.pixelStorei(37440, i.flipY),
          t.pixelStorei(37441, i.premultiplyAlpha),
          t.pixelStorei(3317, i.unpackAlignment),
          t.pixelStorei(37443, 0);
        const e =
          (function (t) {
            return (
              !a &&
              (t.wrapS !== IM ||
                t.wrapT !== IM ||
                (t.minFilter !== OM && t.minFilter !== LM))
            );
          })(i) && !1 === x(i.image);
        let r = y(i.image, e, !1, u);
        r = H(i, r);
        const c = x(r) || a,
          d = s.convert(i.format, i.encoding);
        let p,
          f = s.convert(i.type),
          m = E(i.internalFormat, d, f, i.encoding, i.isVideoTexture);
        N(o, i, c);
        const _ = i.mipmaps,
          g = a && !0 !== i.isVideoTexture,
          v = void 0 === h.__currentVersion || !0 === l,
          w = S(i, r, c);
        if (i.isDepthTexture)
          (m = 6402),
            a
              ? (m =
                  i.type === kM
                    ? 36012
                    : i.type === BM
                    ? 33190
                    : i.type === HM
                    ? 35056
                    : 33189)
              : i.type === kM &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            i.format === VM &&
              6402 === m &&
              1012 !== i.type &&
              i.type !== BM &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = BM),
              (f = s.convert(i.type))),
            i.format === XM &&
              6402 === m &&
              ((m = 34041),
              i.type !== HM &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = HM),
                (f = s.convert(i.type)))),
            v &&
              (g
                ? n.texStorage2D(3553, 1, m, r.width, r.height)
                : n.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, null));
        else if (i.isDataTexture)
          if (_.length > 0 && c) {
            g && v && n.texStorage2D(3553, w, m, _[0].width, _[0].height);
            for (let t = 0, e = _.length; t < e; t++)
              (p = _[t]),
                g
                  ? n.texSubImage2D(
                      3553,
                      t,
                      0,
                      0,
                      p.width,
                      p.height,
                      d,
                      f,
                      p.data
                    )
                  : n.texImage2D(
                      3553,
                      t,
                      m,
                      p.width,
                      p.height,
                      0,
                      d,
                      f,
                      p.data
                    );
            i.generateMipmaps = !1;
          } else
            g
              ? (v && n.texStorage2D(3553, w, m, r.width, r.height),
                n.texSubImage2D(3553, 0, 0, 0, r.width, r.height, d, f, r.data))
              : n.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, r.data);
        else if (i.isCompressedTexture) {
          g && v && n.texStorage2D(3553, w, m, _[0].width, _[0].height);
          for (let t = 0, e = _.length; t < e; t++)
            (p = _[t]),
              i.format !== zM
                ? null !== d
                  ? g
                    ? n.compressedTexSubImage2D(
                        3553,
                        t,
                        0,
                        0,
                        p.width,
                        p.height,
                        d,
                        p.data
                      )
                    : n.compressedTexImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        p.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : g
                ? n.texSubImage2D(
                    3553,
                    t,
                    0,
                    0,
                    p.width,
                    p.height,
                    d,
                    f,
                    p.data
                  )
                : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
        } else if (i.isDataArrayTexture)
          g
            ? (v && n.texStorage3D(35866, w, m, r.width, r.height, r.depth),
              n.texSubImage3D(
                35866,
                0,
                0,
                0,
                0,
                r.width,
                r.height,
                r.depth,
                d,
                f,
                r.data
              ))
            : n.texImage3D(
                35866,
                0,
                m,
                r.width,
                r.height,
                r.depth,
                0,
                d,
                f,
                r.data
              );
        else if (i.isData3DTexture)
          g
            ? (v && n.texStorage3D(32879, w, m, r.width, r.height, r.depth),
              n.texSubImage3D(
                32879,
                0,
                0,
                0,
                0,
                r.width,
                r.height,
                r.depth,
                d,
                f,
                r.data
              ))
            : n.texImage3D(
                32879,
                0,
                m,
                r.width,
                r.height,
                r.depth,
                0,
                d,
                f,
                r.data
              );
        else if (i.isFramebufferTexture) {
          if (v)
            if (g) n.texStorage2D(3553, w, m, r.width, r.height);
            else {
              let t = r.width,
                e = r.height;
              for (let i = 0; i < w; i++)
                n.texImage2D(3553, i, m, t, e, 0, d, f, null),
                  (t >>= 1),
                  (e >>= 1);
            }
        } else if (_.length > 0 && c) {
          g && v && n.texStorage2D(3553, w, m, _[0].width, _[0].height);
          for (let t = 0, e = _.length; t < e; t++)
            (p = _[t]),
              g
                ? n.texSubImage2D(3553, t, 0, 0, d, f, p)
                : n.texImage2D(3553, t, m, d, f, p);
          i.generateMipmaps = !1;
        } else
          g
            ? (v && n.texStorage2D(3553, w, m, r.width, r.height),
              n.texSubImage2D(3553, 0, 0, 0, d, f, r))
            : n.texImage2D(3553, 0, m, d, f, r);
        b(i, c) && T(o),
          (h.__currentVersion = h.version),
          i.onUpdate && i.onUpdate(i);
      }
      e.__version = i.version;
    }
    function F(e, r, o, a, l) {
      const h = s.convert(o.format, o.encoding),
        u = s.convert(o.type),
        c = E(o.internalFormat, h, u, o.encoding);
      i.get(r).__hasExternalTextures ||
        (32879 === l || 35866 === l
          ? n.texImage3D(l, 0, c, r.width, r.height, r.depth, 0, h, u, null)
          : n.texImage2D(l, 0, c, r.width, r.height, 0, h, u, null)),
        n.bindFramebuffer(36160, e),
        G(r)
          ? d.framebufferTexture2DMultisampleEXT(
              36160,
              a,
              l,
              i.get(o).__webglTexture,
              0,
              k(r)
            )
          : t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
        n.bindFramebuffer(36160, null);
    }
    function U(e, n, i) {
      if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
        let r = 33189;
        if (i || G(n)) {
          const e = n.depthTexture;
          e &&
            e.isDepthTexture &&
            (e.type === kM ? (r = 36012) : e.type === BM && (r = 33190));
          const i = k(n);
          G(n)
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                i,
                r,
                n.width,
                n.height
              )
            : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
        } else t.renderbufferStorage(36161, r, n.width, n.height);
        t.framebufferRenderbuffer(36160, 36096, 36161, e);
      } else if (n.depthBuffer && n.stencilBuffer) {
        const r = k(n);
        i && !1 === G(n)
          ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height)
          : G(n)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              r,
              35056,
              n.width,
              n.height
            )
          : t.renderbufferStorage(36161, 34041, n.width, n.height),
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
      } else {
        const e =
          !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
        for (let r = 0; r < e.length; r++) {
          const o = e[r],
            a = s.convert(o.format, o.encoding),
            l = s.convert(o.type),
            h = E(o.internalFormat, a, l, o.encoding),
            u = k(n);
          i && !1 === G(n)
            ? t.renderbufferStorageMultisample(36161, u, h, n.width, n.height)
            : G(n)
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                u,
                h,
                n.width,
                n.height
              )
            : t.renderbufferStorage(36161, h, n.width, n.height);
        }
      }
      t.bindRenderbuffer(36161, null);
    }
    function B(e) {
      const r = i.get(e),
        s = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
        if (s)
          throw new Error(
            "target.depthTexture not supported in Cube render targets"
          );
        !(function (e, r) {
          if (r && r.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (n.bindFramebuffer(36160, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (i.get(r.depthTexture).__webglTexture &&
            r.depthTexture.image.width === r.width &&
            r.depthTexture.image.height === r.height) ||
            ((r.depthTexture.image.width = r.width),
            (r.depthTexture.image.height = r.height),
            (r.depthTexture.needsUpdate = !0)),
            I(r.depthTexture, 0);
          const s = i.get(r.depthTexture).__webglTexture,
            o = k(r);
          if (r.depthTexture.format === VM)
            G(r)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  36096,
                  3553,
                  s,
                  0,
                  o
                )
              : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
          else {
            if (r.depthTexture.format !== XM)
              throw new Error("Unknown depthTexture format");
            G(r)
              ? d.framebufferTexture2DMultisampleEXT(
                  36160,
                  33306,
                  3553,
                  s,
                  0,
                  o
                )
              : t.framebufferTexture2D(36160, 33306, 3553, s, 0);
          }
        })(r.__webglFramebuffer, e);
      } else if (s) {
        r.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++)
          n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
            (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
            U(r.__webglDepthbuffer[i], e, !1);
      } else
        n.bindFramebuffer(36160, r.__webglFramebuffer),
          (r.__webglDepthbuffer = t.createRenderbuffer()),
          U(r.__webglDepthbuffer, e, !1);
      n.bindFramebuffer(36160, null);
    }
    function k(t) {
      return Math.min(c, t.samples);
    }
    function G(t) {
      const n = i.get(t);
      return (
        a &&
        t.samples > 0 &&
        !0 === e.has("WEBGL_multisampled_render_to_texture") &&
        !1 !== n.__useRenderToTexture
      );
    }
    function H(t, n) {
      const i = t.encoding,
        r = t.format,
        s = t.type;
      return (
        !0 === t.isCompressedTexture ||
          !0 === t.isVideoTexture ||
          t.format === oA ||
          (i !== $M &&
            (i === QM
              ? !1 === a
                ? !0 === e.has("EXT_sRGB") && r === zM
                  ? ((t.format = oA),
                    (t.minFilter = LM),
                    (t.generateMipmaps = !1))
                  : (n = FA.sRGBToLinear(n))
                : (r === zM && s === UM) ||
                  console.warn(
                    "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                  )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture encoding:",
                  i
                ))),
        n
      );
    }
    (this.allocateTextureUnit = function () {
      const t = C;
      return (
        t >= l &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              t +
              " texture units while this GPU supports only " +
              l
          ),
        (C += 1),
        t
      );
    }),
      (this.resetTextureUnits = function () {
        C = 0;
      }),
      (this.setTexture2D = I),
      (this.setTexture2DArray = function (t, e) {
        const r = i.get(t);
        t.version > 0 && r.__version !== t.version
          ? L(r, t, e)
          : (n.activeTexture(33984 + e),
            n.bindTexture(35866, r.__webglTexture));
      }),
      (this.setTexture3D = function (t, e) {
        const r = i.get(t);
        t.version > 0 && r.__version !== t.version
          ? L(r, t, e)
          : (n.activeTexture(33984 + e),
            n.bindTexture(32879, r.__webglTexture));
      }),
      (this.setTextureCube = function (e, r) {
        const o = i.get(e);
        e.version > 0 && o.__version !== e.version
          ? (function (e, i, r) {
              if (6 !== i.image.length) return;
              const o = D(e, i),
                l = i.source;
              if (
                (n.activeTexture(33984 + r),
                n.bindTexture(34067, e.__webglTexture),
                l.version !== l.__currentVersion || !0 === o)
              ) {
                t.pixelStorei(37440, i.flipY),
                  t.pixelStorei(37441, i.premultiplyAlpha),
                  t.pixelStorei(3317, i.unpackAlignment),
                  t.pixelStorei(37443, 0);
                const e =
                    i.isCompressedTexture || i.image[0].isCompressedTexture,
                  r = i.image[0] && i.image[0].isDataTexture,
                  u = [];
                for (let t = 0; t < 6; t++)
                  (u[t] =
                    e || r
                      ? r
                        ? i.image[t].image
                        : i.image[t]
                      : y(i.image[t], !1, !0, h)),
                    (u[t] = H(i, u[t]));
                const c = u[0],
                  d = x(c) || a,
                  p = s.convert(i.format, i.encoding),
                  f = s.convert(i.type),
                  m = E(i.internalFormat, p, f, i.encoding),
                  _ = a && !0 !== i.isVideoTexture,
                  g = void 0 === l.__currentVersion || !0 === o;
                let v,
                  w = S(i, c, d);
                if ((N(34067, i, d), e)) {
                  _ && g && n.texStorage2D(34067, w, m, c.width, c.height);
                  for (let t = 0; t < 6; t++) {
                    v = u[t].mipmaps;
                    for (let e = 0; e < v.length; e++) {
                      const r = v[e];
                      i.format !== zM
                        ? null !== p
                          ? _
                            ? n.compressedTexSubImage2D(
                                34069 + t,
                                e,
                                0,
                                0,
                                r.width,
                                r.height,
                                p,
                                r.data
                              )
                            : n.compressedTexImage2D(
                                34069 + t,
                                e,
                                m,
                                r.width,
                                r.height,
                                0,
                                r.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : _
                        ? n.texSubImage2D(
                            34069 + t,
                            e,
                            0,
                            0,
                            r.width,
                            r.height,
                            p,
                            f,
                            r.data
                          )
                        : n.texImage2D(
                            34069 + t,
                            e,
                            m,
                            r.width,
                            r.height,
                            0,
                            p,
                            f,
                            r.data
                          );
                    }
                  }
                } else {
                  (v = i.mipmaps),
                    _ &&
                      g &&
                      (v.length > 0 && w++,
                      n.texStorage2D(34067, w, m, u[0].width, u[0].height));
                  for (let t = 0; t < 6; t++)
                    if (r) {
                      _
                        ? n.texSubImage2D(
                            34069 + t,
                            0,
                            0,
                            0,
                            u[t].width,
                            u[t].height,
                            p,
                            f,
                            u[t].data
                          )
                        : n.texImage2D(
                            34069 + t,
                            0,
                            m,
                            u[t].width,
                            u[t].height,
                            0,
                            p,
                            f,
                            u[t].data
                          );
                      for (let e = 0; e < v.length; e++) {
                        const i = v[e].image[t].image;
                        _
                          ? n.texSubImage2D(
                              34069 + t,
                              e + 1,
                              0,
                              0,
                              i.width,
                              i.height,
                              p,
                              f,
                              i.data
                            )
                          : n.texImage2D(
                              34069 + t,
                              e + 1,
                              m,
                              i.width,
                              i.height,
                              0,
                              p,
                              f,
                              i.data
                            );
                      }
                    } else {
                      _
                        ? n.texSubImage2D(34069 + t, 0, 0, 0, p, f, u[t])
                        : n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                      for (let e = 0; e < v.length; e++) {
                        const i = v[e];
                        _
                          ? n.texSubImage2D(
                              34069 + t,
                              e + 1,
                              0,
                              0,
                              p,
                              f,
                              i.image[t]
                            )
                          : n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
                      }
                    }
                }
                b(i, d) && T(34067),
                  (l.__currentVersion = l.version),
                  i.onUpdate && i.onUpdate(i);
              }
              e.__version = i.version;
            })(o, e, r)
          : (n.activeTexture(33984 + r),
            n.bindTexture(34067, o.__webglTexture));
      }),
      (this.rebindTextures = function (t, e, n) {
        const r = i.get(t);
        void 0 !== e && F(r.__webglFramebuffer, t, t.texture, 36064, 3553),
          void 0 !== n && B(t);
      }),
      (this.setupRenderTarget = function (e) {
        const l = e.texture,
          h = i.get(e),
          u = i.get(l);
        e.addEventListener("dispose", A),
          !0 !== e.isWebGLMultipleRenderTargets &&
            (void 0 === u.__webglTexture &&
              (u.__webglTexture = t.createTexture()),
            (u.__version = l.version),
            o.memory.textures++);
        const c = !0 === e.isWebGLCubeRenderTarget,
          d = !0 === e.isWebGLMultipleRenderTargets,
          p = x(e) || a;
        if (c) {
          h.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++)
            h.__webglFramebuffer[e] = t.createFramebuffer();
        } else {
          if (((h.__webglFramebuffer = t.createFramebuffer()), d))
            if (r.drawBuffers) {
              const n = e.texture;
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = t.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          if (a && e.samples > 0 && !1 === G(e)) {
            const i = d ? l : [l];
            (h.__webglMultisampledFramebuffer = t.createFramebuffer()),
              (h.__webglColorRenderbuffer = []),
              n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              (h.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, h.__webglColorRenderbuffer[n]);
              const o = s.convert(r.format, r.encoding),
                a = s.convert(r.type),
                l = E(r.internalFormat, o, a, r.encoding),
                u = k(e);
              t.renderbufferStorageMultisample(36161, u, l, e.width, e.height),
                t.framebufferRenderbuffer(
                  36160,
                  36064 + n,
                  36161,
                  h.__webglColorRenderbuffer[n]
                );
            }
            t.bindRenderbuffer(36161, null),
              e.depthBuffer &&
                ((h.__webglDepthRenderbuffer = t.createRenderbuffer()),
                U(h.__webglDepthRenderbuffer, e, !0)),
              n.bindFramebuffer(36160, null);
          }
        }
        if (c) {
          n.bindTexture(34067, u.__webglTexture), N(34067, l, p);
          for (let t = 0; t < 6; t++)
            F(h.__webglFramebuffer[t], e, l, 36064, 34069 + t);
          b(l, p) && T(34067), n.unbindTexture();
        } else if (d) {
          const t = e.texture;
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              o = i.get(s);
            n.bindTexture(3553, o.__webglTexture),
              N(3553, s, p),
              F(h.__webglFramebuffer, e, s, 36064 + r, 3553),
              b(s, p) && T(3553);
          }
          n.unbindTexture();
        } else {
          let t = 3553;
          (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
            (a
              ? (t = e.isWebGL3DRenderTarget ? 32879 : 35866)
              : console.error(
                  "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                )),
            n.bindTexture(t, u.__webglTexture),
            N(t, l, p),
            F(h.__webglFramebuffer, e, l, 36064, t),
            b(l, p) && T(t),
            n.unbindTexture();
        }
        e.depthBuffer && B(e);
      }),
      (this.updateRenderTargetMipmap = function (t) {
        const e = x(t) || a,
          r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
        for (let s = 0, o = r.length; s < o; s++) {
          const o = r[s];
          if (b(o, e)) {
            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
              r = i.get(o).__webglTexture;
            n.bindTexture(e, r), T(e), n.unbindTexture();
          }
        }
      }),
      (this.updateMultisampleRenderTarget = function (e) {
        if (a && e.samples > 0 && !1 === G(e)) {
          const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
            s = e.width,
            o = e.height;
          let a = 16384;
          const l = [],
            h = e.stencilBuffer ? 33306 : 36096,
            u = i.get(e),
            c = !0 === e.isWebGLMultipleRenderTargets;
          if (c)
            for (let e = 0; e < r.length; e++)
              n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(36160, 36064 + e, 36161, null),
                n.bindFramebuffer(36160, u.__webglFramebuffer),
                t.framebufferTexture2D(36009, 36064 + e, 3553, null, 0);
          n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer),
            n.bindFramebuffer(36009, u.__webglFramebuffer);
          for (let n = 0; n < r.length; n++) {
            l.push(36064 + n), e.depthBuffer && l.push(h);
            const d = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
            if (
              (!1 === d &&
                (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024)),
              c &&
                t.framebufferRenderbuffer(
                  36008,
                  36064,
                  36161,
                  u.__webglColorRenderbuffer[n]
                ),
              !0 === d &&
                (t.invalidateFramebuffer(36008, [h]),
                t.invalidateFramebuffer(36009, [h])),
              c)
            ) {
              const e = i.get(r[n]).__webglTexture;
              t.framebufferTexture2D(36009, 36064, 3553, e, 0);
            }
            t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728),
              p && t.invalidateFramebuffer(36008, l);
          }
          if (
            (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), c)
          )
            for (let e = 0; e < r.length; e++) {
              n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064 + e,
                  36161,
                  u.__webglColorRenderbuffer[e]
                );
              const s = i.get(r[e]).__webglTexture;
              n.bindFramebuffer(36160, u.__webglFramebuffer),
                t.framebufferTexture2D(36009, 36064 + e, 3553, s, 0);
            }
          n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer);
        }
      }),
      (this.setupDepthRenderbuffer = B),
      (this.setupFrameBufferTexture = F),
      (this.useMultisampledRTT = G);
  }
  function PO(t, e, n) {
    const i = n.isWebGL2;
    return {
      convert: function (n, r = null) {
        let s;
        if (n === UM) return 5121;
        if (1017 === n) return 32819;
        if (1018 === n) return 32820;
        if (1010 === n) return 5120;
        if (1011 === n) return 5122;
        if (1012 === n) return 5123;
        if (1013 === n) return 5124;
        if (n === BM) return 5125;
        if (n === kM) return 5126;
        if (n === GM)
          return i
            ? 5131
            : ((s = e.get("OES_texture_half_float")),
              null !== s ? s.HALF_FLOAT_OES : null);
        if (1021 === n) return 6406;
        if (n === zM) return 6408;
        if (1024 === n) return 6409;
        if (1025 === n) return 6410;
        if (n === VM) return 6402;
        if (n === XM) return 34041;
        if (1028 === n) return 6403;
        if (1022 === n)
          return (
            console.warn(
              "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
            ),
            6408
          );
        if (n === oA)
          return (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null;
        if (1029 === n) return 36244;
        if (1030 === n) return 33319;
        if (1031 === n) return 33320;
        if (1033 === n) return 36249;
        if (n === WM || n === jM || n === YM || n === qM)
          if (r === QM) {
            if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s))
              return null;
            if (n === WM) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (n === jM) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (n === YM) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (n === qM) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s))
              return null;
            if (n === WM) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === jM) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === YM) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === qM) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
          if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
            return null;
          if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === n)
          return (
            (s = e.get("WEBGL_compressed_texture_etc1")),
            null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
          );
        if (37492 === n || 37496 === n) {
          if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
            return null;
          if (37492 === n)
            return r === QM ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
          if (37496 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : s.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
          37808 === n ||
          37809 === n ||
          37810 === n ||
          37811 === n ||
          37812 === n ||
          37813 === n ||
          37814 === n ||
          37815 === n ||
          37816 === n ||
          37817 === n ||
          37818 === n ||
          37819 === n ||
          37820 === n ||
          37821 === n
        ) {
          if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
            return null;
          if (37808 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (37809 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (37810 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (37811 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (37812 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (37813 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (37814 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (37815 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (37816 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (37817 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (37818 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (37819 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (37820 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (37821 === n)
            return r === QM
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
        if (36492 === n) {
          if (((s = e.get("EXT_texture_compression_bptc")), null === s))
            return null;
          if (36492 === n)
            return r === QM
              ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        }
        return n === HM
          ? i
            ? 34042
            : ((s = e.get("WEBGL_depth_texture")),
              null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
          : void 0 !== t[n]
          ? t[n]
          : null;
      },
    };
  }
  class OO extends qC {
    constructor(t = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = t);
    }
  }
  class NO extends qR {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  }
  const DO = { type: "move" };
  class LO {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        null === this._hand &&
          ((this._hand = new NO()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        null === this._targetRay &&
          ((this._targetRay = new NO()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new jA()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new jA())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        null === this._grip &&
          ((this._grip = new NO()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new jA()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new jA())),
        this._grip
      );
    }
    dispatchEvent(t) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
      );
    }
    disconnect(t) {
      return (
        this.dispatchEvent({ type: "disconnected", data: t }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    }
    update(t, e, n) {
      let i = null,
        r = null,
        s = null;
      const o = this._targetRay,
        a = this._grip,
        l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          s = !0;
          for (const s of t.hand.values()) {
            const t = e.getJointPose(s, n);
            if (void 0 === l.joints[s.jointName]) {
              const t = new NO();
              (t.matrixAutoUpdate = !1),
                (t.visible = !1),
                (l.joints[s.jointName] = t),
                l.add(t);
            }
            const i = l.joints[s.jointName];
            null !== t &&
              (i.matrix.fromArray(t.transform.matrix),
              i.matrix.decompose(i.position, i.rotation, i.scale),
              (i.jointRadius = t.radius)),
              (i.visible = null !== t);
          }
          const i = l.joints["index-finger-tip"],
            r = l.joints["thumb-tip"],
            o = i.position.distanceTo(r.position),
            a = 0.02,
            h = 0.005;
          l.inputState.pinching && o > a + h
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              o <= a - h &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this,
              }));
        } else
          null !== a &&
            t.gripSpace &&
            ((r = e.getPose(t.gripSpace, n)),
            null !== r &&
              (a.matrix.fromArray(r.transform.matrix),
              a.matrix.decompose(a.position, a.rotation, a.scale),
              r.linearVelocity
                ? ((a.hasLinearVelocity = !0),
                  a.linearVelocity.copy(r.linearVelocity))
                : (a.hasLinearVelocity = !1),
              r.angularVelocity
                ? ((a.hasAngularVelocity = !0),
                  a.angularVelocity.copy(r.angularVelocity))
                : (a.hasAngularVelocity = !1)));
        null !== o &&
          ((i = e.getPose(t.targetRaySpace, n)),
          null === i && null !== r && (i = r),
          null !== i &&
            (o.matrix.fromArray(i.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale),
            i.linearVelocity
              ? ((o.hasLinearVelocity = !0),
                o.linearVelocity.copy(i.linearVelocity))
              : (o.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((o.hasAngularVelocity = !0),
                o.angularVelocity.copy(i.angularVelocity))
              : (o.hasAngularVelocity = !1),
            this.dispatchEvent(DO)));
      }
      return (
        null !== o && (o.visible = null !== i),
        null !== a && (a.visible = null !== r),
        null !== l && (l.visible = null !== s),
        this
      );
    }
  }
  class FO extends GA {
    constructor(t, e, n, i, r, s, o, a, l, h) {
      if ((h = void 0 !== h ? h : VM) !== VM && h !== XM)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && h === VM && (n = BM),
        void 0 === n && h === XM && (n = HM),
        super(null, i, r, s, o, a, h, n, l),
        (this.isDepthTexture = !0),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== o ? o : OM),
        (this.minFilter = void 0 !== a ? a : OM),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
  }
  class UO extends aA {
    constructor(t, e) {
      super();
      const n = this;
      let i = null,
        r = 1,
        s = null,
        o = "local-floor",
        a = null,
        l = null,
        h = null,
        u = null,
        c = null,
        d = null;
      const p = e.getContextAttributes();
      let f = null,
        m = null;
      const _ = [],
        g = [],
        v = new qC();
      v.layers.enable(1), (v.viewport = new HA());
      const y = new qC();
      y.layers.enable(2), (y.viewport = new HA());
      const x = [v, y],
        b = new OO();
      b.layers.enable(1), b.layers.enable(2);
      let T = null,
        E = null;
      function S(t) {
        const e = g.indexOf(t.inputSource);
        if (-1 === e) return;
        const n = _[e];
        void 0 !== n && n.dispatchEvent({ type: t.type, data: t.inputSource });
      }
      function w() {
        i.removeEventListener("select", S),
          i.removeEventListener("selectstart", S),
          i.removeEventListener("selectend", S),
          i.removeEventListener("squeeze", S),
          i.removeEventListener("squeezestart", S),
          i.removeEventListener("squeezeend", S),
          i.removeEventListener("end", w),
          i.removeEventListener("inputsourceschange", M);
        for (let t = 0; t < _.length; t++) {
          const e = g[t];
          null !== e && ((g[t] = null), _[t].disconnect(e));
        }
        (T = null),
          (E = null),
          t.setRenderTarget(f),
          (c = null),
          (u = null),
          (h = null),
          (i = null),
          (m = null),
          P.stop(),
          (n.isPresenting = !1),
          n.dispatchEvent({ type: "sessionend" });
      }
      function M(t) {
        for (let e = 0; e < t.removed.length; e++) {
          const n = t.removed[e],
            i = g.indexOf(n);
          i >= 0 &&
            ((g[i] = null),
            _[i].dispatchEvent({ type: "disconnected", data: n }));
        }
        for (let e = 0; e < t.added.length; e++) {
          const n = t.added[e];
          let i = g.indexOf(n);
          if (-1 === i) {
            for (let t = 0; t < _.length; t++) {
              if (t >= g.length) {
                g.push(n), (i = t);
                break;
              }
              if (null === g[t]) {
                (g[t] = n), (i = t);
                break;
              }
            }
            if (-1 === i) break;
          }
          const r = _[i];
          r && r.dispatchEvent({ type: "connected", data: n });
        }
      }
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          let e = _[t];
          return (
            void 0 === e && ((e = new LO()), (_[t] = e)), e.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new LO()), (_[t] = e)), e.getGripSpace();
        }),
        (this.getHand = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new LO()), (_[t] = e)), e.getHandSpace();
        }),
        (this.setFramebufferScaleFactor = function (t) {
          (r = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
        (this.setReferenceSpaceType = function (t) {
          (o = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return a || s;
        }),
        (this.setReferenceSpace = function (t) {
          a = t;
        }),
        (this.getBaseLayer = function () {
          return null !== u ? u : c;
        }),
        (this.getBinding = function () {
          return h;
        }),
        (this.getFrame = function () {
          return d;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = async function (l) {
          if (((i = l), null !== i)) {
            if (
              ((f = t.getRenderTarget()),
              i.addEventListener("select", S),
              i.addEventListener("selectstart", S),
              i.addEventListener("selectend", S),
              i.addEventListener("squeeze", S),
              i.addEventListener("squeezestart", S),
              i.addEventListener("squeezeend", S),
              i.addEventListener("end", w),
              i.addEventListener("inputsourceschange", M),
              !0 !== p.xrCompatible && (await e.makeXRCompatible()),
              void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)
            ) {
              const n = {
                antialias: void 0 !== i.renderState.layers || p.antialias,
                alpha: p.alpha,
                depth: p.depth,
                stencil: p.stencil,
                framebufferScaleFactor: r,
              };
              (c = new XRWebGLLayer(i, e, n)),
                i.updateRenderState({ baseLayer: c }),
                (m = new zA(c.framebufferWidth, c.framebufferHeight, {
                  format: zM,
                  type: UM,
                  encoding: t.outputEncoding,
                }));
            } else {
              let n = null,
                s = null,
                o = null;
              p.depth &&
                ((o = p.stencil ? 35056 : 33190),
                (n = p.stencil ? XM : VM),
                (s = p.stencil ? HM : BM));
              const a = { colorFormat: 32856, depthFormat: o, scaleFactor: r };
              (h = new XRWebGLBinding(i, e)),
                (u = h.createProjectionLayer(a)),
                i.updateRenderState({ layers: [u] }),
                (m = new zA(u.textureWidth, u.textureHeight, {
                  format: zM,
                  type: UM,
                  depthTexture: new FO(
                    u.textureWidth,
                    u.textureHeight,
                    s,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    n
                  ),
                  stencilBuffer: p.stencil,
                  encoding: t.outputEncoding,
                  samples: p.antialias ? 4 : 0,
                }));
              t.properties.get(m).__ignoreDepthValues = u.ignoreDepthValues;
            }
            (m.isXRRenderTarget = !0),
              this.setFoveation(1),
              (a = null),
              (s = await i.requestReferenceSpace(o)),
              P.setContext(i),
              P.start(),
              (n.isPresenting = !0),
              n.dispatchEvent({ type: "sessionstart" });
          }
        });
      const A = new jA(),
        R = new jA();
      function C(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.copy(t.matrixWorld).invert();
      }
      (this.updateCamera = function (t) {
        if (null === i) return;
        (b.near = y.near = v.near = t.near),
          (b.far = y.far = v.far = t.far),
          (T === b.near && E === b.far) ||
            (i.updateRenderState({ depthNear: b.near, depthFar: b.far }),
            (T = b.near),
            (E = b.far));
        const e = t.parent,
          n = b.cameras;
        C(b, e);
        for (let i = 0; i < n.length; i++) C(n[i], e);
        b.matrixWorld.decompose(b.position, b.quaternion, b.scale),
          t.position.copy(b.position),
          t.quaternion.copy(b.quaternion),
          t.scale.copy(b.scale),
          t.matrix.copy(b.matrix),
          t.matrixWorld.copy(b.matrixWorld);
        const r = t.children;
        for (let i = 0, s = r.length; i < s; i++) r[i].updateMatrixWorld(!0);
        2 === n.length
          ? (function (t, e, n) {
              A.setFromMatrixPosition(e.matrixWorld),
                R.setFromMatrixPosition(n.matrixWorld);
              const i = A.distanceTo(R),
                r = e.projectionMatrix.elements,
                s = n.projectionMatrix.elements,
                o = r[14] / (r[10] - 1),
                a = r[14] / (r[10] + 1),
                l = (r[9] + 1) / r[5],
                h = (r[9] - 1) / r[5],
                u = (r[8] - 1) / r[0],
                c = (s[8] + 1) / s[0],
                d = o * u,
                p = o * c,
                f = i / (-u + c),
                m = f * -u;
              e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                t.translateX(m),
                t.translateZ(f),
                t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
              const _ = o + f,
                g = a + f,
                v = d - m,
                y = p + (i - m),
                x = ((l * a) / g) * _,
                b = ((h * a) / g) * _;
              t.projectionMatrix.makePerspective(v, y, x, b, _, g);
            })(b, v, y)
          : b.projectionMatrix.copy(v.projectionMatrix);
      }),
        (this.getCamera = function () {
          return b;
        }),
        (this.getFoveation = function () {
          return null !== u
            ? u.fixedFoveation
            : null !== c
            ? c.fixedFoveation
            : void 0;
        }),
        (this.setFoveation = function (t) {
          null !== u && (u.fixedFoveation = t),
            null !== c && void 0 !== c.fixedFoveation && (c.fixedFoveation = t);
        });
      let I = null;
      const P = new oI();
      P.setAnimationLoop(function (e, n) {
        if (((l = n.getViewerPose(a || s)), (d = n), null !== l)) {
          const e = l.views;
          null !== c &&
            (t.setRenderTargetFramebuffer(m, c.framebuffer),
            t.setRenderTarget(m));
          let n = !1;
          e.length !== b.cameras.length && ((b.cameras.length = 0), (n = !0));
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            let s = null;
            if (null !== c) s = c.getViewport(r);
            else {
              const e = h.getViewSubImage(u, r);
              (s = e.viewport),
                0 === i &&
                  (t.setRenderTargetTextures(
                    m,
                    e.colorTexture,
                    u.ignoreDepthValues ? void 0 : e.depthStencilTexture
                  ),
                  t.setRenderTarget(m));
            }
            let o = x[i];
            void 0 === o &&
              ((o = new qC()),
              o.layers.enable(i),
              (o.viewport = new HA()),
              (x[i] = o)),
              o.matrix.fromArray(r.transform.matrix),
              o.projectionMatrix.fromArray(r.projectionMatrix),
              o.viewport.set(s.x, s.y, s.width, s.height),
              0 === i && b.matrix.copy(o.matrix),
              !0 === n && b.cameras.push(o);
          }
        }
        for (let t = 0; t < _.length; t++) {
          const e = g[t],
            i = _[t];
          null !== e && void 0 !== i && i.update(e, n, a || s);
        }
        I && I(e, n), (d = null);
      }),
        (this.setAnimationLoop = function (t) {
          I = t;
        }),
        (this.dispose = function () {});
    }
  }
  function BO(t, e) {
    function n(n, i) {
      (n.opacity.value = i.opacity),
        i.color && n.diffuse.value.copy(i.color),
        i.emissive &&
          n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
        i.map && (n.map.value = i.map),
        i.alphaMap && (n.alphaMap.value = i.alphaMap),
        i.bumpMap &&
          ((n.bumpMap.value = i.bumpMap),
          (n.bumpScale.value = i.bumpScale),
          1 === i.side && (n.bumpScale.value *= -1)),
        i.displacementMap &&
          ((n.displacementMap.value = i.displacementMap),
          (n.displacementScale.value = i.displacementScale),
          (n.displacementBias.value = i.displacementBias)),
        i.emissiveMap && (n.emissiveMap.value = i.emissiveMap),
        i.normalMap &&
          ((n.normalMap.value = i.normalMap),
          n.normalScale.value.copy(i.normalScale),
          1 === i.side && n.normalScale.value.negate()),
        i.specularMap && (n.specularMap.value = i.specularMap),
        i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
      const r = e.get(i).envMap;
      if (
        (r &&
          ((n.envMap.value = r),
          (n.flipEnvMap.value =
            r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1),
          (n.reflectivity.value = i.reflectivity),
          (n.ior.value = i.ior),
          (n.refractionRatio.value = i.refractionRatio)),
        i.lightMap)
      ) {
        n.lightMap.value = i.lightMap;
        const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
        n.lightMapIntensity.value = i.lightMapIntensity * e;
      }
      let s, o;
      i.aoMap &&
        ((n.aoMap.value = i.aoMap),
        (n.aoMapIntensity.value = i.aoMapIntensity)),
        i.map
          ? (s = i.map)
          : i.specularMap
          ? (s = i.specularMap)
          : i.displacementMap
          ? (s = i.displacementMap)
          : i.normalMap
          ? (s = i.normalMap)
          : i.bumpMap
          ? (s = i.bumpMap)
          : i.roughnessMap
          ? (s = i.roughnessMap)
          : i.metalnessMap
          ? (s = i.metalnessMap)
          : i.alphaMap
          ? (s = i.alphaMap)
          : i.emissiveMap
          ? (s = i.emissiveMap)
          : i.clearcoatMap
          ? (s = i.clearcoatMap)
          : i.clearcoatNormalMap
          ? (s = i.clearcoatNormalMap)
          : i.clearcoatRoughnessMap
          ? (s = i.clearcoatRoughnessMap)
          : i.iridescenceMap
          ? (s = i.iridescenceMap)
          : i.iridescenceThicknessMap
          ? (s = i.iridescenceThicknessMap)
          : i.specularIntensityMap
          ? (s = i.specularIntensityMap)
          : i.specularColorMap
          ? (s = i.specularColorMap)
          : i.transmissionMap
          ? (s = i.transmissionMap)
          : i.thicknessMap
          ? (s = i.thicknessMap)
          : i.sheenColorMap
          ? (s = i.sheenColorMap)
          : i.sheenRoughnessMap && (s = i.sheenRoughnessMap),
        void 0 !== s &&
          (s.isWebGLRenderTarget && (s = s.texture),
          !0 === s.matrixAutoUpdate && s.updateMatrix(),
          n.uvTransform.value.copy(s.matrix)),
        i.aoMap ? (o = i.aoMap) : i.lightMap && (o = i.lightMap),
        void 0 !== o &&
          (o.isWebGLRenderTarget && (o = o.texture),
          !0 === o.matrixAutoUpdate && o.updateMatrix(),
          n.uv2Transform.value.copy(o.matrix));
    }
    return {
      refreshFogUniforms: function (t, e) {
        t.fogColor.value.copy(e.color),
          e.isFog
            ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
            : e.isFogExp2 && (t.fogDensity.value = e.density);
      },
      refreshMaterialUniforms: function (t, i, r, s, o) {
        i.isMeshBasicMaterial || i.isMeshLambertMaterial
          ? n(t, i)
          : i.isMeshToonMaterial
          ? (n(t, i),
            (function (t, e) {
              e.gradientMap && (t.gradientMap.value = e.gradientMap);
            })(t, i))
          : i.isMeshPhongMaterial
          ? (n(t, i),
            (function (t, e) {
              t.specular.value.copy(e.specular),
                (t.shininess.value = Math.max(e.shininess, 1e-4));
            })(t, i))
          : i.isMeshStandardMaterial
          ? (n(t, i),
            (function (t, n) {
              (t.roughness.value = n.roughness),
                (t.metalness.value = n.metalness),
                n.roughnessMap && (t.roughnessMap.value = n.roughnessMap);
              n.metalnessMap && (t.metalnessMap.value = n.metalnessMap);
              e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
            })(t, i),
            i.isMeshPhysicalMaterial &&
              (function (t, e, n) {
                (t.ior.value = e.ior),
                  e.sheen > 0 &&
                    (t.sheenColor.value
                      .copy(e.sheenColor)
                      .multiplyScalar(e.sheen),
                    (t.sheenRoughness.value = e.sheenRoughness),
                    e.sheenColorMap &&
                      (t.sheenColorMap.value = e.sheenColorMap),
                    e.sheenRoughnessMap &&
                      (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
                e.clearcoat > 0 &&
                  ((t.clearcoat.value = e.clearcoat),
                  (t.clearcoatRoughness.value = e.clearcoatRoughness),
                  e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                  e.clearcoatRoughnessMap &&
                    (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                  e.clearcoatNormalMap &&
                    (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                    1 === e.side && t.clearcoatNormalScale.value.negate()));
                e.iridescence > 0 &&
                  ((t.iridescence.value = e.iridescence),
                  (t.iridescenceIOR.value = e.iridescenceIOR),
                  (t.iridescenceThicknessMinimum.value =
                    e.iridescenceThicknessRange[0]),
                  (t.iridescenceThicknessMaximum.value =
                    e.iridescenceThicknessRange[1]),
                  e.iridescenceMap &&
                    (t.iridescenceMap.value = e.iridescenceMap),
                  e.iridescenceThicknessMap &&
                    (t.iridescenceThicknessMap.value =
                      e.iridescenceThicknessMap));
                e.transmission > 0 &&
                  ((t.transmission.value = e.transmission),
                  (t.transmissionSamplerMap.value = n.texture),
                  t.transmissionSamplerSize.value.set(n.width, n.height),
                  e.transmissionMap &&
                    (t.transmissionMap.value = e.transmissionMap),
                  (t.thickness.value = e.thickness),
                  e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                  (t.attenuationDistance.value = e.attenuationDistance),
                  t.attenuationColor.value.copy(e.attenuationColor));
                (t.specularIntensity.value = e.specularIntensity),
                  t.specularColor.value.copy(e.specularColor),
                  e.specularIntensityMap &&
                    (t.specularIntensityMap.value = e.specularIntensityMap);
                e.specularColorMap &&
                  (t.specularColorMap.value = e.specularColorMap);
              })(t, i, o))
          : i.isMeshMatcapMaterial
          ? (n(t, i),
            (function (t, e) {
              e.matcap && (t.matcap.value = e.matcap);
            })(t, i))
          : i.isMeshDepthMaterial
          ? n(t, i)
          : i.isMeshDistanceMaterial
          ? (n(t, i),
            (function (t, e) {
              t.referencePosition.value.copy(e.referencePosition),
                (t.nearDistance.value = e.nearDistance),
                (t.farDistance.value = e.farDistance);
            })(t, i))
          : i.isMeshNormalMaterial
          ? n(t, i)
          : i.isLineBasicMaterial
          ? ((function (t, e) {
              t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
            })(t, i),
            i.isLineDashedMaterial &&
              (function (t, e) {
                (t.dashSize.value = e.dashSize),
                  (t.totalSize.value = e.dashSize + e.gapSize),
                  (t.scale.value = e.scale);
              })(t, i))
          : i.isPointsMaterial
          ? (function (t, e, n, i) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.size.value = e.size * n),
                (t.scale.value = 0.5 * i),
                e.map && (t.map.value = e.map);
              e.alphaMap && (t.alphaMap.value = e.alphaMap);
              e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
              let r;
              e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
              void 0 !== r &&
                (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                t.uvTransform.value.copy(r.matrix));
            })(t, i, r, s)
          : i.isSpriteMaterial
          ? (function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.rotation.value = e.rotation),
                e.map && (t.map.value = e.map);
              e.alphaMap && (t.alphaMap.value = e.alphaMap);
              e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
              let n;
              e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
              void 0 !== n &&
                (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                t.uvTransform.value.copy(n.matrix));
            })(t, i)
          : i.isShadowMaterial
          ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
          : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
      },
    };
  }
  function kO(t, e, n, i) {
    let r = {},
      s = {},
      o = [];
    const a = n.isWebGL2 ? t.getParameter(35375) : 0;
    function l(t, e, n) {
      const i = t.value;
      if (void 0 === n[e])
        return (n[e] = "number" == typeof i ? i : i.clone()), !0;
      if ("number" == typeof i) {
        if (n[e] !== i) return (n[e] = i), !0;
      } else {
        const t = n[e];
        if (!1 === t.equals(i)) return t.copy(i), !0;
      }
      return !1;
    }
    function h(t) {
      const e = t.value,
        n = { boundary: 0, storage: 0 };
      return (
        "number" == typeof e
          ? ((n.boundary = 4), (n.storage = 4))
          : e.isVector2
          ? ((n.boundary = 8), (n.storage = 8))
          : e.isVector3 || e.isColor
          ? ((n.boundary = 16), (n.storage = 12))
          : e.isVector4
          ? ((n.boundary = 16), (n.storage = 16))
          : e.isMatrix3
          ? ((n.boundary = 48), (n.storage = 48))
          : e.isMatrix4
          ? ((n.boundary = 64), (n.storage = 64))
          : e.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              e
            ),
        n
      );
    }
    function u(e) {
      const n = e.target;
      n.removeEventListener("dispose", u);
      const i = o.indexOf(n.__bindingPointIndex);
      o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
    }
    return {
      bind: function (t, e) {
        const n = e.program;
        i.uniformBlockBinding(t, n);
      },
      update: function (n, c) {
        let d = r[n.id];
        void 0 === d &&
          (!(function (t) {
            const e = t.uniforms;
            let n = 0;
            const i = 16;
            let r = 0;
            for (let s = 0, o = e.length; s < o; s++) {
              const t = e[s],
                o = h(t);
              if (
                ((t.__data = new Float32Array(
                  o.storage / Float32Array.BYTES_PER_ELEMENT
                )),
                (t.__offset = n),
                s > 0)
              ) {
                r = n % i;
                const e = i - r;
                0 !== r &&
                  e - o.boundary < 0 &&
                  ((n += i - r), (t.__offset = n));
              }
              n += o.storage;
            }
            (r = n % i), r > 0 && (n += i - r);
            (t.__size = n), (t.__cache = {});
          })(n),
          (d = (function (e) {
            const n = (function () {
              for (let t = 0; t < a; t++)
                if (-1 === o.indexOf(t)) return o.push(t), t;
              return (
                console.error(
                  "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                ),
                0
              );
            })();
            e.__bindingPointIndex = n;
            const i = t.createBuffer(),
              r = e.__size,
              s = e.usage;
            return (
              t.bindBuffer(35345, i),
              t.bufferData(35345, r, s),
              t.bindBuffer(35345, null),
              t.bindBufferBase(35345, n, i),
              i
            );
          })(n)),
          (r[n.id] = d),
          n.addEventListener("dispose", u));
        const p = c.program;
        i.updateUBOMapping(n, p);
        const f = e.render.frame;
        s[n.id] !== f &&
          (!(function (e) {
            const n = r[e.id],
              i = e.uniforms,
              s = e.__cache;
            t.bindBuffer(35345, n);
            for (let r = 0, o = i.length; r < o; r++) {
              const e = i[r];
              if (!0 === l(e, r, s)) {
                const n = e.value,
                  i = e.__offset;
                "number" == typeof n
                  ? ((e.__data[0] = n), t.bufferSubData(35345, i, e.__data))
                  : (e.value.isMatrix3
                      ? ((e.__data[0] = e.value.elements[0]),
                        (e.__data[1] = e.value.elements[1]),
                        (e.__data[2] = e.value.elements[2]),
                        (e.__data[3] = e.value.elements[0]),
                        (e.__data[4] = e.value.elements[3]),
                        (e.__data[5] = e.value.elements[4]),
                        (e.__data[6] = e.value.elements[5]),
                        (e.__data[7] = e.value.elements[0]),
                        (e.__data[8] = e.value.elements[6]),
                        (e.__data[9] = e.value.elements[7]),
                        (e.__data[10] = e.value.elements[8]),
                        (e.__data[11] = e.value.elements[0]))
                      : n.toArray(e.__data),
                    t.bufferSubData(35345, i, e.__data));
              }
            }
            t.bindBuffer(35345, null);
          })(n),
          (s[n.id] = f));
      },
      dispose: function () {
        for (const e in r) t.deleteBuffer(r[e]);
        (o = []), (r = {}), (s = {});
      },
    };
  }
  function GO(t = {}) {
    this.isWebGLRenderer = !0;
    const e =
        void 0 !== t.canvas
          ? t.canvas
          : (function () {
              const t = EA("canvas");
              return (t.style.display = "block"), t;
            })(),
      n = void 0 !== t.context ? t.context : null,
      i = void 0 === t.depth || t.depth,
      r = void 0 === t.stencil || t.stencil,
      s = void 0 !== t.antialias && t.antialias,
      o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      a = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      l = void 0 !== t.powerPreference ? t.powerPreference : "default",
      h =
        void 0 !== t.failIfMajorPerformanceCaveat &&
        t.failIfMajorPerformanceCaveat;
    let u;
    u =
      null !== n
        ? n.getContextAttributes().alpha
        : void 0 !== t.alpha && t.alpha;
    let c = null,
      d = null;
    const p = [],
      f = [];
    (this.domElement = e),
      (this.debug = { checkShaderErrors: !0 }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputEncoding = $M),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = 0),
      (this.toneMappingExposure = 1),
      Object.defineProperties(this, {
        gammaFactor: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              ),
              2
            );
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          },
        },
      });
    const m = this;
    let _ = !1,
      g = 0,
      v = 0,
      y = null,
      x = -1,
      b = null;
    const T = new HA(),
      E = new HA();
    let S = null,
      w = e.width,
      M = e.height,
      A = 1,
      R = null,
      C = null;
    const I = new HA(0, 0, w, M),
      P = new HA(0, 0, w, M);
    let O = !1;
    const N = new sI();
    let D = !1,
      L = !1,
      F = null;
    const U = new ER(),
      B = new xA(),
      k = new jA(),
      G = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function H() {
      return null === y ? A : 1;
    }
    let z,
      V,
      X,
      W,
      j,
      Y,
      q,
      K,
      Z,
      J,
      $,
      Q,
      tt,
      et,
      nt,
      it,
      rt,
      st,
      ot,
      at,
      lt,
      ht,
      ut,
      ct,
      dt = n;
    function pt(t, n) {
      for (let i = 0; i < t.length; i++) {
        const r = t[i],
          s = e.getContext(r, n);
        if (null !== s) return s;
      }
      return null;
    }
    try {
      const t = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: s,
        premultipliedAlpha: o,
        preserveDrawingBuffer: a,
        powerPreference: l,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in e && e.setAttribute("data-engine", "three.js r143"),
        e.addEventListener("webglcontextlost", _t, !1),
        e.addEventListener("webglcontextrestored", gt, !1),
        e.addEventListener("webglcontextcreationerror", vt, !1),
        null === dt)
      ) {
        const e = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (!0 === m.isWebGL1Renderer && e.shift(), (dt = pt(e, t)), null === dt)
        )
          throw pt(e)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      void 0 === dt.getShaderPrecisionFormat &&
        (dt.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (It) {
      throw (console.error("THREE.WebGLRenderer: " + It.message), It);
    }
    function ft() {
      (z = new DI(dt)),
        (V = new mI(dt, z, t)),
        z.init(V),
        (ht = new PO(dt, z, V)),
        (X = new CO(dt, z, V)),
        (W = new UI()),
        (j = new mO()),
        (Y = new IO(dt, z, X, j, V, ht, W)),
        (q = new gI(m)),
        (K = new NI(m)),
        (Z = new aI(dt, V)),
        (ut = new pI(dt, z, Z, V)),
        (J = new LI(dt, Z, W, ut)),
        ($ = new zI(dt, J, Z, W)),
        (ot = new HI(dt, V, Y)),
        (it = new _I(j)),
        (Q = new fO(m, q, K, z, V, ut, it)),
        (tt = new BO(m, j)),
        (et = new yO()),
        (nt = new wO(z, V)),
        (st = new dI(m, q, X, $, u, o)),
        (rt = new RO(m, $, V)),
        (ct = new kO(dt, W, V, X)),
        (at = new fI(dt, z, W, V)),
        (lt = new FI(dt, z, W, V)),
        (W.programs = Q.programs),
        (m.capabilities = V),
        (m.extensions = z),
        (m.properties = j),
        (m.renderLists = et),
        (m.shadowMap = rt),
        (m.state = X),
        (m.info = W);
    }
    ft();
    const mt = new UO(m, dt);
    function _t(t) {
      t.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (_ = !0);
    }
    function gt() {
      console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
      const t = W.autoReset,
        e = rt.enabled,
        n = rt.autoUpdate,
        i = rt.needsUpdate,
        r = rt.type;
      ft(),
        (W.autoReset = t),
        (rt.enabled = e),
        (rt.autoUpdate = n),
        (rt.needsUpdate = i),
        (rt.type = r);
    }
    function vt(t) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        t.statusMessage
      );
    }
    function yt(t) {
      const e = t.target;
      e.removeEventListener("dispose", yt),
        (function (t) {
          (function (t) {
            const e = j.get(t).programs;
            void 0 !== e &&
              (e.forEach(function (t) {
                Q.releaseProgram(t);
              }),
              t.isShaderMaterial && Q.releaseShaderCache(t));
          })(t),
            j.remove(t);
        })(e);
    }
    (this.xr = mt),
      (this.getContext = function () {
        return dt;
      }),
      (this.getContextAttributes = function () {
        return dt.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const t = z.get("WEBGL_lose_context");
        t && t.loseContext();
      }),
      (this.forceContextRestore = function () {
        const t = z.get("WEBGL_lose_context");
        t && t.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return A;
      }),
      (this.setPixelRatio = function (t) {
        void 0 !== t && ((A = t), this.setSize(w, M, !1));
      }),
      (this.getSize = function (t) {
        return t.set(w, M);
      }),
      (this.setSize = function (t, n, i) {
        mt.isPresenting
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
          : ((w = t),
            (M = n),
            (e.width = Math.floor(t * A)),
            (e.height = Math.floor(n * A)),
            !1 !== i &&
              ((e.style.width = t + "px"), (e.style.height = n + "px")),
            this.setViewport(0, 0, t, n));
      }),
      (this.getDrawingBufferSize = function (t) {
        return t.set(w * A, M * A).floor();
      }),
      (this.setDrawingBufferSize = function (t, n, i) {
        (w = t),
          (M = n),
          (A = i),
          (e.width = Math.floor(t * i)),
          (e.height = Math.floor(n * i)),
          this.setViewport(0, 0, t, n);
      }),
      (this.getCurrentViewport = function (t) {
        return t.copy(T);
      }),
      (this.getViewport = function (t) {
        return t.copy(I);
      }),
      (this.setViewport = function (t, e, n, i) {
        t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, i),
          X.viewport(T.copy(I).multiplyScalar(A).floor());
      }),
      (this.getScissor = function (t) {
        return t.copy(P);
      }),
      (this.setScissor = function (t, e, n, i) {
        t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
          X.scissor(E.copy(P).multiplyScalar(A).floor());
      }),
      (this.getScissorTest = function () {
        return O;
      }),
      (this.setScissorTest = function (t) {
        X.setScissorTest((O = t));
      }),
      (this.setOpaqueSort = function (t) {
        R = t;
      }),
      (this.setTransparentSort = function (t) {
        C = t;
      }),
      (this.getClearColor = function (t) {
        return t.copy(st.getClearColor());
      }),
      (this.setClearColor = function () {
        st.setClearColor.apply(st, arguments);
      }),
      (this.getClearAlpha = function () {
        return st.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        st.setClearAlpha.apply(st, arguments);
      }),
      (this.clear = function (t = !0, e = !0, n = !0) {
        let i = 0;
        t && (i |= 16384), e && (i |= 256), n && (i |= 1024), dt.clear(i);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        e.removeEventListener("webglcontextlost", _t, !1),
          e.removeEventListener("webglcontextrestored", gt, !1),
          e.removeEventListener("webglcontextcreationerror", vt, !1),
          et.dispose(),
          nt.dispose(),
          j.dispose(),
          q.dispose(),
          K.dispose(),
          $.dispose(),
          ut.dispose(),
          ct.dispose(),
          Q.dispose(),
          mt.dispose(),
          mt.removeEventListener("sessionstart", bt),
          mt.removeEventListener("sessionend", Tt),
          F && (F.dispose(), (F = null)),
          Et.stop();
      }),
      (this.renderBufferDirect = function (t, e, n, i, r, s) {
        null === e && (e = G);
        const o = r.isMesh && r.matrixWorld.determinant() < 0,
          a = (function (t, e, n, i, r) {
            !0 !== e.isScene && (e = G);
            Y.resetTextureUnits();
            const s = e.fog,
              o = i.isMeshStandardMaterial ? e.environment : null,
              a =
                null === y
                  ? m.outputEncoding
                  : !0 === y.isXRRenderTarget
                  ? y.texture.encoding
                  : $M,
              l = (i.isMeshStandardMaterial ? K : q).get(i.envMap || o),
              h =
                !0 === i.vertexColors &&
                !!n.attributes.color &&
                4 === n.attributes.color.itemSize,
              u = !!i.normalMap && !!n.attributes.tangent,
              c = !!n.morphAttributes.position,
              p = !!n.morphAttributes.normal,
              f = !!n.morphAttributes.color,
              _ = i.toneMapped ? m.toneMapping : 0,
              g =
                n.morphAttributes.position ||
                n.morphAttributes.normal ||
                n.morphAttributes.color,
              v = void 0 !== g ? g.length : 0,
              T = j.get(i),
              E = d.state.lights;
            if (!0 === D && (!0 === L || t !== b)) {
              const e = t === b && i.id === x;
              it.setState(i, t, e);
            }
            let S = !1;
            i.version === T.__version
              ? (T.needsLights && T.lightsStateVersion !== E.state.version) ||
                T.outputEncoding !== a ||
                (r.isInstancedMesh && !1 === T.instancing)
                ? (S = !0)
                : r.isInstancedMesh || !0 !== T.instancing
                ? r.isSkinnedMesh && !1 === T.skinning
                  ? (S = !0)
                  : r.isSkinnedMesh || !0 !== T.skinning
                  ? T.envMap !== l || (!0 === i.fog && T.fog !== s)
                    ? (S = !0)
                    : void 0 === T.numClippingPlanes ||
                      (T.numClippingPlanes === it.numPlanes &&
                        T.numIntersection === it.numIntersection)
                    ? (T.vertexAlphas !== h ||
                        T.vertexTangents !== u ||
                        T.morphTargets !== c ||
                        T.morphNormals !== p ||
                        T.morphColors !== f ||
                        T.toneMapping !== _ ||
                        (!0 === V.isWebGL2 && T.morphTargetsCount !== v)) &&
                      (S = !0)
                    : (S = !0)
                  : (S = !0)
                : (S = !0)
              : ((S = !0), (T.__version = i.version));
            let w = T.currentProgram;
            !0 === S && (w = Rt(i, e, r));
            let R = !1,
              C = !1,
              I = !1;
            const P = w.getUniforms(),
              O = T.uniforms;
            X.useProgram(w.program) && ((R = !0), (C = !0), (I = !0));
            i.id !== x && ((x = i.id), (C = !0));
            if (R || b !== t) {
              if (
                (P.setValue(dt, "projectionMatrix", t.projectionMatrix),
                V.logarithmicDepthBuffer &&
                  P.setValue(
                    dt,
                    "logDepthBufFC",
                    2 / (Math.log(t.far + 1) / Math.LN2)
                  ),
                b !== t && ((b = t), (C = !0), (I = !0)),
                i.isShaderMaterial ||
                  i.isMeshPhongMaterial ||
                  i.isMeshToonMaterial ||
                  i.isMeshStandardMaterial ||
                  i.envMap)
              ) {
                const e = P.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(dt, k.setFromMatrixPosition(t.matrixWorld));
              }
              (i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshLambertMaterial ||
                i.isMeshBasicMaterial ||
                i.isMeshStandardMaterial ||
                i.isShaderMaterial) &&
                P.setValue(dt, "isOrthographic", !0 === t.isOrthographicCamera),
                (i.isMeshPhongMaterial ||
                  i.isMeshToonMaterial ||
                  i.isMeshLambertMaterial ||
                  i.isMeshBasicMaterial ||
                  i.isMeshStandardMaterial ||
                  i.isShaderMaterial ||
                  i.isShadowMaterial ||
                  r.isSkinnedMesh) &&
                  P.setValue(dt, "viewMatrix", t.matrixWorldInverse);
            }
            if (r.isSkinnedMesh) {
              P.setOptional(dt, r, "bindMatrix"),
                P.setOptional(dt, r, "bindMatrixInverse");
              const t = r.skeleton;
              t &&
                (V.floatVertexTextures
                  ? (null === t.boneTexture && t.computeBoneTexture(),
                    P.setValue(dt, "boneTexture", t.boneTexture, Y),
                    P.setValue(dt, "boneTextureSize", t.boneTextureSize))
                  : console.warn(
                      "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                    ));
            }
            const N = n.morphAttributes;
            (void 0 !== N.position ||
              void 0 !== N.normal ||
              (void 0 !== N.color && !0 === V.isWebGL2)) &&
              ot.update(r, n, i, w);
            (C || T.receiveShadow !== r.receiveShadow) &&
              ((T.receiveShadow = r.receiveShadow),
              P.setValue(dt, "receiveShadow", r.receiveShadow));
            C &&
              (P.setValue(dt, "toneMappingExposure", m.toneMappingExposure),
              T.needsLights &&
                ((B = I),
                ((U = O).ambientLightColor.needsUpdate = B),
                (U.lightProbe.needsUpdate = B),
                (U.directionalLights.needsUpdate = B),
                (U.directionalLightShadows.needsUpdate = B),
                (U.pointLights.needsUpdate = B),
                (U.pointLightShadows.needsUpdate = B),
                (U.spotLights.needsUpdate = B),
                (U.spotLightShadows.needsUpdate = B),
                (U.rectAreaLights.needsUpdate = B),
                (U.hemisphereLights.needsUpdate = B)),
              s && !0 === i.fog && tt.refreshFogUniforms(O, s),
              tt.refreshMaterialUniforms(O, i, A, M, F),
              jP.upload(dt, T.uniformsList, O, Y));
            var U, B;
            i.isShaderMaterial &&
              !0 === i.uniformsNeedUpdate &&
              (jP.upload(dt, T.uniformsList, O, Y),
              (i.uniformsNeedUpdate = !1));
            i.isSpriteMaterial && P.setValue(dt, "center", r.center);
            if (
              (P.setValue(dt, "modelViewMatrix", r.modelViewMatrix),
              P.setValue(dt, "normalMatrix", r.normalMatrix),
              P.setValue(dt, "modelMatrix", r.matrixWorld),
              i.isShaderMaterial || i.isRawShaderMaterial)
            ) {
              const t = i.uniformsGroups;
              for (let e = 0, n = t.length; e < n; e++)
                if (V.isWebGL2) {
                  const n = t[e];
                  ct.update(n, w), ct.bind(n, w);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                  );
            }
            return w;
          })(t, e, n, i, r);
        X.setMaterial(i, o);
        let l = n.index;
        const h = n.attributes.position;
        if (null === l) {
          if (void 0 === h || 0 === h.count) return;
        } else if (0 === l.count) return;
        let u,
          c = 1;
        !0 === i.wireframe && ((l = J.getWireframeAttribute(n)), (c = 2)),
          ut.setup(r, i, a, n, l);
        let p = at;
        null !== l && ((u = Z.get(l)), (p = lt), p.setIndex(u));
        const f = null !== l ? l.count : h.count,
          _ = n.drawRange.start * c,
          g = n.drawRange.count * c,
          v = null !== s ? s.start * c : 0,
          T = null !== s ? s.count * c : 1 / 0,
          E = Math.max(_, v),
          S = Math.min(f, _ + g, v + T) - 1,
          w = Math.max(0, S - E + 1);
        if (0 !== w) {
          if (r.isMesh)
            !0 === i.wireframe
              ? (X.setLineWidth(i.wireframeLinewidth * H()), p.setMode(1))
              : p.setMode(4);
          else if (r.isLine) {
            let t = i.linewidth;
            void 0 === t && (t = 1),
              X.setLineWidth(t * H()),
              r.isLineSegments
                ? p.setMode(1)
                : r.isLineLoop
                ? p.setMode(2)
                : p.setMode(3);
          } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
          if (r.isInstancedMesh) p.renderInstances(E, w, r.count);
          else if (n.isInstancedBufferGeometry) {
            const t = Math.min(n.instanceCount, n._maxInstanceCount);
            p.renderInstances(E, w, t);
          } else p.render(E, w);
        }
      }),
      (this.compile = function (t, e) {
        (d = nt.get(t)),
          d.init(),
          f.push(d),
          t.traverseVisible(function (t) {
            t.isLight &&
              t.layers.test(e.layers) &&
              (d.pushLight(t), t.castShadow && d.pushShadow(t));
          }),
          d.setupLights(m.physicallyCorrectLights),
          t.traverse(function (e) {
            const n = e.material;
            if (n)
              if (Array.isArray(n))
                for (let i = 0; i < n.length; i++) {
                  Rt(n[i], t, e);
                }
              else Rt(n, t, e);
          }),
          f.pop(),
          (d = null);
      });
    let xt = null;
    function bt() {
      Et.stop();
    }
    function Tt() {
      Et.start();
    }
    const Et = new oI();
    function St(t, e, n, i) {
      if (!1 === t.visible) return;
      if (t.layers.test(e.layers))
        if (t.isGroup) n = t.renderOrder;
        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
        else if (t.isSprite) {
          if (!t.frustumCulled || N.intersectsSprite(t)) {
            i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
            const e = $.update(t),
              r = t.material;
            r.visible && c.push(t, e, r, n, k.z, null);
          }
        } else if (
          (t.isMesh || t.isLine || t.isPoints) &&
          (t.isSkinnedMesh &&
            t.skeleton.frame !== W.render.frame &&
            (t.skeleton.update(), (t.skeleton.frame = W.render.frame)),
          !t.frustumCulled || N.intersectsObject(t))
        ) {
          i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
          const e = $.update(t),
            r = t.material;
          if (Array.isArray(r)) {
            const i = e.groups;
            for (let s = 0, o = i.length; s < o; s++) {
              const o = i[s],
                a = r[o.materialIndex];
              a && a.visible && c.push(t, e, a, n, k.z, o);
            }
          } else r.visible && c.push(t, e, r, n, k.z, null);
        }
      const r = t.children;
      for (let s = 0, o = r.length; s < o; s++) St(r[s], e, n, i);
    }
    function wt(t, e, n, i) {
      const r = t.opaque,
        o = t.transmissive,
        a = t.transparent;
      d.setupLightsView(n),
        o.length > 0 &&
          (function (t, e, n) {
            const i = V.isWebGL2;
            null === F &&
              (F = new zA(1, 1, {
                generateMipmaps: !0,
                type: z.has("EXT_color_buffer_half_float") ? GM : UM,
                minFilter: FM,
                samples: i && !0 === s ? 4 : 0,
              }));
            m.getDrawingBufferSize(B),
              i ? F.setSize(B.x, B.y) : F.setSize(vA(B.x), vA(B.y));
            const r = m.getRenderTarget();
            m.setRenderTarget(F), m.clear();
            const o = m.toneMapping;
            (m.toneMapping = 0),
              Mt(t, e, n),
              (m.toneMapping = o),
              Y.updateMultisampleRenderTarget(F),
              Y.updateRenderTargetMipmap(F),
              m.setRenderTarget(r);
          })(r, e, n),
        i && X.viewport(T.copy(i)),
        r.length > 0 && Mt(r, e, n),
        o.length > 0 && Mt(o, e, n),
        a.length > 0 && Mt(a, e, n),
        X.buffers.depth.setTest(!0),
        X.buffers.depth.setMask(!0),
        X.buffers.color.setMask(!0),
        X.setPolygonOffset(!1);
    }
    function Mt(t, e, n) {
      const i = !0 === e.isScene ? e.overrideMaterial : null;
      for (let r = 0, s = t.length; r < s; r++) {
        const s = t[r],
          o = s.object,
          a = s.geometry,
          l = null === i ? s.material : i,
          h = s.group;
        o.layers.test(n.layers) && At(o, e, n, a, l, h);
      }
    }
    function At(t, e, n, i, r, s) {
      t.onBeforeRender(m, e, n, i, r, s),
        t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        r.onBeforeRender(m, e, n, i, t, s),
        !0 === r.transparent && 2 === r.side
          ? ((r.side = 1),
            (r.needsUpdate = !0),
            m.renderBufferDirect(n, e, i, r, t, s),
            (r.side = 0),
            (r.needsUpdate = !0),
            m.renderBufferDirect(n, e, i, r, t, s),
            (r.side = 2))
          : m.renderBufferDirect(n, e, i, r, t, s),
        t.onAfterRender(m, e, n, i, r, s);
    }
    function Rt(t, e, n) {
      !0 !== e.isScene && (e = G);
      const i = j.get(t),
        r = d.state.lights,
        s = d.state.shadowsArray,
        o = r.state.version,
        a = Q.getParameters(t, r.state, s, e, n),
        l = Q.getProgramCacheKey(a);
      let h = i.programs;
      (i.environment = t.isMeshStandardMaterial ? e.environment : null),
        (i.fog = e.fog),
        (i.envMap = (t.isMeshStandardMaterial ? K : q).get(
          t.envMap || i.environment
        )),
        void 0 === h &&
          (t.addEventListener("dispose", yt),
          (h = new Map()),
          (i.programs = h));
      let u = h.get(l);
      if (void 0 !== u) {
        if (i.currentProgram === u && i.lightsStateVersion === o)
          return Ct(t, a), u;
      } else
        (a.uniforms = Q.getUniforms(t)),
          t.onBuild(n, a, m),
          t.onBeforeCompile(a, m),
          (u = Q.acquireProgram(a, l)),
          h.set(l, u),
          (i.uniforms = a.uniforms);
      const c = i.uniforms;
      ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
        (c.clippingPlanes = it.uniform),
        Ct(t, a),
        (i.needsLights = (function (t) {
          return (
            t.isMeshLambertMaterial ||
            t.isMeshToonMaterial ||
            t.isMeshPhongMaterial ||
            t.isMeshStandardMaterial ||
            t.isShadowMaterial ||
            (t.isShaderMaterial && !0 === t.lights)
          );
        })(t)),
        (i.lightsStateVersion = o),
        i.needsLights &&
          ((c.ambientLightColor.value = r.state.ambient),
          (c.lightProbe.value = r.state.probe),
          (c.directionalLights.value = r.state.directional),
          (c.directionalLightShadows.value = r.state.directionalShadow),
          (c.spotLights.value = r.state.spot),
          (c.spotLightShadows.value = r.state.spotShadow),
          (c.rectAreaLights.value = r.state.rectArea),
          (c.ltc_1.value = r.state.rectAreaLTC1),
          (c.ltc_2.value = r.state.rectAreaLTC2),
          (c.pointLights.value = r.state.point),
          (c.pointLightShadows.value = r.state.pointShadow),
          (c.hemisphereLights.value = r.state.hemi),
          (c.directionalShadowMap.value = r.state.directionalShadowMap),
          (c.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
          (c.spotShadowMap.value = r.state.spotShadowMap),
          (c.spotShadowMatrix.value = r.state.spotShadowMatrix),
          (c.pointShadowMap.value = r.state.pointShadowMap),
          (c.pointShadowMatrix.value = r.state.pointShadowMatrix));
      const p = u.getUniforms(),
        f = jP.seqWithValue(p.seq, c);
      return (i.currentProgram = u), (i.uniformsList = f), u;
    }
    function Ct(t, e) {
      const n = j.get(t);
      (n.outputEncoding = e.outputEncoding),
        (n.instancing = e.instancing),
        (n.skinning = e.skinning),
        (n.morphTargets = e.morphTargets),
        (n.morphNormals = e.morphNormals),
        (n.morphColors = e.morphColors),
        (n.morphTargetsCount = e.morphTargetsCount),
        (n.numClippingPlanes = e.numClippingPlanes),
        (n.numIntersection = e.numClipIntersection),
        (n.vertexAlphas = e.vertexAlphas),
        (n.vertexTangents = e.vertexTangents),
        (n.toneMapping = e.toneMapping);
    }
    Et.setAnimationLoop(function (t) {
      xt && xt(t);
    }),
      "undefined" != typeof self && Et.setContext(self),
      (this.setAnimationLoop = function (t) {
        (xt = t), mt.setAnimationLoop(t), null === t ? Et.stop() : Et.start();
      }),
      mt.addEventListener("sessionstart", bt),
      mt.addEventListener("sessionend", Tt),
      (this.render = function (t, e) {
        if (void 0 !== e && !0 !== e.isCamera)
          return void console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
        if (!0 === _) return;
        !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          !0 === mt.enabled &&
            !0 === mt.isPresenting &&
            (!0 === mt.cameraAutoUpdate && mt.updateCamera(e),
            (e = mt.getCamera())),
          !0 === t.isScene && t.onBeforeRender(m, t, e, y),
          (d = nt.get(t, f.length)),
          d.init(),
          f.push(d),
          U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          N.setFromProjectionMatrix(U),
          (L = this.localClippingEnabled),
          (D = it.init(this.clippingPlanes, L, e)),
          (c = et.get(t, p.length)),
          c.init(),
          p.push(c),
          St(t, e, 0, m.sortObjects),
          c.finish(),
          !0 === m.sortObjects && c.sort(R, C),
          !0 === D && it.beginShadows();
        const n = d.state.shadowsArray;
        if (
          (rt.render(n, t, e),
          !0 === D && it.endShadows(),
          !0 === this.info.autoReset && this.info.reset(),
          st.render(c, t),
          d.setupLights(m.physicallyCorrectLights),
          e.isArrayCamera)
        ) {
          const n = e.cameras;
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            wt(c, t, i, i.viewport);
          }
        } else wt(c, t, e);
        null !== y &&
          (Y.updateMultisampleRenderTarget(y), Y.updateRenderTargetMipmap(y)),
          !0 === t.isScene && t.onAfterRender(m, t, e),
          ut.resetDefaultState(),
          (x = -1),
          (b = null),
          f.pop(),
          (d = f.length > 0 ? f[f.length - 1] : null),
          p.pop(),
          (c = p.length > 0 ? p[p.length - 1] : null);
      }),
      (this.getActiveCubeFace = function () {
        return g;
      }),
      (this.getActiveMipmapLevel = function () {
        return v;
      }),
      (this.getRenderTarget = function () {
        return y;
      }),
      (this.setRenderTargetTextures = function (t, e, n) {
        (j.get(t.texture).__webglTexture = e),
          (j.get(t.depthTexture).__webglTexture = n);
        const i = j.get(t);
        (i.__hasExternalTextures = !0),
          i.__hasExternalTextures &&
            ((i.__autoAllocateDepthBuffer = void 0 === n),
            i.__autoAllocateDepthBuffer ||
              (!0 === z.has("WEBGL_multisampled_render_to_texture") &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (i.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (t, e) {
        const n = j.get(t);
        (n.__webglFramebuffer = e), (n.__useDefaultFramebuffer = void 0 === e);
      }),
      (this.setRenderTarget = function (t, e = 0, n = 0) {
        (y = t), (g = e), (v = n);
        let i = !0;
        if (t) {
          const e = j.get(t);
          void 0 !== e.__useDefaultFramebuffer
            ? (X.bindFramebuffer(36160, null), (i = !1))
            : void 0 === e.__webglFramebuffer
            ? Y.setupRenderTarget(t)
            : e.__hasExternalTextures &&
              Y.rebindTextures(
                t,
                j.get(t.texture).__webglTexture,
                j.get(t.depthTexture).__webglTexture
              );
        }
        let r = null,
          s = !1,
          o = !1;
        if (t) {
          const n = t.texture;
          (n.isData3DTexture || n.isDataArrayTexture) && (o = !0);
          const i = j.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget
            ? ((r = i[e]), (s = !0))
            : (r =
                V.isWebGL2 && t.samples > 0 && !1 === Y.useMultisampledRTT(t)
                  ? j.get(t).__webglMultisampledFramebuffer
                  : i),
            T.copy(t.viewport),
            E.copy(t.scissor),
            (S = t.scissorTest);
        } else
          T.copy(I).multiplyScalar(A).floor(),
            E.copy(P).multiplyScalar(A).floor(),
            (S = O);
        if (
          (X.bindFramebuffer(36160, r) &&
            V.drawBuffers &&
            i &&
            X.drawBuffers(t, r),
          X.viewport(T),
          X.scissor(E),
          X.setScissorTest(S),
          s)
        ) {
          const i = j.get(t.texture);
          dt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n);
        } else if (o) {
          const i = j.get(t.texture),
            r = e || 0;
          dt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r);
        }
        x = -1;
      }),
      (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
        if (!t || !t.isWebGLRenderTarget)
          return void console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let a = j.get(t).__webglFramebuffer;
        if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
          X.bindFramebuffer(36160, a);
          try {
            const o = t.texture,
              a = o.format,
              l = o.type;
            if (a !== zM && ht.convert(a) !== dt.getParameter(35739))
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
            const h =
              l === GM &&
              (z.has("EXT_color_buffer_half_float") ||
                (V.isWebGL2 && z.has("EXT_color_buffer_float")));
            if (
              !(
                l === UM ||
                ht.convert(l) === dt.getParameter(35738) ||
                (l === kM &&
                  (V.isWebGL2 ||
                    z.has("OES_texture_float") ||
                    z.has("WEBGL_color_buffer_float"))) ||
                h
              )
            )
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            e >= 0 &&
              e <= t.width - i &&
              n >= 0 &&
              n <= t.height - r &&
              dt.readPixels(e, n, i, r, ht.convert(a), ht.convert(l), s);
          } finally {
            const t = null !== y ? j.get(y).__webglFramebuffer : null;
            X.bindFramebuffer(36160, t);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (t, e, n = 0) {
        const i = Math.pow(2, -n),
          r = Math.floor(e.image.width * i),
          s = Math.floor(e.image.height * i);
        Y.setTexture2D(e, 0),
          dt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s),
          X.unbindTexture();
      }),
      (this.copyTextureToTexture = function (t, e, n, i = 0) {
        const r = e.image.width,
          s = e.image.height,
          o = ht.convert(n.format),
          a = ht.convert(n.type);
        Y.setTexture2D(n, 0),
          dt.pixelStorei(37440, n.flipY),
          dt.pixelStorei(37441, n.premultiplyAlpha),
          dt.pixelStorei(3317, n.unpackAlignment),
          e.isDataTexture
            ? dt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data)
            : e.isCompressedTexture
            ? dt.compressedTexSubImage2D(
                3553,
                i,
                t.x,
                t.y,
                e.mipmaps[0].width,
                e.mipmaps[0].height,
                o,
                e.mipmaps[0].data
              )
            : dt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
          0 === i && n.generateMipmaps && dt.generateMipmap(3553),
          X.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
        if (m.isWebGL1Renderer)
          return void console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
        const s = t.max.x - t.min.x + 1,
          o = t.max.y - t.min.y + 1,
          a = t.max.z - t.min.z + 1,
          l = ht.convert(i.format),
          h = ht.convert(i.type);
        let u;
        if (i.isData3DTexture) Y.setTexture3D(i, 0), (u = 32879);
        else {
          if (!i.isDataArrayTexture)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
            );
          Y.setTexture2DArray(i, 0), (u = 35866);
        }
        dt.pixelStorei(37440, i.flipY),
          dt.pixelStorei(37441, i.premultiplyAlpha),
          dt.pixelStorei(3317, i.unpackAlignment);
        const c = dt.getParameter(3314),
          d = dt.getParameter(32878),
          p = dt.getParameter(3316),
          f = dt.getParameter(3315),
          _ = dt.getParameter(32877),
          g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
        dt.pixelStorei(3314, g.width),
          dt.pixelStorei(32878, g.height),
          dt.pixelStorei(3316, t.min.x),
          dt.pixelStorei(3315, t.min.y),
          dt.pixelStorei(32877, t.min.z),
          n.isDataTexture || n.isData3DTexture
            ? dt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, h, g.data)
            : n.isCompressedTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              dt.compressedTexSubImage3D(
                u,
                r,
                e.x,
                e.y,
                e.z,
                s,
                o,
                a,
                l,
                g.data
              ))
            : dt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, h, g),
          dt.pixelStorei(3314, c),
          dt.pixelStorei(32878, d),
          dt.pixelStorei(3316, p),
          dt.pixelStorei(3315, f),
          dt.pixelStorei(32877, _),
          0 === r && i.generateMipmaps && dt.generateMipmap(u),
          X.unbindTexture();
      }),
      (this.initTexture = function (t) {
        t.isCubeTexture
          ? Y.setTextureCube(t, 0)
          : t.isData3DTexture
          ? Y.setTexture3D(t, 0)
          : t.isDataArrayTexture
          ? Y.setTexture2DArray(t, 0)
          : Y.setTexture2D(t, 0),
          X.unbindTexture();
      }),
      (this.resetState = function () {
        (g = 0), (v = 0), (y = null), X.reset(), ut.reset();
      }),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  (class extends GO {}).prototype.isWebGL1Renderer = !0;
  class HO {
    constructor(t, e = 1, n = 1e3) {
      (this.isFog = !0),
        (this.name = ""),
        (this.color = new DA(t)),
        (this.near = e),
        (this.far = n);
    }
    clone() {
      return new HO(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }
  }
  class zO extends qR {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        null !== t.background && (this.background = t.background.clone()),
        null !== t.environment && (this.environment = t.environment.clone()),
        null !== t.fog && (this.fog = t.fog.clone()),
        null !== t.overrideMaterial &&
          (this.overrideMaterial = t.overrideMaterial.clone()),
        (this.autoUpdate = t.autoUpdate),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
    }
  }
  class VO {
    constructor(t, e) {
      (this.isInterleavedBuffer = !0),
        (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = rA),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = dA());
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    copy(t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.stride), (n *= e.stride);
      for (let i = 0, r = this.stride; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = dA()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const e = new this.array.constructor(
          t.arrayBuffers[this.array.buffer._uuid]
        ),
        n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    toJSON(t) {
      return (
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = dA()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  }
  const XO = new jA();
  class WO {
    constructor(t, e, n, i = !1) {
      (this.isInterleavedBufferAttribute = !0),
        (this.name = ""),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = !0 === i);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++)
        XO.fromBufferAttribute(this, e),
          XO.applyMatrix4(t),
          this.setXYZ(e, XO.x, XO.y, XO.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        XO.fromBufferAttribute(this, e),
          XO.applyNormalMatrix(t),
          this.setXYZ(e, XO.x, XO.y, XO.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        XO.fromBufferAttribute(this, e),
          XO.transformDirection(t),
          this.setXYZ(e, XO.x, XO.y, XO.z);
      return this;
    }
    setX(t, e) {
      return (this.data.array[t * this.data.stride + this.offset] = e), this;
    }
    setY(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 1] = e), this
      );
    }
    setZ(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 2] = e), this
      );
    }
    setW(t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 3] = e), this
      );
    }
    getX(t) {
      return this.data.array[t * this.data.stride + this.offset];
    }
    getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    }
    getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    }
    getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    }
    setXY(t, e, n) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        (this.data.array[t + 3] = r),
        this
      );
    }
    clone(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return new cC(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized
        );
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new WO(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    }
    toJSON(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    }
  }
  const jO = new jA(),
    YO = new HA(),
    qO = new HA(),
    KO = new jA(),
    ZO = new ER();
  class JO extends GC {
    constructor(t, e) {
      super(t, e),
        (this.isSkinnedMesh = !0),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new ER()),
        (this.bindMatrixInverse = new ER());
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.bindMode = t.bindMode),
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        (this.skeleton = t.skeleton),
        this
      );
    }
    bind(t, e) {
      (this.skeleton = t),
        void 0 === e &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t = new HA(),
        e = this.geometry.attributes.skinWeight;
      for (let n = 0, i = e.count; n < i; n++) {
        t.fromBufferAttribute(e, n);
        const i = 1 / t.manhattanLength();
        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
          e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        "attached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    }
    boneTransform(t, e) {
      const n = this.skeleton,
        i = this.geometry;
      YO.fromBufferAttribute(i.attributes.skinIndex, t),
        qO.fromBufferAttribute(i.attributes.skinWeight, t),
        jO.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
        const t = qO.getComponent(r);
        if (0 !== t) {
          const i = YO.getComponent(r);
          ZO.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
            e.addScaledVector(KO.copy(jO).applyMatrix4(ZO), t);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class $O extends qR {
    constructor() {
      super(), (this.isBone = !0), (this.type = "Bone");
    }
  }
  class QO extends GA {
    constructor(
      t = null,
      e = 1,
      n = 1,
      i,
      r,
      s,
      o,
      a,
      l = 1003,
      h = 1003,
      u,
      c
    ) {
      super(null, s, o, a, l, h, i, r, u, c),
        (this.isDataTexture = !0),
        (this.image = { data: t, width: e, height: n }),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  const tN = new ER(),
    eN = new ER();
  class nN {
    constructor(t = [], e = []) {
      (this.uuid = dA()),
        (this.bones = t.slice(0)),
        (this.boneInverses = e),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        (this.boneTextureSize = 0),
        (this.frame = -1),
        this.init();
    }
    init() {
      const t = this.bones,
        e = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)
      )
        this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new ER());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = new ER();
        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
          this.boneInverses.push(e);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e &&
          (e.parent && e.parent.isBone
            ? (e.matrix.copy(e.parent.matrixWorld).invert(),
              e.matrix.multiply(e.matrixWorld))
            : e.matrix.copy(e.matrixWorld),
          e.matrix.decompose(e.position, e.quaternion, e.scale));
      }
    }
    update() {
      const t = this.bones,
        e = this.boneInverses,
        n = this.boneMatrices,
        i = this.boneTexture;
      for (let r = 0, s = t.length; r < s; r++) {
        const i = t[r] ? t[r].matrixWorld : eN;
        tN.multiplyMatrices(i, e[r]), tN.toArray(n, 16 * r);
      }
      null !== i && (i.needsUpdate = !0);
    }
    clone() {
      return new nN(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(4 * this.bones.length);
      (t = gA(t)), (t = Math.max(t, 4));
      const e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      const n = new QO(e, t, t, zM, kM);
      return (
        (n.needsUpdate = !0),
        (this.boneMatrices = e),
        (this.boneTexture = n),
        (this.boneTextureSize = t),
        this
      );
    }
    getBoneByName(t) {
      for (let e = 0, n = this.bones.length; e < n; e++) {
        const n = this.bones[e];
        if (n.name === t) return n;
      }
    }
    dispose() {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let n = 0, i = t.bones.length; n < i; n++) {
        const i = t.bones[n];
        let r = e[i];
        void 0 === r &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", i),
          (r = new $O())),
          this.bones.push(r),
          this.boneInverses.push(new ER().fromArray(t.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      t.uuid = this.uuid;
      const e = this.bones,
        n = this.boneInverses;
      for (let i = 0, r = e.length; i < r; i++) {
        const r = e[i];
        t.bones.push(r.uuid);
        const s = n[i];
        t.boneInverses.push(s.toArray());
      }
      return t;
    }
  }
  class iN extends aC {
    constructor(t) {
      super(),
        (this.isLineBasicMaterial = !0),
        (this.type = "LineBasicMaterial"),
        (this.color = new DA(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const rN = new jA(),
    sN = new jA(),
    oN = new ER(),
    aN = new TR(),
    lN = new fR();
  class hN extends qR {
    constructor(t = new TC(), e = new iN()) {
      super(),
        (this.isLine = !0),
        (this.type = "Line"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [0];
        for (let t = 1, i = e.count; t < i; t++)
          rN.fromBufferAttribute(e, t - 1),
            sN.fromBufferAttribute(e, t),
            (n[t] = n[t - 1]),
            (n[t] += rN.distanceTo(sN));
        t.setAttribute("lineDistance", new fC(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Line.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        lN.copy(n.boundingSphere),
        lN.applyMatrix4(i),
        (lN.radius += r),
        !1 === t.ray.intersectsSphere(lN))
      )
        return;
      oN.copy(i).invert(), aN.copy(t.ray).applyMatrix4(oN);
      const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        a = o * o,
        l = new jA(),
        h = new jA(),
        u = new jA(),
        c = new jA(),
        d = this.isLineSegments ? 2 : 1,
        p = n.index,
        f = n.attributes.position;
      if (null !== p) {
        for (
          let n = Math.max(0, s.start),
            i = Math.min(p.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          const i = p.getX(n),
            r = p.getX(n + 1);
          l.fromBufferAttribute(f, i), h.fromBufferAttribute(f, r);
          if (aN.distanceSqToSegment(l, h, c, u) > a) continue;
          c.applyMatrix4(this.matrixWorld);
          const s = t.ray.origin.distanceTo(c);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            i = Math.min(f.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          l.fromBufferAttribute(f, n), h.fromBufferAttribute(f, n + 1);
          if (aN.distanceSqToSegment(l, h, c, u) > a) continue;
          c.applyMatrix4(this.matrixWorld);
          const i = t.ray.origin.distanceTo(c);
          i < t.near ||
            i > t.far ||
            e.push({
              distance: i,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  const uN = new jA(),
    cN = new jA();
  class dN extends hN {
    constructor(t, e) {
      super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [];
        for (let t = 0, i = e.count; t < i; t += 2)
          uN.fromBufferAttribute(e, t),
            cN.fromBufferAttribute(e, t + 1),
            (n[t] = 0 === t ? 0 : n[t - 1]),
            (n[t + 1] = n[t] + uN.distanceTo(cN));
        t.setAttribute("lineDistance", new fC(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
  }
  class pN extends hN {
    constructor(t, e) {
      super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
    }
  }
  class fN extends aC {
    constructor(t) {
      super(),
        (this.isPointsMaterial = !0),
        (this.type = "PointsMaterial"),
        (this.color = new DA(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.fog = t.fog),
        this
      );
    }
  }
  const mN = new ER(),
    _N = new TR(),
    gN = new fR(),
    vN = new jA();
  class yN extends qR {
    constructor(t = new TC(), e = new fN()) {
      super(),
        (this.isPoints = !0),
        (this.type = "Points"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Points.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        gN.copy(n.boundingSphere),
        gN.applyMatrix4(i),
        (gN.radius += r),
        !1 === t.ray.intersectsSphere(gN))
      )
        return;
      mN.copy(i).invert(), _N.copy(t.ray).applyMatrix4(mN);
      const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        a = o * o,
        l = n.index,
        h = n.attributes.position;
      if (null !== l) {
        for (
          let n = Math.max(0, s.start),
            r = Math.min(l.count, s.start + s.count);
          n < r;
          n++
        ) {
          const r = l.getX(n);
          vN.fromBufferAttribute(h, r), xN(vN, r, a, i, t, e, this);
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            r = Math.min(h.count, s.start + s.count);
          n < r;
          n++
        )
          vN.fromBufferAttribute(h, n), xN(vN, n, a, i, t, e, this);
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  function xN(t, e, n, i, r, s, o) {
    const a = _N.distanceSqToPoint(t);
    if (a < n) {
      const n = new jA();
      _N.closestPointToPoint(t, n), n.applyMatrix4(i);
      const l = r.ray.origin.distanceTo(n);
      if (l < r.near || l > r.far) return;
      s.push({
        distance: l,
        distanceToRay: Math.sqrt(a),
        point: n,
        index: e,
        face: null,
        object: o,
      });
    }
  }
  class bN extends GA {
    constructor(t, e, n, i, r, s, o, a, l) {
      super(t, e, n, i, r, s, o, a, l),
        (this.isVideoTexture = !0),
        (this.minFilter = void 0 !== s ? s : LM),
        (this.magFilter = void 0 !== r ? r : LM),
        (this.generateMipmaps = !1);
      const h = this;
      "requestVideoFrameCallback" in t &&
        t.requestVideoFrameCallback(function e() {
          (h.needsUpdate = !0), t.requestVideoFrameCallback(e);
        });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const t = this.image;
      !1 === "requestVideoFrameCallback" in t &&
        t.readyState >= t.HAVE_CURRENT_DATA &&
        (this.needsUpdate = !0);
    }
  }
  class TN extends aC {
    constructor(t) {
      super(),
        (this.isMeshStandardMaterial = !0),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new DA(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new DA(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new xA(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "" }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class EN extends TN {
    constructor(t) {
      super(),
        (this.isMeshPhysicalMaterial = !0),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new xA(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.ior = 1.5),
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return pA((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
          },
          set: function (t) {
            this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
          },
        }),
        (this.iridescenceMap = null),
        (this.iridescenceIOR = 1.3),
        (this.iridescenceThicknessRange = [100, 400]),
        (this.iridescenceThicknessMap = null),
        (this.sheenColor = new DA(0)),
        (this.sheenColorMap = null),
        (this.sheenRoughness = 1),
        (this.sheenRoughnessMap = null),
        (this.transmissionMap = null),
        (this.thickness = 0),
        (this.thicknessMap = null),
        (this.attenuationDistance = 0),
        (this.attenuationColor = new DA(1, 1, 1)),
        (this.specularIntensity = 1),
        (this.specularIntensityMap = null),
        (this.specularColor = new DA(1, 1, 1)),
        (this.specularColorMap = null),
        (this._sheen = 0),
        (this._clearcoat = 0),
        (this._iridescence = 0),
        (this._transmission = 0),
        this.setValues(t);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(t) {
      this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++,
        (this._transmission = t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.clearcoat = t.clearcoat),
        (this.clearcoatMap = t.clearcoatMap),
        (this.clearcoatRoughness = t.clearcoatRoughness),
        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = t.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        (this.ior = t.ior),
        (this.iridescence = t.iridescence),
        (this.iridescenceMap = t.iridescenceMap),
        (this.iridescenceIOR = t.iridescenceIOR),
        (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
        (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
        (this.sheen = t.sheen),
        this.sheenColor.copy(t.sheenColor),
        (this.sheenColorMap = t.sheenColorMap),
        (this.sheenRoughness = t.sheenRoughness),
        (this.sheenRoughnessMap = t.sheenRoughnessMap),
        (this.transmission = t.transmission),
        (this.transmissionMap = t.transmissionMap),
        (this.thickness = t.thickness),
        (this.thicknessMap = t.thicknessMap),
        (this.attenuationDistance = t.attenuationDistance),
        this.attenuationColor.copy(t.attenuationColor),
        (this.specularIntensity = t.specularIntensity),
        (this.specularIntensityMap = t.specularIntensityMap),
        this.specularColor.copy(t.specularColor),
        (this.specularColorMap = t.specularColorMap),
        this
      );
    }
  }
  class SN extends aC {
    constructor(t) {
      super(),
        (this.isMeshPhongMaterial = !0),
        (this.type = "MeshPhongMaterial"),
        (this.color = new DA(16777215)),
        (this.specular = new DA(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new DA(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new xA(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  function wN(t, e, n) {
    return AN(t)
      ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
      : t.slice(e, n);
  }
  function MN(t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t);
  }
  function AN(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  }
  function RN(t) {
    const e = t.length,
      n = new Array(e);
    for (let i = 0; i !== e; ++i) n[i] = i;
    return (
      n.sort(function (e, n) {
        return t[e] - t[n];
      }),
      n
    );
  }
  function CN(t, e, n) {
    const i = t.length,
      r = new t.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
      const i = n[s] * e;
      for (let n = 0; n !== e; ++n) r[o++] = t[i + n];
    }
    return r;
  }
  function IN(t, e, n, i) {
    let r = 1,
      s = t[0];
    for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
    if (void 0 === s) return;
    let o = s[i];
    if (void 0 !== o)
      if (Array.isArray(o))
        do {
          (o = s[i]),
            void 0 !== o && (e.push(s.time), n.push.apply(n, o)),
            (s = t[r++]);
        } while (void 0 !== s);
      else if (void 0 !== o.toArray)
        do {
          (o = s[i]),
            void 0 !== o && (e.push(s.time), o.toArray(n, n.length)),
            (s = t[r++]);
        } while (void 0 !== s);
      else
        do {
          (o = s[i]), void 0 !== o && (e.push(s.time), n.push(o)), (s = t[r++]);
        } while (void 0 !== s);
  }
  class PN {
    constructor(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          let s;
          n: {
            i: if (!(t < i)) {
              for (let s = n + 2; ; ) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.copySampleValue_(n - 1)
                  );
                }
                if (n === s) break;
                if (((r = i), (i = e[++n]), t < i)) break e;
              }
              s = e.length;
              break n;
            }
            if (t >= r) break t;
            {
              const o = e[1];
              t < o && ((n = 2), (r = o));
              for (let s = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (n === s) break;
                if (((i = r), (r = e[--n - 1]), t >= r)) break e;
              }
              (s = n), (n = 0);
            }
          }
          for (; n < s; ) {
            const i = (n + s) >>> 1;
            t < e[i] ? (s = i) : (n = i + 1);
          }
          if (((i = e[n]), (r = e[n - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (void 0 === i)
            return (
              (n = e.length),
              (this._cachedIndex = n),
              this.copySampleValue_(n - 1)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i;
      for (let s = 0; s !== i; ++s) e[s] = n[r + s];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  class ON extends PN {
    constructor(t, e, n, i) {
      super(t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
    }
    intervalChanged_(t, e, n) {
      const i = this.parameterPositions;
      let r = t - 2,
        s = t + 1,
        o = i[r],
        a = i[s];
      if (void 0 === o)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (r = t), (o = 2 * e - n);
            break;
          case 2402:
            (r = i.length - 2), (o = e + i[r] - i[r + 1]);
            break;
          default:
            (r = t), (o = n);
        }
      if (void 0 === a)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (s = t), (a = 2 * n - e);
            break;
          case 2402:
            (s = 1), (a = n + i[1] - i[0]);
            break;
          default:
            (s = t - 1), (a = e);
        }
      const l = 0.5 * (n - e),
        h = this.valueSize;
      (this._weightPrev = l / (e - o)),
        (this._weightNext = l / (a - n)),
        (this._offsetPrev = r * h),
        (this._offsetNext = s * h);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize,
        a = t * o,
        l = a - o,
        h = this._offsetPrev,
        u = this._offsetNext,
        c = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        f = p * p,
        m = f * p,
        _ = -c * m + 2 * c * f - c * p,
        g = (1 + c) * m + (-1.5 - 2 * c) * f + (-0.5 + c) * p + 1,
        v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        y = d * m - d * f;
      for (let x = 0; x !== o; ++x)
        r[x] = _ * s[h + x] + g * s[l + x] + v * s[a + x] + y * s[u + x];
      return r;
    }
  }
  class NN extends PN {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize,
        a = t * o,
        l = a - o,
        h = (n - e) / (i - e),
        u = 1 - h;
      for (let c = 0; c !== o; ++c) r[c] = s[l + c] * u + s[a + c] * h;
      return r;
    }
  }
  class DN extends PN {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class LN {
    constructor(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = MN(e, this.TimeBufferType)),
        (this.values = MN(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: MN(t.times, Array),
          values: MN(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e);
      }
      return (n.type = t.ValueTypeName), n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new DN(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new NN(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new ON(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case KM:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case ZM:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case JM:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return KM;
        case this.InterpolantFactoryMethodLinear:
          return ZM;
        case this.InterpolantFactoryMethodSmooth:
          return JM;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      const n = this.times,
        i = n.length;
      let r = 0,
        s = i - 1;
      for (; r !== i && n[r] < t; ) ++r;
      for (; -1 !== s && n[s] > e; ) --s;
      if ((++s, 0 !== r || s !== i)) {
        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
        const t = this.getValueSize();
        (this.times = wN(n, r, s)),
          (this.values = wN(this.values, r * t, s * t));
      }
      return this;
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (t = !1));
      const n = this.times,
        i = this.values,
        r = n.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let s = null;
      for (let o = 0; o !== r; o++) {
        const e = n[o];
        if ("number" == typeof e && isNaN(e)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            o,
            e
          ),
            (t = !1);
          break;
        }
        if (null !== s && s > e) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            o,
            e,
            s
          ),
            (t = !1);
          break;
        }
        s = e;
      }
      if (void 0 !== i && AN(i))
        for (let o = 0, a = i.length; o !== a; ++o) {
          const e = i[o];
          if (isNaN(e)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              o,
              e
            ),
              (t = !1);
            break;
          }
        }
      return t;
    }
    optimize() {
      const t = wN(this.times),
        e = wN(this.values),
        n = this.getValueSize(),
        i = this.getInterpolation() === JM,
        r = t.length - 1;
      let s = 1;
      for (let o = 1; o < r; ++o) {
        let r = !1;
        const a = t[o];
        if (a !== t[o + 1] && (1 !== o || a !== t[0]))
          if (i) r = !0;
          else {
            const t = o * n,
              i = t - n,
              s = t + n;
            for (let o = 0; o !== n; ++o) {
              const n = e[t + o];
              if (n !== e[i + o] || n !== e[s + o]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (o !== s) {
            t[s] = t[o];
            const i = o * n,
              r = s * n;
            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
        ++s;
      }
      return (
        s !== t.length
          ? ((this.times = wN(t, 0, s)), (this.values = wN(e, 0, s * n)))
          : ((this.times = t), (this.values = e)),
        this
      );
    }
    clone() {
      const t = wN(this.times, 0),
        e = wN(this.values, 0),
        n = new (0, this.constructor)(this.name, t, e);
      return (n.createInterpolant = this.createInterpolant), n;
    }
  }
  (LN.prototype.TimeBufferType = Float32Array),
    (LN.prototype.ValueBufferType = Float32Array),
    (LN.prototype.DefaultInterpolation = ZM);
  class FN extends LN {}
  (FN.prototype.ValueTypeName = "bool"),
    (FN.prototype.ValueBufferType = Array),
    (FN.prototype.DefaultInterpolation = KM),
    (FN.prototype.InterpolantFactoryMethodLinear = void 0),
    (FN.prototype.InterpolantFactoryMethodSmooth = void 0);
  class UN extends LN {}
  UN.prototype.ValueTypeName = "color";
  class BN extends LN {}
  BN.prototype.ValueTypeName = "number";
  class kN extends PN {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize,
        a = (n - e) / (i - e);
      let l = t * o;
      for (let h = l + o; l !== h; l += 4)
        WA.slerpFlat(r, 0, s, l - o, s, l, a);
      return r;
    }
  }
  class GN extends LN {
    InterpolantFactoryMethodLinear(t) {
      return new kN(this.times, this.values, this.getValueSize(), t);
    }
  }
  (GN.prototype.ValueTypeName = "quaternion"),
    (GN.prototype.DefaultInterpolation = ZM),
    (GN.prototype.InterpolantFactoryMethodSmooth = void 0);
  class HN extends LN {}
  (HN.prototype.ValueTypeName = "string"),
    (HN.prototype.ValueBufferType = Array),
    (HN.prototype.DefaultInterpolation = KM),
    (HN.prototype.InterpolantFactoryMethodLinear = void 0),
    (HN.prototype.InterpolantFactoryMethodSmooth = void 0);
  class zN extends LN {}
  zN.prototype.ValueTypeName = "vector";
  class VN {
    constructor(t, e = -1, n, i = 2500) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = e),
        (this.blendMode = i),
        (this.uuid = dA()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      const e = [],
        n = t.tracks,
        i = 1 / (t.fps || 1);
      for (let s = 0, o = n.length; s !== o; ++s) e.push(XN(n[s]).scale(i));
      const r = new this(t.name, t.duration, e, t.blendMode);
      return (r.uuid = t.uuid), r;
    }
    static toJSON(t) {
      const e = [],
        n = t.tracks,
        i = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode,
        };
      for (let r = 0, s = n.length; r !== s; ++r) e.push(LN.toJSON(n[r]));
      return i;
    }
    static CreateFromMorphTargetSequence(t, e, n, i) {
      const r = e.length,
        s = [];
      for (let o = 0; o < r; o++) {
        let t = [],
          a = [];
        t.push((o + r - 1) % r, o, (o + 1) % r), a.push(0, 1, 0);
        const l = RN(t);
        (t = CN(t, 1, l)),
          (a = CN(a, 1, l)),
          i || 0 !== t[0] || (t.push(r), a.push(a[0])),
          s.push(
            new BN(".morphTargetInfluences[" + e[o].name + "]", t, a).scale(
              1 / n
            )
          );
      }
      return new this(t, -1, s);
    }
    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const e = t;
        n = (e.geometry && e.geometry.animations) || e.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
      const i = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (let o = 0, a = t.length; o < a; o++) {
        const e = t[o],
          n = e.name.match(r);
        if (n && n.length > 1) {
          const t = n[1];
          let r = i[t];
          r || (i[t] = r = []), r.push(e);
        }
      }
      const s = [];
      for (const o in i)
        s.push(this.CreateFromMorphTargetSequence(o, i[o], e, n));
      return s;
    }
    static parseAnimation(t, e) {
      if (!t)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      const n = function (t, e, n, i, r) {
          if (0 !== n.length) {
            const s = [],
              o = [];
            IN(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o));
          }
        },
        i = [],
        r = t.name || "default",
        s = t.fps || 30,
        o = t.blendMode;
      let a = t.length || -1;
      const l = t.hierarchy || [];
      for (let h = 0; h < l.length; h++) {
        const t = l[h].keys;
        if (t && 0 !== t.length)
          if (t[0].morphTargets) {
            const e = {};
            let n;
            for (n = 0; n < t.length; n++)
              if (t[n].morphTargets)
                for (let i = 0; i < t[n].morphTargets.length; i++)
                  e[t[n].morphTargets[i]] = -1;
            for (const r in e) {
              const e = [],
                s = [];
              for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                const i = t[n];
                e.push(i.time), s.push(i.morphTarget === r ? 1 : 0);
              }
              i.push(new BN(".morphTargetInfluence[" + r + "]", e, s));
            }
            a = e.length * s;
          } else {
            const r = ".bones[" + e[h].name + "]";
            n(zN, r + ".position", t, "pos", i),
              n(GN, r + ".quaternion", t, "rot", i),
              n(zN, r + ".scale", t, "scl", i);
          }
      }
      if (0 === i.length) return null;
      return new this(r, a, i, o);
    }
    resetDuration() {
      let t = 0;
      for (let e = 0, n = this.tracks.length; e !== n; ++e) {
        const n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return (this.duration = t), this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function XN(t) {
    if (void 0 === t.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    const e = (function (t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return BN;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return zN;
        case "color":
          return UN;
        case "quaternion":
          return GN;
        case "bool":
        case "boolean":
          return FN;
        case "string":
          return HN;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    })(t.type);
    if (void 0 === t.times) {
      const e = [],
        n = [];
      IN(t.keys, e, n, "value"), (t.times = e), (t.values = n);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  const WN = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  class jN {
    constructor(t, e, n) {
      const i = this;
      let r,
        s = !1,
        o = 0,
        a = 0;
      const l = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), (s = !0);
        }),
        (this.itemEnd = function (t) {
          o++,
            void 0 !== i.onProgress && i.onProgress(t, o, a),
            o === a && ((s = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return r ? r(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (r = t), this;
        }),
        (this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (let e = 0, n = l.length; e < n; e += 2) {
            const n = l[e],
              i = l[e + 1];
            if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
          }
          return null;
        });
    }
  }
  const YN = new jN();
  class qN {
    constructor(t) {
      (this.manager = void 0 !== t ? t : YN),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n.load(t, i, e, r);
      });
    }
    parse() {}
    setCrossOrigin(t) {
      return (this.crossOrigin = t), this;
    }
    setWithCredentials(t) {
      return (this.withCredentials = t), this;
    }
    setPath(t) {
      return (this.path = t), this;
    }
    setResourcePath(t) {
      return (this.resourcePath = t), this;
    }
    setRequestHeader(t) {
      return (this.requestHeader = t), this;
    }
  }
  const KN = {};
  class ZN extends Error {
    constructor(t, e) {
      super(t), (this.response = e);
    }
  }
  class JN extends qN {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = WN.get(t);
      if (void 0 !== r)
        return (
          this.manager.itemStart(t),
          setTimeout(() => {
            e && e(r), this.manager.itemEnd(t);
          }, 0),
          r
        );
      if (void 0 !== KN[t])
        return void KN[t].push({ onLoad: e, onProgress: n, onError: i });
      (KN[t] = []), KN[t].push({ onLoad: e, onProgress: n, onError: i });
      const s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        o = this.mimeType,
        a = this.responseType;
      fetch(s)
        .then((e) => {
          if (200 === e.status || 0 === e.status) {
            if (
              (0 === e.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              "undefined" == typeof ReadableStream ||
                void 0 === e.body ||
                void 0 === e.body.getReader)
            )
              return e;
            const n = KN[t],
              i = e.body.getReader(),
              r = e.headers.get("Content-Length"),
              s = r ? parseInt(r) : 0,
              o = 0 !== s;
            let a = 0;
            const l = new ReadableStream({
              start(t) {
                !(function e() {
                  i.read().then(({ done: i, value: r }) => {
                    if (i) t.close();
                    else {
                      a += r.byteLength;
                      const i = new ProgressEvent("progress", {
                        lengthComputable: o,
                        loaded: a,
                        total: s,
                      });
                      for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t];
                        e.onProgress && e.onProgress(i);
                      }
                      t.enqueue(r), e();
                    }
                  });
                })();
              },
            });
            return new Response(l);
          }
          throw new ZN(
            `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
            e
          );
        })
        .then((t) => {
          switch (a) {
            case "arraybuffer":
              return t.arrayBuffer();
            case "blob":
              return t.blob();
            case "document":
              return t
                .text()
                .then((t) => new DOMParser().parseFromString(t, o));
            case "json":
              return t.json();
            default:
              if (void 0 === o) return t.text();
              {
                const e = /charset="?([^;"\s]*)"?/i.exec(o),
                  n = e && e[1] ? e[1].toLowerCase() : void 0,
                  i = new TextDecoder(n);
                return t.arrayBuffer().then((t) => i.decode(t));
              }
          }
        })
        .then((e) => {
          WN.add(t, e);
          const n = KN[t];
          delete KN[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onLoad && i.onLoad(e);
          }
        })
        .catch((e) => {
          const n = KN[t];
          if (void 0 === n) throw (this.manager.itemError(t), e);
          delete KN[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onError && i.onError(e);
          }
          this.manager.itemError(t);
        })
        .finally(() => {
          this.manager.itemEnd(t);
        }),
        this.manager.itemStart(t);
    }
    setResponseType(t) {
      return (this.responseType = t), this;
    }
    setMimeType(t) {
      return (this.mimeType = t), this;
    }
  }
  class $N extends qN {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = WN.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const o = EA("img");
      function a() {
        h(), WN.add(t, this), e && e(this), r.manager.itemEnd(t);
      }
      function l(e) {
        h(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }
      function h() {
        o.removeEventListener("load", a, !1),
          o.removeEventListener("error", l, !1);
      }
      return (
        o.addEventListener("load", a, !1),
        o.addEventListener("error", l, !1),
        "data:" !== t.slice(0, 5) &&
          void 0 !== this.crossOrigin &&
          (o.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        (o.src = t),
        o
      );
    }
  }
  class QN extends qN {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      const r = new GA(),
        s = new $N(this.manager);
      return (
        s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(
          t,
          function (t) {
            (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
          },
          n,
          i
        ),
        r
      );
    }
  }
  class tD extends qR {
    constructor(t, e = 1) {
      super(),
        (this.isLight = !0),
        (this.type = "Light"),
        (this.color = new DA(t)),
        (this.intensity = e);
    }
    dispose() {}
    copy(t, e) {
      return (
        super.copy(t, e),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.color = this.color.getHex()),
        (e.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
      );
    }
  }
  const eD = new ER(),
    nD = new jA(),
    iD = new jA();
  class rD {
    constructor(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new xA(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new ER()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new sI()),
        (this._frameExtents = new xA(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new HA(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      const e = this.camera,
        n = this.matrix;
      nD.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(nD),
        iD.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(iD),
        e.updateMatrixWorld(),
        eD.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(eD),
        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        n.multiply(e.projectionMatrix),
        n.multiply(e.matrixWorldInverse);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t = {};
      return (
        0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      );
    }
  }
  class sD extends rD {
    constructor() {
      super(new qC(50, 1, 0.5, 500)),
        (this.isSpotLightShadow = !0),
        (this.focus = 1);
    }
    updateMatrices(t) {
      const e = this.camera,
        n = 2 * cA * t.angle * this.focus,
        i = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      (n === e.fov && i === e.aspect && r === e.far) ||
        ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
        super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), (this.focus = t.focus), this;
    }
  }
  class oD extends tD {
    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
      super(t, e),
        (this.isSpotLight = !0),
        (this.type = "SpotLight"),
        this.position.copy(qR.DefaultUp),
        this.updateMatrix(),
        (this.target = new qR()),
        (this.distance = n),
        (this.angle = i),
        (this.penumbra = r),
        (this.decay = s),
        (this.shadow = new sD());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.angle = t.angle),
        (this.penumbra = t.penumbra),
        (this.decay = t.decay),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  const aD = new ER(),
    lD = new jA(),
    hD = new jA();
  class uD extends rD {
    constructor() {
      super(new qC(90, 1, 0.5, 500)),
        (this.isPointLightShadow = !0),
        (this._frameExtents = new xA(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new HA(2, 1, 1, 1),
          new HA(0, 1, 1, 1),
          new HA(3, 1, 1, 1),
          new HA(1, 1, 1, 1),
          new HA(3, 0, 1, 1),
          new HA(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new jA(1, 0, 0),
          new jA(-1, 0, 0),
          new jA(0, 0, 1),
          new jA(0, 0, -1),
          new jA(0, 1, 0),
          new jA(0, -1, 0),
        ]),
        (this._cubeUps = [
          new jA(0, 1, 0),
          new jA(0, 1, 0),
          new jA(0, 1, 0),
          new jA(0, 1, 0),
          new jA(0, 0, 1),
          new jA(0, 0, -1),
        ]);
    }
    updateMatrices(t, e = 0) {
      const n = this.camera,
        i = this.matrix,
        r = t.distance || n.far;
      r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
        lD.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(lD),
        hD.copy(n.position),
        hD.add(this._cubeDirections[e]),
        n.up.copy(this._cubeUps[e]),
        n.lookAt(hD),
        n.updateMatrixWorld(),
        i.makeTranslation(-lD.x, -lD.y, -lD.z),
        aD.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(aD);
    }
  }
  class cD extends tD {
    constructor(t, e, n = 0, i = 1) {
      super(t, e),
        (this.isPointLight = !0),
        (this.type = "PointLight"),
        (this.distance = n),
        (this.decay = i),
        (this.shadow = new uD());
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.decay = t.decay),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class dD extends rD {
    constructor() {
      super(new vI(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0);
    }
  }
  class pD extends tD {
    constructor(t, e) {
      super(t, e),
        (this.isDirectionalLight = !0),
        (this.type = "DirectionalLight"),
        this.position.copy(qR.DefaultUp),
        this.updateMatrix(),
        (this.target = new qR()),
        (this.shadow = new dD());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class fD extends tD {
    constructor(t, e) {
      super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
    }
  }
  class mD {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      let e = "";
      for (let i = 0, r = t.length; i < r; i++) e += String.fromCharCode(t[i]);
      try {
        return decodeURIComponent(escape(e));
      } catch (n) {
        return e;
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.slice(0, e + 1);
    }
    static resolveURL(t, e) {
      return "string" != typeof t || "" === t
        ? ""
        : (/^https?:\/\//i.test(e) &&
            /^\//.test(t) &&
            (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(t) ||
          /^data:.*,.*$/i.test(t) ||
          /^blob:.*$/i.test(t)
            ? t
            : e + t);
    }
  }
  class _D extends qN {
    constructor(t) {
      super(t),
        (this.isImageBitmapLoader = !0),
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(t) {
      return (this.options = t), this;
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = WN.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const o = {};
      (o.credentials =
        "anonymous" === this.crossOrigin ? "same-origin" : "include"),
        (o.headers = this.requestHeader),
        fetch(t, o)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return createImageBitmap(
              t,
              Object.assign(r.options, { colorSpaceConversion: "none" })
            );
          })
          .then(function (n) {
            WN.add(t, n), e && e(n), r.manager.itemEnd(t);
          })
          .catch(function (e) {
            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }),
        r.manager.itemStart(t);
    }
  }
  class gD {
    constructor(t = !0) {
      (this.autoStart = t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = vD()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const e = vD();
        (t = (e - this.oldTime) / 1e3),
          (this.oldTime = e),
          (this.elapsedTime += t);
      }
      return t;
    }
  }
  function vD() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const yD = "\\[\\]\\.:\\/",
    xD = new RegExp("[\\[\\]\\.:\\/]", "g"),
    bD = "[^\\[\\]\\.:\\/]",
    TD = "[^" + yD.replace("\\.", "") + "]",
    ED = new RegExp(
      "^" +
        /((?:WC+[\/:])*)/.source.replace("WC", bD) +
        /(WCOD+)?/.source.replace("WCOD", TD) +
        /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", bD) +
        /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", bD) +
        "$"
    ),
    SD = ["material", "materials", "bones"];
  class wD {
    constructor(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || wD.parseTrackName(e)),
        (this.node = wD.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(t, e, n) {
      return t && t.isAnimationObjectGroup
        ? new wD.Composite(t, e, n)
        : new wD(t, e, n);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(xD, "");
    }
    static parseTrackName(t) {
      const e = ED.exec(t);
      if (null === e)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        const t = n.nodeName.substring(i + 1);
        -1 !== SD.indexOf(t) &&
          ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
      }
      if (null === n.propertyName || 0 === n.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t
        );
      return n;
    }
    static findNode(t, e) {
      if (
        void 0 === e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n;
      }
      if (t.children) {
        const n = function (t) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.name === e || r.uuid === e) return r;
              const s = n(r.children);
              if (s) return s;
            }
            return null;
          },
          i = n(t.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t ||
          ((t = wD.findNode(this.rootNode, e.nodeName) || this.rootNode),
          (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path +
            " but it wasn't found."
        );
      if (n) {
        let i = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === i) {
                i = e;
                break;
              }
            break;
          default:
            if (void 0 === t[n])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            t = t[n];
        }
        if (void 0 !== i) {
          if (void 0 === t[i])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t
            );
          t = t[i];
        }
      }
      const s = t[i];
      if (void 0 === s) {
        const n = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            n +
            "." +
            i +
            " but it wasn't found.",
          t
        );
      }
      let o = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (o = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (o = this.Versioning.MatrixWorldNeedsUpdate);
      let a = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (a = this.BindingType.ArrayElement),
          (this.resolvedProperty = s),
          (this.propertyIndex = r);
      } else
        void 0 !== s.fromArray && void 0 !== s.toArray
          ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
          : Array.isArray(s)
          ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = s))
          : (this.propertyName = i);
      (this.getValue = this.GetterByBindingType[a]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (wD.Composite = class {
    constructor(t, e, n) {
      const i = n || wD.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
    setValue(t, e) {
      const n = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].unbind();
    }
  }),
    (wD.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (wD.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (wD.prototype.GetterByBindingType = [
      wD.prototype._getValue_direct,
      wD.prototype._getValue_array,
      wD.prototype._getValue_arrayElement,
      wD.prototype._getValue_toArray,
    ]),
    (wD.prototype.SetterByBindingTypeAndVersioning = [
      [
        wD.prototype._setValue_direct,
        wD.prototype._setValue_direct_setNeedsUpdate,
        wD.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        wD.prototype._setValue_array,
        wD.prototype._setValue_array_setNeedsUpdate,
        wD.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        wD.prototype._setValue_arrayElement,
        wD.prototype._setValue_arrayElement_setNeedsUpdate,
        wD.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        wD.prototype._setValue_fromArray,
        wD.prototype._setValue_fromArray_setNeedsUpdate,
        wD.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: SM } })
      ),
    "undefined" != typeof window &&
      (window.__THREE__
        ? console.warn(
            "WARNING: Multiple instances of Three.js being imported."
          )
        : (window.__THREE__ = SM));
  const MD = (t, e) => {
      const n = e.x - t.x,
        i = e.y - t.y;
      return Math.sqrt(n * n + i * i);
    },
    AD = (t) => t * (Math.PI / 180),
    RD = (t) => t * (180 / Math.PI),
    CD = new Map(),
    ID = (t) => {
      CD.has(t) && clearTimeout(CD.get(t)), CD.set(t, setTimeout(t, 100));
    },
    PD = (t, e, n) => {
      const i = e.split(/[ ,]+/g);
      let r;
      for (let s = 0; s < i.length; s += 1)
        (r = i[s]),
          t.addEventListener
            ? t.addEventListener(r, n, !1)
            : t.attachEvent && t.attachEvent(r, n);
    },
    OD = (t, e, n) => {
      const i = e.split(/[ ,]+/g);
      let r;
      for (let s = 0; s < i.length; s += 1)
        (r = i[s]),
          t.removeEventListener
            ? t.removeEventListener(r, n)
            : t.detachEvent && t.detachEvent(r, n);
    },
    ND = (t) => (
      t.preventDefault(), t.type.match(/^touch/) ? t.changedTouches : t
    ),
    DD = () => ({
      x:
        void 0 !== window.pageXOffset
          ? window.pageXOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollLeft,
      y:
        void 0 !== window.pageYOffset
          ? window.pageYOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollTop,
    }),
    LD = (t, e) => {
      e.top || e.right || e.bottom || e.left
        ? ((t.style.top = e.top),
          (t.style.right = e.right),
          (t.style.bottom = e.bottom),
          (t.style.left = e.left))
        : ((t.style.left = e.x + "px"), (t.style.top = e.y + "px"));
    },
    FD = (t, e, n) => {
      const i = UD(t);
      for (let r in i)
        if (i.hasOwnProperty(r))
          if ("string" == typeof e) i[r] = e + " " + n;
          else {
            let t = "";
            for (let i = 0, r = e.length; i < r; i += 1)
              t += e[i] + " " + n + ", ";
            i[r] = t.slice(0, -2);
          }
      return i;
    },
    UD = (t) => {
      const e = {};
      e[t] = "";
      return (
        ["webkit", "Moz", "o"].forEach(function (n) {
          e[n + t.charAt(0).toUpperCase() + t.slice(1)] = "";
        }),
        e
      );
    },
    BD = (t, e) => {
      for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      return t;
    },
    kD = (t, e) => {
      if (t.length) for (let n = 0, i = t.length; n < i; n += 1) e(t[n]);
      else e(t);
    };
  var GD,
    HD = !!("ontouchstart" in window),
    zD = !!window.PointerEvent,
    VD = !!window.MSPointerEvent,
    XD = { start: "mousedown", move: "mousemove", end: "mouseup" },
    WD = {};
  function jD() {}
  function YD(t, e) {
    return (
      (this.identifier = e.identifier),
      (this.position = e.position),
      (this.frontPosition = e.frontPosition),
      (this.collection = t),
      (this.defaults = {
        size: 100,
        threshold: 0.1,
        color: "white",
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: 0.5,
        mode: "dynamic",
        zone: document.body,
        lockX: !1,
        lockY: !1,
        shape: "circle",
      }),
      this.config(e),
      "dynamic" === this.options.mode && (this.options.restOpacity = 0),
      (this.id = YD.id),
      (YD.id += 1),
      this.buildEl().stylize(),
      (this.instance = {
        el: this.ui.el,
        on: this.on.bind(this),
        off: this.off.bind(this),
        show: this.show.bind(this),
        hide: this.hide.bind(this),
        add: this.addToDom.bind(this),
        remove: this.removeFromDom.bind(this),
        destroy: this.destroy.bind(this),
        setPosition: this.setPosition.bind(this),
        resetDirection: this.resetDirection.bind(this),
        computeDirection: this.computeDirection.bind(this),
        trigger: this.trigger.bind(this),
        position: this.position,
        frontPosition: this.frontPosition,
        ui: this.ui,
        identifier: this.identifier,
        id: this.id,
        options: this.options,
      }),
      this.instance
    );
  }
  function qD(t, e) {
    var n = this;
    (n.nipples = []),
      (n.idles = []),
      (n.actives = []),
      (n.ids = []),
      (n.pressureIntervals = {}),
      (n.manager = t),
      (n.id = qD.id),
      (qD.id += 1),
      (n.defaults = {
        zone: document.body,
        multitouch: !1,
        maxNumberOfNipples: 10,
        mode: "dynamic",
        position: { top: 0, left: 0 },
        catchDistance: 200,
        size: 100,
        threshold: 0.1,
        color: "white",
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: 0.5,
        lockX: !1,
        lockY: !1,
        shape: "circle",
        dynamicPage: !1,
        follow: !1,
      }),
      n.config(e),
      ("static" !== n.options.mode && "semi" !== n.options.mode) ||
        (n.options.multitouch = !1),
      n.options.multitouch || (n.options.maxNumberOfNipples = 1);
    const i = getComputedStyle(n.options.zone.parentElement);
    return (
      i && "flex" === i.display && (n.parentIsFlex = !0),
      n.updateBox(),
      n.prepareNipples(),
      n.bindings(),
      n.begin(),
      n.nipples
    );
  }
  function KD(t) {
    var e = this;
    (e.ids = {}),
      (e.index = 0),
      (e.collections = []),
      (e.scroll = DD()),
      e.config(t),
      e.prepareCollections();
    var n = function () {
      var t;
      e.collections.forEach(function (n) {
        n.forEach(function (n) {
          (t = n.el.getBoundingClientRect()),
            (n.position = { x: e.scroll.x + t.left, y: e.scroll.y + t.top });
        });
      });
    };
    PD(window, "resize", function () {
      ID(n);
    });
    var i = function () {
      e.scroll = DD();
    };
    return (
      PD(window, "scroll", function () {
        ID(i);
      }),
      e.collections
    );
  }
  zD
    ? (GD = {
        start: "pointerdown",
        move: "pointermove",
        end: "pointerup, pointercancel",
      })
    : VD
    ? (GD = {
        start: "MSPointerDown",
        move: "MSPointerMove",
        end: "MSPointerUp",
      })
    : HD
    ? ((GD = {
        start: "touchstart",
        move: "touchmove",
        end: "touchend, touchcancel",
      }),
      (WD = XD))
    : (GD = XD),
    (jD.prototype.on = function (t, e) {
      var n,
        i = this,
        r = t.split(/[ ,]+/g);
      i._handlers_ = i._handlers_ || {};
      for (var s = 0; s < r.length; s += 1)
        (n = r[s]),
          (i._handlers_[n] = i._handlers_[n] || []),
          i._handlers_[n].push(e);
      return i;
    }),
    (jD.prototype.off = function (t, e) {
      var n = this;
      return (
        (n._handlers_ = n._handlers_ || {}),
        void 0 === t
          ? (n._handlers_ = {})
          : void 0 === e
          ? (n._handlers_[t] = null)
          : n._handlers_[t] &&
            n._handlers_[t].indexOf(e) >= 0 &&
            n._handlers_[t].splice(n._handlers_[t].indexOf(e), 1),
        n
      );
    }),
    (jD.prototype.trigger = function (t, e) {
      var n,
        i = this,
        r = t.split(/[ ,]+/g);
      i._handlers_ = i._handlers_ || {};
      for (var s = 0; s < r.length; s += 1)
        (n = r[s]),
          i._handlers_[n] &&
            i._handlers_[n].length &&
            i._handlers_[n].forEach(function (t) {
              t.call(i, { type: n, target: i }, e);
            });
    }),
    (jD.prototype.config = function (t) {
      var e = this;
      (e.options = e.defaults || {}),
        t &&
          (e.options = ((t, e) => {
            const n = {};
            for (let i in t)
              t.hasOwnProperty(i) && e.hasOwnProperty(i)
                ? (n[i] = e[i])
                : t.hasOwnProperty(i) && (n[i] = t[i]);
            return n;
          })(e.options, t));
    }),
    (jD.prototype.bindEvt = function (t, e) {
      var n = this;
      return (
        (n._domHandlers_ = n._domHandlers_ || {}),
        (n._domHandlers_[e] = function () {
          "function" == typeof n["on" + e]
            ? n["on" + e].apply(n, arguments)
            : console.warn('[WARNING] : Missing "on' + e + '" handler.');
        }),
        PD(t, GD[e], n._domHandlers_[e]),
        WD[e] && PD(t, WD[e], n._domHandlers_[e]),
        n
      );
    }),
    (jD.prototype.unbindEvt = function (t, e) {
      var n = this;
      return (
        (n._domHandlers_ = n._domHandlers_ || {}),
        OD(t, GD[e], n._domHandlers_[e]),
        WD[e] && OD(t, WD[e], n._domHandlers_[e]),
        delete n._domHandlers_[e],
        this
      );
    }),
    (YD.prototype = new jD()),
    (YD.constructor = YD),
    (YD.id = 0),
    (YD.prototype.buildEl = function (t) {
      return (
        (this.ui = {}),
        this.options.dataOnly ||
          ((this.ui.el = document.createElement("div")),
          (this.ui.back = document.createElement("div")),
          (this.ui.front = document.createElement("div")),
          (this.ui.el.className = "nipple collection_" + this.collection.id),
          (this.ui.back.className = "back"),
          (this.ui.front.className = "front"),
          this.ui.el.setAttribute(
            "id",
            "nipple_" + this.collection.id + "_" + this.id
          ),
          this.ui.el.appendChild(this.ui.back),
          this.ui.el.appendChild(this.ui.front)),
        this
      );
    }),
    (YD.prototype.stylize = function () {
      if (this.options.dataOnly) return this;
      var t = this.options.fadeTime + "ms",
        e = ((t, e) => {
          const n = UD(t);
          for (let i in n) n.hasOwnProperty(i) && (n[i] = e);
          return n;
        })("borderRadius", "50%"),
        n = FD("transition", "opacity", t),
        i = {};
      return (
        (i.el = {
          position: "absolute",
          opacity: this.options.restOpacity,
          display: "block",
          zIndex: 999,
        }),
        (i.back = {
          position: "absolute",
          display: "block",
          width: this.options.size + "px",
          height: this.options.size + "px",
          marginLeft: -this.options.size / 2 + "px",
          marginTop: -this.options.size / 2 + "px",
          background: this.options.color,
          opacity: ".5",
        }),
        (i.front = {
          width: this.options.size / 2 + "px",
          height: this.options.size / 2 + "px",
          position: "absolute",
          display: "block",
          marginLeft: -this.options.size / 4 + "px",
          marginTop: -this.options.size / 4 + "px",
          background: this.options.color,
          opacity: ".5",
        }),
        BD(i.el, n),
        "circle" === this.options.shape && BD(i.back, e),
        BD(i.front, e),
        this.applyStyles(i),
        this
      );
    }),
    (YD.prototype.applyStyles = function (t) {
      for (var e in this.ui)
        if (this.ui.hasOwnProperty(e))
          for (var n in t[e]) this.ui[e].style[n] = t[e][n];
      return this;
    }),
    (YD.prototype.addToDom = function () {
      return (
        this.options.dataOnly ||
          document.body.contains(this.ui.el) ||
          this.options.zone.appendChild(this.ui.el),
        this
      );
    }),
    (YD.prototype.removeFromDom = function () {
      return (
        this.options.dataOnly ||
          !document.body.contains(this.ui.el) ||
          this.options.zone.removeChild(this.ui.el),
        this
      );
    }),
    (YD.prototype.destroy = function () {
      clearTimeout(this.removeTimeout),
        clearTimeout(this.showTimeout),
        clearTimeout(this.restTimeout),
        this.trigger("destroyed", this.instance),
        this.removeFromDom(),
        this.off();
    }),
    (YD.prototype.show = function (t) {
      var e = this;
      return (
        e.options.dataOnly ||
          (clearTimeout(e.removeTimeout),
          clearTimeout(e.showTimeout),
          clearTimeout(e.restTimeout),
          e.addToDom(),
          e.restCallback(),
          setTimeout(function () {
            e.ui.el.style.opacity = 1;
          }, 0),
          (e.showTimeout = setTimeout(function () {
            e.trigger("shown", e.instance),
              "function" == typeof t && t.call(this);
          }, e.options.fadeTime))),
        e
      );
    }),
    (YD.prototype.hide = function (t) {
      var e = this;
      if (e.options.dataOnly) return e;
      if (
        ((e.ui.el.style.opacity = e.options.restOpacity),
        clearTimeout(e.removeTimeout),
        clearTimeout(e.showTimeout),
        clearTimeout(e.restTimeout),
        (e.removeTimeout = setTimeout(function () {
          var n = "dynamic" === e.options.mode ? "none" : "block";
          (e.ui.el.style.display = n),
            "function" == typeof t && t.call(e),
            e.trigger("hidden", e.instance);
        }, e.options.fadeTime)),
        e.options.restJoystick)
      ) {
        const n = e.options.restJoystick,
          i = {};
        (i.x = !0 === n || !1 !== n.x ? 0 : e.instance.frontPosition.x),
          (i.y = !0 === n || !1 !== n.y ? 0 : e.instance.frontPosition.y),
          e.setPosition(t, i);
      }
      return e;
    }),
    (YD.prototype.setPosition = function (t, e) {
      var n = this;
      n.frontPosition = { x: e.x, y: e.y };
      var i = n.options.fadeTime + "ms",
        r = {};
      r.front = FD("transition", ["top", "left"], i);
      var s = { front: {} };
      (s.front = {
        left: n.frontPosition.x + "px",
        top: n.frontPosition.y + "px",
      }),
        n.applyStyles(r),
        n.applyStyles(s),
        (n.restTimeout = setTimeout(function () {
          "function" == typeof t && t.call(n), n.restCallback();
        }, n.options.fadeTime));
    }),
    (YD.prototype.restCallback = function () {
      var t = this,
        e = {};
      (e.front = FD("transition", "none", "")),
        t.applyStyles(e),
        t.trigger("rested", t.instance);
    }),
    (YD.prototype.resetDirection = function () {
      this.direction = { x: !1, y: !1, angle: !1 };
    }),
    (YD.prototype.computeDirection = function (t) {
      var e,
        n,
        i,
        r = t.angle.radian,
        s = Math.PI / 4,
        o = Math.PI / 2;
      if (
        (r > s && r < 3 * s && !t.lockX
          ? (e = "up")
          : r > -s && r <= s && !t.lockY
          ? (e = "left")
          : r > 3 * -s && r <= -s && !t.lockX
          ? (e = "down")
          : t.lockY || (e = "right"),
        t.lockY || (n = r > -o && r < o ? "left" : "right"),
        t.lockX || (i = r > 0 ? "up" : "down"),
        t.force > this.options.threshold)
      ) {
        var a,
          l = {};
        for (a in this.direction)
          this.direction.hasOwnProperty(a) && (l[a] = this.direction[a]);
        var h = {};
        for (a in ((this.direction = { x: n, y: i, angle: e }),
        (t.direction = this.direction),
        l))
          l[a] === this.direction[a] && (h[a] = !0);
        if (h.x && h.y && h.angle) return t;
        (h.x && h.y) || this.trigger("plain", t),
          h.x || this.trigger("plain:" + n, t),
          h.y || this.trigger("plain:" + i, t),
          h.angle || this.trigger("dir dir:" + e, t);
      } else this.resetDirection();
      return t;
    }),
    (qD.prototype = new jD()),
    (qD.constructor = qD),
    (qD.id = 0),
    (qD.prototype.prepareNipples = function () {
      var t = this,
        e = t.nipples;
      (e.on = t.on.bind(t)),
        (e.off = t.off.bind(t)),
        (e.options = t.options),
        (e.destroy = t.destroy.bind(t)),
        (e.ids = t.ids),
        (e.id = t.id),
        (e.processOnMove = t.processOnMove.bind(t)),
        (e.processOnEnd = t.processOnEnd.bind(t)),
        (e.get = function (t) {
          if (void 0 === t) return e[0];
          for (var n = 0, i = e.length; n < i; n += 1)
            if (e[n].identifier === t) return e[n];
          return !1;
        });
    }),
    (qD.prototype.bindings = function () {
      var t = this;
      t.bindEvt(t.options.zone, "start"),
        (t.options.zone.style.touchAction = "none"),
        (t.options.zone.style.msTouchAction = "none");
    }),
    (qD.prototype.begin = function () {
      var t = this,
        e = t.options;
      if ("static" === e.mode) {
        var n = t.createNipple(e.position, t.manager.getIdentifier());
        n.add(), t.idles.push(n);
      }
    }),
    (qD.prototype.createNipple = function (t, e) {
      var n = this,
        i = n.manager.scroll,
        r = {},
        s = n.options,
        o = n.parentIsFlex ? i.x : i.x + n.box.left,
        a = n.parentIsFlex ? i.y : i.y + n.box.top;
      if (t.x && t.y) r = { x: t.x - o, y: t.y - a };
      else if (t.top || t.right || t.bottom || t.left) {
        var l = document.createElement("DIV");
        (l.style.display = "hidden"),
          (l.style.top = t.top),
          (l.style.right = t.right),
          (l.style.bottom = t.bottom),
          (l.style.left = t.left),
          (l.style.position = "absolute"),
          s.zone.appendChild(l);
        var h = l.getBoundingClientRect();
        s.zone.removeChild(l),
          (r = t),
          (t = { x: h.left + i.x, y: h.top + i.y });
      }
      var u = new YD(n, {
        color: s.color,
        size: s.size,
        threshold: s.threshold,
        fadeTime: s.fadeTime,
        dataOnly: s.dataOnly,
        restJoystick: s.restJoystick,
        restOpacity: s.restOpacity,
        mode: s.mode,
        identifier: e,
        position: t,
        zone: s.zone,
        frontPosition: { x: 0, y: 0 },
        shape: s.shape,
      });
      return (
        s.dataOnly || (LD(u.ui.el, r), LD(u.ui.front, u.frontPosition)),
        n.nipples.push(u),
        n.trigger("added " + u.identifier + ":added", u),
        n.manager.trigger("added " + u.identifier + ":added", u),
        n.bindNipple(u),
        u
      );
    }),
    (qD.prototype.updateBox = function () {
      this.box = this.options.zone.getBoundingClientRect();
    }),
    (qD.prototype.bindNipple = function (t) {
      var e,
        n = this,
        i = function (t, i) {
          (e = t.type + " " + i.id + ":" + t.type), n.trigger(e, i);
        };
      t.on("destroyed", n.onDestroyed.bind(n)),
        t.on("shown hidden rested dir plain", i),
        t.on("dir:up dir:right dir:down dir:left", i),
        t.on("plain:up plain:right plain:down plain:left", i);
    }),
    (qD.prototype.pressureFn = function (t, e, n) {
      var i = this,
        r = 0;
      clearInterval(i.pressureIntervals[n]),
        (i.pressureIntervals[n] = setInterval(
          function () {
            var n = t.force || t.pressure || t.webkitForce || 0;
            n !== r &&
              (e.trigger("pressure", n),
              i.trigger("pressure " + e.identifier + ":pressure", n),
              (r = n));
          }.bind(i),
          100
        ));
    }),
    (qD.prototype.onstart = function (t) {
      var e = this,
        n = e.options,
        i = t;
      (t = ND(t)), e.updateBox();
      return (
        kD(t, function (r) {
          e.actives.length < n.maxNumberOfNipples
            ? e.processOnStart(r)
            : i.type.match(/^touch/) &&
              (Object.keys(e.manager.ids).forEach(function (n) {
                if (
                  Object.values(i.touches).findIndex(function (t) {
                    return t.identifier === n;
                  }) < 0
                ) {
                  var r = [t[0]];
                  (r.identifier = n), e.processOnEnd(r);
                }
              }),
              e.actives.length < n.maxNumberOfNipples && e.processOnStart(r));
        }),
        e.manager.bindDocument(),
        !1
      );
    }),
    (qD.prototype.processOnStart = function (t) {
      var e,
        n = this,
        i = n.options,
        r = n.manager.getIdentifier(t),
        s = t.force || t.pressure || t.webkitForce || 0,
        o = { x: t.pageX, y: t.pageY },
        a = n.getOrCreate(r, o);
      a.identifier !== r && n.manager.removeIdentifier(a.identifier),
        (a.identifier = r);
      var l = function (e) {
        e.trigger("start", e),
          n.trigger("start " + e.id + ":start", e),
          e.show(),
          s > 0 && n.pressureFn(t, e, e.identifier),
          n.processOnMove(t);
      };
      if (
        ((e = n.idles.indexOf(a)) >= 0 && n.idles.splice(e, 1),
        n.actives.push(a),
        n.ids.push(a.identifier),
        "semi" !== i.mode)
      )
        l(a);
      else {
        if (!(MD(o, a.position) <= i.catchDistance))
          return a.destroy(), void n.processOnStart(t);
        l(a);
      }
      return a;
    }),
    (qD.prototype.getOrCreate = function (t, e) {
      var n,
        i = this,
        r = i.options;
      return /(semi|static)/.test(r.mode)
        ? (n = i.idles[0])
          ? (i.idles.splice(0, 1), n)
          : "semi" === r.mode
          ? i.createNipple(e, t)
          : (console.warn("Coudln't find the needed nipple."), !1)
        : (n = i.createNipple(e, t));
    }),
    (qD.prototype.processOnMove = function (t) {
      var e = this,
        n = e.options,
        i = e.manager.getIdentifier(t),
        r = e.nipples.get(i),
        s = e.manager.scroll;
      if (((t) => (isNaN(t.buttons) ? 0 !== t.pressure : 0 !== t.buttons))(t)) {
        if (!r)
          return (
            console.error("Found zombie joystick with ID " + i),
            void e.manager.removeIdentifier(i)
          );
        if (n.dynamicPage) {
          var o = r.el.getBoundingClientRect();
          r.position = { x: s.x + o.left, y: s.y + o.top };
        }
        r.identifier = i;
        var a = r.options.size / 2,
          l = { x: t.pageX, y: t.pageY };
        n.lockX && (l.y = r.position.y), n.lockY && (l.x = r.position.x);
        var h,
          u,
          c = MD(l, r.position),
          d = ((t, e) => {
            const n = e.x - t.x,
              i = e.y - t.y;
            return RD(Math.atan2(i, n));
          })(l, r.position),
          p = AD(d),
          f = c / a,
          m = { distance: c, position: l };
        if (
          ("circle" === r.options.shape
            ? ((h = Math.min(c, a)),
              (u = ((t, e, n) => {
                const i = { x: 0, y: 0 };
                return (
                  (n = AD(n)),
                  (i.x = t.x - e * Math.cos(n)),
                  (i.y = t.y - e * Math.sin(n)),
                  i
                );
              })(r.position, h, d)))
            : ((u = ((t, e, n) => ({
                x: Math.min(Math.max(t.x, e.x - n), e.x + n),
                y: Math.min(Math.max(t.y, e.y - n), e.y + n),
              }))(l, r.position, a)),
              (h = MD(u, r.position))),
          n.follow)
        ) {
          if (c > a) {
            let t = l.x - u.x,
              n = l.y - u.y;
            (r.position.x += t),
              (r.position.y += n),
              (r.el.style.top = r.position.y - (e.box.top + s.y) + "px"),
              (r.el.style.left = r.position.x - (e.box.left + s.x) + "px"),
              (c = MD(l, r.position));
          }
        } else (l = u), (c = h);
        var _ = l.x - r.position.x,
          g = l.y - r.position.y;
        (r.frontPosition = { x: _, y: g }),
          n.dataOnly || LD(r.ui.front, r.frontPosition);
        var v = {
          identifier: r.identifier,
          position: l,
          force: f,
          pressure: t.force || t.pressure || t.webkitForce || 0,
          distance: c,
          angle: { radian: p, degree: d },
          vector: { x: _ / a, y: -g / a },
          raw: m,
          instance: r,
          lockX: n.lockX,
          lockY: n.lockY,
        };
        ((v = r.computeDirection(v)).angle = {
          radian: AD(180 - d),
          degree: 180 - d,
        }),
          r.trigger("move", v),
          e.trigger("move " + r.id + ":move", v);
      } else this.processOnEnd(t);
    }),
    (qD.prototype.processOnEnd = function (t) {
      var e = this,
        n = e.options,
        i = e.manager.getIdentifier(t),
        r = e.nipples.get(i),
        s = e.manager.removeIdentifier(r.identifier);
      r &&
        (n.dataOnly ||
          r.hide(function () {
            "dynamic" === n.mode &&
              (r.trigger("removed", r),
              e.trigger("removed " + r.id + ":removed", r),
              e.manager.trigger("removed " + r.id + ":removed", r),
              r.destroy());
          }),
        clearInterval(e.pressureIntervals[r.identifier]),
        r.resetDirection(),
        r.trigger("end", r),
        e.trigger("end " + r.id + ":end", r),
        e.ids.indexOf(r.identifier) >= 0 &&
          e.ids.splice(e.ids.indexOf(r.identifier), 1),
        e.actives.indexOf(r) >= 0 && e.actives.splice(e.actives.indexOf(r), 1),
        /(semi|static)/.test(n.mode)
          ? e.idles.push(r)
          : e.nipples.indexOf(r) >= 0 &&
            e.nipples.splice(e.nipples.indexOf(r), 1),
        e.manager.unbindDocument(),
        /(semi|static)/.test(n.mode) && (e.manager.ids[s.id] = s.identifier));
    }),
    (qD.prototype.onDestroyed = function (t, e) {
      var n = this;
      n.nipples.indexOf(e) >= 0 && n.nipples.splice(n.nipples.indexOf(e), 1),
        n.actives.indexOf(e) >= 0 && n.actives.splice(n.actives.indexOf(e), 1),
        n.idles.indexOf(e) >= 0 && n.idles.splice(n.idles.indexOf(e), 1),
        n.ids.indexOf(e.identifier) >= 0 &&
          n.ids.splice(n.ids.indexOf(e.identifier), 1),
        n.manager.removeIdentifier(e.identifier),
        n.manager.unbindDocument();
    }),
    (qD.prototype.destroy = function () {
      var t = this;
      for (var e in (t.unbindEvt(t.options.zone, "start"),
      t.nipples.forEach(function (t) {
        t.destroy();
      }),
      t.pressureIntervals))
        t.pressureIntervals.hasOwnProperty(e) &&
          clearInterval(t.pressureIntervals[e]);
      t.trigger("destroyed", t.nipples), t.manager.unbindDocument(), t.off();
    }),
    (KD.prototype = new jD()),
    (KD.constructor = KD),
    (KD.prototype.prepareCollections = function () {
      var t = this;
      (t.collections.create = t.create.bind(t)),
        (t.collections.on = t.on.bind(t)),
        (t.collections.off = t.off.bind(t)),
        (t.collections.destroy = t.destroy.bind(t)),
        (t.collections.get = function (e) {
          var n;
          return (
            t.collections.every(function (t) {
              return !(n = t.get(e));
            }),
            n
          );
        });
    }),
    (KD.prototype.create = function (t) {
      return this.createCollection(t);
    }),
    (KD.prototype.createCollection = function (t) {
      var e = this,
        n = new qD(e, t);
      return e.bindCollection(n), e.collections.push(n), n;
    }),
    (KD.prototype.bindCollection = function (t) {
      var e,
        n = this,
        i = function (t, i) {
          (e = t.type + " " + i.id + ":" + t.type), n.trigger(e, i);
        };
      t.on("destroyed", n.onDestroyed.bind(n)),
        t.on("shown hidden rested dir plain", i),
        t.on("dir:up dir:right dir:down dir:left", i),
        t.on("plain:up plain:right plain:down plain:left", i);
    }),
    (KD.prototype.bindDocument = function () {
      var t = this;
      t.binded ||
        (t.bindEvt(document, "move").bindEvt(document, "end"), (t.binded = !0));
    }),
    (KD.prototype.unbindDocument = function (t) {
      var e = this;
      (Object.keys(e.ids).length && !0 !== t) ||
        (e.unbindEvt(document, "move").unbindEvt(document, "end"),
        (e.binded = !1));
    }),
    (KD.prototype.getIdentifier = function (t) {
      var e;
      return (
        t
          ? void 0 ===
              (e = void 0 === t.identifier ? t.pointerId : t.identifier) &&
            (e = this.latest || 0)
          : (e = this.index),
        void 0 === this.ids[e] &&
          ((this.ids[e] = this.index), (this.index += 1)),
        (this.latest = e),
        this.ids[e]
      );
    }),
    (KD.prototype.removeIdentifier = function (t) {
      var e = {};
      for (var n in this.ids)
        if (this.ids[n] === t) {
          (e.id = n), (e.identifier = this.ids[n]), delete this.ids[n];
          break;
        }
      return e;
    }),
    (KD.prototype.onmove = function (t) {
      return this.onAny("move", t), !1;
    }),
    (KD.prototype.onend = function (t) {
      return this.onAny("end", t), !1;
    }),
    (KD.prototype.oncancel = function (t) {
      return this.onAny("end", t), !1;
    }),
    (KD.prototype.onAny = function (t, e) {
      var n,
        i = this,
        r = "processOn" + t.charAt(0).toUpperCase() + t.slice(1);
      e = ND(e);
      var s = function (t, e, n) {
        n.ids.indexOf(e) >= 0 && (n[r](t), (t._found_ = !0));
      };
      return (
        kD(e, function (t) {
          (n = i.getIdentifier(t)),
            kD(i.collections, s.bind(null, t, n)),
            t._found_ || i.removeIdentifier(n);
        }),
        !1
      );
    }),
    (KD.prototype.destroy = function () {
      var t = this;
      t.unbindDocument(!0),
        (t.ids = {}),
        (t.index = 0),
        t.collections.forEach(function (t) {
          t.destroy();
        }),
        t.off();
    }),
    (KD.prototype.onDestroyed = function (t, e) {
      var n = this;
      if (n.collections.indexOf(e) < 0) return !1;
      n.collections.splice(n.collections.indexOf(e), 1);
    });
  const ZD = new KD(),
    JD = function (t) {
      return ZD.create(t);
    };
  class $D extends qN {
    constructor(t) {
      super(t),
        (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (t) {
          return new rL(t);
        }),
        this.register(function (t) {
          return new cL(t);
        }),
        this.register(function (t) {
          return new dL(t);
        }),
        this.register(function (t) {
          return new oL(t);
        }),
        this.register(function (t) {
          return new aL(t);
        }),
        this.register(function (t) {
          return new lL(t);
        }),
        this.register(function (t) {
          return new hL(t);
        }),
        this.register(function (t) {
          return new iL(t);
        }),
        this.register(function (t) {
          return new uL(t);
        }),
        this.register(function (t) {
          return new sL(t);
        }),
        this.register(function (t) {
          return new eL(t);
        }),
        this.register(function (t) {
          return new pL(t);
        });
    }
    load(t, e, n, i) {
      const r = this;
      let s;
      (s =
        "" !== this.resourcePath
          ? this.resourcePath
          : "" !== this.path
          ? this.path
          : mD.extractUrlBase(t)),
        this.manager.itemStart(t);
      const o = function (e) {
          i ? i(e) : console.error(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t);
        },
        a = new JN(this.manager);
      a.setPath(this.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(
          t,
          function (n) {
            try {
              r.parse(
                n,
                s,
                function (n) {
                  e(n), r.manager.itemEnd(t);
                },
                o
              );
            } catch (i) {
              o(i);
            }
          },
          n,
          o
        );
    }
    setDRACOLoader(t) {
      return (this.dracoLoader = t), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(t) {
      return (this.ktx2Loader = t), this;
    }
    setMeshoptDecoder(t) {
      return (this.meshoptDecoder = t), this;
    }
    register(t) {
      return (
        -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
        this
      );
    }
    unregister(t) {
      return (
        -1 !== this.pluginCallbacks.indexOf(t) &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
        this
      );
    }
    parse(t, e, n, i) {
      let r;
      const s = {},
        o = {};
      if ("string" == typeof t) r = t;
      else {
        if (mD.decodeText(new Uint8Array(t, 0, 4)) === fL) {
          try {
            s[tL.KHR_BINARY_GLTF] = new gL(t);
          } catch (h) {
            return void (i && i(h));
          }
          r = s[tL.KHR_BINARY_GLTF].content;
        } else r = mD.decodeText(new Uint8Array(t));
      }
      const a = JSON.parse(r);
      if (void 0 === a.asset || a.asset.version[0] < 2)
        return void (
          i &&
          i(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          )
        );
      const l = new KL(a, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let u = 0; u < this.pluginCallbacks.length; u++) {
        const t = this.pluginCallbacks[u](l);
        (o[t.name] = t), (s[t.name] = !0);
      }
      if (a.extensionsUsed)
        for (let u = 0; u < a.extensionsUsed.length; ++u) {
          const t = a.extensionsUsed[u],
            e = a.extensionsRequired || [];
          switch (t) {
            case tL.KHR_MATERIALS_UNLIT:
              s[t] = new nL();
              break;
            case tL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              s[t] = new bL();
              break;
            case tL.KHR_DRACO_MESH_COMPRESSION:
              s[t] = new vL(a, this.dracoLoader);
              break;
            case tL.KHR_TEXTURE_TRANSFORM:
              s[t] = new yL();
              break;
            case tL.KHR_MESH_QUANTIZATION:
              s[t] = new TL();
              break;
            default:
              e.indexOf(t) >= 0 &&
                void 0 === o[t] &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + t + '".'
                );
          }
        }
      l.setExtensions(s), l.setPlugins(o), l.parse(n, i);
    }
    parseAsync(t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n.parse(t, e, i, r);
      });
    }
  }
  function QD() {
    let t = {};
    return {
      get: function (e) {
        return t[e];
      },
      add: function (e, n) {
        t[e] = n;
      },
      remove: function (e) {
        delete t[e];
      },
      removeAll: function () {
        t = {};
      },
    };
  }
  const tL = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
      "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  };
  class eL {
    constructor(t) {
      (this.parser = t),
        (this.name = tL.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    _markDefs() {
      const t = this.parser,
        e = this.parser.json.nodes || [];
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        i.extensions &&
          i.extensions[this.name] &&
          void 0 !== i.extensions[this.name].light &&
          t._addNodeRef(this.cache, i.extensions[this.name].light);
      }
    }
    _loadLight(t) {
      const e = this.parser,
        n = "light:" + t;
      let i = e.cache.get(n);
      if (i) return i;
      const r = e.json,
        s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[t];
      let o;
      const a = new DA(16777215);
      void 0 !== s.color && a.fromArray(s.color);
      const l = void 0 !== s.range ? s.range : 0;
      switch (s.type) {
        case "directional":
          (o = new pD(a)), o.target.position.set(0, 0, -1), o.add(o.target);
          break;
        case "point":
          (o = new cD(a)), (o.distance = l);
          break;
        case "spot":
          (o = new oD(a)),
            (o.distance = l),
            (s.spot = s.spot || {}),
            (s.spot.innerConeAngle =
              void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
            (s.spot.outerConeAngle =
              void 0 !== s.spot.outerConeAngle
                ? s.spot.outerConeAngle
                : Math.PI / 4),
            (o.angle = s.spot.outerConeAngle),
            (o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
            o.target.position.set(0, 0, -1),
            o.add(o.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
      }
      return (
        o.position.set(0, 0, 0),
        (o.decay = 2),
        void 0 !== s.intensity && (o.intensity = s.intensity),
        (o.name = e.createUniqueName(s.name || "light_" + t)),
        (i = Promise.resolve(o)),
        e.cache.add(n, i),
        i
      );
    }
    createNodeAttachment(t) {
      const e = this,
        n = this.parser,
        i = n.json.nodes[t],
        r = ((i.extensions && i.extensions[this.name]) || {}).light;
      return void 0 === r
        ? null
        : this._loadLight(r).then(function (t) {
            return n._getNodeRef(e.cache, r, t);
          });
    }
  }
  class nL {
    constructor() {
      this.name = tL.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return lC;
    }
    extendParams(t, e, n) {
      const i = [];
      (t.color = new DA(1, 1, 1)), (t.opacity = 1);
      const r = e.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const e = r.baseColorFactor;
          t.color.fromArray(e), (t.opacity = e[3]);
        }
        void 0 !== r.baseColorTexture &&
          i.push(n.assignTexture(t, "map", r.baseColorTexture, QM));
      }
      return Promise.all(i);
    }
  }
  class iL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_EMISSIVE_STRENGTH);
    }
    extendMaterialParams(t, e) {
      const n = this.parser.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = n.extensions[this.name].emissiveStrength;
      return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve();
    }
  }
  class rL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_CLEARCOAT);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      if (
        (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
        void 0 !== s.clearcoatTexture &&
          r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
        void 0 !== s.clearcoatRoughnessFactor &&
          (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
        void 0 !== s.clearcoatRoughnessTexture &&
          r.push(
            n.assignTexture(
              e,
              "clearcoatRoughnessMap",
              s.clearcoatRoughnessTexture
            )
          ),
        void 0 !== s.clearcoatNormalTexture &&
          (r.push(
            n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)
          ),
          void 0 !== s.clearcoatNormalTexture.scale))
      ) {
        const t = s.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new xA(t, t);
      }
      return Promise.all(r);
    }
  }
  class sL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_IRIDESCENCE);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor),
        void 0 !== s.iridescenceTexture &&
          r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)),
        void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor),
        void 0 === e.iridescenceThicknessRange &&
          (e.iridescenceThicknessRange = [100, 400]),
        void 0 !== s.iridescenceThicknessMinimum &&
          (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
        void 0 !== s.iridescenceThicknessMaximum &&
          (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
        void 0 !== s.iridescenceThicknessTexture &&
          r.push(
            n.assignTexture(
              e,
              "iridescenceThicknessMap",
              s.iridescenceThicknessTexture
            )
          ),
        Promise.all(r)
      );
    }
  }
  class oL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_SHEEN);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [];
      (e.sheenColor = new DA(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1);
      const s = i.extensions[this.name];
      return (
        void 0 !== s.sheenColorFactor &&
          e.sheenColor.fromArray(s.sheenColorFactor),
        void 0 !== s.sheenRoughnessFactor &&
          (e.sheenRoughness = s.sheenRoughnessFactor),
        void 0 !== s.sheenColorTexture &&
          r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, QM)),
        void 0 !== s.sheenRoughnessTexture &&
          r.push(
            n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)
          ),
        Promise.all(r)
      );
    }
  }
  class aL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_TRANSMISSION);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        void 0 !== s.transmissionFactor &&
          (e.transmission = s.transmissionFactor),
        void 0 !== s.transmissionTexture &&
          r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
        Promise.all(r)
      );
    }
  }
  class lL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_VOLUME);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      (e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
        void 0 !== s.thicknessTexture &&
          r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
        (e.attenuationDistance = s.attenuationDistance || 0);
      const o = s.attenuationColor || [1, 1, 1];
      return (e.attenuationColor = new DA(o[0], o[1], o[2])), Promise.all(r);
    }
  }
  class hL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_IOR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = n.extensions[this.name];
      return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
    }
  }
  class uL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_MATERIALS_SPECULAR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? EN : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      (e.specularIntensity =
        void 0 !== s.specularFactor ? s.specularFactor : 1),
        void 0 !== s.specularTexture &&
          r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
      const o = s.specularColorFactor || [1, 1, 1];
      return (
        (e.specularColor = new DA(o[0], o[1], o[2])),
        void 0 !== s.specularColorTexture &&
          r.push(
            n.assignTexture(e, "specularColorMap", s.specularColorTexture, QM)
          ),
        Promise.all(r)
      );
    }
  }
  class cL {
    constructor(t) {
      (this.parser = t), (this.name = tL.KHR_TEXTURE_BASISU);
    }
    loadTexture(t) {
      const e = this.parser,
        n = e.json,
        i = n.textures[t];
      if (!i.extensions || !i.extensions[this.name]) return null;
      const r = i.extensions[this.name],
        s = e.options.ktx2Loader;
      if (!s) {
        if (
          n.extensionsRequired &&
          n.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
          );
        return null;
      }
      return e.loadTextureImage(t, r.source, s);
    }
  }
  class dL {
    constructor(t) {
      (this.parser = t),
        (this.name = tL.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    loadTexture(t) {
      const e = this.name,
        n = this.parser,
        i = n.json,
        r = i.textures[t];
      if (!r.extensions || !r.extensions[e]) return null;
      const s = r.extensions[e],
        o = i.images[s.source];
      let a = n.textureLoader;
      if (o.uri) {
        const t = n.options.manager.getHandler(o.uri);
        null !== t && (a = t);
      }
      return this.detectSupport().then(function (r) {
        if (r) return n.loadTextureImage(t, s.source, a);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported."
          );
        return n.loadTexture(t);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (t) {
            const e = new Image();
            (e.src =
              "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
              (e.onload = e.onerror =
                function () {
                  t(1 === e.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class pL {
    constructor(t) {
      (this.name = tL.EXT_MESHOPT_COMPRESSION), (this.parser = t);
    }
    loadBufferView(t) {
      const e = this.parser.json,
        n = e.bufferViews[t];
      if (n.extensions && n.extensions[this.name]) {
        const t = n.extensions[this.name],
          i = this.parser.getDependency("buffer", t.buffer),
          r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (
            e.extensionsRequired &&
            e.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
            );
          return null;
        }
        return Promise.all([i, r.ready]).then(function (e) {
          const n = t.byteOffset || 0,
            i = t.byteLength || 0,
            s = t.count,
            o = t.byteStride,
            a = new ArrayBuffer(s * o),
            l = new Uint8Array(e[0], n, i);
          return (
            r.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter), a
          );
        });
      }
      return null;
    }
  }
  const fL = "glTF",
    mL = 1313821514,
    _L = 5130562;
  class gL {
    constructor(t) {
      (this.name = tL.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      const e = new DataView(t, 0, 12);
      if (
        ((this.header = {
          magic: mD.decodeText(new Uint8Array(t.slice(0, 4))),
          version: e.getUint32(4, !0),
          length: e.getUint32(8, !0),
        }),
        this.header.magic !== fL)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n = this.header.length - 12,
        i = new DataView(t, 12);
      let r = 0;
      for (; r < n; ) {
        const e = i.getUint32(r, !0);
        r += 4;
        const n = i.getUint32(r, !0);
        if (((r += 4), n === mL)) {
          const n = new Uint8Array(t, 12 + r, e);
          this.content = mD.decodeText(n);
        } else if (n === _L) {
          const n = 12 + r;
          this.body = t.slice(n, n + e);
        }
        r += e;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class vL {
    constructor(t, e) {
      if (!e)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = tL.KHR_DRACO_MESH_COMPRESSION),
        (this.json = t),
        (this.dracoLoader = e),
        this.dracoLoader.preload();
    }
    decodePrimitive(t, e) {
      const n = this.json,
        i = this.dracoLoader,
        r = t.extensions[this.name].bufferView,
        s = t.extensions[this.name].attributes,
        o = {},
        a = {},
        l = {};
      for (const h in s) {
        const t = UL[h] || h.toLowerCase();
        o[t] = s[h];
      }
      for (const h in t.attributes) {
        const e = UL[h] || h.toLowerCase();
        if (void 0 !== s[h]) {
          const i = n.accessors[t.attributes[h]],
            r = NL[i.componentType];
          (l[e] = r), (a[e] = !0 === i.normalized);
        }
      }
      return e.getDependency("bufferView", r).then(function (t) {
        return new Promise(function (e) {
          i.decodeDracoFile(
            t,
            function (t) {
              for (const e in t.attributes) {
                const n = t.attributes[e],
                  i = a[e];
                void 0 !== i && (n.normalized = i);
              }
              e(t);
            },
            o,
            l
          );
        });
      });
    }
  }
  class yL {
    constructor() {
      this.name = tL.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t, e) {
      return (
        void 0 !== e.texCoord &&
          console.warn(
            'THREE.GLTFLoader: Custom UV sets in "' +
              this.name +
              '" extension not yet supported.'
          ),
        (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) ||
          ((t = t.clone()),
          void 0 !== e.offset && t.offset.fromArray(e.offset),
          void 0 !== e.rotation && (t.rotation = e.rotation),
          void 0 !== e.scale && t.repeat.fromArray(e.scale),
          (t.needsUpdate = !0)),
        t
      );
    }
  }
  class xL extends TN {
    constructor(t) {
      super(), (this.isGLTFSpecularGlossinessMaterial = !0);
      const e = [
          "#ifdef USE_SPECULARMAP",
          "\tuniform sampler2D specularMap;",
          "#endif",
        ].join("\n"),
        n = [
          "#ifdef USE_GLOSSINESSMAP",
          "\tuniform sampler2D glossinessMap;",
          "#endif",
        ].join("\n"),
        i = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
          "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tspecularFactor *= texelSpecular.rgb;",
          "#endif",
        ].join("\n"),
        r = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tglossinessFactor *= texelGlossiness.a;",
          "#endif",
        ].join("\n"),
        s = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.roughness += geometryRoughness;",
          "material.roughness = min( material.roughness, 1.0 );",
          "material.specularColor = specularFactor;",
        ].join("\n"),
        o = {
          specular: { value: new DA().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null },
        };
      (this._extraUniforms = o),
        (this.onBeforeCompile = function (t) {
          for (const e in o) t.uniforms[e] = o[e];
          t.fragmentShader = t.fragmentShader
            .replace("uniform float roughness;", "uniform vec3 specular;")
            .replace("uniform float metalness;", "uniform float glossiness;")
            .replace("#include <roughnessmap_pars_fragment>", e)
            .replace("#include <metalnessmap_pars_fragment>", n)
            .replace("#include <roughnessmap_fragment>", i)
            .replace("#include <metalnessmap_fragment>", r)
            .replace("#include <lights_physical_fragment>", s);
        }),
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return o.specular.value;
            },
            set: function (t) {
              o.specular.value = t;
            },
          },
          specularMap: {
            get: function () {
              return o.specularMap.value;
            },
            set: function (t) {
              (o.specularMap.value = t),
                t
                  ? (this.defines.USE_SPECULARMAP = "")
                  : delete this.defines.USE_SPECULARMAP;
            },
          },
          glossiness: {
            get: function () {
              return o.glossiness.value;
            },
            set: function (t) {
              o.glossiness.value = t;
            },
          },
          glossinessMap: {
            get: function () {
              return o.glossinessMap.value;
            },
            set: function (t) {
              (o.glossinessMap.value = t),
                t
                  ? ((this.defines.USE_GLOSSINESSMAP = ""),
                    (this.defines.USE_UV = ""))
                  : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV);
            },
          },
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.specularMap = t.specularMap),
        this.specular.copy(t.specular),
        (this.glossinessMap = t.glossinessMap),
        (this.glossiness = t.glossiness),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
      );
    }
  }
  class bL {
    constructor() {
      (this.name = tL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
        (this.specularGlossinessParams = [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
        ]);
    }
    getMaterialType() {
      return xL;
    }
    extendParams(t, e, n) {
      const i = e.extensions[this.name];
      (t.color = new DA(1, 1, 1)), (t.opacity = 1);
      const r = [];
      if (Array.isArray(i.diffuseFactor)) {
        const e = i.diffuseFactor;
        t.color.fromArray(e), (t.opacity = e[3]);
      }
      if (
        (void 0 !== i.diffuseTexture &&
          r.push(n.assignTexture(t, "map", i.diffuseTexture, QM)),
        (t.emissive = new DA(0, 0, 0)),
        (t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
        (t.specular = new DA(1, 1, 1)),
        Array.isArray(i.specularFactor) &&
          t.specular.fromArray(i.specularFactor),
        void 0 !== i.specularGlossinessTexture)
      ) {
        const e = i.specularGlossinessTexture;
        r.push(n.assignTexture(t, "glossinessMap", e)),
          r.push(n.assignTexture(t, "specularMap", e, QM));
      }
      return Promise.all(r);
    }
    createMaterial(t) {
      const e = new xL(t);
      return (
        (e.fog = !0),
        (e.color = t.color),
        (e.map = void 0 === t.map ? null : t.map),
        (e.lightMap = null),
        (e.lightMapIntensity = 1),
        (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
        (e.aoMapIntensity = 1),
        (e.emissive = t.emissive),
        (e.emissiveIntensity =
          void 0 === t.emissiveIntensity ? 1 : t.emissiveIntensity),
        (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
        (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
        (e.bumpScale = 1),
        (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
        (e.normalMapType = 0),
        t.normalScale && (e.normalScale = t.normalScale),
        (e.displacementMap = null),
        (e.displacementScale = 1),
        (e.displacementBias = 0),
        (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
        (e.specular = t.specular),
        (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
        (e.glossiness = t.glossiness),
        (e.alphaMap = null),
        (e.envMap = void 0 === t.envMap ? null : t.envMap),
        (e.envMapIntensity = 1),
        e
      );
    }
  }
  class TL {
    constructor() {
      this.name = tL.KHR_MESH_QUANTIZATION;
    }
  }
  class EL extends PN {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i * 3 + i;
      for (let s = 0; s !== i; s++) e[s] = n[r + s];
      return e;
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize,
        a = 2 * o,
        l = 3 * o,
        h = i - e,
        u = (n - e) / h,
        c = u * u,
        d = c * u,
        p = t * l,
        f = p - l,
        m = -2 * d + 3 * c,
        _ = d - c,
        g = 1 - m,
        v = _ - c + u;
      for (let y = 0; y !== o; y++) {
        const t = s[f + y + o],
          e = s[f + y + a] * h,
          n = s[p + y + o],
          i = s[p + y] * h;
        r[y] = g * t + v * e + m * n + _ * i;
      }
      return r;
    }
  }
  const SL = new WA();
  class wL extends EL {
    interpolate_(t, e, n, i) {
      const r = super.interpolate_(t, e, n, i);
      return SL.fromArray(r).normalize().toArray(r), r;
    }
  }
  const ML = 0,
    AL = 1,
    RL = 2,
    CL = 3,
    IL = 4,
    PL = 5,
    OL = 6,
    NL = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    DL = { 9728: OM, 9729: LM, 9984: NM, 9985: 1007, 9986: DM, 9987: FM },
    LL = { 33071: IM, 33648: PM, 10497: CM },
    FL = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    UL = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    BL = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    kL = { CUBICSPLINE: void 0, LINEAR: ZM, STEP: KM },
    GL = "OPAQUE",
    HL = "MASK",
    zL = "BLEND";
  function VL(t, e, n) {
    for (const i in n.extensions)
      void 0 === t[i] &&
        ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
        (e.userData.gltfExtensions[i] = n.extensions[i]));
  }
  function XL(t, e) {
    void 0 !== e.extras &&
      ("object" == typeof e.extras
        ? Object.assign(t.userData, e.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
          ));
  }
  function WL(t, e) {
    if ((t.updateMorphTargets(), void 0 !== e.weights))
      for (let n = 0, i = e.weights.length; n < i; n++)
        t.morphTargetInfluences[n] = e.weights[n];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const n = e.extras.targetNames;
      if (t.morphTargetInfluences.length === n.length) {
        t.morphTargetDictionary = {};
        for (let e = 0, i = n.length; e < i; e++)
          t.morphTargetDictionary[n[e]] = e;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function jL(t) {
    const e = t.extensions && t.extensions[tL.KHR_DRACO_MESH_COMPRESSION];
    let n;
    return (
      (n = e
        ? "draco:" + e.bufferView + ":" + e.indices + ":" + YL(e.attributes)
        : t.indices + ":" + YL(t.attributes) + ":" + t.mode),
      n
    );
  }
  function YL(t) {
    let e = "";
    const n = Object.keys(t).sort();
    for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
    return e;
  }
  function qL(t) {
    switch (t) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  class KL {
    constructor(t = {}, e = {}) {
      (this.json = t),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = e),
        (this.cache = new QD()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.sourceCache = {}),
        (this.textureCache = {}),
        (this.nodeNamesUsed = {});
      const n =
          !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        i = navigator.userAgent.indexOf("Firefox") > -1,
        r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || n || (i && r < 98)
        ? (this.textureLoader = new QN(this.options.manager))
        : (this.textureLoader = new _D(this.options.manager)),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        (this.fileLoader = new JN(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(t) {
      this.extensions = t;
    }
    setPlugins(t) {
      this.plugins = t;
    }
    parse(t, e) {
      const n = this,
        i = this.json,
        r = this.extensions;
      this.cache.removeAll(),
        this._invokeAll(function (t) {
          return t._markDefs && t._markDefs();
        }),
        Promise.all(
          this._invokeAll(function (t) {
            return t.beforeRoot && t.beforeRoot();
          })
        )
          .then(function () {
            return Promise.all([
              n.getDependencies("scene"),
              n.getDependencies("animation"),
              n.getDependencies("camera"),
            ]);
          })
          .then(function (e) {
            const s = {
              scene: e[0][i.scene || 0],
              scenes: e[0],
              animations: e[1],
              cameras: e[2],
              asset: i.asset,
              parser: n,
              userData: {},
            };
            VL(r, s, i),
              XL(s, i),
              Promise.all(
                n._invokeAll(function (t) {
                  return t.afterRoot && t.afterRoot(s);
                })
              ).then(function () {
                t(s);
              });
          })
          .catch(e);
    }
    _markDefs() {
      const t = this.json.nodes || [],
        e = this.json.skins || [],
        n = this.json.meshes || [];
      for (let i = 0, r = e.length; i < r; i++) {
        const n = e[i].joints;
        for (let e = 0, i = n.length; e < i; e++) t[n[e]].isBone = !0;
      }
      for (let i = 0, r = t.length; i < r; i++) {
        const e = t[i];
        void 0 !== e.mesh &&
          (this._addNodeRef(this.meshCache, e.mesh),
          void 0 !== e.skin && (n[e.mesh].isSkinnedMesh = !0)),
          void 0 !== e.camera && this._addNodeRef(this.cameraCache, e.camera);
      }
    }
    _addNodeRef(t, e) {
      void 0 !== e &&
        (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
    }
    _getNodeRef(t, e, n) {
      if (t.refs[e] <= 1) return n;
      const i = n.clone(),
        r = (t, e) => {
          const n = this.associations.get(t);
          null != n && this.associations.set(e, n);
          for (const [i, s] of t.children.entries()) r(s, e.children[i]);
        };
      return r(n, i), (i.name += "_instance_" + t.uses[e]++), i;
    }
    _invokeOne(t) {
      const e = Object.values(this.plugins);
      e.push(this);
      for (let n = 0; n < e.length; n++) {
        const i = t(e[n]);
        if (i) return i;
      }
      return null;
    }
    _invokeAll(t) {
      const e = Object.values(this.plugins);
      e.unshift(this);
      const n = [];
      for (let i = 0; i < e.length; i++) {
        const r = t(e[i]);
        r && n.push(r);
      }
      return n;
    }
    getDependency(t, e) {
      const n = t + ":" + e;
      let i = this.cache.get(n);
      if (!i) {
        switch (t) {
          case "scene":
            i = this.loadScene(e);
            break;
          case "node":
            i = this.loadNode(e);
            break;
          case "mesh":
            i = this._invokeOne(function (t) {
              return t.loadMesh && t.loadMesh(e);
            });
            break;
          case "accessor":
            i = this.loadAccessor(e);
            break;
          case "bufferView":
            i = this._invokeOne(function (t) {
              return t.loadBufferView && t.loadBufferView(e);
            });
            break;
          case "buffer":
            i = this.loadBuffer(e);
            break;
          case "material":
            i = this._invokeOne(function (t) {
              return t.loadMaterial && t.loadMaterial(e);
            });
            break;
          case "texture":
            i = this._invokeOne(function (t) {
              return t.loadTexture && t.loadTexture(e);
            });
            break;
          case "skin":
            i = this.loadSkin(e);
            break;
          case "animation":
            i = this._invokeOne(function (t) {
              return t.loadAnimation && t.loadAnimation(e);
            });
            break;
          case "camera":
            i = this.loadCamera(e);
            break;
          default:
            throw new Error("Unknown type: " + t);
        }
        this.cache.add(n, i);
      }
      return i;
    }
    getDependencies(t) {
      let e = this.cache.get(t);
      if (!e) {
        const n = this,
          i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
        (e = Promise.all(
          i.map(function (e, i) {
            return n.getDependency(t, i);
          })
        )),
          this.cache.add(t, e);
      }
      return e;
    }
    loadBuffer(t) {
      const e = this.json.buffers[t],
        n = this.fileLoader;
      if (e.type && "arraybuffer" !== e.type)
        throw new Error(
          "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
        );
      if (void 0 === e.uri && 0 === t)
        return Promise.resolve(this.extensions[tL.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function (t, r) {
        n.load(mD.resolveURL(e.uri, i.path), t, void 0, function () {
          r(
            new Error(
              'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
            )
          );
        });
      });
    }
    loadBufferView(t) {
      const e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then(function (t) {
        const n = e.byteLength || 0,
          i = e.byteOffset || 0;
        return t.slice(i, i + n);
      });
    }
    loadAccessor(t) {
      const e = this,
        n = this.json,
        i = this.json.accessors[t];
      if (void 0 === i.bufferView && void 0 === i.sparse)
        return Promise.resolve(null);
      const r = [];
      return (
        void 0 !== i.bufferView
          ? r.push(this.getDependency("bufferView", i.bufferView))
          : r.push(null),
        void 0 !== i.sparse &&
          (r.push(
            this.getDependency("bufferView", i.sparse.indices.bufferView)
          ),
          r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(r).then(function (t) {
          const r = t[0],
            s = FL[i.type],
            o = NL[i.componentType],
            a = o.BYTES_PER_ELEMENT,
            l = a * s,
            h = i.byteOffset || 0,
            u =
              void 0 !== i.bufferView
                ? n.bufferViews[i.bufferView].byteStride
                : void 0,
            c = !0 === i.normalized;
          let d, p;
          if (u && u !== l) {
            const t = Math.floor(h / u),
              n =
                "InterleavedBuffer:" +
                i.bufferView +
                ":" +
                i.componentType +
                ":" +
                t +
                ":" +
                i.count;
            let l = e.cache.get(n);
            l ||
              ((d = new o(r, t * u, (i.count * u) / a)),
              (l = new VO(d, u / a)),
              e.cache.add(n, l)),
              (p = new WO(l, s, (h % u) / a, c));
          } else (d = null === r ? new o(i.count * s) : new o(r, h, i.count * s)), (p = new cC(d, s, c));
          if (void 0 !== i.sparse) {
            const e = FL.SCALAR,
              n = NL[i.sparse.indices.componentType],
              a = i.sparse.indices.byteOffset || 0,
              l = i.sparse.values.byteOffset || 0,
              h = new n(t[1], a, i.sparse.count * e),
              u = new o(t[2], l, i.sparse.count * s);
            null !== r &&
              (p = new cC(p.array.slice(), p.itemSize, p.normalized));
            for (let t = 0, i = h.length; t < i; t++) {
              const e = h[t];
              if (
                (p.setX(e, u[t * s]),
                s >= 2 && p.setY(e, u[t * s + 1]),
                s >= 3 && p.setZ(e, u[t * s + 2]),
                s >= 4 && p.setW(e, u[t * s + 3]),
                s >= 5)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                );
            }
          }
          return p;
        })
      );
    }
    loadTexture(t) {
      const e = this.json,
        n = this.options,
        i = e.textures[t].source,
        r = e.images[i];
      let s = this.textureLoader;
      if (r.uri) {
        const t = n.manager.getHandler(r.uri);
        null !== t && (s = t);
      }
      return this.loadTextureImage(t, i, s);
    }
    loadTextureImage(t, e, n) {
      const i = this,
        r = this.json,
        s = r.textures[t],
        o = r.images[e],
        a = (o.uri || o.bufferView) + ":" + s.sampler;
      if (this.textureCache[a]) return this.textureCache[a];
      const l = this.loadImageSource(e, n)
        .then(function (e) {
          (e.flipY = !1), s.name && (e.name = s.name);
          const n = (r.samplers || {})[s.sampler] || {};
          return (
            (e.magFilter = DL[n.magFilter] || LM),
            (e.minFilter = DL[n.minFilter] || FM),
            (e.wrapS = LL[n.wrapS] || CM),
            (e.wrapT = LL[n.wrapT] || CM),
            i.associations.set(e, { textures: t }),
            e
          );
        })
        .catch(function () {
          return null;
        });
      return (this.textureCache[a] = l), l;
    }
    loadImageSource(t, e) {
      const n = this,
        i = this.json,
        r = this.options;
      if (void 0 !== this.sourceCache[t])
        return this.sourceCache[t].then((t) => t.clone());
      const s = i.images[t],
        o = self.URL || self.webkitURL;
      let a = s.uri || "",
        l = !1;
      if (void 0 !== s.bufferView)
        a = n.getDependency("bufferView", s.bufferView).then(function (t) {
          l = !0;
          const e = new Blob([t], { type: s.mimeType });
          return (a = o.createObjectURL(e)), a;
        });
      else if (void 0 === s.uri)
        throw new Error(
          "THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"
        );
      const h = Promise.resolve(a)
        .then(function (t) {
          return new Promise(function (n, i) {
            let s = n;
            !0 === e.isImageBitmapLoader &&
              (s = function (t) {
                const e = new GA(t);
                (e.needsUpdate = !0), n(e);
              }),
              e.load(mD.resolveURL(t, r.path), s, void 0, i);
          });
        })
        .then(function (t) {
          var e;
          return (
            !0 === l && o.revokeObjectURL(a),
            (t.userData.mimeType =
              s.mimeType ||
              ((e = s.uri).search(/\.jpe?g($|\?)/i) > 0 ||
              0 === e.search(/^data\:image\/jpeg/)
                ? "image/jpeg"
                : e.search(/\.webp($|\?)/i) > 0 ||
                  0 === e.search(/^data\:image\/webp/)
                ? "image/webp"
                : "image/png")),
            t
          );
        })
        .catch(function (t) {
          throw (
            (console.error("THREE.GLTFLoader: Couldn't load texture", a), t)
          );
        });
      return (this.sourceCache[t] = h), h;
    }
    assignTexture(t, e, n, i) {
      const r = this;
      return this.getDependency("texture", n.index).then(function (s) {
        if (
          (void 0 === n.texCoord ||
            0 == n.texCoord ||
            ("aoMap" === e && 1 == n.texCoord) ||
            console.warn(
              "THREE.GLTFLoader: Custom UV set " +
                n.texCoord +
                " for texture " +
                e +
                " not yet supported."
            ),
          r.extensions[tL.KHR_TEXTURE_TRANSFORM])
        ) {
          const t =
            void 0 !== n.extensions
              ? n.extensions[tL.KHR_TEXTURE_TRANSFORM]
              : void 0;
          if (t) {
            const e = r.associations.get(s);
            (s = r.extensions[tL.KHR_TEXTURE_TRANSFORM].extendTexture(s, t)),
              r.associations.set(s, e);
          }
        }
        return void 0 !== i && (s.encoding = i), (t[e] = s), s;
      });
    }
    assignFinalMaterial(t) {
      const e = t.geometry;
      let n = t.material;
      const i = void 0 === e.attributes.tangent,
        r = void 0 !== e.attributes.color,
        s = void 0 === e.attributes.normal;
      if (t.isPoints) {
        const t = "PointsMaterial:" + n.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new fN()),
          aC.prototype.copy.call(e, n),
          e.color.copy(n.color),
          (e.map = n.map),
          (e.sizeAttenuation = !1),
          this.cache.add(t, e)),
          (n = e);
      } else if (t.isLine) {
        const t = "LineBasicMaterial:" + n.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new iN()),
          aC.prototype.copy.call(e, n),
          e.color.copy(n.color),
          this.cache.add(t, e)),
          (n = e);
      }
      if (i || r || s) {
        let t = "ClonedMaterial:" + n.uuid + ":";
        n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
          i && (t += "derivative-tangents:"),
          r && (t += "vertex-colors:"),
          s && (t += "flat-shading:");
        let e = this.cache.get(t);
        e ||
          ((e = n.clone()),
          r && (e.vertexColors = !0),
          s && (e.flatShading = !0),
          i &&
            (e.normalScale && (e.normalScale.y *= -1),
            e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
          this.cache.add(t, e),
          this.associations.set(e, this.associations.get(n))),
          (n = e);
      }
      n.aoMap &&
        void 0 === e.attributes.uv2 &&
        void 0 !== e.attributes.uv &&
        e.setAttribute("uv2", e.attributes.uv),
        (t.material = n);
    }
    getMaterialType() {
      return TN;
    }
    loadMaterial(t) {
      const e = this,
        n = this.json,
        i = this.extensions,
        r = n.materials[t];
      let s;
      const o = {},
        a = r.extensions || {},
        l = [];
      if (a[tL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const t = i[tL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        (s = t.getMaterialType()), l.push(t.extendParams(o, r, e));
      } else if (a[tL.KHR_MATERIALS_UNLIT]) {
        const t = i[tL.KHR_MATERIALS_UNLIT];
        (s = t.getMaterialType()), l.push(t.extendParams(o, r, e));
      } else {
        const n = r.pbrMetallicRoughness || {};
        if (
          ((o.color = new DA(1, 1, 1)),
          (o.opacity = 1),
          Array.isArray(n.baseColorFactor))
        ) {
          const t = n.baseColorFactor;
          o.color.fromArray(t), (o.opacity = t[3]);
        }
        void 0 !== n.baseColorTexture &&
          l.push(e.assignTexture(o, "map", n.baseColorTexture, QM)),
          (o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
          (o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
          void 0 !== n.metallicRoughnessTexture &&
            (l.push(
              e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)
            ),
            l.push(
              e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture)
            )),
          (s = this._invokeOne(function (e) {
            return e.getMaterialType && e.getMaterialType(t);
          })),
          l.push(
            Promise.all(
              this._invokeAll(function (e) {
                return e.extendMaterialParams && e.extendMaterialParams(t, o);
              })
            )
          );
      }
      !0 === r.doubleSided && (o.side = 2);
      const h = r.alphaMode || GL;
      if (
        (h === zL
          ? ((o.transparent = !0), (o.depthWrite = !1))
          : ((o.transparent = !1),
            h === HL &&
              (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
        void 0 !== r.normalTexture &&
          s !== lC &&
          (l.push(e.assignTexture(o, "normalMap", r.normalTexture)),
          (o.normalScale = new xA(1, 1)),
          void 0 !== r.normalTexture.scale))
      ) {
        const t = r.normalTexture.scale;
        o.normalScale.set(t, t);
      }
      return (
        void 0 !== r.occlusionTexture &&
          s !== lC &&
          (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)),
          void 0 !== r.occlusionTexture.strength &&
            (o.aoMapIntensity = r.occlusionTexture.strength)),
        void 0 !== r.emissiveFactor &&
          s !== lC &&
          (o.emissive = new DA().fromArray(r.emissiveFactor)),
        void 0 !== r.emissiveTexture &&
          s !== lC &&
          l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, QM)),
        Promise.all(l).then(function () {
          let n;
          return (
            (n =
              s === xL
                ? i[tL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o)
                : new s(o)),
            r.name && (n.name = r.name),
            XL(n, r),
            e.associations.set(n, { materials: t }),
            r.extensions && VL(i, n, r),
            n
          );
        })
      );
    }
    createUniqueName(t) {
      const e = wD.sanitizeNodeName(t || "");
      let n = e;
      for (let i = 1; this.nodeNamesUsed[n]; ++i) n = e + "_" + i;
      return (this.nodeNamesUsed[n] = !0), n;
    }
    loadGeometries(t) {
      const e = this,
        n = this.extensions,
        i = this.primitiveCache;
      function r(t) {
        return n[tL.KHR_DRACO_MESH_COMPRESSION]
          .decodePrimitive(t, e)
          .then(function (n) {
            return JL(n, t, e);
          });
      }
      const s = [];
      for (let o = 0, a = t.length; o < a; o++) {
        const n = t[o],
          a = jL(n),
          l = i[a];
        if (l) s.push(l.promise);
        else {
          let t;
          (t =
            n.extensions && n.extensions[tL.KHR_DRACO_MESH_COMPRESSION]
              ? r(n)
              : JL(new TC(), n, e)),
            (i[a] = { primitive: n, promise: t }),
            s.push(t);
        }
      }
      return Promise.all(s);
    }
    loadMesh(t) {
      const e = this,
        n = this.json,
        i = this.extensions,
        r = n.meshes[t],
        s = r.primitives,
        o = [];
      for (let l = 0, h = s.length; l < h; l++) {
        const t =
          void 0 === s[l].material
            ? (void 0 === (a = this.cache).DefaultMaterial &&
                (a.DefaultMaterial = new TN({
                  color: 16777215,
                  emissive: 0,
                  metalness: 1,
                  roughness: 1,
                  transparent: !1,
                  depthTest: !0,
                  side: 0,
                })),
              a.DefaultMaterial)
            : this.getDependency("material", s[l].material);
        o.push(t);
      }
      var a;
      return (
        o.push(e.loadGeometries(s)),
        Promise.all(o).then(function (n) {
          const o = n.slice(0, n.length - 1),
            a = n[n.length - 1],
            l = [];
          for (let u = 0, c = a.length; u < c; u++) {
            const n = a[u],
              h = s[u];
            let c;
            const d = o[u];
            if (
              h.mode === IL ||
              h.mode === PL ||
              h.mode === OL ||
              void 0 === h.mode
            )
              (c = !0 === r.isSkinnedMesh ? new JO(n, d) : new GC(n, d)),
                !0 !== c.isSkinnedMesh ||
                  c.geometry.attributes.skinWeight.normalized ||
                  c.normalizeSkinWeights(),
                h.mode === PL
                  ? (c.geometry = $L(c.geometry, 1))
                  : h.mode === OL && (c.geometry = $L(c.geometry, 2));
            else if (h.mode === AL) c = new dN(n, d);
            else if (h.mode === CL) c = new hN(n, d);
            else if (h.mode === RL) c = new pN(n, d);
            else {
              if (h.mode !== ML)
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
                );
              c = new yN(n, d);
            }
            Object.keys(c.geometry.morphAttributes).length > 0 && WL(c, r),
              (c.name = e.createUniqueName(r.name || "mesh_" + t)),
              XL(c, r),
              h.extensions && VL(i, c, h),
              e.assignFinalMaterial(c),
              l.push(c);
          }
          for (let i = 0, r = l.length; i < r; i++)
            e.associations.set(l[i], { meshes: t, primitives: i });
          if (1 === l.length) return l[0];
          const h = new NO();
          e.associations.set(h, { meshes: t });
          for (let t = 0, e = l.length; t < e; t++) h.add(l[t]);
          return h;
        })
      );
    }
    loadCamera(t) {
      let e;
      const n = this.json.cameras[t],
        i = n[n.type];
      if (i)
        return (
          "perspective" === n.type
            ? (e = new qC(
                yA.radToDeg(i.yfov),
                i.aspectRatio || 1,
                i.znear || 1,
                i.zfar || 2e6
              ))
            : "orthographic" === n.type &&
              (e = new vI(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
          n.name && (e.name = this.createUniqueName(n.name)),
          XL(e, n),
          Promise.resolve(e)
        );
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(t) {
      const e = this.json.skins[t],
        n = { joints: e.joints };
      return void 0 === e.inverseBindMatrices
        ? Promise.resolve(n)
        : this.getDependency("accessor", e.inverseBindMatrices).then(function (
            t
          ) {
            return (n.inverseBindMatrices = t), n;
          });
    }
    loadAnimation(t) {
      const e = this.json.animations[t],
        n = [],
        i = [],
        r = [],
        s = [],
        o = [];
      for (let a = 0, l = e.channels.length; a < l; a++) {
        const t = e.channels[a],
          l = e.samplers[t.sampler],
          h = t.target,
          u = void 0 !== h.node ? h.node : h.id,
          c = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
          d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
        n.push(this.getDependency("node", u)),
          i.push(this.getDependency("accessor", c)),
          r.push(this.getDependency("accessor", d)),
          s.push(l),
          o.push(h);
      }
      return Promise.all([
        Promise.all(n),
        Promise.all(i),
        Promise.all(r),
        Promise.all(s),
        Promise.all(o),
      ]).then(function (n) {
        const i = n[0],
          r = n[1],
          s = n[2],
          o = n[3],
          a = n[4],
          l = [];
        for (let t = 0, e = i.length; t < e; t++) {
          const e = i[t],
            n = r[t],
            h = s[t],
            u = o[t],
            c = a[t];
          if (void 0 === e) continue;
          let d;
          switch ((e.updateMatrix(), BL[c.path])) {
            case BL.weights:
              d = BN;
              break;
            case BL.rotation:
              d = GN;
              break;
            default:
              d = zN;
          }
          const p = e.name ? e.name : e.uuid,
            f = void 0 !== u.interpolation ? kL[u.interpolation] : ZM,
            m = [];
          BL[c.path] === BL.weights
            ? e.traverse(function (t) {
                t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid);
              })
            : m.push(p);
          let _ = h.array;
          if (h.normalized) {
            const t = qL(_.constructor),
              e = new Float32Array(_.length);
            for (let n = 0, i = _.length; n < i; n++) e[n] = _[n] * t;
            _ = e;
          }
          for (let t = 0, i = m.length; t < i; t++) {
            const e = new d(m[t] + "." + BL[c.path], n.array, _, f);
            "CUBICSPLINE" === u.interpolation &&
              ((e.createInterpolant = function (t) {
                return new (this instanceof GN ? wL : EL)(
                  this.times,
                  this.values,
                  this.getValueSize() / 3,
                  t
                );
              }),
              (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                !0)),
              l.push(e);
          }
        }
        const h = e.name ? e.name : "animation_" + t;
        return new VN(h, void 0, l);
      });
    }
    createNodeMesh(t) {
      const e = this.json,
        n = this,
        i = e.nodes[t];
      return void 0 === i.mesh
        ? null
        : n.getDependency("mesh", i.mesh).then(function (t) {
            const e = n._getNodeRef(n.meshCache, i.mesh, t);
            return (
              void 0 !== i.weights &&
                e.traverse(function (t) {
                  if (t.isMesh)
                    for (let e = 0, n = i.weights.length; e < n; e++)
                      t.morphTargetInfluences[e] = i.weights[e];
                }),
              e
            );
          });
    }
    loadNode(t) {
      const e = this.json,
        n = this.extensions,
        i = this,
        r = e.nodes[t],
        s = r.name ? i.createUniqueName(r.name) : "";
      return (function () {
        const e = [],
          n = i._invokeOne(function (e) {
            return e.createNodeMesh && e.createNodeMesh(t);
          });
        return (
          n && e.push(n),
          void 0 !== r.camera &&
            e.push(
              i.getDependency("camera", r.camera).then(function (t) {
                return i._getNodeRef(i.cameraCache, r.camera, t);
              })
            ),
          i
            ._invokeAll(function (e) {
              return e.createNodeAttachment && e.createNodeAttachment(t);
            })
            .forEach(function (t) {
              e.push(t);
            }),
          Promise.all(e)
        );
      })().then(function (e) {
        let o;
        if (
          ((o =
            !0 === r.isBone
              ? new $O()
              : e.length > 1
              ? new NO()
              : 1 === e.length
              ? e[0]
              : new qR()),
          o !== e[0])
        )
          for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
        if (
          (r.name && ((o.userData.name = r.name), (o.name = s)),
          XL(o, r),
          r.extensions && VL(n, o, r),
          void 0 !== r.matrix)
        ) {
          const t = new ER();
          t.fromArray(r.matrix), o.applyMatrix4(t);
        } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
        return (
          i.associations.has(o) || i.associations.set(o, {}),
          (i.associations.get(o).nodes = t),
          o
        );
      });
    }
    loadScene(t) {
      const e = this.json,
        n = this.extensions,
        i = this.json.scenes[t],
        r = this,
        s = new NO();
      i.name && (s.name = r.createUniqueName(i.name)),
        XL(s, i),
        i.extensions && VL(n, s, i);
      const o = i.nodes || [],
        a = [];
      for (let l = 0, h = o.length; l < h; l++) a.push(ZL(o[l], s, e, r));
      return Promise.all(a).then(function () {
        return (
          (r.associations = ((t) => {
            const e = new Map();
            for (const [n, i] of r.associations)
              (n instanceof aC || n instanceof GA) && e.set(n, i);
            return (
              t.traverse((t) => {
                const n = r.associations.get(t);
                null != n && e.set(t, n);
              }),
              e
            );
          })(s)),
          s
        );
      });
    }
  }
  function ZL(t, e, n, i) {
    const r = n.nodes[t];
    return i
      .getDependency("node", t)
      .then(function (t) {
        if (void 0 === r.skin) return t;
        let e;
        return i
          .getDependency("skin", r.skin)
          .then(function (t) {
            e = t;
            const n = [];
            for (let r = 0, s = e.joints.length; r < s; r++)
              n.push(i.getDependency("node", e.joints[r]));
            return Promise.all(n);
          })
          .then(function (n) {
            return (
              t.traverse(function (t) {
                if (!t.isMesh) return;
                const i = [],
                  r = [];
                for (let s = 0, o = n.length; s < o; s++) {
                  const t = n[s];
                  if (t) {
                    i.push(t);
                    const n = new ER();
                    void 0 !== e.inverseBindMatrices &&
                      n.fromArray(e.inverseBindMatrices.array, 16 * s),
                      r.push(n);
                  } else
                    console.warn(
                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                      e.joints[s]
                    );
                }
                t.bind(new nN(i, r), t.matrixWorld);
              }),
              t
            );
          });
      })
      .then(function (t) {
        e.add(t);
        const s = [];
        if (r.children) {
          const e = r.children;
          for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            s.push(ZL(o, t, n, i));
          }
        }
        return Promise.all(s);
      });
  }
  function JL(t, e, n) {
    const i = e.attributes,
      r = [];
    function s(e, i) {
      return n.getDependency("accessor", e).then(function (e) {
        t.setAttribute(i, e);
      });
    }
    for (const o in i) {
      const e = UL[o] || o.toLowerCase();
      e in t.attributes || r.push(s(i[o], e));
    }
    if (void 0 !== e.indices && !t.index) {
      const i = n.getDependency("accessor", e.indices).then(function (e) {
        t.setIndex(e);
      });
      r.push(i);
    }
    return (
      XL(t, e),
      (function (t, e, n) {
        const i = e.attributes,
          r = new KA();
        if (void 0 === i.POSITION) return;
        {
          const t = n.json.accessors[i.POSITION],
            e = t.min,
            s = t.max;
          if (void 0 === e || void 0 === s)
            return void console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
          if (
            (r.set(new jA(e[0], e[1], e[2]), new jA(s[0], s[1], s[2])),
            t.normalized)
          ) {
            const e = qL(NL[t.componentType]);
            r.min.multiplyScalar(e), r.max.multiplyScalar(e);
          }
        }
        const s = e.targets;
        if (void 0 !== s) {
          const t = new jA(),
            e = new jA();
          for (let i = 0, r = s.length; i < r; i++) {
            const r = s[i];
            if (void 0 !== r.POSITION) {
              const i = n.json.accessors[r.POSITION],
                s = i.min,
                o = i.max;
              if (void 0 !== s && void 0 !== o) {
                if (
                  (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                  e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                  e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                  i.normalized)
                ) {
                  const t = qL(NL[i.componentType]);
                  e.multiplyScalar(t);
                }
                t.max(e);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          r.expandByVector(t);
        }
        t.boundingBox = r;
        const o = new fR();
        r.getCenter(o.center),
          (o.radius = r.min.distanceTo(r.max) / 2),
          (t.boundingSphere = o);
      })(t, e, n),
      Promise.all(r).then(function () {
        return void 0 !== e.targets
          ? (function (t, e, n) {
              let i = !1,
                r = !1,
                s = !1;
              for (let h = 0, u = e.length; h < u; h++) {
                const t = e[h];
                if (
                  (void 0 !== t.POSITION && (i = !0),
                  void 0 !== t.NORMAL && (r = !0),
                  void 0 !== t.COLOR_0 && (s = !0),
                  i && r && s)
                )
                  break;
              }
              if (!i && !r && !s) return Promise.resolve(t);
              const o = [],
                a = [],
                l = [];
              for (let h = 0, u = e.length; h < u; h++) {
                const u = e[h];
                if (i) {
                  const e =
                    void 0 !== u.POSITION
                      ? n.getDependency("accessor", u.POSITION)
                      : t.attributes.position;
                  o.push(e);
                }
                if (r) {
                  const e =
                    void 0 !== u.NORMAL
                      ? n.getDependency("accessor", u.NORMAL)
                      : t.attributes.normal;
                  a.push(e);
                }
                if (s) {
                  const e =
                    void 0 !== u.COLOR_0
                      ? n.getDependency("accessor", u.COLOR_0)
                      : t.attributes.color;
                  l.push(e);
                }
              }
              return Promise.all([
                Promise.all(o),
                Promise.all(a),
                Promise.all(l),
              ]).then(function (e) {
                const n = e[0],
                  o = e[1],
                  a = e[2];
                return (
                  i && (t.morphAttributes.position = n),
                  r && (t.morphAttributes.normal = o),
                  s && (t.morphAttributes.color = a),
                  (t.morphTargetsRelative = !0),
                  t
                );
              });
            })(t, e.targets, n)
          : t;
      })
    );
  }
  function $L(t, e) {
    let n = t.getIndex();
    if (null === n) {
      const e = [],
        i = t.getAttribute("position");
      if (void 0 === i)
        return (
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          t
        );
      for (let t = 0; t < i.count; t++) e.push(t);
      t.setIndex(e), (n = t.getIndex());
    }
    const i = n.count - 2,
      r = [];
    if (2 === e)
      for (let o = 1; o <= i; o++)
        r.push(n.getX(0)), r.push(n.getX(o)), r.push(n.getX(o + 1));
    else
      for (let o = 0; o < i; o++)
        o % 2 == 0
          ? (r.push(n.getX(o)), r.push(n.getX(o + 1)), r.push(n.getX(o + 2)))
          : (r.push(n.getX(o + 2)), r.push(n.getX(o + 1)), r.push(n.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = t.clone();
    return s.setIndex(r), s;
  }
  var QL = "1.13.4",
    tF =
      ("object" == typeof self && self.self === self && self) ||
      ("object" == typeof global && global.global === global && global) ||
      Function("return this")() ||
      {},
    eF = Array.prototype,
    nF = Object.prototype,
    iF = "undefined" != typeof Symbol ? Symbol.prototype : null,
    rF = eF.push,
    sF = eF.slice,
    oF = nF.toString,
    aF = nF.hasOwnProperty,
    lF = "undefined" != typeof ArrayBuffer,
    hF = "undefined" != typeof DataView,
    uF = Array.isArray,
    cF = Object.keys,
    dF = Object.create,
    pF = lF && ArrayBuffer.isView,
    fF = isNaN,
    mF = isFinite,
    _F = !{ toString: null }.propertyIsEnumerable("toString"),
    gF = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString",
    ],
    vF = Math.pow(2, 53) - 1;
  function yF(t, e) {
    return (
      (e = null == e ? t.length - 1 : +e),
      function () {
        for (
          var n = Math.max(arguments.length - e, 0), i = Array(n), r = 0;
          r < n;
          r++
        )
          i[r] = arguments[r + e];
        switch (e) {
          case 0:
            return t.call(this, i);
          case 1:
            return t.call(this, arguments[0], i);
          case 2:
            return t.call(this, arguments[0], arguments[1], i);
        }
        var s = Array(e + 1);
        for (r = 0; r < e; r++) s[r] = arguments[r];
        return (s[e] = i), t.apply(this, s);
      }
    );
  }
  function xF(t) {
    var e = typeof t;
    return "function" === e || ("object" === e && !!t);
  }
  function bF(t) {
    return void 0 === t;
  }
  function TF(t) {
    return !0 === t || !1 === t || "[object Boolean]" === oF.call(t);
  }
  function EF(t) {
    var e = "[object " + t + "]";
    return function (t) {
      return oF.call(t) === e;
    };
  }
  const SF = EF("String"),
    wF = EF("Number"),
    MF = EF("Date"),
    AF = EF("RegExp"),
    RF = EF("Error"),
    CF = EF("Symbol"),
    IF = EF("ArrayBuffer");
  var PF = EF("Function"),
    OF = tF.document && tF.document.childNodes;
  "function" != typeof /./ &&
    "object" != typeof Int8Array &&
    "function" != typeof OF &&
    (PF = function (t) {
      return "function" == typeof t || !1;
    });
  const NF = PF,
    DF = EF("Object");
  var LF = hF && DF(new DataView(new ArrayBuffer(8))),
    FF = "undefined" != typeof Map && DF(new Map()),
    UF = EF("DataView");
  const BF = LF
      ? function (t) {
          return null != t && NF(t.getInt8) && IF(t.buffer);
        }
      : UF,
    kF = uF || EF("Array");
  function GF(t, e) {
    return null != t && aF.call(t, e);
  }
  var HF = EF("Arguments");
  !(function () {
    HF(arguments) ||
      (HF = function (t) {
        return GF(t, "callee");
      });
  })();
  const zF = HF;
  function VF(t) {
    return wF(t) && fF(t);
  }
  function XF(t) {
    return function () {
      return t;
    };
  }
  function WF(t) {
    return function (e) {
      var n = t(e);
      return "number" == typeof n && n >= 0 && n <= vF;
    };
  }
  function jF(t) {
    return function (e) {
      return null == e ? void 0 : e[t];
    };
  }
  const YF = jF("byteLength"),
    qF = WF(YF);
  var KF =
    /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
  const ZF = lF
      ? function (t) {
          return pF ? pF(t) && !BF(t) : qF(t) && KF.test(oF.call(t));
        }
      : XF(!1),
    JF = jF("length");
  function $F(t, e) {
    e = (function (t) {
      for (var e = {}, n = t.length, i = 0; i < n; ++i) e[t[i]] = !0;
      return {
        contains: function (t) {
          return !0 === e[t];
        },
        push: function (n) {
          return (e[n] = !0), t.push(n);
        },
      };
    })(e);
    var n = gF.length,
      i = t.constructor,
      r = (NF(i) && i.prototype) || nF,
      s = "constructor";
    for (GF(t, s) && !e.contains(s) && e.push(s); n--; )
      (s = gF[n]) in t && t[s] !== r[s] && !e.contains(s) && e.push(s);
  }
  function QF(t) {
    if (!xF(t)) return [];
    if (cF) return cF(t);
    var e = [];
    for (var n in t) GF(t, n) && e.push(n);
    return _F && $F(t, e), e;
  }
  function tU(t, e) {
    var n = QF(e),
      i = n.length;
    if (null == t) return !i;
    for (var r = Object(t), s = 0; s < i; s++) {
      var o = n[s];
      if (e[o] !== r[o] || !(o in r)) return !1;
    }
    return !0;
  }
  function eU(t) {
    return t instanceof eU
      ? t
      : this instanceof eU
      ? void (this._wrapped = t)
      : new eU(t);
  }
  function nU(t) {
    return new Uint8Array(t.buffer || t, t.byteOffset || 0, YF(t));
  }
  (eU.VERSION = QL),
    (eU.prototype.value = function () {
      return this._wrapped;
    }),
    (eU.prototype.valueOf = eU.prototype.toJSON = eU.prototype.value),
    (eU.prototype.toString = function () {
      return String(this._wrapped);
    });
  var iU = "[object DataView]";
  function rU(t, e, n, i) {
    if (t === e) return 0 !== t || 1 / t == 1 / e;
    if (null == t || null == e) return !1;
    if (t != t) return e != e;
    var r = typeof t;
    return (
      ("function" === r || "object" === r || "object" == typeof e) &&
      sU(t, e, n, i)
    );
  }
  function sU(t, e, n, i) {
    t instanceof eU && (t = t._wrapped), e instanceof eU && (e = e._wrapped);
    var r = oF.call(t);
    if (r !== oF.call(e)) return !1;
    if (LF && "[object Object]" == r && BF(t)) {
      if (!BF(e)) return !1;
      r = iU;
    }
    switch (r) {
      case "[object RegExp]":
      case "[object String]":
        return "" + t == "" + e;
      case "[object Number]":
        return +t != +t ? +e != +e : 0 == +t ? 1 / +t == 1 / e : +t == +e;
      case "[object Date]":
      case "[object Boolean]":
        return +t == +e;
      case "[object Symbol]":
        return iF.valueOf.call(t) === iF.valueOf.call(e);
      case "[object ArrayBuffer]":
      case iU:
        return sU(nU(t), nU(e), n, i);
    }
    var s = "[object Array]" === r;
    if (!s && ZF(t)) {
      if (YF(t) !== YF(e)) return !1;
      if (t.buffer === e.buffer && t.byteOffset === e.byteOffset) return !0;
      s = !0;
    }
    if (!s) {
      if ("object" != typeof t || "object" != typeof e) return !1;
      var o = t.constructor,
        a = e.constructor;
      if (
        o !== a &&
        !(NF(o) && o instanceof o && NF(a) && a instanceof a) &&
        "constructor" in t &&
        "constructor" in e
      )
        return !1;
    }
    i = i || [];
    for (var l = (n = n || []).length; l--; ) if (n[l] === t) return i[l] === e;
    if ((n.push(t), i.push(e), s)) {
      if ((l = t.length) !== e.length) return !1;
      for (; l--; ) if (!rU(t[l], e[l], n, i)) return !1;
    } else {
      var h,
        u = QF(t);
      if (((l = u.length), QF(e).length !== l)) return !1;
      for (; l--; ) if (!GF(e, (h = u[l])) || !rU(t[h], e[h], n, i)) return !1;
    }
    return n.pop(), i.pop(), !0;
  }
  function oU(t) {
    if (!xF(t)) return [];
    var e = [];
    for (var n in t) e.push(n);
    return _F && $F(t, e), e;
  }
  function aU(t) {
    var e = JF(t);
    return function (n) {
      if (null == n) return !1;
      var i = oU(n);
      if (JF(i)) return !1;
      for (var r = 0; r < e; r++) if (!NF(n[t[r]])) return !1;
      return t !== dU || !NF(n[lU]);
    };
  }
  var lU = "forEach",
    hU = ["clear", "delete"],
    uU = ["get", "has", "set"],
    cU = hU.concat(lU, uU),
    dU = hU.concat(uU),
    pU = ["add"].concat(hU, lU, "has");
  const fU = FF ? aU(cU) : EF("Map"),
    mU = FF ? aU(dU) : EF("WeakMap"),
    _U = FF ? aU(pU) : EF("Set"),
    gU = EF("WeakSet");
  function vU(t) {
    for (var e = QF(t), n = e.length, i = Array(n), r = 0; r < n; r++)
      i[r] = t[e[r]];
    return i;
  }
  function yU(t) {
    for (var e = {}, n = QF(t), i = 0, r = n.length; i < r; i++)
      e[t[n[i]]] = n[i];
    return e;
  }
  function xU(t) {
    var e = [];
    for (var n in t) NF(t[n]) && e.push(n);
    return e.sort();
  }
  function bU(t, e) {
    return function (n) {
      var i = arguments.length;
      if ((e && (n = Object(n)), i < 2 || null == n)) return n;
      for (var r = 1; r < i; r++)
        for (var s = arguments[r], o = t(s), a = o.length, l = 0; l < a; l++) {
          var h = o[l];
          (e && void 0 !== n[h]) || (n[h] = s[h]);
        }
      return n;
    };
  }
  const TU = bU(oU),
    EU = bU(QF),
    SU = bU(oU, !0);
  function wU(t) {
    if (!xF(t)) return {};
    if (dF) return dF(t);
    var e = function () {};
    e.prototype = t;
    var n = new e();
    return (e.prototype = null), n;
  }
  function MU(t) {
    return kF(t) ? t : [t];
  }
  function AU(t) {
    return eU.toPath(t);
  }
  function RU(t, e) {
    for (var n = e.length, i = 0; i < n; i++) {
      if (null == t) return;
      t = t[e[i]];
    }
    return n ? t : void 0;
  }
  function CU(t, e, n) {
    var i = RU(t, AU(e));
    return bF(i) ? n : i;
  }
  function IU(t) {
    return t;
  }
  function PU(t) {
    return (
      (t = EU({}, t)),
      function (e) {
        return tU(e, t);
      }
    );
  }
  function OU(t) {
    return (
      (t = AU(t)),
      function (e) {
        return RU(e, t);
      }
    );
  }
  function NU(t, e, n) {
    if (void 0 === e) return t;
    switch (null == n ? 3 : n) {
      case 1:
        return function (n) {
          return t.call(e, n);
        };
      case 3:
        return function (n, i, r) {
          return t.call(e, n, i, r);
        };
      case 4:
        return function (n, i, r, s) {
          return t.call(e, n, i, r, s);
        };
    }
    return function () {
      return t.apply(e, arguments);
    };
  }
  function DU(t, e, n) {
    return null == t
      ? IU
      : NF(t)
      ? NU(t, e, n)
      : xF(t) && !kF(t)
      ? PU(t)
      : OU(t);
  }
  function LU(t, e) {
    return DU(t, e, 1 / 0);
  }
  function FU(t, e, n) {
    return eU.iteratee !== LU ? eU.iteratee(t, e) : DU(t, e, n);
  }
  function UU() {}
  function BU(t, e) {
    return (
      null == e && ((e = t), (t = 0)),
      t + Math.floor(Math.random() * (e - t + 1))
    );
  }
  (eU.toPath = MU), (eU.iteratee = LU);
  const kU =
    Date.now ||
    function () {
      return new Date().getTime();
    };
  function GU(t) {
    var e = function (e) {
        return t[e];
      },
      n = "(?:" + QF(t).join("|") + ")",
      i = RegExp(n),
      r = RegExp(n, "g");
    return function (t) {
      return (t = null == t ? "" : "" + t), i.test(t) ? t.replace(r, e) : t;
    };
  }
  const HU = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
    },
    zU = GU(HU),
    VU = GU(yU(HU)),
    XU = (eU.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g,
    });
  var WU = /(.)^/,
    jU = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029",
    },
    YU = /\\|'|\r|\n|\u2028|\u2029/g;
  function qU(t) {
    return "\\" + jU[t];
  }
  var KU = /^\s*(\w|\$)+\s*$/;
  var ZU = 0;
  function JU(t, e, n, i, r) {
    if (!(i instanceof e)) return t.apply(n, r);
    var s = wU(t.prototype),
      o = t.apply(s, r);
    return xF(o) ? o : s;
  }
  var $U = yF(function (t, e) {
    var n = $U.placeholder,
      i = function () {
        for (var r = 0, s = e.length, o = Array(s), a = 0; a < s; a++)
          o[a] = e[a] === n ? arguments[r++] : e[a];
        for (; r < arguments.length; ) o.push(arguments[r++]);
        return JU(t, i, this, this, o);
      };
    return i;
  });
  $U.placeholder = eU;
  const QU = yF(function (t, e, n) {
      if (!NF(t)) throw new TypeError("Bind must be called on a function");
      var i = yF(function (r) {
        return JU(t, i, e, this, n.concat(r));
      });
      return i;
    }),
    tB = WF(JF);
  function eB(t, e, n, i) {
    if (((i = i || []), e || 0 === e)) {
      if (e <= 0) return i.concat(t);
    } else e = 1 / 0;
    for (var r = i.length, s = 0, o = JF(t); s < o; s++) {
      var a = t[s];
      if (tB(a) && (kF(a) || zF(a)))
        if (e > 1) eB(a, e - 1, n, i), (r = i.length);
        else for (var l = 0, h = a.length; l < h; ) i[r++] = a[l++];
      else n || (i[r++] = a);
    }
    return i;
  }
  const nB = yF(function (t, e) {
    var n = (e = eB(e, !1, !1)).length;
    if (n < 1) throw new Error("bindAll must be passed function names");
    for (; n--; ) {
      var i = e[n];
      t[i] = QU(t[i], t);
    }
    return t;
  });
  const iB = yF(function (t, e, n) {
      return setTimeout(function () {
        return t.apply(null, n);
      }, e);
    }),
    rB = $U(iB, eU, 1);
  function sB(t) {
    return function () {
      return !t.apply(this, arguments);
    };
  }
  function oB(t, e) {
    var n;
    return function () {
      return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n;
    };
  }
  const aB = $U(oB, 2);
  function lB(t, e, n) {
    e = FU(e, n);
    for (var i, r = QF(t), s = 0, o = r.length; s < o; s++)
      if (e(t[(i = r[s])], i, t)) return i;
  }
  function hB(t) {
    return function (e, n, i) {
      n = FU(n, i);
      for (var r = JF(e), s = t > 0 ? 0 : r - 1; s >= 0 && s < r; s += t)
        if (n(e[s], s, e)) return s;
      return -1;
    };
  }
  const uB = hB(1),
    cB = hB(-1);
  function dB(t, e, n, i) {
    for (var r = (n = FU(n, i, 1))(e), s = 0, o = JF(t); s < o; ) {
      var a = Math.floor((s + o) / 2);
      n(t[a]) < r ? (s = a + 1) : (o = a);
    }
    return s;
  }
  function pB(t, e, n) {
    return function (i, r, s) {
      var o = 0,
        a = JF(i);
      if ("number" == typeof s)
        t > 0
          ? (o = s >= 0 ? s : Math.max(s + a, o))
          : (a = s >= 0 ? Math.min(s + 1, a) : s + a + 1);
      else if (n && s && a) return i[(s = n(i, r))] === r ? s : -1;
      if (r != r) return (s = e(sF.call(i, o, a), VF)) >= 0 ? s + o : -1;
      for (s = t > 0 ? o : a - 1; s >= 0 && s < a; s += t)
        if (i[s] === r) return s;
      return -1;
    };
  }
  const fB = pB(1, uB, dB),
    mB = pB(-1, cB);
  function _B(t, e, n) {
    var i = (tB(t) ? uB : lB)(t, e, n);
    if (void 0 !== i && -1 !== i) return t[i];
  }
  function gB(t, e, n) {
    var i, r;
    if (((e = NU(e, n)), tB(t)))
      for (i = 0, r = t.length; i < r; i++) e(t[i], i, t);
    else {
      var s = QF(t);
      for (i = 0, r = s.length; i < r; i++) e(t[s[i]], s[i], t);
    }
    return t;
  }
  function vB(t, e, n) {
    e = FU(e, n);
    for (
      var i = !tB(t) && QF(t), r = (i || t).length, s = Array(r), o = 0;
      o < r;
      o++
    ) {
      var a = i ? i[o] : o;
      s[o] = e(t[a], a, t);
    }
    return s;
  }
  function yB(t) {
    var e = function (e, n, i, r) {
      var s = !tB(e) && QF(e),
        o = (s || e).length,
        a = t > 0 ? 0 : o - 1;
      for (r || ((i = e[s ? s[a] : a]), (a += t)); a >= 0 && a < o; a += t) {
        var l = s ? s[a] : a;
        i = n(i, e[l], l, e);
      }
      return i;
    };
    return function (t, n, i, r) {
      var s = arguments.length >= 3;
      return e(t, NU(n, r, 4), i, s);
    };
  }
  const xB = yB(1),
    bB = yB(-1);
  function TB(t, e, n) {
    var i = [];
    return (
      (e = FU(e, n)),
      gB(t, function (t, n, r) {
        e(t, n, r) && i.push(t);
      }),
      i
    );
  }
  function EB(t, e, n) {
    e = FU(e, n);
    for (var i = !tB(t) && QF(t), r = (i || t).length, s = 0; s < r; s++) {
      var o = i ? i[s] : s;
      if (!e(t[o], o, t)) return !1;
    }
    return !0;
  }
  function SB(t, e, n) {
    e = FU(e, n);
    for (var i = !tB(t) && QF(t), r = (i || t).length, s = 0; s < r; s++) {
      var o = i ? i[s] : s;
      if (e(t[o], o, t)) return !0;
    }
    return !1;
  }
  function wB(t, e, n, i) {
    return (
      tB(t) || (t = vU(t)),
      ("number" != typeof n || i) && (n = 0),
      fB(t, e, n) >= 0
    );
  }
  const MB = yF(function (t, e, n) {
    var i, r;
    return (
      NF(e)
        ? (r = e)
        : ((e = AU(e)), (i = e.slice(0, -1)), (e = e[e.length - 1])),
      vB(t, function (t) {
        var s = r;
        if (!s) {
          if ((i && i.length && (t = RU(t, i)), null == t)) return;
          s = t[e];
        }
        return null == s ? s : s.apply(t, n);
      })
    );
  });
  function AB(t, e) {
    return vB(t, OU(e));
  }
  function RB(t, e, n) {
    var i,
      r,
      s = -1 / 0,
      o = -1 / 0;
    if (
      null == e ||
      ("number" == typeof e && "object" != typeof t[0] && null != t)
    )
      for (var a = 0, l = (t = tB(t) ? t : vU(t)).length; a < l; a++)
        null != (i = t[a]) && i > s && (s = i);
    else
      (e = FU(e, n)),
        gB(t, function (t, n, i) {
          ((r = e(t, n, i)) > o || (r === -1 / 0 && s === -1 / 0)) &&
            ((s = t), (o = r));
        });
    return s;
  }
  var CB = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  function IB(t) {
    return t
      ? kF(t)
        ? sF.call(t)
        : SF(t)
        ? t.match(CB)
        : tB(t)
        ? vB(t, IU)
        : vU(t)
      : [];
  }
  function PB(t, e, n) {
    if (null == e || n) return tB(t) || (t = vU(t)), t[BU(t.length - 1)];
    var i = IB(t),
      r = JF(i);
    e = Math.max(Math.min(e, r), 0);
    for (var s = r - 1, o = 0; o < e; o++) {
      var a = BU(o, s),
        l = i[o];
      (i[o] = i[a]), (i[a] = l);
    }
    return i.slice(0, e);
  }
  function OB(t, e) {
    return function (n, i, r) {
      var s = e ? [[], []] : {};
      return (
        (i = FU(i, r)),
        gB(n, function (e, r) {
          var o = i(e, r, n);
          t(s, e, o);
        }),
        s
      );
    };
  }
  const NB = OB(function (t, e, n) {
      GF(t, n) ? t[n].push(e) : (t[n] = [e]);
    }),
    DB = OB(function (t, e, n) {
      t[n] = e;
    }),
    LB = OB(function (t, e, n) {
      GF(t, n) ? t[n]++ : (t[n] = 1);
    }),
    FB = OB(function (t, e, n) {
      t[n ? 0 : 1].push(e);
    }, !0);
  function UB(t, e, n) {
    return e in n;
  }
  const BB = yF(function (t, e) {
      var n = {},
        i = e[0];
      if (null == t) return n;
      NF(i)
        ? (e.length > 1 && (i = NU(i, e[1])), (e = oU(t)))
        : ((i = UB), (e = eB(e, !1, !1)), (t = Object(t)));
      for (var r = 0, s = e.length; r < s; r++) {
        var o = e[r],
          a = t[o];
        i(a, o, t) && (n[o] = a);
      }
      return n;
    }),
    kB = yF(function (t, e) {
      var n,
        i = e[0];
      return (
        NF(i)
          ? ((i = sB(i)), e.length > 1 && (n = e[1]))
          : ((e = vB(eB(e, !1, !1), String)),
            (i = function (t, n) {
              return !wB(e, n);
            })),
        BB(t, i, n)
      );
    });
  function GB(t, e, n) {
    return sF.call(t, 0, Math.max(0, t.length - (null == e || n ? 1 : e)));
  }
  function HB(t, e, n) {
    return null == t || t.length < 1
      ? null == e || n
        ? void 0
        : []
      : null == e || n
      ? t[0]
      : GB(t, t.length - e);
  }
  function zB(t, e, n) {
    return sF.call(t, null == e || n ? 1 : e);
  }
  const VB = yF(function (t, e) {
      return (
        (e = eB(e, !0, !0)),
        TB(t, function (t) {
          return !wB(e, t);
        })
      );
    }),
    XB = yF(function (t, e) {
      return VB(t, e);
    });
  function WB(t, e, n, i) {
    TF(e) || ((i = n), (n = e), (e = !1)), null != n && (n = FU(n, i));
    for (var r = [], s = [], o = 0, a = JF(t); o < a; o++) {
      var l = t[o],
        h = n ? n(l, o, t) : l;
      e && !n
        ? ((o && s === h) || r.push(l), (s = h))
        : n
        ? wB(s, h) || (s.push(h), r.push(l))
        : wB(r, l) || r.push(l);
    }
    return r;
  }
  const jB = yF(function (t) {
    return WB(eB(t, !0, !0));
  });
  function YB(t) {
    for (var e = (t && RB(t, JF).length) || 0, n = Array(e), i = 0; i < e; i++)
      n[i] = AB(t, i);
    return n;
  }
  const qB = yF(YB);
  function KB(t, e) {
    return t._chain ? eU(e).chain() : e;
  }
  function ZB(t) {
    return (
      gB(xU(t), function (e) {
        var n = (eU[e] = t[e]);
        eU.prototype[e] = function () {
          var t = [this._wrapped];
          return rF.apply(t, arguments), KB(this, n.apply(eU, t));
        };
      }),
      eU
    );
  }
  gB(
    ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
    function (t) {
      var e = eF[t];
      eU.prototype[t] = function () {
        var n = this._wrapped;
        return (
          null != n &&
            (e.apply(n, arguments),
            ("shift" !== t && "splice" !== t) || 0 !== n.length || delete n[0]),
          KB(this, n)
        );
      };
    }
  ),
    gB(["concat", "join", "slice"], function (t) {
      var e = eF[t];
      eU.prototype[t] = function () {
        var t = this._wrapped;
        return null != t && (t = e.apply(t, arguments)), KB(this, t);
      };
    });
  const JB = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        VERSION: QL,
        restArguments: yF,
        isObject: xF,
        isNull: function (t) {
          return null === t;
        },
        isUndefined: bF,
        isBoolean: TF,
        isElement: function (t) {
          return !(!t || 1 !== t.nodeType);
        },
        isString: SF,
        isNumber: wF,
        isDate: MF,
        isRegExp: AF,
        isError: RF,
        isSymbol: CF,
        isArrayBuffer: IF,
        isDataView: BF,
        isArray: kF,
        isFunction: NF,
        isArguments: zF,
        isFinite: function (t) {
          return !CF(t) && mF(t) && !isNaN(parseFloat(t));
        },
        isNaN: VF,
        isTypedArray: ZF,
        isEmpty: function (t) {
          if (null == t) return !0;
          var e = JF(t);
          return "number" == typeof e && (kF(t) || SF(t) || zF(t))
            ? 0 === e
            : 0 === JF(QF(t));
        },
        isMatch: tU,
        isEqual: function (t, e) {
          return rU(t, e);
        },
        isMap: fU,
        isWeakMap: mU,
        isSet: _U,
        isWeakSet: gU,
        keys: QF,
        allKeys: oU,
        values: vU,
        pairs: function (t) {
          for (var e = QF(t), n = e.length, i = Array(n), r = 0; r < n; r++)
            i[r] = [e[r], t[e[r]]];
          return i;
        },
        invert: yU,
        functions: xU,
        methods: xU,
        extend: TU,
        extendOwn: EU,
        assign: EU,
        defaults: SU,
        create: function (t, e) {
          var n = wU(t);
          return e && EU(n, e), n;
        },
        clone: function (t) {
          return xF(t) ? (kF(t) ? t.slice() : TU({}, t)) : t;
        },
        tap: function (t, e) {
          return e(t), t;
        },
        get: CU,
        has: function (t, e) {
          for (var n = (e = AU(e)).length, i = 0; i < n; i++) {
            var r = e[i];
            if (!GF(t, r)) return !1;
            t = t[r];
          }
          return !!n;
        },
        mapObject: function (t, e, n) {
          e = FU(e, n);
          for (var i = QF(t), r = i.length, s = {}, o = 0; o < r; o++) {
            var a = i[o];
            s[a] = e(t[a], a, t);
          }
          return s;
        },
        identity: IU,
        constant: XF,
        noop: UU,
        toPath: MU,
        property: OU,
        propertyOf: function (t) {
          return null == t
            ? UU
            : function (e) {
                return CU(t, e);
              };
        },
        matcher: PU,
        matches: PU,
        times: function (t, e, n) {
          var i = Array(Math.max(0, t));
          e = NU(e, n, 1);
          for (var r = 0; r < t; r++) i[r] = e(r);
          return i;
        },
        random: BU,
        now: kU,
        escape: zU,
        unescape: VU,
        templateSettings: XU,
        template: function (t, e, n) {
          !e && n && (e = n), (e = SU({}, e, eU.templateSettings));
          var i = RegExp(
              [
                (e.escape || WU).source,
                (e.interpolate || WU).source,
                (e.evaluate || WU).source,
              ].join("|") + "|$",
              "g"
            ),
            r = 0,
            s = "__p+='";
          t.replace(i, function (e, n, i, o, a) {
            return (
              (s += t.slice(r, a).replace(YU, qU)),
              (r = a + e.length),
              n
                ? (s += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'")
                : i
                ? (s += "'+\n((__t=(" + i + "))==null?'':__t)+\n'")
                : o && (s += "';\n" + o + "\n__p+='"),
              e
            );
          }),
            (s += "';\n");
          var o,
            a = e.variable;
          if (a) {
            if (!KU.test(a))
              throw new Error("variable is not a bare identifier: " + a);
          } else (s = "with(obj||{}){\n" + s + "}\n"), (a = "obj");
          s =
            "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" +
            s +
            "return __p;\n";
          try {
            o = new Function(a, "_", s);
          } catch (h) {
            throw ((h.source = s), h);
          }
          var l = function (t) {
            return o.call(this, t, eU);
          };
          return (l.source = "function(" + a + "){\n" + s + "}"), l;
        },
        result: function (t, e, n) {
          var i = (e = AU(e)).length;
          if (!i) return NF(n) ? n.call(t) : n;
          for (var r = 0; r < i; r++) {
            var s = null == t ? void 0 : t[e[r]];
            void 0 === s && ((s = n), (r = i)), (t = NF(s) ? s.call(t) : s);
          }
          return t;
        },
        uniqueId: function (t) {
          var e = ++ZU + "";
          return t ? t + e : e;
        },
        chain: function (t) {
          var e = eU(t);
          return (e._chain = !0), e;
        },
        iteratee: LU,
        partial: $U,
        bind: QU,
        bindAll: nB,
        memoize: function (t, e) {
          var n = function (i) {
            var r = n.cache,
              s = "" + (e ? e.apply(this, arguments) : i);
            return GF(r, s) || (r[s] = t.apply(this, arguments)), r[s];
          };
          return (n.cache = {}), n;
        },
        delay: iB,
        defer: rB,
        throttle: function (t, e, n) {
          var i,
            r,
            s,
            o,
            a = 0;
          n || (n = {});
          var l = function () {
              (a = !1 === n.leading ? 0 : kU()),
                (i = null),
                (o = t.apply(r, s)),
                i || (r = s = null);
            },
            h = function () {
              var h = kU();
              a || !1 !== n.leading || (a = h);
              var u = e - (h - a);
              return (
                (r = this),
                (s = arguments),
                u <= 0 || u > e
                  ? (i && (clearTimeout(i), (i = null)),
                    (a = h),
                    (o = t.apply(r, s)),
                    i || (r = s = null))
                  : i || !1 === n.trailing || (i = setTimeout(l, u)),
                o
              );
            };
          return (
            (h.cancel = function () {
              clearTimeout(i), (a = 0), (i = r = s = null);
            }),
            h
          );
        },
        debounce: function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l = function () {
              var h = kU() - r;
              e > h
                ? (i = setTimeout(l, e - h))
                : ((i = null), n || (o = t.apply(a, s)), i || (s = a = null));
            },
            h = yF(function (h) {
              return (
                (a = this),
                (s = h),
                (r = kU()),
                i || ((i = setTimeout(l, e)), n && (o = t.apply(a, s))),
                o
              );
            });
          return (
            (h.cancel = function () {
              clearTimeout(i), (i = s = a = null);
            }),
            h
          );
        },
        wrap: function (t, e) {
          return $U(e, t);
        },
        negate: sB,
        compose: function () {
          var t = arguments,
            e = t.length - 1;
          return function () {
            for (var n = e, i = t[e].apply(this, arguments); n--; )
              i = t[n].call(this, i);
            return i;
          };
        },
        after: function (t, e) {
          return function () {
            if (--t < 1) return e.apply(this, arguments);
          };
        },
        before: oB,
        once: aB,
        findKey: lB,
        findIndex: uB,
        findLastIndex: cB,
        sortedIndex: dB,
        indexOf: fB,
        lastIndexOf: mB,
        find: _B,
        detect: _B,
        findWhere: function (t, e) {
          return _B(t, PU(e));
        },
        each: gB,
        forEach: gB,
        map: vB,
        collect: vB,
        reduce: xB,
        foldl: xB,
        inject: xB,
        reduceRight: bB,
        foldr: bB,
        filter: TB,
        select: TB,
        reject: function (t, e, n) {
          return TB(t, sB(FU(e)), n);
        },
        every: EB,
        all: EB,
        some: SB,
        any: SB,
        contains: wB,
        includes: wB,
        include: wB,
        invoke: MB,
        pluck: AB,
        where: function (t, e) {
          return TB(t, PU(e));
        },
        max: RB,
        min: function (t, e, n) {
          var i,
            r,
            s = 1 / 0,
            o = 1 / 0;
          if (
            null == e ||
            ("number" == typeof e && "object" != typeof t[0] && null != t)
          )
            for (var a = 0, l = (t = tB(t) ? t : vU(t)).length; a < l; a++)
              null != (i = t[a]) && i < s && (s = i);
          else
            (e = FU(e, n)),
              gB(t, function (t, n, i) {
                ((r = e(t, n, i)) < o || (r === 1 / 0 && s === 1 / 0)) &&
                  ((s = t), (o = r));
              });
          return s;
        },
        shuffle: function (t) {
          return PB(t, 1 / 0);
        },
        sample: PB,
        sortBy: function (t, e, n) {
          var i = 0;
          return (
            (e = FU(e, n)),
            AB(
              vB(t, function (t, n, r) {
                return { value: t, index: i++, criteria: e(t, n, r) };
              }).sort(function (t, e) {
                var n = t.criteria,
                  i = e.criteria;
                if (n !== i) {
                  if (n > i || void 0 === n) return 1;
                  if (n < i || void 0 === i) return -1;
                }
                return t.index - e.index;
              }),
              "value"
            )
          );
        },
        groupBy: NB,
        indexBy: DB,
        countBy: LB,
        partition: FB,
        toArray: IB,
        size: function (t) {
          return null == t ? 0 : tB(t) ? t.length : QF(t).length;
        },
        pick: BB,
        omit: kB,
        first: HB,
        head: HB,
        take: HB,
        initial: GB,
        last: function (t, e, n) {
          return null == t || t.length < 1
            ? null == e || n
              ? void 0
              : []
            : null == e || n
            ? t[t.length - 1]
            : zB(t, Math.max(0, t.length - e));
        },
        rest: zB,
        tail: zB,
        drop: zB,
        compact: function (t) {
          return TB(t, Boolean);
        },
        flatten: function (t, e) {
          return eB(t, e, !1);
        },
        without: XB,
        uniq: WB,
        unique: WB,
        union: jB,
        intersection: function (t) {
          for (var e = [], n = arguments.length, i = 0, r = JF(t); i < r; i++) {
            var s = t[i];
            if (!wB(e, s)) {
              var o;
              for (o = 1; o < n && wB(arguments[o], s); o++);
              o === n && e.push(s);
            }
          }
          return e;
        },
        difference: VB,
        unzip: YB,
        transpose: YB,
        zip: qB,
        object: function (t, e) {
          for (var n = {}, i = 0, r = JF(t); i < r; i++)
            e ? (n[t[i]] = e[i]) : (n[t[i][0]] = t[i][1]);
          return n;
        },
        range: function (t, e, n) {
          null == e && ((e = t || 0), (t = 0)), n || (n = e < t ? -1 : 1);
          for (
            var i = Math.max(Math.ceil((e - t) / n), 0), r = Array(i), s = 0;
            s < i;
            s++, t += n
          )
            r[s] = t;
          return r;
        },
        chunk: function (t, e) {
          if (null == e || e < 1) return [];
          for (var n = [], i = 0, r = t.length; i < r; )
            n.push(sF.call(t, i, (i += e)));
          return n;
        },
        mixin: ZB,
        default: eU,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  var $B = ZB(JB);
  function QB(t) {
    const e = document.createElement("video");
    (e.src = t),
      (e.loop = !0),
      (e.muted = !0),
      (e.crossOrigin = "anonymous"),
      e.play();
    const n = new bN(e),
      i = new lI(4, 4),
      r = new lC({ map: n, side: 2, transparent: !0 }),
      s = new GC(i, r);
    return (
      (s.customDepthMaterial = new MO({
        depthPacking: tA,
        map: n,
        alphaTest: 0.5,
      })),
      (s.receiveShadow = !0),
      s
    );
  }
  function tk(t, e, n = () => {}) {
    new $D().load(
      e,
      function (e) {
        return (
          e.scene.traverse(function (t) {
            t.isMesh &&
              ((t.castShadow = !0),
              (t.material.side = 2),
              (t.material.transparent = !0));
          }),
          t.add(e.scene),
          n(e),
          e.scene
        );
      },
      function (t) {},
      function (t) {
        console.log("An error happened");
      }
    );
  }
  function ek(t) {
    let e = !1,
      n = [];
    var i = JD({ zone: t });
    const r = new zO({ antialias: !0 }),
      s = new qC(60, t.offsetWidth / t.offsetHeight, 0.1, 1e4);
    s.position.set(0, 4, 15);
    const o = new gD();
    (r.fog = new HO(11650815, 0.25, 50)),
      (r.background = new DA(11650815)),
      (function (t) {
        const e = new pD(16777215, 1.25);
        e.position.set(15, 15, 25), (e.castShadow = !0), t.add(e);
        const n = new fD(4210752, 1.5);
        t.add(n),
          (e.shadow.mapSize.width = 3512),
          (e.shadow.mapSize.height = 3512),
          (e.shadow.camera.near = 0.1),
          (e.shadow.camera.far = 1500),
          (e.shadow.camera.left = -80),
          (e.shadow.camera.right = 100),
          (e.shadow.camera.top = 80),
          (e.shadow.camera.bottom = -80);
      })(r);
    let a = (function () {
      let t = [],
        e = 0.005;
      return {
        add: function (e, n = { x: 0, y: 1, z: 0 }) {
          t.push({ mesh: e, options: n });
        },
        update: function () {
          t.forEach((t) => {
            t.mesh.rotateY(t.options.y * e),
              t.mesh.rotateX(t.options.x * e),
              t.mesh.rotateZ(t.options.z * e);
          });
        },
      };
    })();
    for (let f = 0; f < 3; f++)
      for (let t = 0; t < 3; t++)
        tk(r, ht() + "/assets/3d/Wix_Virtual_Space15.gltf", (e) => {
          e.scene.position.set(150 * f - 150, -0, 150 * t - 150),
            e.scene.scale.set(0.02, 0.02, 0.02),
            e.scene;
          let i = [
            { "21_Do no harm": { x: 1, y: 0, z: 1 } },
            { "12_Dumpster": { x: 0, y: 1, z: 0 } },
            { "03_Feel Better": { x: 1, y: 1, z: 1 } },
            { "10_Mac": { x: 0, y: 0.01, z: -20 } },
            { Spin: { x: 0, y: 0, z: 0.5 } },
          ];
          e.scene.traverse(function (t) {
            t.isObject3D &&
              (t.name.includes("faceme") && n.push(t),
              i.forEach((e) => {
                t.name.includes(Object.keys(e)[0]) &&
                  a.add(t, e[Object.keys(e)[0]]);
              }));
          });
        });
    let l = (function (t) {
      const e = new QN().load(t),
        n = new lI(4, 4),
        i = new lC({ map: e, side: 2, transparent: !0 }),
        r = new GC(n, i);
      return (
        (r.customDepthMaterial = new MO({
          depthPacking: tA,
          map: e,
          alphaTest: 0.5,
        })),
        (r.receiveShadow = !0),
        r
      );
    })(ht() + "/assets/memes/kim.png");
    l.position.set(-2.82, 3.5, -35.34),
      l.scale.set(0.65, 0.65, 0.65),
      r.add(l),
      a.add(l),
      tk(r, ht() + "/assets/3d/column.glb", (t) => {
        t.scene.position.set(-2.82, 0, -35.34),
          t.scene.scale.set(0.6, 0.6, 0.6),
          t.scene.traverse(function (t) {
            t.isMesh && (t.material = new SN({ color: 16711422 }));
          });
      });
    let h = QB(ht() + "/assets/3d/20_Elmo.mp4");
    h.position.set(-7.02, 7, -108.37), r.add(h), a.add(h);
    let u = QB(ht() + "/assets/3d/11_Sponge Bob.mp4");
    u.position.set(-23, 4, -11.577),
      u.scale.set(0.8, 0.8, 0.8),
      r.add(u),
      a.add(u),
      (function (t) {
        const e = new lI(5e3, 5e3),
          n = new SN({ color: 16777215 }),
          i = new GC(e, n);
        i.position.set(0, 0, 0),
          (i.receiveShadow = !0),
          i.rotateX(-Math.PI / 2),
          t.add(i);
      })(r);
    const c = new GO({ antialias: !1 });
    c.setSize(t.offsetWidth, t.offsetHeight),
      c.setAnimationLoop(function (t) {
        if (e) return;
        a.update();
        let i = o.getDelta();
        for (var l = 0; l < n.length; l++) n[l].lookAt(s.position);
        d.on &&
          (s.translateZ(10 * -d.vector.y * i), s.rotateY(1 * -d.vector.x * i));
        p.on
          ? (p.up && s.translateZ(-7 * i),
            p.down && s.translateZ(7 * i),
            p.left && s.rotateY(1 * i),
            p.right && s.rotateY(-1 * i))
          : (p.up = p.down = p.left = p.right = !1);
        c.render(r, s);
      }),
      (c.toneMapping = 0),
      (c.shadowMap.enabled = !0),
      (c.shadowMap.type = 2),
      t.appendChild(c.domElement),
      (c.toneMappingExposure = 1);
    let d = { on: !1, vector: { x: 0, y: 0 } };
    i.on("added", function (t, e) {
      (d.on = !0),
        e.on("move", function (t, e) {
          d.vector = e.vector;
        });
    }).on("removed", function (t, e) {
      (d.on = !1), e.off("move");
    });
    let p = {
      on: !1,
      up: !1,
      left: !1,
      right: !1,
      down: !1,
      vector: { x: 0, y: 0 },
    };
    return (
      document.addEventListener(
        "keydown",
        function (t) {
          p.on = !0;
          var e = t.which;
          87 == e || 38 == e
            ? (p.up = !0)
            : 83 == e || 40 == e
            ? (p.down = !0)
            : 65 == e || 37 == e
            ? (p.left = !0)
            : (68 != e && 39 != e) || (p.right = !0);
        },
        !1
      ),
      document.addEventListener(
        "keyup",
        function (t) {
          (p.on = !1), (p.vector = { x: 0, y: 0 });
        },
        !1
      ),
      {
        pause: function () {
          e = !0;
        },
        play: function () {
          e = !1;
        },
      }
    );
  }
  $B._ = $B;
  const nk = lM`
  position: relative;

  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none; /* Safari */
  -khtml-user-select: none; /* Konqueror HTML */
  -moz-user-select: none; /* Old versions of Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
  user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }
`,
    ik = lM`
  position: absolute;
  z-index: 1;
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(64px);
  width: 100%;
  height: 100%;
  color: #f2f5f0;
  display: flex;
  flex-direction: column;
  cursor: pointer;

  align-items: center;
  justify-content: center;
  text-align: center;

  @media (max-width: 768px) {
    h1.font_0 {
      font-size: 32px !important;
    }
    & > div {
      /* font-size: 16px !important; */
    }

    /* grid-template-rows: 1fr 1fr 1fr 1fr 1fr; */
  }

  h1.font_0 {
    /* font-size: 32px !important; */
    color: #f2f5f0;
  }

  & > div {
    max-width: 750px;
    font-size: 13px;
    text-transform: uppercase;
    padding: 2rem;
    color: #f2f5f0;
    /* margin: auto; */
  }
`,
    rk = lM`
  position: absolute;
  z-index: 2;
  bottom: 20px;
  left: 0;
  right: 0;
  padding: 1rem;
  color: black;
  text-align: center;
  text-transform: uppercase;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  opacity: 0;
  display: flex;
  flex-direction: column-reverse;
  img {
    width: 125px;
  }

  & > .exitButton {
    background: rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(4px);
    border-radius: 4px;
    padding: 8px 12px;
    text-transform: uppercase;
  }
`,
    sk = lM`
  position: fixed;
  top: 0px;
  left: 0px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(4px);
  border-radius: 4px;
  font-size: 12px;
  padding: 8px 12px;
  opacity: 0;
  z-index: 3;
  color: white !important;
  text-transform: uppercase;

  @media (max-width: 768px) {
    width: fit-content;
    /* margin: auto; */
    /* margin-top: 10px; */
    position: relative;
    top: 10px;
    opacity: 1;
    padding: 16px 18px;
  }
`,
    ok = () => {
      const [t, e] = tt(!1),
        n = nt();
      let i = nt();
      const [r, s] = tt(!1);
      function o(t) {
        ["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(
          t.code
        ) > -1 && t.preventDefault();
      }
      return (
        et(() => {
          window.innerWidth < 768 && s(!0);
        }, []),
        ut(
          n,
          () => {
            (i.current = ek(n.current)),
              window.addEventListener("keydown", o, !1);
          },
          () => {
            window.addEventListener("keydown", o, !1), i.current.play();
          },
          () => {
            window.removeEventListener("keydown", o, !1), i.current.pause();
          }
        ),
        et(
          () => (
            Jc.to("." + rk, { opacity: 1, y: -10, stagger: 0.1 }),
            t
              ? document.body.classList.add("posture-check--open")
              : document.body.classList.remove("posture-check--open"),
            () => {}
          ),
          [t]
        ),
        Qc("div", {
          style: { width: "100%", height: "100%", cursor: "pointer" },
          onClick: function (n) {
            t || e(!0);
          },
          children: [
            Qc("div", {
              className: nk,
              onMouseEnter: () => window.addEventListener("keydown", o, !1),
              onMouseLeave: () => window.removeEventListener("keydown", o, !1),
              style: { width: "100%", height: "100%" },
              ref: n,
              children:
                !t &&
                Qc("div", {
                  className: ik,
                  onMouseIn: function (t) {
                    Jc.set("#" + sk, { x: t.clientX + 25, y: t.clientY - 25 });
                  },
                  onMouseMove: function (t) {
                    Jc.to("#" + sk, {
                      x: t.clientX + 25,
                      y: t.clientY - 25,
                      opacity: 1,
                      duration: 0.1,
                    });
                  },
                  onMouseOut: function (t) {
                    Jc.to("#" + sk, { opacity: 0, duration: 0.1 });
                  },
                  children: [
                    Qc("div", {}),
                    Qc("h1", {
                      className: "font_0",
                      children: "POSTURE CHECK",
                    }),
                    Qc("div", {
                      className: "font_9",
                      children:
                        "When we asked designers what image best represents the state of design in 2022, many responded with ambivalent memes. Instead of explaining them, we let them speak for themselves. This gallery takes its title from one meme submissionposture check, bestie!and acts as 1) a break from reading and 2) an emotional temperature check on the design community. Hows our collective posture?",
                    }),
                    Qc("span", {
                      className: sk + " font_9",
                      id: sk,
                      children: "Explore",
                    }),
                  ],
                }),
            }),
            t &&
              Qc(
                "div",
                r
                  ? {
                      className: rk + " font_9",
                      children: [
                        Qc("div", { children: " Swipe Up To Navigate" }),
                        Qc("div", {
                          className: "exitButton",
                          onClick: () => {
                            window.scrollBy({
                              top: window.innerHeight,
                              behavior: "smooth",
                            });
                          },
                          children: "Exit Simulation",
                        }),
                      ],
                    }
                  : {
                      className: rk + " font_9",
                      children: [
                        "commands of navigation",
                        " ",
                        Qc("img", { src: ht() + "/assets/3d/keyboard.png" }),
                      ],
                    }
              ),
          ],
        })
      );
    };
  class ak extends ev {
    constructor() {
      super(...arguments),
        (this.backdropUniformName = null),
        (this._backdropActive = !1),
        (this.clearColor = null);
    }
  }
  class lk extends ak {
    constructor(t) {
      let e =
        "\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D uBackdrop;\nuniform vec2 uBackdrop_flipY;\n\n%UNIFORM_CODE%\n\nvoid main(void)\n{\n   vec2 backdropCoord = vec2(vTextureCoord.x, uBackdrop_flipY.x + uBackdrop_flipY.y * vTextureCoord.y);\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\n   vec4 b_dest = texture2D(uBackdrop, backdropCoord);\n   vec4 b_res = b_dest;\n   \n   %BLEND_CODE%\n\n   gl_FragColor = b_res;\n}";
      (e = e.replace("%UNIFORM_CODE%", t.uniformCode || "")),
        (e = e.replace("%BLEND_CODE%", t.blendCode || "")),
        super(void 0, e, t.uniforms),
        (this.backdropUniformName = "uBackdrop");
    }
  }
  class hk extends ev {
    constructor(t, e) {
      const n = e || {};
      n.flipY || (n.flipY = new Float32Array([0, 1])),
        super(
          "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec2 flipY;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vTextureCoord.y = flipY.x + flipY.y * vTextureCoord.y;\n}\n\n",
          t,
          n
        );
    }
  }
  var uk, ck;
  ((ck = uk || (uk = {}))[(ck.RED = 0)] = "RED"),
    (ck[(ck.GREEN = 1)] = "GREEN"),
    (ck[(ck.BLUE = 2)] = "BLUE"),
    (ck[(ck.ALPHA = 3)] = "ALPHA");
  class dk {
    constructor(t = !1, e = uk.ALPHA) {
      (this.maskBefore = t),
        (this.uniformCode = "uniform vec4 uChannel;"),
        (this.uniforms = { uChannel: new Float32Array([0, 0, 0, 0]) }),
        (this.blendCode = "b_res = dot(b_src, uChannel) * b_dest;"),
        (this.safeFlipY = !1),
        (this.uniforms.uChannel[e] = 1);
    }
  }
  const pk = new Float32Array([0, 1]);
  class fk extends lk {
    constructor(t, e = new dk()) {
      super(e),
        (this.baseFilter = t),
        (this.config = e),
        (this.padding = t.padding),
        (this.safeFlipY = e.safeFlipY);
    }
    apply(t, e, n, i) {
      const r = t.getFilterTexture(e);
      if (this.config.maskBefore) {
        const { blendMode: s } = this.state;
        (this.state.blendMode = xf.NONE),
          t.applyFilter(this, e, r, If.YES),
          (this.baseFilter.blendMode = s),
          this.baseFilter.apply(t, r, n, i),
          (this.state.blendMode = s);
      } else {
        const { uBackdrop: s, uBackdrop_flipY: o } = this.uniforms;
        if (o[1] > 0 || this.safeFlipY) this.baseFilter.apply(t, s, r, If.YES);
        else {
          const n = t.getFilterTexture(e);
          fk._flipYFilter || (fk._flipYFilter = new hk()),
            (fk._flipYFilter.uniforms.flipY[0] = o[0]),
            (fk._flipYFilter.uniforms.flipY[1] = o[1]),
            fk._flipYFilter.apply(t, s, n, If.YES),
            this.baseFilter.apply(t, n, r, If.YES),
            t.returnFilterTexture(n),
            (this.uniforms.uBackdrop_flipY = pk);
        }
        (this.uniforms.uBackdrop = r),
          t.applyFilter(this, e, n, i),
          (this.uniforms.uBackdrop = s),
          (this.uniforms.uBackdrop_flipY = o);
      }
      t.returnFilterTexture(r);
    }
  }
  fk._flipYFilter = null;
  const mk =
      "if (b_src.a == 0.0) {\n  gl_FragColor = vec4(0, 0, 0, 0);\n  return;\n}\nif (b_dest.a == 0.0) {\n  gl_FragColor = b_src;\n  return;\n}\nvec3 Cb = b_dest.rgb / b_dest.a;\nvec3 Cs = b_src.rgb / b_src.a;\n%NPM_BLEND%\n// SWAP SRC WITH NPM BLEND\nvec3 new_src = (1.0 - b_dest.a) * Cs + b_dest.a * B;\n// PORTER DUFF PMA COMPOSITION MODE\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\nb_res.rgb = b_src.a * new_src + (1.0 - b_src.a) * b_dest.rgb;\n",
    _k = mk.replace(
      "%NPM_BLEND%",
      "vec3 multiply = Cb * Cs * 2.0;\nvec3 Cb2 = Cb * 2.0 - 1.0;\nvec3 screen = Cb2 + Cs - Cb2 * Cs;\nvec3 B;\nif (Cb.r <= 0.5) {\n  B.r = multiply.r;\n} else {\n  B.r = screen.r;\n}\nif (Cb.g <= 0.5) {\n  B.g = multiply.g;\n} else {\n  B.g = screen.g;\n}\nif (Cb.b <= 0.5) {\n  B.b = multiply.b;\n} else {\n  B.b = screen.b;\n}\n"
    ),
    gk = mk.replace(
      "%NPM_BLEND%",
      "vec3 multiply = Cb * Cs * 2.0;\nvec3 Cs2 = Cs * 2.0 - 1.0;\nvec3 screen = Cb + Cs2 - Cb * Cs2;\nvec3 B;\nif (Cs.r <= 0.5) {\n  B.r = multiply.r;\n} else {\n  B.r = screen.r;\n}\nif (Cs.g <= 0.5) {\n  B.g = multiply.g;\n} else {\n  B.g = screen.g;\n}\nif (Cs.b <= 0.5) {\n  B.b = multiply.b;\n} else {\n  B.b = screen.b;\n}\n"
    ),
    vk = mk.replace(
      "%NPM_BLEND%",
      "vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\nvec3 B;\nvec3 D;\nif (Cs.r <= 0.5)\n{\n  B.r = first.r;\n}\nelse\n{\n  if (Cb.r <= 0.25)\n  {\n    D.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \n  }\n  else\n  {\n    D.r = sqrt(Cb.r);\n  }\n  B.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\n}\nif (Cs.g <= 0.5)\n{\n  B.g = first.g;\n}\nelse\n{\n  if (Cb.g <= 0.25)\n  {\n    D.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \n  }\n  else\n  {\n    D.g = sqrt(Cb.g);\n  }\n  B.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\n}\nif (Cs.b <= 0.5)\n{\n  B.b = first.b;\n}\nelse\n{\n  if (Cb.b <= 0.25)\n  {\n    D.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \n  }\n  else\n  {\n    D.b = sqrt(Cb.b);\n  }\n  B.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\n}\n"
    ),
    yk = mk.replace("%NPM_BLEND%", "vec3 B = Cs * Cb;\n"),
    xk = [];
  (xk[xf.MULTIPLY] = yk),
    (xk[xf.OVERLAY] = _k),
    (xk[xf.HARD_LIGHT] = gk),
    (xk[xf.SOFT_LIGHT] = vk);
  const bk = [],
    Tk = [];
  function Ek(t) {
    return xk[t]
      ? (bk[t] || (bk[t] = new lk({ blendCode: xk[t] })), bk[t])
      : null;
  }
  class Sk extends hb {
    _render(t) {
      const e = this._texture;
      if (!e || !e.valid) return;
      const n =
        ((i = this.blendMode),
        xk[i] ? (Tk[i] || (Tk[i] = [Ek(i)]), Tk[i]) : null);
      var i;
      const r = this.blendMode;
      if (n) {
        if ((t.batch.flush(), !t.filter.pushWithCheck(this, n))) return;
        this.blendMode = xf.NORMAL;
      }
      this.calculateVertices(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this),
        n && (t.batch.flush(), t.filter.pop(), (this.blendMode = r));
    }
  }
  function wk(t, e = 0) {
    const { gl: n } = this;
    this.currentLocation !== e &&
      ((this.currentLocation = e), n.activeTexture(n.TEXTURE0 + e)),
      this.bind(t, e);
  }
  const Mk = new Um();
  function Ak(t, e, n = !0) {
    const i = this.renderer,
      r = this.defaultFilterStack,
      s = this.statePool.pop() || new _g(),
      o = this.renderer.renderTexture;
    let a = e[0].resolution,
      l = e[0].padding,
      h = e[0].autoFit,
      u = e[0].legacy;
    for (let f = 1; f < e.length; f++) {
      const t = e[f];
      (a = Math.min(a, t.resolution)),
        (l = this.useMaxPadding ? Math.max(l, t.padding) : l + t.padding),
        (h = h && t.autoFit),
        (u = u || t.legacy);
    }
    1 === r.length && (this.defaultFilterStack[0].renderTexture = o.current),
      r.push(s),
      (s.resolution = a),
      (s.legacy = u),
      (s.target = t),
      s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
      s.sourceFrame.pad(l);
    let c = !0;
    if (h) {
      const t = this.tempRect.copyFrom(o.sourceFrame);
      i.projection.transform &&
        this.transformAABB(Mk.copyFrom(i.projection.transform).invert(), t),
        s.sourceFrame.fit(t);
    } else
      c = (function (t, e) {
        let n = e.x + e.width,
          i = e.y + e.height,
          r = t.x + t.width,
          s = t.y + t.height;
        return (
          e.x >= t.x &&
          e.x <= r &&
          e.y >= t.y &&
          e.y <= s &&
          n >= t.x &&
          n <= r &&
          i >= t.y &&
          i <= s
        );
      })(this.renderer.renderTexture.sourceFrame, s.sourceFrame);
    if (n && s.sourceFrame.width <= 1 && s.sourceFrame.height <= 1)
      return r.pop(), s.clear(), this.statePool.push(s), !1;
    if (
      (this.roundFrame(
        s.sourceFrame,
        o.current ? o.current.resolution : i.resolution,
        o.sourceFrame,
        o.destinationFrame,
        i.projection.transform
      ),
      s.sourceFrame.ceil(a),
      c)
    ) {
      let t = null,
        n = null;
      for (let i = 0; i < e.length; i++) {
        const r = e[i].backdropUniformName;
        if (r) {
          const { uniforms: o } = e[i];
          o[r + "_flipY"] || (o[r + "_flipY"] = new Float32Array([0, 1]));
          const a = o[r + "_flipY"];
          null === t
            ? ((t = this.prepareBackdrop(s.sourceFrame, a)), (n = a))
            : ((a[0] = n[0]), (a[1] = n[1])),
            (o[r] = t),
            t && (e[i]._backdropActive = !0);
        }
      }
      t && (a = s.resolution = t.resolution);
    }
    (s.renderTexture = this.getOptimalFilterTexture(
      s.sourceFrame.width,
      s.sourceFrame.height,
      a
    )),
      (s.filters = e),
      (s.destinationFrame.width = s.renderTexture.width),
      (s.destinationFrame.height = s.renderTexture.height);
    const d = this.tempRect;
    (d.x = 0),
      (d.y = 0),
      (d.width = s.sourceFrame.width),
      (d.height = s.sourceFrame.height),
      (s.renderTexture.filterFrame = s.sourceFrame),
      s.bindingSourceFrame.copyFrom(o.sourceFrame),
      s.bindingDestinationFrame.copyFrom(o.destinationFrame),
      (s.transform = i.projection.transform),
      (i.projection.transform = null),
      o.bind(s.renderTexture, s.sourceFrame, d);
    const p = e[e.length - 1].clearColor;
    return (
      p
        ? i.framebuffer.clear(p[0], p[1], p[2], p[3])
        : i.framebuffer.clear(0, 0, 0, 0),
      !0
    );
  }
  function Rk(t, e) {
    return this.pushWithCheck(t, e, !1);
  }
  function Ck() {
    const t = this.defaultFilterStack,
      e = t.pop(),
      n = e.filters;
    this.activeState = e;
    const i = this.globalUniforms.uniforms;
    (i.outputFrame = e.sourceFrame), (i.resolution = e.resolution);
    const r = i.inputSize,
      s = i.inputPixel,
      o = i.inputClamp;
    if (
      ((r[0] = e.destinationFrame.width),
      (r[1] = e.destinationFrame.height),
      (r[2] = 1 / r[0]),
      (r[3] = 1 / r[1]),
      (s[0] = r[0] * e.resolution),
      (s[1] = r[1] * e.resolution),
      (s[2] = 1 / s[0]),
      (s[3] = 1 / s[1]),
      (o[0] = 0.5 * s[2]),
      (o[1] = 0.5 * s[3]),
      (o[2] = e.sourceFrame.width * r[2] - 0.5 * s[2]),
      (o[3] = e.sourceFrame.height * r[3] - 0.5 * s[3]),
      e.legacy)
    ) {
      const t = i.filterArea;
      (t[0] = e.destinationFrame.width),
        (t[1] = e.destinationFrame.height),
        (t[2] = e.sourceFrame.x),
        (t[3] = e.sourceFrame.y),
        (i.filterClamp = i.inputClamp);
    }
    this.globalUniforms.update();
    const a = t[t.length - 1];
    if (
      (e.renderTexture.framebuffer.multisample > 1 &&
        this.renderer.framebuffer.blit(),
      1 === n.length)
    )
      n[0].apply(this, e.renderTexture, a.renderTexture, If.BLEND, e),
        this.returnFilterTexture(e.renderTexture);
    else {
      let t = e.renderTexture,
        i = this.getOptimalFilterTexture(t.width, t.height, e.resolution);
      i.filterFrame = t.filterFrame;
      let r = 0;
      for (r = 0; r < n.length - 1; ++r) {
        n[r].apply(this, t, i, If.CLEAR, e);
        const s = t;
        (t = i), (i = s);
      }
      n[r].apply(this, t, a.renderTexture, If.BLEND, e),
        this.returnFilterTexture(t),
        this.returnFilterTexture(i);
    }
    let l = !1;
    for (let h = 0; h < n.length; h++)
      if (n[h]._backdropActive) {
        const t = n[h].backdropUniformName;
        l || (this.returnFilterTexture(n[h].uniforms[t]), (l = !0)),
          (n[h].uniforms[t] = null),
          (n[h]._backdropActive = !1);
      }
    e.clear(), this.statePool.push(e);
  }
  let Ik = !1;
  function Pk(t, e) {
    const n = this.renderer,
      i = n.renderTexture.current,
      r = this.renderer.renderTexture.sourceFrame,
      s = n.projection.transform || Um.IDENTITY;
    let o = 1;
    if (i) (o = i.baseTexture.resolution), (e[1] = 1);
    else {
      if (!n.useContextAlpha)
        return (
          Ik ||
            ((Ik = !0),
            console.warn(
              "pixi-picture: you are trying to use Blend Filter on main framebuffer! That wont work."
            )),
          null
        );
      (o = n.resolution), (e[1] = -1);
    }
    const a = Math.round((t.x - r.x + s.tx) * o),
      l = t.y - r.y + s.ty,
      h = Math.round((e[1] < 0 ? r.height - (l + t.height) : l) * o),
      u = Math.round(t.width * o),
      c = Math.round(t.height * o),
      d = n.gl,
      p = this.getOptimalFilterTexture(u, c, 1);
    return (
      e[1] < 0 && (e[0] = c / p.height),
      (p.filterFrame = r),
      p.setResolution(o),
      n.texture.bindForceLocation(p.baseTexture, 0),
      d.copyTexSubImage2D(d.TEXTURE_2D, 0, 0, 0, a, h, u, c),
      p
    );
  }
  function Ok(t) {
    const e = t.offsetWidth,
      n = t.offsetHeight,
      i = new TS({
        resizeTo: t,
        antialias: !1,
        autoDensity: !0,
        interactive: !0,
        resolution: 2,
        backgroundColor: 0,
        backgroundAlpha: 1,
      });
    (Rp.SORTABLE_CHILDREN = !0),
      (i.renderer.plugins.interaction.autoPreventDefault = !1),
      (i.renderer.view.style["touch-action"] = "auto"),
      t.appendChild(i.view);
    const r = new hb.from(eg.WHITE);
    (r.position.x = 0),
      (r.position.y = 0),
      (r.hitArea = new Pm(0, 0, e, n)),
      (r.anchor = 0.5),
      (r.interactive = !0),
      i.stage.addChild(r),
      r.on("pointermove", function (t) {
        void 0 !== s && window.clearTimeout(s);
        (s = window.setTimeout(function () {
          (o[1].alpha = 0), (o[2].alpha = 0), (o[3].alpha = 0);
        }, 100)),
          (o[1].alpha = 1),
          (o[2].alpha = 1),
          (o[1].zIndex = qw(4)),
          (o[1].blendMode = qw([
            xf.OVERLAY,
            xf.COLOR_DODGE,
            xf.COLOR_BURN,
            xf.SCREEN,
          ])),
          (o[2].zIndex = qw(4)),
          (o[2].blendMode = qw([
            xf.OVERLAY,
            xf.COLOR_DODGE,
            xf.COLOR_BURN,
            xf.SCREEN,
          ])),
          (o[3].zIndex = qw(4)),
          (o[3].blendMode = qw([
            xf.OVERLAY,
            xf.COLOR_DODGE,
            xf.COLOR_BURN,
            xf.SCREEN,
          ]));
      });
    let s,
      o = (function () {
        let t = [];
        for (let i = 0; i < 4; i++) {
          let s = new Sk(eg.from(ht() + `/assets/storm/storm${i + 1}.mp4`));
          s.position.set(e / 2, n / 2),
            s.anchor.set(0.5),
            e < n
              ? ((s.rotation = Math.PI / 2), (s.width = n), (s.height = e))
              : ((s.width = e), (s.height = n)),
            0 != i && (s.blendMode = xf.OVERLAY);
          let o = s.texture.baseTexture.resource.source;
          (o.volume = 0),
            (o.loop = !0),
            (o.muted = !0),
            (o.autoPlay = !0),
            t.push(s),
            r.addChild(s);
        }
        return t;
      })();
    return i.ticker.add(() => {}), { app: i };
  }
  (Av.prototype.bindForceLocation = wk),
    (yg.prototype.push = Rk),
    (yg.prototype.pushWithCheck = Ak),
    (yg.prototype.pop = Ck),
    (yg.prototype.prepareBackdrop = Pk);
  const Nk = [
    {
      "Cell number in design threads spreadsheet": 12,
      quotes:
        "Just because things were done a certain way or you were treated a certain way early in your career, doesnt mean you need to perpetuate that cycle.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 24,
      quotes:
        "Find joy in your immediate life, in people, space, and activities. Joy is an act of resistance.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 27,
      quotes: "silence is beautiful",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 29,
      quotes: "It's not always about you  but it can be!",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 36,
      quotes: "Good design = good citizenship",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 40,
      quotes: "Rule no. 4: Consider everything an experiment",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 47,
      quotes: "Be ready. The future is unpredictable.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 51,
      quotes:
        "Design is just a tool. Learn about yourself, where you come from and its history is way more important. Keep your essence and get as much repertory as you can. Keep yourself conscious and try to forget you're a designer sometimes.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 53,
      quotes: "Before putting something out in the world, be still for a bit",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 55,
      quotes: "Design is context.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 57,
      quotes:
        "Let's not gatekeep like designers did in the past. We don't have to put future designers through the same bullshit we went through",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 66,
      quotes:
        "Its impossible to send one perfect message for all designers in the world while there are so much inequality and so many different contexts. So I decided to split my message in three. \n\n1) for whoever is starting their career, even if they dont know yet: its possible to have a decent life as a designer. I didnt know it 15 years ago, I thought I would have to work in Advertising for the rest of my life. Most people dont even know or believe this is a possibility and this is a big part of the problem \n\n2) for whoever is struggling as a designer right now: we all have been there. I still struggle more than I want to, you are not alone. \n\n3) for designers in a position of power, including myself: listen more, be more open, learn from young designers, dont get stuck, keep designing.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 72,
      quotes: "You got this!",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 73,
      quotes: "Just design honestly",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 78,
      quotes:
        "Would you rather be (viral/famous/trend-setting/original/correct) or would you rather be happy?",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 83,
      quotes:
        "Stay chill guys! At the end of the day were the ones with the expertise. They might think they know but they don't",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 86,
      quotes: "How can we love better?",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 87,
      quotes: "Think about design as gardening",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 94,
      quotes:
        "Don't quit your agency job under the assumption that getting into publishing will take 3-5 business days",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 100,
      quotes: "Just chill",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 103,
      quotes: "breathe",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 106,
      quotes:
        "Seamos menos egosta, preocupemosnos que en el intento de crear y reflejar nuestra identidad est contemplada la situacin y realidad  de otro montn ms que no tienen la posibilidad de disear",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 118,
      quotes:
        "Create your own path and dont dwell on what others are achieving. Weve all got our own internal issues. Dont be scared to show off, nobody else will show you off",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 121,
      quotes:
        "Continue to challenge your clients to think of every decision, no matter how small, as an opportunity to become a better version of themselves to the world.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 122,
      quotes:
        "Dont listen to the doomers! For creative people, design is still the best way to make money and solve interesting problems.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 124,
      quotes: "Spell check is for suckers",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 131,
      quotes: "No one dies from a missed deadline x",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 140,
      quotes: "The sweet aint as sweet without the bitter",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 142,
      quotes: "can you guess the next trend? yeah, I thought so!",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 143,
      quotes: "Eat your greens.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 149,
      quotes: "Less research on Behance (that's for me too)",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 150,
      quotes:
        "It gets easier. Every day it gets a little easier. But you gotta do it every day thats the hard part. But it does get easier",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 155,
      quotes:
        "Do not forget why you started design. Make sure to hold onto that memory and use it as fuel for your passions. Never stop creating personal work. Take your time, everyones life and career is at a different pace. Never compare yourself to anyone else, you are you.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 185,
      quotes: "the harder the flop, the bigger the slay<3",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 189,
      quotes:
        "The most radical thing you can do is be optimistic, relentlessly positive and to do your best work. Stay in conversation with other artists.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 196,
      quotes: "Let's, please, start saying no.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 200,
      quotes:
        "hey friends, keep doing what you're doing as long as you don't hurt or upset anyone. Also, yes we're all feeling the imposter syndrome and are constantly comparing ourselves to each other, but hey, you're not alone. We're all in the same boat!",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 216,
      quotes:
        "Nothing will stop you from being creative so effectively as the fear of making a mistake. It's a tough field, but we gotta trust in ourselves.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 218,
      quotes:
        "Something I've heard recently and loved it: (sorry, it's in Portuguese)\n\n\"Design enquanto Designo:  um exerccio de fazer escolhas e mostrar ao mundo.\nDesejo do vir a ser, trazer para o mundo algo que antes existia apenas nas ideias, na eminncia de nascer",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 220,
      quotes:
        "Please stop making websites full of motion and crazy interactions that take 627 minutes to load, no one really likes that",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 236,
      quotes:
        "Why are you doing what youre doing, and the way youre doing it, actually?",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 242,
      quotes:
        "Not everyone will understand and like your design  and thats okay",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 246,
      quotes:
        "It's weird times right now. Everyone moves at a different pace. Just be patient and focus on your survival.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 250,
      quotes: "Talk less",
      "": "listen more. Remember how little you know.",
    },
    {
      "Cell number in design threads spreadsheet": 251,
      quotes:
        "Emotion is the only feature that differentiates us from machines. Therefore, emotion has to be present in everything we produce.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 116,
      quotes: "Stop fucking doing posters, start fucking acting.",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 17,
      quotes:
        "Trust your instincts, include and uplift those around youespecially those who are different from you, find joy in the resistance, check your own biases, and don't forget to play :)",
      "": "",
    },
    {
      "Cell number in design threads spreadsheet": 243,
      quotes: "Do not work as a designer if you dont like it",
      "": "",
    },
  ];
  let Dk = ht();
  const Lk = lM`
  display: flex;
  flex-direction: column;
  align-items: center;

  padding: 20px;

  .ps-mobileOnly {
    display: none;
    @media (max-width: 768px) {
      display: block;
    }
  }

  .card-generate-button {
    border: 0.5px solid #000000;
    background-color: transparent;
    padding: 20px;
    margin: 20px;
    transition: all 0.5s ease;
    min-width: 275px;
  }

  .card-generate-button:hover {
    background-color: rgba(0, 0, 0, 0.1);
    cursor: pointer;
  }
`,
    Fk = lM`
  width: 100%;
  height: 100%;
  perspective: 1000px;
  aspect-ratio: 1.5/1;
  margin-bottom: 30px;
  img {
    border-radius: 6px;
  }

  .card-side {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.5s ease;
    transform-style: preserve-3d;

    /* overflow: hidden; */
    cursor: pointer;
  }

  .card-front {
    box-shadow: rgba(0, 0, 0, 0.2) 20px 20px 10px;

    img {
      width: 100%;
      height: auto;
    }
  }

  .card-back {
    box-shadow: rgba(0, 0, 0, 0.2) 20px 20px 10px;
    transform: rotateY(180deg);
  }

  .card-side-clicked {
    transform: rotateY(180deg);
  }

  .card-front,
  .card-back,
  .card-back img {
    position: absolute;
    width: 100%;
    height: 100%;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    top: 0;
    left: 0;
  }

  .card-back p {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    width: 40%;
    text-transform: uppercase;
    text-align: left;
    padding: 1.5vw 1.5vw;
    font-size: 1vw;
    line-height: 1.3vw;
    height: 70%;
    overflow: hidden;

    @media (max-width: 768px) {
      padding: 2vw 2vw;
      line-height: 2vw;
      font-size: 1.5vw;
    }
    @media (max-width: 1000px) {
      font-size: 1.3vw;
      line-height: 1.8vw;
    }
  }
`,
    Uk = lM`
  position: fixed;
  top: 0px;
  left: 0px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(4px);
  border-radius: 4px;
  z-index: 1000;
  font-size: 12px;
  padding: 8px 12px;
  opacity: 0;

  pointer-events: none;
`,
    Bk = lM`
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  border-radius: 4px;

  font-size: 12px;
  color: white;
`;
  G(
    () =>
      Qc(d, {
        children: Qc("div", {
          className: "container",
          style: { width: "100vw", height: "100vh" },
          children: Qc(ok, {}),
        }),
      }),
    "x-greeting",
    ["name"],
    { shadow: !1 }
  ),
    G(
      () => {
        const t = nt(),
          e = nt();
        return (
          ut(
            t,
            () => {
              e.current = (function (t) {
                let e = window.matchMedia(
                  "only screen and (max-width: 480px)"
                ).matches;
                const n = t.offsetWidth,
                  i = t.offsetHeight;
                let r = { isDown: !1, px: 0, py: 0, x: 0, y: 0 },
                  s = [];
                const o = new TS({
                  resizeTo: t,
                  antialias: !1,
                  autoDensity: !0,
                  preserveDrawingBuffer: !0,
                  clearBeforeRender: !1,
                });
                (o.renderer.plugins.interaction.autoPreventDefault = !1),
                  (o.renderer.view.style["touch-action"] = "auto");
                const a = new y_();
                (a.position.x = 0),
                  (a.position.y = 0),
                  (a.hitArea = new Pm(0, 0, n, i)),
                  (a.anchor = 0.5),
                  o.stage.addChild(a);
                const l = new hb.from(eg.WHITE);
                (l.tint = 16777215),
                  (l.width = 1),
                  (l.height = 1),
                  a.addChild(l),
                  e ||
                    ((a.interactive = !0),
                    a
                      .on("pointerdown", function (t) {
                        (r.isDown = !0), (u = []), (h = Ww(a));
                      })
                      .on("pointermove", function (t) {
                        (r.px = r.x),
                          (r.py = r.y),
                          (r.x = t.data.global.x),
                          (r.y = t.data.global.y),
                          r.isDown &&
                            (h.drawLine(r.px, r.py, r.x, r.y),
                            u.push({ px: r.px, py: r.py, x: r.x, y: r.y }));
                      })
                      .on("pointerup", d)
                      .on("pointerupoutside", d));
                let h,
                  u = [],
                  c = "drawings";
                function d(t) {
                  (r.isDown = !1), zw(c, { line: u });
                }
                Vw(c, (t) => {
                  s.push(t.line);
                }),
                  t.appendChild(o.view);
                let p = 0,
                  f = 0;
                return (
                  o.ticker.add(() => {
                    for (let t = 0; t < 5; t++)
                      if (p < s.length) {
                        let t = Ww(a),
                          e = s[p];
                        if (f < e.length) {
                          let n = e[f];
                          t.drawLine(n.px, n.py, n.x, n.y), f++;
                        } else (f = 0), p++;
                      }
                  }),
                  { app: o }
                );
              })(t.current);
            },
            () => {
              e.current.app.start();
            },
            () => {
              e.current.app.stop();
            }
          ),
          Qc("div", {
            children: Qc(nd, {
              children: Qc("div", {
                class: "scene",
                style: {
                  width: "100vw",
                  height: "100vh",
                  background: "black",
                  imageRendering: "pixelated",
                  cursor: `url(${jw}/assets/cursors/drawing.png) 3 20, auto`,
                },
                ref: t,
              }),
            }),
          })
        );
      },
      "design-threads-drawing",
      [],
      { shadow: !1 }
    ),
    G(
      () => {
        const t = nt();
        let e = nt();
        return (
          ut(
            t,
            () => {
              e.current = Jw(t.current);
            },
            () => {
              e.current.app.start();
            },
            () => {
              e.current.app.stop();
            }
          ),
          Qc(d, {
            children: Qc("div", {
              class: "scene",
              style: {
                width: "100%",
                height: "100%",
                cursor: `url(${ht()}/assets/cursors/cyclone.png) 20 20, auto`,
              },
              ref: t,
            }),
          })
        );
      },
      "design-threads-excess",
      [],
      { shadow: !1 }
    ),
    G(
      ({ titles: t = "Global vs Local", initialdata: e }) => {
        const [n, i] = (function (t, e) {
          const [n, i] = tt(() => {
            if ("undefined" == typeof window) return e;
            try {
              const n = window.localStorage.getItem(t);
              return n ? JSON.parse(n) : e;
            } catch (n) {
              return console.log(n), e;
            }
          });
          return [
            n,
            (e) => {
              try {
                const r = e instanceof Function ? e(n) : e;
                i(r),
                  "undefined" != typeof window &&
                    window.localStorage.setItem(t, JSON.stringify(r));
              } catch (r) {
                console.log(r);
              }
            },
          ];
        })("hasVoted" + fM(t), !1);
        let r = JSON.parse(
          e.replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": ')
        );
        const [s, o] = tt(r),
          [a, l] = tt("tooltipID-" + qw(0, 100).toFixed()),
          h = nt();
        let u = "tables/" + fM(t);
        function c() {
          let t = 0;
          return (
            Object.keys(s).forEach((e) => {
              t += s[e];
            }),
            t
          );
        }
        et(() => {
          Xw(u, (t) => {
            null == t &&
              (function (t, e) {
                ta($o(Gw, t), { ...e });
              })(u, r),
              o(t);
          });
        }, []),
          et(() => {
            n &&
              Object.keys(s).map((t) =>
                (function (t) {
                  let e = (s[t] / c()) * 100;
                  Jc.to("#" + t, { width: e + "%", duration: 0.75 });
                })(t)
              );
          }, [s]);
        const d = (t) => lM`
    border: 1px solid #231f20;
    display: grid;
    place-content: center;
    cursor: pointer;
    height: 100%;
    text-align: center;

    &:first-child {
      border-right: none;
    }

    background: ${t === n ? "rgba(35, 31, 32, 0.05)" : "none"};

    &:hover {
      background: rgba(35, 31, 32, 0.05);
    }
  `;
        function p(t) {
          n ||
            Jc.to("#" + a, {
              x: t.clientX + 25,
              y: t.clientY - 25,
              opacity: 1,
              duration: 0.1,
            });
        }
        function f(t) {
          Jc.to("#" + a, { opacity: 0, duration: 0.1 });
        }
        function m(t) {
          Jc.set("#" + a, { x: t.clientX + 25, y: t.clientY - 25 });
        }
        return Qc("article", {
          className: uM,
          ref: h,
          children: [
            Qc("header", {
              children: [
                Qc("div", {
                  className: "font_3",
                  children: [t, ", CHOOSE ONE:"],
                }),
                Qc("div", {
                  className: "font_9 transparent ps-subtitle",
                  children: ["OPEN SURVEY, TOTAL RESPONSES: ", c()],
                }),
              ],
            }),
            Qc("div", {
              className: cM + " font_9",
              children: Object.keys(s).map((t) =>
                Qc(
                  "div",
                  {
                    className: dM + " " + d(t),
                    id: t,
                    style: { width: "100%", cursor: n && "not-allowed" },
                    onClick: () =>
                      (function (t) {
                        if (n) return;
                        let e = s[t] + 1;
                        f(), Hw(u, t, e), i(t);
                      })(t),
                    onMouseIn: m,
                    onMouseMove: p,
                    onMouseOut: f,
                    children: [
                      t,
                      Qc("br", {}),
                      Qc("span", {
                        className: `transparent psvalue-${t}`,
                        children: Qc(
                          "div",
                          n
                            ? {
                                style: { width: "fit-content" },
                                children: Qc("span", {
                                  children: [
                                    Qc(hM, { value: (s[t] / c()) * 100 }),
                                    "%(",
                                    Qc(hM, { value: s[t] }),
                                    ")",
                                  ],
                                }),
                              }
                            : { className: pM + " mobile", children: "+1" }
                        ),
                      }),
                    ],
                  },
                  t
                )
              ),
            }),
            Qc("div", { className: pM, id: a, children: "+1" }),
          ],
        });
      },
      "design-threads-graphic",
      ["titles", "initialdata"],
      { shadow: !1 }
    ),
    G(
      () => {
        const [t, e] = tt(!1),
          [n, i] = tt(TM),
          [r, s] = tt(0),
          [o, a] = tt(!1);
        function l() {
          return n.data[r];
        }
        function h() {
          let t = 250;
          return (t = l().homage + l().copycat), 0 === t && (t = 1), t;
        }
        function u(n) {
          if (t) return;
          let i = l()[n] + 1;
          d(), Hw("poll/data/" + r, n, i), e(!0);
        }
        function c(e) {
          t ||
            Jc.to("#" + _M, {
              x: e.clientX + 25,
              y: e.clientY - 25,
              opacity: 1,
              duration: 0.1,
            });
        }
        function d(t) {
          Jc.to("#" + _M, { opacity: 0, duration: 0.1 });
        }
        return (
          et(() => {
            Xw(EM, (t) => {
              i(t);
            });
          }, []),
          et(() => {
            if (t)
              return (
                (function () {
                  let t = l();
                  Jc.to("." + vM, {
                    "--a-bar": (t.homage / h()) * 100 + "%",
                    "--b-bar": (t.copycat / h()) * 100 + "%",
                    duration: 0.5,
                    ease: "power4.out",
                  });
                })(),
                () => {}
              );
          }, [n, r]),
          Qc("article", {
            className: mM,
            children: [
              Qc("header", {
                children: [
                  Qc("div", {
                    className: "font_3",
                    children: "Inspired or Copied, You decide:",
                  }),
                  Qc("caption", {
                    className: xM + " font_9 transparent",
                    children: [
                      "( copied from",
                      " ",
                      Qc("a", {
                        href: "https://www.instagram.com/kindaremindsmeof/",
                        target: "_blank",
                        children: "@kindaremindsmeof",
                      }),
                      " ",
                      ")",
                    ],
                  }),
                ],
              }),
              Qc("div", {
                className: gM,
                children: [
                  Qc("div", {
                    children: [
                      Qc("img", {
                        src: `${bM}/assets/homageVsCopycat/${l().a.url}`,
                      }),
                      Qc("caption", {
                        className: xM + " font_9",
                        children: [l().a.title, Qc("br", {}), l().a.credit],
                      }),
                    ],
                  }),
                  Qc("div", {
                    children: [
                      Qc("img", {
                        src: `${bM}/assets/homageVsCopycat/${l().b.url}`,
                      }),
                      Qc("caption", {
                        className: xM + " font_9",
                        children: [
                          l().b.title,
                          " ",
                          Qc("br", {}),
                          l().b.credit,
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              Qc("div", {
                className: yM,
                children: [
                  Qc("div", {
                    className: vM + " a font_9",
                    onClick: () => u("homage"),
                    onMouseMove: c,
                    onMouseOut: d,
                    onMouseIn: function (t) {
                      Jc.set("#" + _M, {
                        x: t.clientX + 25,
                        y: t.clientY - 25,
                      });
                    },
                    children: [
                      "Inspired",
                      Qc("caption", {
                        className: xM + " transparent font_9",
                        children:
                          t &&
                          Qc("span", {
                            children: [
                              ((l().homage / h()) * 100).toFixed(),
                              "%(",
                              l().homage,
                              ")",
                            ],
                          }),
                      }),
                    ],
                  }),
                  Qc("div", {
                    className: vM + " b font_9",
                    onClick: () => u("copycat"),
                    onMouseMove: c,
                    onMouseOut: d,
                    children: [
                      "Copied",
                      Qc("caption", {
                        className: xM + " transparent font_9",
                        children:
                          t &&
                          Qc("span", {
                            children: [
                              ((l().copycat / h()) * 100).toFixed(),
                              "%(",
                              l().copycat,
                              ")",
                            ],
                          }),
                      }),
                    ],
                  }),
                ],
              }),
              !o &&
                Qc("span", {
                  className: xM + " underline font_9",
                  onClick: function () {
                    let t = r + 1;
                    t >= n.data.length
                      ? a(!0)
                      : (Jc.to("." + vM, {
                          "--a-bar": "0%",
                          "--b-bar": "0%",
                          duration: 0.5,
                          ease: "power4.out",
                        }),
                        e(!1),
                        s(t));
                  },
                  children: "Show Next",
                }),
              Qc("div", { id: _M, className: _M, children: "+1" }),
            ],
          })
        );
      },
      "design-threads-copycat",
      [],
      { shadow: !1 }
    ),
    G(ok, "design-threads-gallery", [], { shadow: !1 }),
    G(
      () => {
        const t = nt();
        let e = nt();
        return (
          ut(
            t,
            () => {
              e.current = Ok(t.current);
            },
            () => {
              e.current.app.start();
            },
            () => {
              e.current.app.stop();
            }
          ),
          Qc(d, {
            children: Qc("div", {
              class: "scene",
              style: {
                width: "100vw",
                height: "100vh",
                cursor: `url(${ht()}/assets/cursors/high-voltage.png) 20 20, auto`,
              },
              ref: t,
            }),
          })
        );
      },
      "design-threads-storm",
      [],
      { shadow: !1 }
    ),
    G(
      function () {
        const [t, e] = tt(1),
          [n, i] = tt(0),
          [r, s] = tt(!1),
          [o] = tt("tooltipID-" + qw(0, 100).toFixed());
        return Qc("section", {
          className: Lk,
          children: [
            Qc("div", {
              id: o,
              className: Uk + " mobile font_9",
              style: { color: r ? "black" : "white" },
              children: "FLIP",
            }),
            Qc("div", {
              className: Fk,
              children: Qc("div", {
                onClick: function () {
                  s(!r);
                },
                onMouseMove: function (t) {
                  Jc.to("#" + o, {
                    x: t.clientX + 25,
                    y: t.clientY - 20,
                    opacity: 1,
                    duration: 0.1,
                  });
                },
                onMouseOut: function (t) {
                  Jc.to("#" + o, { opacity: 0, duration: 0.1 });
                },
                onMouseIn: function (t) {
                  Jc.set("#" + o, { x: t.clientX + 25, y: t.clientY - 25 });
                },
                className: `card-side ${r && "card-side-clicked"}`,
                children: [
                  Qc("div", {
                    className: "card-front",
                    children: [
                      Qc("img", {
                        src: `${Dk}/assets/postcard/postcard_${t} Large.jpeg`,
                      }),
                      Qc("div", {
                        className: Bk + " ps-mobileOnly",
                        children: "Flip",
                      }),
                    ],
                  }),
                  Qc("div", {
                    className: "card-back font_9",
                    children: [
                      Qc("p", {
                        children: [
                          `"${Nk[n].quotes}"`,
                          " ",
                          Qc("br", {}),
                          " ",
                          Qc("br", {}),
                          "  Respondent #",
                          Nk[n]["Cell number in design threads spreadsheet"],
                          " ",
                        ],
                      }),
                      Qc("img", {
                        src: `${Dk}/assets/postcard/postcard_back.png`,
                      }),
                    ],
                  }),
                ],
              }),
            }),
            Qc("button", {
              className: "card-generate-button font_9",
              onClick: function () {
                setTimeout(() => {
                  r && s(!1), i(qw(0, Nk.length).toFixed());
                }, 500),
                  e(qw(1, 50).toFixed());
              },
              children: "GENERATE NEW POSTCARD",
            }),
          ],
        });
      },
      "design-threads-postcard",
      [],
      { shadow: !1 }
    );
})();
